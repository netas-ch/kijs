/* global HTMLElement */

// --------------------------------------------------------------
// kijs (Static)
// --------------------------------------------------------------
window.kijs = class kijs {

    // PRIVATE VARS
    // __getTextFn {Function|null}      Verweise auf die getText()-Funktion
    // __getTextFnContext {Object|null} Kontext der getText()-Funktion
    // __language {String}              Aktuelle Sprache. Z.B. 'de-CH' oder 'fr' (Standard='de')
    // __rpcs {Object}                  Objekt mit Verweisen auf eine kijs.gui.Rpc-Instanz
    //                                  { default:..., myRpc2:... }
    //                                  { en:{...}, fr:{...} }
    // __uniqueId {Number|null}         Zähler der eindeutigen UniqueId



    // --------------------------------------------------------------
    // STATIC GETTERS / SETTERS
    // --------------------------------------------------------------
    static get version() { return '2.8.2'; }

    static get language() {
        if (this.__language) {
            return this.__language;
        } else {
            return 'de';
        }
    }

    static set language(val) {
        this.__language = val;
    }



    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Erstellt eine Delegate
     * @param {Function} fn
     * @param {Object} context
     * @param {Mixed} args
     * @returns {Function}
     */
    static createDelegate(fn, context, args) {
        return function() {
            const callArgs = args || arguments;
            return fn.apply(context || window, callArgs);
        };
    }

    /**
     * Erstellt einen Namespace
     * @param {String} name - Name des Namespace. Beispiel: 'kijs.gui.field'
     * @param {Object} [object] - Objekt das zugewiesen wird
     * @returns {String}
     */
    static createNamespace(name, object) {
        const parts = name.split('.');
        let parent = window;
        let part;

        for (let i=0; i<parts.length; i++) {
            part = parts[i];
            if (!parent[part]) {
                parent[part] = i===parts.length-1 && object ? object : {};
            }
            parent = parent[part];
        }

        return part;
    }

    /**
     * Führt eine Funktion zeitverzögert aus
     * @param {Function} fn
     * @param {Number} millis
     * @param {Object} context
     * @param {mixed} [args]
     * @returns {Number} Timeout-ID die mit clearTimeout gelöscht werden kann
     */
    static defer(fn, millis, context, args = null) {
        if (args !== null) {
            args = kijs.isArray(args) ? args : [args];
        }

        fn = this.createDelegate(fn, context, args);
        if (millis > 0) {
            return setTimeout(fn, millis);
        } else {
            fn();
            return 0;
        }
    }

    /**
     * Erstellt aus einem String eine Funktion
     * Dazu kann entweder eine neue Funktion als String übergeben werden:
     * 'function(myArg) { return myArg; }'
     * Oder ein Verweis auf eine bestehende Funktion:
     * 'myApp.doThis'
     * @param {String|Function} str
     * @returns {Function|Null}
     */
    static getFunctionFromString(str) {
        if (kijs.isFunction(str)) {
            return str;

        } else if (kijs.isString(str)) {
            // Funktion als String Bsp: function(a,b,...) {...}
            let res = /^function\s*\(([a-zA-Z0-9_, ]*)\)\s*\{\s(.*)\s\}/s.exec(str);
            if (res !== null) {
                // Funktionsargumente
                let args = res[1];

                // Funktionsinhalt
                let fnContent = res[2];

                // Funktion erstellen und zurückgeben
                return Function(args, fnContent);
            }

            // Verweis auf eine bestehende Funktion als String Bsp: console.log
            if (str.match(/^([a-zA-Z][a-zA-Z0-9_]*\.?)+$/s) !== null) {
                let fn = kijs.getObjectFromString(str);
                if (kijs.isFunction(fn)) {
                    return fn;
                }
            }
        }

        return null;
    }

    /**
     * Gibt die Parameter zurück, die mittels GET an die URL übergeben werden
     * @param {String} [parameterName] Den Parameter, der gesucht wird. Ohne Argument werden alle zurückgegeben.
     * @returns {String|Object|undefined}
     */
    static getGetParameter(parameterName) {
        console.warn(`DEPRECATED: use "kijs.Navigator.getGetParameter" instead of "kijs.getGetParameter"`);
        return kijs.Navigator.getGetParameter(parameterName);
    }

    /**
     * Erstellt aus einem String mit einem Verweis ein Objekt/Funktion
     * Beispiel: 'myApp.doThis' oder 'kijs.gui.Button'
     * @param {String} str
     * @param {Object} [parent=window]
     * @returns {Object|Funktion|Null}
     */
    static getObjectFromString(str, parent=window) {
        if (kijs.isFunction(str) || kijs.isObject(str)) {
            return str;

        } else {
            const parts = str.split('.');

            if (parts.length > 0) {
                if (parts[0] === 'window') {
                    parts.shift();

                }
            }

            for (let i=0; i<parts.length; i++) {
                let part = parts[i];
                if (!parent[part]) {
                    return null;
                }
                parent = parent[part];
            }
            return parent;
        }

        return null;
    }

    /**
     * Gibt den Verweis auf eine RPC-Instanz zurück.
     * Wird kein Namen angegeben, wird der default-RPC zurück gegeben.
     * Die RPCs müssen vorgängig mit kijs.setRpc() definiert werden.
     * @param {String} [name='default']
     * @returns {undefined}
     */
    static getRpc(name = 'default') {
        if (!kijs.isObject(kijs.__rpcs) || kijs.isEmpty(kijs.__rpcs[name])) {
            throw new kijs.Error(`global RPC "${name}" is not exist.`);
        }
        return kijs.__rpcs[name];
    }

    /**
     * Text für Übersetzung zurückgeben
     * @param {String} key
     * @param {String} variant
     * @param {mixed} args
     * @param {String} language
     * @returns {String}
     */
    static getText(key, variant='', args=null, language=null) {
        let ret;

        // aktuelle Sprache
        if (!language) {
            language = kijs.language;
        }

        // Falls eine eigene getText-fn definiert ist, diese verwenden
        if (kijs.isFunction(kijs.__getTextFn)) {
            return kijs.__getTextFn.call(kijs.__getTextFnContext || this, key, variant, args, language);
        }

        // sonst schauen, ob es eine Sprachdatei von kijs in der gewünschten Sprache gibt
        if (kijs.translation[language] && this.isDefined(kijs.translation[language][key])) {
            let txt = kijs.translation[language][key];

            // Evtl. sind Varianten vorhanden
            if (kijs.isObject(txt)) {
                if (Object.hasOwn(txt, variant)) {
                    ret = txt[variant];
                } else if (Object.hasOwn(txt, '')) {
                    ret = txt[''];
                } else {
                    ret = key;
                }
            } else {
                ret = txt;
            }
        } else {
            ret = key;
        }

        // Evtl. noch Argumente ersetzen
        if (args !== null) {
            args = kijs.isArray(args) ? args : [args];

            for (let i=args.length; i>0; i--) {
                ret = kijs.String.replaceAll(ret, '%' + i, args[i-1]);
            }
        }

        return ret;
    }

    /**
     * Führt eine Funktion in einem Interval aus
     * @param {Function} fn
     * @param {Number} millis
     * @param {Object} context
     * @param {Array} [args]
     * @returns {Number} Interval-ID die mit clearInterval gelöscht werden kann
     */
    static interval(fn, millis, context, args) {
        fn = this.createDelegate(fn, context, args);
        return setInterval(fn, millis);
    }

    /**
     * Prüft, ob ein value vom Typ Array ist.
     * @param {Array} value
     * @returns {Boolean}
     */
    static isArray(value) {
        return Object.prototype.toString.call(value) === '[object Array]';
    }

    /**
     * Prüft, ob ein value vom Typ Boolean ist
     * @param {Boolean} value
     * @returns {Boolean}
     */
    static isBoolean(value) {
        return value===true || value===false;
    }

    /**
     * Prüft ob ein Wert ein gültiges Datum ist
     * @param {Date} value
     * @returns {Boolean}
     */
    static isDate(value) {
        return value instanceof Date && !window.isNaN(value.valueOf());
    }

    /**
     * Prüft, ob ein value definiert ist.
     * @param {undefined} value
     * @returns {Boolean}
     */
    static isDefined(value) {
        return typeof value !== 'undefined';
    }

    /**
     * Prüft, ob ein value leer ist.
     * @param {Mixed} value
     * @returns {Boolean}
     */
    static isEmpty(value){
        if (value === null || value === '' || value === undefined) {
            return true;
        }

        if (this.isArray(value)) {
            return value.length === 0;
        }

        if (this.isObject(value)) {
            return Object.keys(value).length === 0;
        }

        return false;
    }

    /**
     * Prüft, ob ein value vom Typ Float ist, d.h. Nachkommastellen hat.
     * @param {Number} value
     * @returns {Boolean}
     */
    static isFloat(value) {
      return this.isInteger(value) === false && parseFloat(value) === value;
    }

    /**
     * Prüft, ob ein value vom Typ Function ist.
     * @param {Function} value
     * @returns {Boolean}
     */
    static isFunction(value){
        return typeof value === 'function';
    }

    /**
     * Prüft, ob ein value vom Typ HTMLElement ist.
     * @param {Mixed} value
     * @returns {Boolean}
     */
    static isHTMLElement(value) {
        return value instanceof HTMLElement;
    }

    /**
     * Prüft, ob ein value vom Typ Number und kein Float ist.
     * @param {Number} value
     * @returns {Boolean}
     */
    static isInteger(value) {
        return parseInt(value) === value;
    }

    /**
     * Prüft, ob ein value vom Typ Number ist.
     * @param {Number} value
     * @returns {Boolean}
     */
    static isNumber(value) {
        return typeof value === 'number' && !window.isNaN(value);
    }

    /**
     * Prüft, ob ein value einen numerischen Wert enthält (Number oder String)
     * @param {Number|String} value
     * @returns {Boolean}
     */
    static isNumeric(value) {
        return this.isNumber(value) || !!(this.isString(value) && value.match(/^-?[0-9]+(?:\.[0-9]+)?$/));
    }

    /**
     * Prüft, ob ein value vom Typ Objekt ist.
     * @param {Object} value
     * @returns {Boolean}
     */
    static isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }

    /**
     * Erstellt einen DOMContentLoaded Listener
     * @param {Function} fn
     * @param {Object} context
     * @returns {undefined}
     */
    static isReady(fn, context) {
        document.addEventListener('DOMContentLoaded', this.createDelegate(fn, context || this), false);
    }

    /**
     * Prüft, ob ein value vom Typ RegExp ist.
     * @param {Object} value
     * @returns {Boolean}
     */
    static isRegExp(value) {
        return (typeof value === 'object') && (value instanceof RegExp);
    }

    /**
     * Prüft, ob ein Wert eine Instanz von einem Standard-Objekt ist. (z.B. let obj = {};)
     * @param {Mixed} value
     * @returns {Boolean}
     */
    static isStandardObject(value) {
        return kijs.isObject(value) && value.constructor === window.Object;
    }

    /**
     * Prüft, ob ein value vom Typ String ist.
     * @param {String} value
     * @returns {Boolean}
     */
    static isString(value) {
        return typeof value === 'string';
    }

    /**
     * Setzt eine individuelle getText-Funktion.
     * Die fn erhält folgende Argumente: key, variant, args, language
     * @param {Function} fn
     * @param {Object} [context=this]
     * @returns {undefined}
     */
    static setGetTextFn(fn, context) {
        kijs.__getTextFn = fn;
        kijs.__getTextFnContext = context || this;
    }
    
    /**
     * Erstellt einen globalen Verweis auf eine RPC-Klasse
     * Der Standard-RPC sollte 'default' heissen.
     * Weitere sind mit beliebigen Namen möglich.
     * @param {String} name
     * @param {kijs.gui.Rpc} rpc
     * @returns {undefined}
     */
    static setRpc(name, rpc) {
        if (!kijs.isObject(kijs.__rpcs)) {
            kijs.__rpcs = {};
        }
        kijs.__rpcs[name] = rpc;
    }

    /**
     * Wandelt einen beliebigen Wert in einen String um.
     * @param {mixed} value
     * @returns {String}
     */
    static toString(value) {
        if (kijs.isString(value)) {
            return value;

        } else if (value === null || !kijs.isDefined(value)) {
            return '';

        } else if (kijs.isBoolean(value)) {
            return value ? '1' : ''; // Achtung: '0' wird zu true ausgewertet.

        } else if (kijs.isFunction(value.toString)) {
            return value.toString();
        }

        return (value + '');
    }
    
    /**
     * Gibt eine eindeutige ID zurück.
     * @param {String} [prefix=''] Ein optionales Prefix
     * @returns {String}
     */
    static uniqId(prefix = '') {
        if (!kijs.__uniqId) {
            kijs.__uniqId = 0;
        }
        kijs.__uniqId++;
        return 'kijs-' + (prefix ? prefix + '-' : '') + kijs.__uniqId;
    }

    /**
     * Kleine Hilfsfunktion, um ein Timeout in einer Async-Funktion zu nutzen.
     * @param {Number} ms Miliseconds
     * @returns {Promise}
     */
    static wait(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.Error
// --------------------------------------------------------------
kijs.Error = class kijs_Error extends Error {

    // overwrite
    constructor(message, fileName, lineNumber) {
        super(message, fileName, lineNumber);
    }
};/* global kijs */

// --------------------------------------------------------------
// kijs.String (Static)
// --------------------------------------------------------------
kijs.String = class kijs_String {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------

    /**
     * Überprüft, ob ein String mit einem gesuchten String beginnt
     * @param {String} text
     * @param {String} search
     * @returns {Boolean}
     */
    static beginsWith(text, search) {
        return text.indexOf(search) === 0;
    }

    /**
     * Überprüft, ob ein String einen gesuchten String enthält
     * @param {String} text
     * @param {String} search
     * @returns {Boolean}
     */
    static contains(text, search) {
        return text.indexOf(search) >= 0;
    }

    /**
     * Überprüft, ob ein String mit einem gesuchten String endet
     * @param {String} text
     * @param {String} search
     * @returns {Boolean}
     */
    static endsWith(text, search) {
        return text.indexOf(search, text.length - search.length) !== -1;
    }

    /**
     * Konvertiert einen HTML-String in einen String, in dem Unicode-Zeichen durch HTML-Entities ersetzt werden
     * Es werden folgende Zeichen ersetzt
     *  - Unicode 00A0 - 9999
     *  - < und >
     *  - &
     *  - "
     *  - '
     * Beispiel: '<p>Test</p>' => '&#60;p&#62;Test&#60;/p&#62;'
     * @param {String} html
     * @returns {String}
     */
    static htmlentities(html) {
        return kijs.toString(html).replace(/[\u00A0-\u9999<>\&\'\"]/gim, function(i) {
            return '&#x' + i.codePointAt(0).toString(16) + ';';
        });
    }

    /**
     * Konvertiert einen HTML-String in einen String, in dem die HTML-Entities durch die entsprechenden Unicode-Zeichen ersetzt sind
     *
     * @param {String} html
     * @returns {String}
     */
    static htmlentities_decode(html) {

        // Geschwindigkeit optimieren, falls der String nur aus einem einzelen entity ("&#xabab;") besteht
        if (kijs.isString(html) && (html.length === 7 || (html.length === 8 && html[7] === ';')) && html.substr(0,3) === '&#x') {
            return String.fromCodePoint(window.parseInt(html.substr(3,4), 16));
        }

        // HTML-Entities suchen und ersetzen
        let decoded = kijs.toString(html).replace(/&#(x[0-9a-f]+|[0-9]+)(;|$)/gim, function(entity, number) {
            let nr = null;
            if (number.substr(0,1).toLowerCase() === 'x') {
                nr = window.parseInt(number.substr(1), 16);
            } else {
                nr = window.parseInt(number, 10);
            }

            if (kijs.isNumber(nr)) {
                return String.fromCodePoint(nr);
            } else {
                return entity;
            }
        });

        // benannte Entities
        if (decoded.length > 3) {
            let namedEntity = [
                ['nbsp', 160],
                ['lt',   60],
                ['gt',   62],
                ['amp',  38],
                ['quot', 34],
                ['apos', 39],
                ['euro', 8364],
                ['copy', 169],
                ['reg',  174]
            ];
            for (let i=0; i < namedEntity.length; i++) {
                decoded = kijs.String.replaceAll(decoded, '&' + namedEntity[i][0] + ';',  String.fromCodePoint(namedEntity[i][1]));
            }
        }

        return decoded;
    }

    /**
     * Wandelt Sonderzeichen in HTML-Codes um
     * @param {String}  text           Die zu konvertierende Zeichenkette.
     * @param {Boolean} [doubleEncode] Wird der Parameter doubleEncode ausgeschaltet,
     *                                 kodiert es bereits existierende HTML-Entities
     *                                 nicht noch einmal. Standardmässig werden
     *                                 jedoch alle Zeichen konvertiert.
     * @returns {String}
     */
    static htmlspecialchars(text, doubleEncode=true) {
        let replaces = [
            {f:'&', t: '&amp;'},
            {f:'"', t: '&quot;'},
            {f:'\'', t: '&apos;'},
            {f:'<', t: '&lt;'},
            {f:'>', t: '&gt;'}
        ];

        if (!doubleEncode) {
            kijs.Array.each(replaces, function(replace) {
                text = kijs.String.replaceAll(text, replace.t, replace.f);
            }, this);
        }

        kijs.Array.each(replaces, function(replace) {
            text = kijs.String.replaceAll(text, replace.f, replace.t);
        }, this);

        return text;
    }

    /**
     * Fügt vor allen Zeilenumbrüchen eines Strings HTML-Zeilenumbrüche ein
     * @param {String} text
     * @returns {String}
     */
    static nl2br(text) {
        return kijs.toString(text).replace(/(?:\r\n|\n\r|\n|\r)/g, "<br />\n");
    }

    /**
     * Ergänzt eine Zahl mit vorangestellten Nullen
     * @param {String} text
     * @param {Number} length
     * @param {String} [padString=' ']
     * @param {String} [type='right'] 'left', 'right' oder 'both'
     * @returns {String}
     */
    static padding(text, length, padString=' ', type='right') {
        length = length || 0;
        text = kijs.toString(text);
        while (text.length < length) {
            if (type === 'left' || type === 'both') {
                text = padString + text;
            }

            if (!type || type === 'right' || type === 'both') {
                text = text + padString;
            }
        }
        return text;
    }

    /**
     * Maskiert Zeichen regulärer Ausdrücke
     * @param {String} text
     * @returns {String}
     */
    static regexpEscape(text) {
        return kijs.toString(text).replace(/[-\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    /**
     * Wiederholt einen String.
     * Gibt text multiplier mal wiederholt zurück.
     * @param {String} text
     * @param {Number} multiplier
     * @returns {String}
     */
    static repeat(text, multiplier) {
        let ret = '';
        for (let i=0; i<multiplier; i++) {
            ret += kijs.toString(text);
        }
        return ret;
    }

    /**
     * Ersetzt alle Vorkommen in einem String ohne reguläre Ausdrücke
     * @param {String} text
     * @param {String} search
     * @param {String} replace
     * @returns {String} replace
     */
    static replaceAll(text, search, replace) {
        text = kijs.toString(text);
        search = kijs.toString(search);
        replace = kijs.toString(replace);
        return kijs.isFunction(text.replaceAll) ? text.replaceAll(search, replace) : text.split(search).join(replace);
    }

    /**
     * Konvertiert einen String in einen Regulären Ausdruck (RegExp)
     * @param {String} text Regulärer Ausdruck als String Beispiel: '/^[0-9A-Z]{3,4}$/i'
     * @returns {RegExp|Boolean} Regulärer Ausdruck oder false bei Fehler
     */
    static toRegExp(text) {
        // Falls es bereits ein RegExp ist: direkt zurückgeben
        if (kijs.isRegExp(text)) {
            return text;
        }

        // Es muss ein String sein!
        if (!kijs.isString(text)) {
            return false;
        }

        // Der RegExp muss mit / eingeschlossen sein. Dahinter können noch modifiers sein.
        if (text[0] !== '/') {
            return false;
        }
        let i = text.lastIndexOf('/');
        if (i <= 0) {
            return false;
        }

        // RegExp erstellen
        try {
            return new RegExp(text.slice(1, i), text.slice(i+1));
        } catch (ex) {
            return false;
        }
    }

    /**
     * Kürzt eine Zeichenkette auf eine maximale Länge und fügt ein "…"-Zeichen an
     * @param {String} text
     * @param {Number} length maximale Länge
     * @param {Boolean} [useWordBoundary=false] Nur bei Leerzeichen abschneiden
     * @param {String} [postFixChar='…'] Zeichen, dass beim Abschneiden angehängt wird
     * @returns {String}
     */
    static trunc(text, length, useWordBoundary=false, postFixChar='…') {
        if (kijs.isEmpty(text) || !length || text.length <= length) {
            return text;
        }
        let subString = text.substr(0, length-1);
        if (useWordBoundary) {
            subString = subString.substr(0, subString.lastIndexOf(' '));
        }
        return subString + '' + postFixChar;
    }

    /**
     * Fügt Zeilenumbrüche in eine Zeichenkette ein
     * https://stackoverflow.com/a/51506718
     * @param {String} text
     * @param {Number} length Anzahl Zeichen pro Zeile
     * @param {Boolean} [useWordBoundary=true] Nur bei Leerzeichen Umbrüche einfügen
     * @returns {String}
     */
    static wrap(text, length, useWordBoundary=true) {
        if (useWordBoundary) {
            return text.replace(new RegExp(`(?![^\\n]{1,${length}}$)([^\\n]{1,${length}})\\s`, 'g'), '$1\n');
        } else {
            return text.replace(new RegExp(`(?![^\\n]{1,${length}}$)([^\\n]{1,${length}})`, 'g'), '$1\n');
        }
    }
};
/* global kijs */

// --------------------------------------------------------------
// kijs.Array (Static)
// --------------------------------------------------------------
kijs.Array = class kijs_Array {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------

    /**
     * Wandelt ein ArrayBuffer in Base64 um
     * @param {ArrayBuffer} buf
     * @returns {String}
     */
    static arrayBufferToBase64(buf) {
        const bufView = new Uint8Array(buf);
        var binary = '';
        for (let i=0; i<bufView.length; i++) {
            binary += String.fromCharCode(bufView[i]);
        }
        return window.btoa(binary);
    }

    /**
     * Wandelt base64 in ein ArrayBuffer um
     * @param {String} base64
     * @returns {ArrayBuffer}
     */
    static base64ToArrayBuffer(base64) {
        const bin_str = window.atob(base64), buf = new ArrayBuffer(bin_str.length), bufView = new Uint8Array(buf);
        for (let i=0; i<bin_str.length; i++) {
            bufView[i] = bin_str.charCodeAt(i);
        }
        return buf;
    }

    /**
     * Leert ein Array
     * @param {Array} array
     */
    static clear(array) {
        while(array.length > 0) {
            array.pop();
        }
    }

    /**
     * Erstellt eine Kopie eines flachen Arrays
     * @param {Array} array
     * @returns {Array}
     */
    static clone(array) {
        return Array.prototype.slice.call(array);
    }

    /**
     * Vergleicht zwei Arrays und Gibt bei gleichem Inhalt true zurück
     * @param {Array} array1
     * @param {Array} array2
     * @returns {Boolean}
     */
    static compare(array1, array2) {
        // Beides muss ein Array sein
        if (!kijs.isArray(array1) || !kijs.isArray(array2)) {
            return false;
        }

        // Die Länge muss übereinstimmen
        if (array1.length !== array2.length) {
            return false;
        }

        // Elemente durchgehen un den Inhalt vergleichen
        for (let i=0, l=array1.length; i<l; i++) {
            // Bei sub-Arrays: Rekursiver Aufruf
            if (array1[i] instanceof Array && array2[i] instanceof Array) {
                if (!this.compare(array1[i], array2[i])) {
                    return false;
                }

            // Datumswerte vergleichen
            } else if (array1[i] instanceof Date && array2[i] instanceof Date) {
                if (array1[i].getTime() !== array2[i].getTime()) {
                    return false;
                }

            // Bei allen anderen Datentypen: direkter Vergleich
            // ACHTUNG bei Objekten: {x:20} != {x:20}
            } else if (array1[i] !== array2[i]) {
                return false;
            }
        }

        return true;
    }

    /**
     * Fügt Arrays zusammen
     * @param {...Array} arrays
     * @returns {Array}
     */
    static concat(...arrays) {
        let arr;
        [arr, ...arrays] = arrays;
        return arr.slice(0).concat(...arrays);
    }

    /**
     * Fügt Arrays zusammen und entfernt Duplikate
     * @param {...Array} arrays
     * @returns {Array}
     */
    static concatUnique(...arrays) {
        return kijs.Array.unique(kijs.Array.concat(...arrays));
    }

    /**
     * Prüft, ob ein Wert in einem Array vorkommt
     * @param {Array} array
     * @param {mixed} value
     * @returns {Boolean}
     */
    static contains(array, value) {
        if (kijs.isFunction(array.indexOf)) {
            return array.indexOf(value) !== -1;

        // gewisse List Elemente haben keine indexOf-Funktion
        // z.B. DOMStringList im Edge
        } else if (kijs.isInteger(array.length)) {
            for (let i=0; i<array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Vergleicht array1 mit einem oder mehr anderen Arrays und gibt die Werte
     * aus array1 zurück, die in keinem der anderen Arrays enthalten sind.
     * @param {Array} array1
     * @param {Array} arrays 2...x
     * @returns {Array}
     */
    static diff(array1, ...arrays) {
        let diff = [];
        kijs.Array.each(array1, function(v) {
            let uniqueVal = true;
            kijs.Array.each(arrays, function(compareArray) {
                if (kijs.Array.contains(compareArray, v)) {
                    uniqueVal = false;
                    return false;
                }
            }, this);

            if (uniqueVal) {
                diff.push(v);
            }

        }, this);

        return diff;
    }

    /**
     * Durchläuft ein Array und ruft pro Element die callback-Funktion auf.
     * Die Iteration kann durch die Rückgabe von false gestoppt werden.
     * @param {Array} array
     * @param {Function} fn - Callback Funktion
     * @param {Object} context - Gültigkeitsbereich
     * @param {Boolean} [reverse=false] - Soll das Array rückwärts durchlaufen werden?
     * @returns {Boolean}
     */
    static each(array, fn, context, reverse) {
        const len = array.length;

        if (reverse) {
            for (let i=len-1; i>-1; i--) {
                if (fn.call(context, array[i], i, array) === false) {
                    return i;
                }
            }

        } else {
            for (let i=0; i<len; i++) {
                if (fn.call(context, array[i], i, array) === false) {
                    return i;
                }
            }
        }

        return true;
    }

    /**
     * Gibt den grössten Wert eines Arrays zurück
     * @param {Array} array
     * @returns {Mixed} Den grössten Wert im Array
     */
    static max(array) {
        let max;
        for (let i=0; i<array.length; i++) {
            if (max === undefined || array[i] > max) {
                max = array[i];
            }
        }
        return max;
    }

    /**
     * Gibt den kleinsten Wert eines Arrays zurück
     * @param {Array} array
     * @returns {Mixed} Den kleinsten Wert im Array
     */
    static min(array) {
        let min;
        for (let i=0; i<array.length; i++) {
            if (min === undefined || array[i] < min) {
                min = array[i];
            }
        }
        return min;
    }

    /**
     * Schiebt ein Element in einem Array um einen bestimmten Offset
     * @param {Array} array
     * @param {Int} fromIndex Index des Elements, das geschoben werden soll
     * @param {Int} toIndex Index der neuen Position
     * @returns {Array}
     */
    static move(array, fromIndex, toIndex) {
        fromIndex = Math.max(0, Math.min(fromIndex, array.length));
        toIndex = Math.max(0, Math.min(toIndex, array.length));
        const value = array[fromIndex];

        // Da das array um eine Position kürzer ist, wenn das element
        // entfernt wird, muss eine pos. abgezogen werden.
        if (toIndex > fromIndex) {
            toIndex -= 1;
        }

        if (fromIndex !== toIndex) {
            array.splice(fromIndex, 1);
            array.splice(toIndex, 0, value);
        }

        return array;
    }

    /**
     * Löscht einen Wert aus einem Array und gibt dieses zurück.
     * @param {Array} array
     * @param {mixed} value
     * @returns {Array}
     */
    static remove(array, value) {
        const index = array.indexOf(value);

        if (index !== -1) {
            array.splice(index, 1);
        }

        return array;
    }

    /**
     * Löscht einen Wert aus einem Array, wenn die übergebene Funktion
     * true zurückgibt. Die Fn wird für jedes Item aufgerufen.
     * @param {Array} array     Array, aus dem gelöscht wird
     * @param {Function} fn     Funktion, die die Löschung prüft
     * @param {Object} context  Kontext der Funktion
     * @returns {Array}
     */
    static removeIf(array, fn, context) {
        let toDelete = [];
        kijs.Array.each(array, function(item) {
            if (fn.call(context, item) === true) {
                toDelete.push(item);
            }
        }, this);
        kijs.Array.removeMultiple(array, toDelete);
        return array;
    }

    /**
     * Löscht Werte aus einem Array. Die Werte werden mittels Array übergeben.
     * @param {Array} array     Array, aus dem die Werte gelöscht werden.
     * @param {Array} values    Array mit zu entfernenden Werten
     * @returns {Array}
     */
    static removeMultiple(array, values) {
        kijs.Array.each(values, function(value) {
            kijs.Array.remove(array, value);
        });
        return array;
    }

    /**
     * Gibt einen Teil des Arrays als Kopie zurück.
     * @param {Array} array
     * @param {Number} [begin]  Erstes Element des genommen werden soll. Leer = Element mit Index 0.
     * @param {Number} [end]    Letztes Element des genommen werden soll. Leer = letztes Element.
    * @returns {Array}
     */
    static slice(array, begin, end) {
        if ([1,2].slice(1, undefined).length) {
            return Array.prototype.slice.call(array, begin, end);
        } else {
            // see http://jsperf.com/slice-fix
            if (typeof begin === 'undefined') {
                return Array.prototype.slice.call(array);
            }
            if (typeof end === 'undefined') {
                return Array.prototype.slice.call(array, begin);
            }
            return Array.prototype.slice.call(array, begin, end);
        }
    }

    /**
     * Klont ein neues Array ohne Duplikate und gibt dieses zurück
     * @param {Array} array
     * @returns {Array}
     */
    static unique(array) {
        const ret = [];

        for (let i=0; i<array.length; i++) {
            if (ret.indexOf(array[i]) === -1) {
                ret.push(array[i]);
            }
        }

        return ret;
    }
};/* global kijs */

// --------------------------------------------------------------
// kijs.Object (Static)
// --------------------------------------------------------------
kijs.Object = class kijs_Object {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Wendet Konfigurations-Eigenschaften auf ein Objekt an
     * @param {Object} object       Ziel Objekt
     * @param {Object} config       Config Objekt
     * @param {Object} configMap    Config Map
     * @returns {undefined}
     */
    static assignConfig(object, config, configMap) {

        // 1. Shortcuts auflösen, Standardwerte übernehmen und configs in temporäres Array 'tmpConfigs' übernehmen
        let tmpConfigs = [];
        kijs.Object.each(config, function(cfgKey, cfgVal){

            if (!configMap.hasOwnProperty(cfgKey)) {
                // skipUnknownConfigs immer ignorieren
                if (cfgKey === 'skipUnknownConfigs') {
                    return;
                }
                
                // Bei unbekannten Config-Eigenschaften nur einen Fehler ausgeben, wenn
                // der Propertyname nicht in der Eigenschaft skipUnknownConfigs steht.
                // (Array wird bei der Zuweisung der defaults vom ki.gui.Container gefüllt)
                if ( kijs.isArray(config.skipUnknownConfigs) 
                        && kijs.Array.contains(config.skipUnknownConfigs, cfgKey) ) {
                    return;
                }
                
                // sonst Fehler
                throw new kijs.Error(`Unknown config "${cfgKey}"`);
            }

            // fn und target ermitteln
            // -----------------------
            let prio = Number.MIN_SAFE_INTEGER;
            let fn = 'replace';
            let target = '_' + cfgKey;
            let context = object;
            let map = configMap[cfgKey];

            // True
            if (map === true) {
                // Standards nehmen

            } else if (map === false) {
                fn = 'error';

            // String (mit Target
            } else if (kijs.isString(map)) {
                target = map;

            // Objekt im Format { fn: '...', target:'...' }
            } else if (kijs.isObject(map)) {
                if (kijs.isNumeric(map.prio)) {
                    prio = Number(map.prio);
                }
                if (map.fn) {
                    fn = map.fn;
                }
                if (map.target) {
                    target = map.target;
                }
                if (map.context) {
                    context = map.context;
                }
            } else {
                throw new kijs.Error(`Unknown format on configMap "${cfgKey}"`);

            }

            tmpConfigs.push({
                prio: prio,
                key: cfgKey,
                fn: fn,
                target: target,
                context: context,
                value: cfgVal
            });
        }, this);

        // 2. Sortieren nach Priorität je grösser die Zahl, desto später wird die Eigenschaft zugewiesen
        tmpConfigs.sort(function(a, b) {
            return a.prio - b.prio;
        });

        // 3. Eigenschaften in der Reihenfolge ihrer Priorität zuweisen
        kijs.Array.each(tmpConfigs, function(cfg) {

            // Je nach fn den Wert zuweisen
            // ----------------------------
            switch (cfg.fn) {
                // Manuelle Zuweisung. Hier muss nichts getan werden
                case 'manual':
                    break;

                // Bestehenden Wert ersetzen
                case 'replace':
                    cfg.context[cfg.target] = cfg.value;
                    break;

                // zum Array hinzufügen
                case 'append':
                    if (kijs.isArray(cfg.context[cfg.target])) {
                        if (kijs.isArray(cfg.value)) {
                            cfg.context[cfg.target] = kijs.Array.concat(cfg.context[cfg.target], cfg.value);
                        } else if (cfg.value) {
                            cfg.context[cfg.target].push(cfg.value);
                        }

                    } else {
                        if (kijs.isArray(cfg.value)) {
                            cfg.context[cfg.target] = cfg.value;
                        } else if (cfg.value) {
                            cfg.context[cfg.target] = [cfg.value];
                        }

                    }
                    break;

                // zum Array hinzufügen und duplikate entfernen
                case 'appendUnique':
                    if (kijs.isArray(cfg.context[cfg.target])) {
                        if (kijs.isArray(cfg.value)) {
                            cfg.context[cfg.target] = kijs.Array.concatUnique(cfg.context[cfg.target], cfg.value);
                        } else if (cfg.value) {
                            cfg.context[cfg.target].push(cfg.value);
                            kijs.Array.unique(cfg.context[cfg.target]);
                        }

                    } else {
                        if (kijs.isArray(cfg.value)) {
                            cfg.context[cfg.target] = cfg.value;
                            kijs.Array.unique(cfg.context[cfg.target]);
                        } else if (cfg.value) {
                            cfg.context[cfg.target] = [cfg.value];
                        }

                    }
                    break;

                // Objekt mergen (nur 1. Hierarchiestufe)
                case 'assign':
                    if (kijs.isObject(cfg.context[cfg.target])) {
                        if (kijs.isObject(cfg.value)) {
                            Object.assign(cfg.context[cfg.target], cfg.value);
                        } else if (cfg.value) {
                            throw new kijs.Error(`config "${cfg.key}" is not an object`);
                        }
                    } else {
                        if (kijs.isObject(cfg.value)) {
                            cfg.context[cfg.target] = cfg.value;
                        } else if (cfg.value) {
                            throw new kijs.Error(`config "${cfg.key}" is not an object`);
                        }
                    }
                    break;

                // Objekt mergen (ganze Hierarchie)
                case 'assignDeep':
                    if (kijs.isObject(cfg.context[cfg.target])) {
                        if (kijs.isObject(cfg.value)) {
                            kijs.Object.assignDeep(cfg.context[cfg.target], cfg.value);
                        } else if (cfg.value) {
                            throw new kijs.Error(`config "${cfg.key}" is not an object`);
                        }
                    } else {
                        if (kijs.isObject(cfg.value)) {
                            cfg.context[cfg.target] = cfg.value;
                        } else if (cfg.value) {
                            throw new kijs.Error(`config "${cfg.key}" is not an object`);
                        }
                    }
                    break;
                    
                // Listeners des "on"-Objekts mergen
                case 'assignListeners':
                    if (kijs.isObject(cfg.value)) {
                        // context ermitteln
                        let fnContext = null;
                        if (kijs.isEmpty(cfg.value.context)) {
                            fnContext = cfg.context;
                        } else {
                            fnContext = kijs.getObjectFromString(cfg.value.context);
                            if (!kijs.isObject(fnContext)) {
                                throw new kijs.Error('Context of listener ist not valid.');
                            }
                        }
                        
                        // Listeners durchgehen und übernehmen
                        for (let k in cfg.value) {
                            if (k !== 'context') {
                                let fn = kijs.getFunctionFromString(cfg.value[k]);
                                if (!kijs.isFunction(fn)) {
                                    throw new kijs.Error('Listener "' + k + '" ist not valid.');
                                }
                                cfg.context.on(k, fn, fnContext);
                            }
                        }
                    }
                    break;
                    
                // Funktion ausführen
                case 'function':
                    if (kijs.isFunction(cfg.target)) {
                        cfg.target.call(cfg.context, cfg.value);
                    } else {
                        throw new kijs.Error(`config "${cfg.key}" is not a function`);
                    }
                    break;

                // Zuweisung der Eigenschaft verbieten: Fehler ausgeben
                case 'error':
                    throw new kijs.Error(`Assignment of config "${cfg.key}" is prohibited`);
                    break;

            }
        }, this);
        tmpConfigs = null;
    }

    /**
    * Kopiert alle Eigenschaften des source-Objekts in das target-Objekt (rekursiv)
    * @param {Object} target Ziel-Objekt
    * @param {Object} source Quell-Objekt
    * @param {Boolean} [overwrite=true] Sollen bereits existierende Objekte überschrieben werden?
    * @return {Object} Erweitertes Ziel-Objekt
    */
    static assignDeep(target, source, overwrite=true) {
        kijs.Object.each(source, function(key, val){

            // Object -> mergen oder überschreiben mit Klon
            if (kijs.isObject(val)) {
                if (kijs.isObject(target[key])) {
                    kijs.Object.assignDeep(target[key], val, overwrite);
                } else {
                    target[key] = kijs.Object.clone(val);
                }

            // Array -> überschreiben per Klon
            } else if (kijs.isArray(val)) {
                if (overwrite || target[key] === undefined) {
                    target[key] = kijs.Array.clone(val);
                }

            // alles andere (inkl. Funktionen) -> überschreiben
            } else {
                if (overwrite || target[key] === undefined) {
                    target[key] = val;
                }

            }
        }, this);

        return target;
    }

    /**
     * Klont das übergebene Objekt
     * @param {Object} object
     * @returns {Object}
     */
    static clone(object) {
        return JSON.parse(JSON.stringify(object));
    }

    /**
     * Zählt die Anzahl Attribute in einem Objekt
     * @param {Object} object
     * @param {Boolean} [ownPropertysOnly=false]  count only own propertys, ignore inherited propertys
     * @returns {Number}
     */
    static count(object, ownPropertysOnly=false) {
        if (ownPropertysOnly) {
            let cnt=0;
            if (kijs.isObject(object)) {
                for (let key in object) {
                    if (object.hasOwnProperty(key)) {
                        cnt++;
                    }
                }
            }
            return cnt;
        } else {
            return kijs.isObject(object) ? Object.keys(object).length : 0;
        }
    }

    /**
     * Durchläuft ein Objekt, ruft pro Element die callback-Funktion auf.
     * Die Iteration kann durch die Rückgabe von false gestoppt werden.
     * @param {Object} object
     * @param {Function} fn - Callback Funktion
     * @param {Object} context - Gültigkeitsbereich
     * @returns {undefined}
     */
    static each(object, fn, context) {
        for (let key in object) {
            if (object.hasOwnProperty(key)) {
                if (fn.call(context, key, object[key]) === false) {
                    return;
                }
            }
        }
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.Number (Static)
// --------------------------------------------------------------
kijs.Number = class kijs_String {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------

    /**
     * Formatiert eine Zahl
     * @param {Number} number
     * @param {Number|String|null} [decimals='']    // Anzahl Kommastellen '' oder null = auto
     * @param {String} [decPoint='.']               // Dezimaltrennzeichen
     * @param {String} [thousandsSep='\'']          // Tausendertrennzeichen
     * @returns {String}
     */
    static format(number, decimals=0, decPoint='.', thousandsSep='\'') {
        let ret = '';

        // Bei decimals==='' oder null automatisch die Anzahl Kommastellen ermitteln
        if (decimals==='' || decimals===null) {
            let tmp = kijs.toString(number).split('.');
            if (tmp.length > 1) {
                decimals = tmp[1].length;
            } else {
                decimals = 0;
            }
        } else {
            decimals = Number(decimals);
        }

        // Zahl auf gegebene Präzision runden und in Array wandeln.
        let tmp = kijs.toString(Math.abs(kijs.Number.round(number, decimals))).split('.');

        // Tausendertrennzeichen einfügen
        if (!kijs.isEmpty(thousandsSep) && !kijs.isEmpty(tmp[0])) {
            const len = kijs.toString(tmp[0]).length;
            for (let i=len-1; i>=0; i--) {
                ret = tmp[0].substr(i, 1) + ret;
                if ((len-i) % 3 === 0 && i > 0) {
                    ret = thousandsSep + ret;
                }
            }
        } else {
            ret = tmp[0]+'';
        }

        // Anzahl Kommastellen
        if (decimals > 0 && !kijs.isEmpty(ret) && !kijs.isEmpty(decPoint)) {
            let digits = tmp.length > 1 ? kijs.toString(tmp[1]) : '';
            digits = kijs.String.padding(digits.substr(0, decimals), decimals, '0', 'right');
            ret += decPoint + digits;
        }


        // Negative Nummer
        if (kijs.Number.round(number, decimals) < 0) {
            ret = '-' + ret;
        }

        return ret;
    }
    
    /**
     * Parst ein String zu einer Nummer und rundet auf die angegebenen Decimals.
     * Die Funktion rundet kaufmännisch, d.H. 0.5 wird immer  aufgerundet.
     * @param {String} number
     * @param {Number} decimals
     * @param {String} decPoint
     * @param {String} thousandsSep
     * @returns {Number}
     */
    static parse(number, decimals=0, decPoint='.', thousandsSep='\'') {
        number = kijs.toString(number);
        if (thousandsSep !== '') {
            number = kijs.String.replaceAll(number, thousandsSep, '');
        }
        if (decPoint !== '.' && decPoint !== '') {
            number = kijs.String.replaceAll(number, decPoint, '.');
        }
        number = number.replace(/[^\-0-9\.]/, '');
        number = window.parseFloat(number);

        if (!window.isNaN(number)) {
            if (decimals === 0) {
                number = window.parseInt(number.toFixed(0));
            } else {
                number = window.parseFloat(number.toFixed(decimals));
            }

            return number;
        }

        return null;
    }

    /**
     * Gibt eine Zufallszahl zwischen min und max (inklusiv) zurück
     * @param {Number} min
     * @param {Number} max
     * @returns {Number}
     */
    static random(min, max) {
        if (!kijs.isNumber(min)) {
            min = 0;
        }
        if (!kijs.isNumber(max)) {
            max = Number.MAX_SAFE_INTEGER;
        }
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min +1)) + min;
    }

    /**
     * Rundet einen Fliesskommawert.
     * Halbe werden aufgerundet: Somit wird 1.5 zu 2 und -1.5 zu -2 (Kaufmännisches Runden).
     * @param {Number} number
     * @param {Number} precision
     * @returns {Number}
     */
    static round(number, precision=0) {
        return Number(Math.round(number + 'e' + precision) + 'e-' + precision);
    }

    /**
     * Rundet eine Zahl auf eine angegebene Präzision
     * @param {Number} number
     * @param {Number} roundTo Auf 5er Runden:0.05 auf 10er Runden:0.1 auf Franken:1
     * @returns {Number}
     */
    static roundTo(number, roundTo=0) {
        if (roundTo > 0) {
            return kijs.Number.round(number/roundTo) * roundTo;
        } else {
            return kijs.Number.round(number);
        }
    }

};/* global kijs */

// --------------------------------------------------------------
// kijs.Date (Static)
// --------------------------------------------------------------
/*
 * Datumsformatierung
 * ------------------
 * date.format(date, 'd.m.Y H:i', de);
 *
 * Tag
 * d   Tag des Monats, 2-stellig mit führender Null  01 bis 31
 * D   Wochentag, gekürzt auf zwei Buchstaben  Mo bis So
 * j   Tag des Monats ohne führende Nullen    1 bis 31
 * l   (kleines 'L') Ausgeschriebener Wochentag Montag bis Sontag
 *
 * Monat
 * F   Monat als ganzes Wort, wie Januar bis Dezember
 * m   Monat als Zahl, mit führenden Nullen  01 bis 12
 * M   Monatsname mit drei Buchstaben  Jan bis Dez
 * n   Monatszahl, ohne führende Nullen  1 bis 12
 *
 * Woche
 * W  ISO-8601 Wochennummer des Jahres, die Woche beginnt am Montag
 *
 * Jahr
 * Y   Vierstellige Jahreszahl  Beispiele: 1999 oder 2003
 * y   Jahreszahl, zweistellig  Beispiele: 99 oder 03
 * L   Schaltjahr oder nicht  1 für ein Schaltjahr, ansonsten 0
 *
 * Uhrzeit
 * G   Stunde im 24-Stunden-Format, ohne führende Nullen  0 bis 23
 * H   Stunde im 24-Stunden-Format, mit führenden Nullen  00 bis 23
 * i   Minuten, mit führenden Nullen  00 bis 59
 * s   Sekunden, mit führenden Nullen  00 bis 59
 */
kijs.Date = class kijs_Date {

    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Addiert oder subtrahiert Tage zu einem Datum
     * @param {Date} date
     * @param {Number} days
     * @returns {Date}
     */
    static addDays(date, days) {
        const ret = new Date(date.valueOf());
        ret.setDate(ret.getDate() + days);
        return ret;
    }

    /**
     * Addiert oder subtrahiert Monate zu einem Datum
     * @param {Date} date
     * @param {Number} months
     * @returns {Date}
     */
    static addMonths(date, months) {
        const ret = new Date(date.valueOf());
        ret.setMonth(ret.getMonth() + months);
        return ret;
    }

    /**
     * Addiert oder subtrahiert Jahre zu einem Datum
     * @param {Date} date
     * @param {Number} yars
     * @returns {Date}
     */
    static addYears(date, yars) {
        const ret = new Date(date.valueOf());
        ret.setFullYear(ret.getFullYear() + yars);
        return ret;
    }

    /**
     * Klont ein Datumsobjekt
     * @param {Date} date
     * @returns {Date}
     */
    static clone(date) {
        return new Date(date.getTime());
    }

    /**
     * Vergleicht zwei Datumswerte und gibt bei identischem Wert true zurück
     * @param {Date|null} date1
     * @param {Date|null} date2
     * @returns {Boolean}
     */
    static compare(date1, date2) {
        if (date1 instanceof Date !== date2 instanceof Date) {
            return false;
        }

        if (date1 instanceof Date) {
            return date1.getTime() === date2.getTime();
        } else {
            return date1 === date2;
        }
    }

    /**
     * Erstellt ein Datum aus
     *  - Datum: Datum wird geklont
     *  - Unix-Zeitstempel (Sekunden)
     *  - SQL-Datums-String "2017-01-01 10:00:00"
     *  - Array mit folgenden Werten [Jahr, Monat, Tag, Stunden, Minuten, Sekunden]
     *  @param {String|Date|Number} arg
     * @returns {Date|null}
     */
    static create(arg) {
        let ret = null;

        // Date übergeben: Klonen
        if (arg instanceof Date) {
            ret = this.clone(arg);

        // Unix-Zeitstempel (Sekunden)
        } else if (kijs.isNumber(arg)) {
            ret = new Date(arg*1000);

        // SQL-Zeitstempel '2017-01-01' oder '2017-01-01 10:00:00'
        } else if (kijs.isString(arg) && arg.match(/^[0-9]{4}-[0-9]{2}-[0-9]{2}/)) {
            ret = this.getDateFromSqlString(arg);

        // Array
        // Beispiele: [2018, 05, 26, 14, 57, 12] => "2018-05-26 14:57:12"
        //            [2018, 05] => "2018-05-01 00:00:00"
        //            [2018] => "2018-01-01 00:00:00"
        } else if (kijs.isArray(arg) && arg.length > 0) {
            let year = parseInt(arg[0]);
            let month = 1;
            let day = 1;
            let hour = 0;
            let minute = 0;
            let second = 0;

            if (arg.length > 1) month = parseInt(arg[1]);
            if (arg.length > 2) day = parseInt(arg[2]);
            if (arg.length > 3) hour = parseInt(arg[3]);
            if (arg.length > 4) minute = parseInt(arg[4]);
            if (arg.length > 5) second = parseInt(arg[5]);

            ret = new Date(year, month-1, day, hour, minute, second);
        }

        // Ist das Datum ungültig?
        if (!kijs.isDate(ret)) {
            ret = null;
        }

        return ret;
    }

    /**
     * Gibt die Anzahl Tage zwischen zwei Datum zurück (date2 - date1)
     * @param {Date} date1
     * @param {Date} date2
     * @return {Number}
     */
    static diff(date1, date2) {
        return Math.round((date2-date1)/(1000*60*60*24));
    }

    /**
     * Gibt ein formatierter Datumsstring zurück.
     * Parameterliste siehe PHP
     * @param {Date} date
     * @param {String} format
     * @returns {String}
     */
    static format(date, format) {
        return kijs.toString(format).replace(/[a-zA-Z]/g, (letter) => {
            return this.#formatReplace(letter, date);
        });
    }

    /**
     * Berechnet das Alter aus einem Geburtsdatum
     * @param {String|Date|Number} birthday
     * @param {String|Date|Number|Null} [curDate=Now]
     * @returns {Number|Null}
     */
    static getAge(birthday, curDate) {
        if (kijs.isEmpty(birthday)) {
            return null;
        } else {
            birthday = kijs.Date.getDatePart(birthday);
        }
        
        if (kijs.isEmpty(curDate)) {
            curDate = Date.now();
        } else {
            curDate = kijs.Date.getDatePart(curDate);
        }
        
        if (birthday > curDate) {
            return null;
        }
        
        const ageDifMs = curDate - birthday;
        const ageDate = new Date(ageDifMs);
        return Math.abs(ageDate.getUTCFullYear() - 1970);
    }
    
    /**
     * Konvertiert eine Wochennummer ein Datum-Objekt
     * Format: [A-Z ]+([0-9]+) ([0-9]+)
     *         Prefix  Woche   Jahr
     *
     * Es muss mit einem beliebigen String begonnen werden.
     * Darauf folgt die Wochen-Nr und mit einem Leerzeichen getrennt das Jahr.
     * Anschliessend können noch andere Texte/Zahlen/Zeichen sein, diese werden aber ignoriert.
     * Beispiele: 'Woche 4 2017', 'W4 17', 'W 4 2017', 'Wo 4 17'
     * Weitere Beispiele: 'Wo 4 2017 vom 23.01.2017'
     * @param {String} strWeek
     * @returns {Date}  Datum des Montags der gewählten Woche
     */
    static getDateFromWeekString(strWeek) {
        const matches = strWeek.match(/^[^0-9]+([0-9]{1,2})[^0-9]?([0-9]{2,4})?/);
        const week = parseInt(matches[1]);
        let year = matches[2] ? parseInt(matches[2]) : (new Date).getFullYear();

        // Kurzschreibweisen vom Jahr konventieren
        if (year < 100) {
            if (year < 70) {
                year += 2000;
            } else if (year >= 70) {
                year += 1900;
            }
        }

        return this.getFirstOfWeek(week, year);
    }

    /**
     * Konvertiert ein SQL-Datum im Format '2016-01-01' oder '2016-01-01 08:55:00' in ein Datum-Objekt
     * @param {String} sqlDate
     * @returns {Date}
     */
    static getDateFromSqlString(sqlDate) {
        let year = parseInt(sqlDate.substr(0,4));
        let month = parseInt(sqlDate.substr(5,2));
        let day = parseInt(sqlDate.substr(8,2));
        let hours = 0;
        let minutes = 0;
        let seconds = 0;

        if (sqlDate.length >= 13) {
            hours = parseInt(sqlDate.substr(11,2));
        }
        if (sqlDate.length >= 16) {
            minutes = parseInt(sqlDate.substr(14,2));
        }
        if (sqlDate.length >= 19) {
            seconds = parseInt(sqlDate.substr(17,2));
        }
        
        return new Date(year, month-1, day, hours, minutes, seconds, 0);
    }

    /**
     * Gibt ein Datum ohne Uhrzeit zurück
     * @param {Date} date
     * @returns {Date}
     */
    static getDatePart(date) {
        return new Date(date.getFullYear(),date.getMonth(),date.getDate());
    }

    /**
     * Gibt das Datum des ersten Tags eines Monats zurück
     * @param {Date} date
     * @returns {Date} letztes Datum des Monats
     */
    static getFirstOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1);
    }

    /**
     * Gibt das Datum des ersten Tags einer Kalenderwoche nach ISO-8601 zurück
     * @param {Number} week
     * @param {Number} year
     * @returns {Date} Montag der Woche
     */
    static getFirstOfWeek(week, year) {
        // Der 4. Januar ist immer in der ersten Woche
        let date = new Date(year, 0, 4, 0, 0, 0, 0);

        // Montag dieser Woche ermitteln
        date = this.getMonday(date);

        // Wochen addieren
        return this.addDays(date, (week-1) * 7);
    }

    /**
     * BUG: Rechnet die Sommerzeit falsch. Deshalb wurde diese Funktion ersetzt.
     * Gibt das Datum des ersten Tags einer Kalenderwoche nach ISO-8601 zurück
     * @param {Number} week
     * @param {Number} year
     * @returns {Date} Montag der Woche
     */
    /*static getFirstOfWeek_OLD(week, year) {
        // Der 4. Januar ist immer in der ersten Woche
        let u = parseInt(Date.UTC(year,0,4,0,0,0,0)/1000), d = new Date(u*1000).getUTCDay();
        // Auf den Montag zurückrechnen
        if (d > 1) {
            u -= (d - 1) * 3600 * 24;
        }
        if (d === 0) {
            u -= 6 * 3600 * 24;
        }
        // Wochen dazuzählen
        u += (week-1) * (7 * 24 * 3600);

        return new Date(this.create(u));
    }*/

    /**
     * Gibt das Datum des letzten Tags eines Monats zurück
     * @param {Date} date
     * @returns {Date} letztes Datum des Monats
     */
    static getLastOfMonth(date) {
        return new Date(date.getFullYear(), date.getMonth() + 1, 0);
    }

    /**
     * Gibt das Datum des ersten Tags (Montag) einer Kalenderwoche nach ISO-8601 zurück
     * @param {Date} date Beliebiges Datum in der Woche
     * @returns {Date} Montag der Woche
     */
    static getMonday(date) {
        const day = date.getDay(),
            diff = date.getDate() - day + (day === 0 ? -6:1);
        return new Date(date.setDate(diff));
    }

    /**
     * Gibt den Namen eines Monats zurück
     * @param {Date} date                   Datum
     * @param {String} [format='long']      Länge
     *                      'narrow': 1 Zeichen. Bsp: 'J'
     *                      'short': 2-3 Zeichen. Bsp: 'Jan'
     *                      'long': Ausgeschrieben. Bsp: 'Januar'
     *                      'numeric': '1'
     *                      '2-digit': '01'
     * @returns {String}
     */
    static getMonthName(date, format='long') {
        return date.toLocaleDateString(kijs.language, { month: format });
    }

    /**
     * Gibt zurück, ob ein Jahr nach ISO-8601 52 oder 53 Wochen hat.
     * @param {Number} year
     * @returns {Number}
     */
    static getNumberOfWeeks(year) {
        const fd = new Date(year,0,1).getDay(); // first day
        const ld = new Date(year,11,31).getDay(); // last day
        const ly = this.isLeapYear(new Date(year, 0, 1)); //leap year
        if (ly) {
            if (fd === 3 && ld === 4) return 53;
            if (fd === 4 && ld === 5) return 53;
        } else {
            if (fd === 4 && ld === 4) return 53;
        }
        return 52;
    }
    
    /**
     * Gibt das Datum als SQL-String im Format "Y-m-d" zurück
     * @param {Date} date
     * @return {String}
     */
    static getSqlDate(date) {
        return kijs.isEmpty(date) ? '' : this.format(date, 'Y-m-d');
    }
    
    /**
     * Gibt das Datum mit Uhrzeit als SQL-String im Format "Y-m-d H:i:s" zurück
     * @param {Date} date
     * @return {String}
     */
    static getSqlDateTime(date) {
        return kijs.isEmpty(date) ? '' : this.format(date, 'Y-m-d H:i:s');
    }
    
    /*
     * Gibt die Uhrzeit als SQL-String im Format "H:i:s" zurück
     * @param {Time} time
     * @return {String}
     */
    static getSqlTime(time) {
        return kijs.isEmpty(time) ? '' : this.format(time, 'H:i:s');
    }

    /**
     * Gibt das Datum des letzten Tags (Sonntag) einer Kalenderwoche nach ISO-8601 zurück
     * @param {Date} date Beliebiges Datum in der Woche
     * @returns {Date} Sonntag der Woche
     */
    static getSunday(date) {
        const f = this.getMonday(date);
        f.setDate(f.getDate()+6);
        return f;
    }

    /**
     * Gibt den Namen eines Wochentags zurück
     * @param {Date} date                   Datum
     * @param {String} [format='long']      Länge
     *                      'narrow': 1 Zeichen. Bsp: 'M'
     *                      'short': 2-3 Zeichen. Bsp: 'Mo'
     *                      'long': Ausgeschrieben. Bsp: 'Montag'
     * @returns {String}
     */
    static getWeekday(date, format='long') {
        return date.toLocaleDateString(kijs.language, { weekday: format });
    }

    /**
     * Gibt die ISO-8601 Wochennummer zurück
     * @param {Date} date
     * @return {Number} 1 to 53
     */
    static getWeekOfYear(date) {
        // adapted from http://www.merlyn.demon.co.uk/weekcalc.htm
        const ms1d = 864e5;    // milliseconds in a day
        const ms7d = 7 * ms1d; // milliseconds in a week

        const DC3 = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d; // an Absolute Day Number
        const AWN = Math.floor(DC3 / 7); // an Absolute Week Number
        const Wyr = new Date(AWN * ms7d).getUTCFullYear();

        return AWN - Math.floor(Date.UTC(Wyr, 0, 7) / ms7d) + 1;
    }

    /**
     * Gibt zurück, ob das Datum in einem Schaltjahr liegt
     * @param {Date} date
     * @returns {Boolean}
     */
    static isLeapYear(date) {
        const year = date.getFullYear();
        return !!((year & 3) === 0 && (year % 100 || (year % 400 === 0 && year)));
    }


    /**
     * Erstellt ein Datum aus einem Länderspezifischen String
     * @param {String} strInput Datum in einem länder-spezifischen Format
     * @param {String} [language='auto'] Sprache. z.B: 'de', 'en-US' oder 'auto'=kijs.language
     * @param {Number} year2000Threshold Wenn zweistellige Jahreszahlen eingegeben werden,
     *                                   können sie automatisch in vierstellige umgewandelt
     *                                   werden. Dazu kann hier der Schwellwert angegeben werden.
     *                                   Ein guter Wert ist 30. Keine Umwandlung=Null
     * @returns {Date|Null}
     */
    static parseLocalDateString(strInput, year2000Threshold, language='auto') {
        let day = null;
        let month = null;
        let year = null;

        // Lokales Datumsformat ohne Trennzeichen ermitteln:
        // 'dmY', 'dYm', 'mdY', 'mYt', 'Ydm', 'Ymt' oder null
        const format = this.#getLocalDateFormat(language);

        if (format === null) {
            return;
        }

        // Alle Trennzeichen durch Leerzeichen ersetzen
        strInput = strInput.replace(/[^0-9]+/g, ' ');

        // Sicherstellen, dass jeweils nur ein Leerzeichen vorkommt
        // und Leerzeichen am Anfang und Ende entfernen
        strInput = strInput.replace(/[ ]+/g, ' ').trim();

        // Splitten nach Leerzeichen
        const arr = strInput.split(' ');

        // Der String darf aus ein bis drei Bestandteilen bestehen
        if (arr.length < 1 || arr.length > 3) {
            return null;
        }

        // Bestandtile durchgehen
        for (let i=0; i<arr.length; i++) {
            if (!kijs.isNumeric(arr[i])) {
                return null;
            }

            switch (format[i]) {
                // Tag
                case 'd':
                    day = parseInt(arr[i]);
                    if (day < 1 || day > 31) {
                        return null;
                    }
                    break;

                // Monat
                case 'm':
                    month = parseInt(arr[i]);
                    if (month < 1 || month > 12) {
                        return null;
                    }
                    break;

                // Jahr
                case 'Y':
                    year = parseInt(arr[i]);
                    // Evtl. aus zweistelliger Jahrezahl eine vierstellige machen
                    if (!kijs.isEmpty(year2000Threshold) && year >= 0 && year <= 99) {
                        if (year >= year2000Threshold) {
                            year += 1900;
                        } else {
                            year += 2000;
                        }
                    }
                    break;

            }
        }

        // Fehlende Bestandteile vom aktuellen Datum nehmen
        if (day === null) {
            day = (new Date()).getDate();
        }
        if (month === null) {
            month = (new Date()).getMonth() + 1;
        }
        if (year === null) {
            year = (new Date()).getFullYear();
        }

        // Daraus nun ein Datum erstellen
        return new Date(year, month-1, day);
    }

     /**
     * Erstellt ein Datum mit Uhrzeit aus einem Länderspezifischen String
     * @param {String} strInput Datum und Uhrzeit in einem länder-spezifischen Format
     * @param {String} [language='auto'] Sprache. z.B: 'de', 'en-US' oder 'auto'=kijs.language
     * @param {Number} year2000Threshold Wenn zweistellige Jahreszahlen eingegeben werden,
     *                                   können sie automatisch in vierstellige umgewandelt
     *                                   werden. Dazu kann hier der Schwellwert angegeben werden.
     *                                   Ein guter Wert ist 30. Keine Umwandlung=Null
     * @returns {Date|Null}
     */
    static parseLocalDateTimeString(strInput, year2000Threshold, language='auto') {
        const seperators = [' '];
        let date = null;
        let time = '';

        // Zulässige Trennzeichen durch #|@# ersetzen
        for (let i=0; i<seperators.length; i++) {
            strInput = kijs.String.replaceAll(strInput, seperators[i], '#|@#');
        }

        // Splitten nach #|@#
        let arr = strInput.split('#|@#');

        // Der String darf aus ein bis drei Bestandteilen bestehen (Datum, Uhrzeit, AM/PM)
        if (arr.length < 1 || arr.length > 3) {
            return null;
        }

         // Datum
        if (arr.length >= 1) {
            date = this.parseLocalDateString(arr[0], year2000Threshold);
            if (kijs.isEmpty(date)) {
                return null;
            }
        }

        // Uhrzeit
        if (arr.length >= 2) {
            let tmp = arr[1];
            // evtl. noch AM oder PM anhängen
            if (arr.length >= 3) {
                tmp += ' ' + arr[2];
            }

            time = this.parseLocalTimeString(tmp);
            if (kijs.isEmpty(time)) {
                return null;
            }
        }

        return new Date(this.format(date, 'Y-m-d') + ' ' + time);
    }

    /**
     * Erstellt ein Uhrzeit-String im Format 'H:i:s aus einem Länderspezifischen String
     * @param {String} strInput Uhrzeit in einem länder-spezifischen Format
     * @param {String} [language='auto'] Sprache. z.B: 'de', 'en-US' oder 'auto'=kijs.language
     * @returns {String|Null}
     */
    static parseLocalTimeString(strInput, language='auto') {
        let isPm = false;
        let hour = null;
        let minute = null;
        let second = null;

        // Lokales Uhrzeitformat ohne Trennzeichen ermitteln:
        // 'His', 'Hsi', 'iHs', 'isH', 'sHi', 'siH' oder null
        const format = this.#getLocalTimeFormat(language);

        if (format === null) {
            return;
        }

        // PM?
        isPm = !!strInput.match(/PM/gi);

        // Alle Trennzeichen durch Leerzeichen ersetzen
        strInput = strInput.replace(/[^0-9]+/g, ' ');

        // Sicherstellen, dass jeweils nur ein Leerzeichen vorkommt
        // und Leerzeichen am Anfang und Ende entfernen
        strInput = strInput.replace(/[ ]+/g, ' ').trim();

        // Splitten nach Leerzeichen
        let arr = strInput.split(' ');

        // Der String darf aus ein bis drei Bestandteilen bestehen
        if (arr.length < 1 || arr.length > 3) {
            return null;
        }

        // Bestandtile durchgehen
        for (let i=0; i<arr.length; i++) {
            if (!kijs.isNumeric(arr[i])) {
                return null;
            }

            switch (format[i]) {
                // Stunde 24-Stunden-Format
                case 'H':
                    hour = parseInt(arr[i]);
                    if (hour < 0 || hour > 23) {
                        return null;
                    }
                    break;

                // Stunde 12-Stunden-Format
                case 'h':
                    hour = parseInt(arr[i]);
                    if (hour < 0 || hour > 23) {
                        return null;
                    }
                    if (hour < 12 && isPm) {
                        hour += 12;
                    }
                    break;

                // Minute
                case 'm':
                    minute = parseInt(arr[i]);
                    if (minute < 0 || minute > 60) {
                        return null;
                    }
                    break;

                // Sekunde
                case 'i':
                    second = parseInt(arr[i]);
                    if (second < 0 || second > 60) {
                        return null;
                    }
                    break;

            }
        }

        // Fehlende Bestandteile vom aktuellen Datum nehmen
        if (hour === null) {
            hour = 0;
        }
        if (minute === null) {
            minute = 0;
        }
        if (second === null) {
            second = 0;
        }

        // Daraus nun ein Datum erstellen
        let date = new Date(2000, 1, 1, hour, minute, second);

        // und daraus die Uhrzeit im Format H:i:s zurückgeben
        return this.format(date, 'H:i:s');
    }

    /**
     * Erstellt ein Datum aus einem Länderspezifischen Wocehn-String z.B. 'KW 5 2024'
     * Dabei wird der 1. Tag der Woche als Datum zurückgegeben.
     * @param {String} strInput Woche in einem länder-spezifischen Format
     * @param {String} [language='auto'] Sprache. z.B: 'de', 'en-US' oder 'auto'=kijs.language
     * @param {Number} year2000Threshold Wenn zweistellige Jahreszahlen eingegeben werden,
     *                                   können sie automatisch in vierstellige umgewandelt
     *                                   werden. Dazu kann hier der Schwellwert angegeben werden.
     *                                   Ein guter Wert ist 30. Keine Umwandlung=Null
     * @returns {Date|Null}
     */
    static parseLocalWeekString(strInput, year2000Threshold, language='auto') {
        let matches = strInput.match(/^[^0-9]*([0-9]{1,2})[^0-9]?([0-9]{2,4})?/);
        if (!matches) {
            return null;
        }

        // Wochen-Nr.
        let week = parseInt(matches[1]);

        // Jahr (wenn leer = aktuelles Jahr
        let year = matches[2] ? parseInt(matches[2]) : (new Date).getFullYear();

        // Evtl. aus zweistelliger Jahrezahl eine vierstellige machen
        if (!kijs.isEmpty(year2000Threshold) && year >= 0 && year <= 99) {
            if (year >= year2000Threshold) {
                year += 1900;
            } else {
                year += 2000;
            }
        }

        // Datum vom ersten Wochentag zurückgeben
        return kijs.Date.getFirstOfWeek(week, year);
    }

    /**
     * Gibt die Anzahl Sekunden seit dem 01.01.1970 zurück
     * @param {Date} date
     * @returns {Number}
     */
    static unixTimestamp(date) {
        return Math.round(date.getTime() / 1000);
    }


    // PRIVATE
    static #formatReplace(letter, date) {
        switch (letter) {
            // Tag
            // d  Tag des Monats, 2-stellig mit führender Null  01 bis 31
            case 'd': return kijs.String.padding(date.getDate(), 2, '0', 'left');
            // D  Wochentag, gekürzt auf zwei-drei Buchstaben  Mo bis So
            case 'D': return this.getWeekday(date, 'short');
            // j  Tag des Monats ohne führende Nullen  1 bis 31
            case 'j': return date.getDate();
            // l (kleines 'L')  Ausgeschriebener Wochentag  Montag bis Sontag
            case 'l': return this.getWeekday(date, 'long');

            // Monat
            // F  Monat als ganzes Wort, wie Januar bis Dezember
            case 'F': return this.getMonthName(date, 'long');
            // m  Monat als Zahl, mit führenden Nullen  01 bis 12
            case 'm': return kijs.String.padding(date.getMonth()+1, 2, '0', 'left');
            // M  Monatsname mit drei Buchstaben  Jan bis Dez
            case 'M': return this.getMonthName(date, 'short');
            // n  Monatszahl, ohne führende Nullen  1 bis 12
            case 'n': return (date.getMonth()+1);

            // Woche
            // W  ISO-8601 Wochennummer des Jahres, die Woche beginnt am Montag
            case 'W': return kijs.String.padding(this.getWeekOfYear(date), 2, '0', 'left');

            // Jahr
            // Y  Vierstellige Jahreszahl  Beispiele: 1999 oder 2003
            case 'Y': return date.getFullYear();
            // y  Jahreszahl, zweistellig  Beispiele: 99 oder 03
            case 'y': return kijs.toString(date.getFullYear()).substr(2);
            // L  Schaltjahr oder nicht  1 für ein Schaltjahr, ansonsten 0
            case 'L': return this.isLeapYear(date) ? '1' : '0';

            // Uhrzeit
            // G  Stunde im 24-Stunden-Format, ohne führende Nullen  0 bis 23
            case 'G': return date.getHours();
            // H  Stunde im 24-Stunden-Format, mit führenden Nullen  00 bis 23
            case 'H': return kijs.String.padding(date.getHours(), 2, '0', 'left');
            // i  Minuten, mit führenden Nullen  00 bis 59
            case 'i': return kijs.String.padding(date.getMinutes(), 2, '0', 'left');
            // s  Sekunden, mit führenden Nullen  00 bis 59
            case 's': return kijs.String.padding(date.getSeconds(), 2, '0', 'left');

            // Vollständige(s) Datum/Uhrzeit
            // c  ISO 8601 Datum (2011-10-05T14:48:00.000Z)
            case 'c': return date.toISOString();
            // r  Gemäß RFC 2822 formatiertes Datum (Tue Aug 19 1975 23:15:30 GMT+0200 (CEST))
            case 'r': return date.toString();
            // U  Sekunden seit Beginn der UNIX-Epoche
            case 'U': return kijs.toString(kijs.Date.unixTimestamp(date));

            default: return letter;
        }
    }

    /**
     * Ermittelt das Datumsformat zu einer Sprache
     * @param {String} [language='auto'] Sprache. z.B: 'de', 'en-US' oder 'auto'=kijs.language
     * @returns {String|Null}
     */
    static #getLocalDateFormat(language='auto') {
        if (language === 'auto') {
            language = kijs.language;
        }

        // Reihenfolge von d,m,Y ermitteln
        // dazu das Datum 2000-01-02 in ein lokales Datum umwandeln
        let format = new Date(2000, 0, 2);
        format = format.toLocaleDateString(language, { day: '2-digit', month: '2-digit', year: 'numeric'  });
        // 2000 durch Y ersetzen
        format = format.replace(/2000/g, 'Y');
        // 01 durch m ersetzen
        format = format.replace(/01/g, 'm');
        // 02 durch d ersetzen
        format = format.replace(/02/g, 'd');
        // Trennzeichen entfernen
        format = format.replace(/[^Ymd]+/g, '').trim();

        // Jetzt sollte tmp entweder 'dmY', 'dYm', 'mdY', 'mYt', 'Ydm' oder 'Ymt' sein
        if (format.length !== 3) {
            return null;
        }
        
        return format;
    }

    /**
     * Ermittelt das Uhrzeitformat zu einer Sprache
     * @param {String} [language='auto'] Sprache. z.B: 'de', 'en-US' oder 'auto'=kijs.language
     * @returns {String|Null}
     */
    static #getLocalTimeFormat(language='auto') {
        if (language === 'auto') {
            language = kijs.language;
        }

        // Reihenfolge von H,i,s ermitteln
        // dazu das Datum, Uhrzeit 2000-01-02 18:17:16 in eine lokales Uhrzeit umwandeln
        let format = new Date(2000, 0, 2, 18, 17, 16);
        format = format.toLocaleTimeString(language, {
            hour: '2-digit',
            minute: '2-digit',
            second: 'numeric'
        });
        // 18 durch H ersetzen (25-Stundenformat)
        format = format.replace(/18/g, 'H');
        // 06 durch h ersetzen (12-Stundenformat)
        format = format.replace(/06/g, 'h');
        // 17 durch m ersetzen
        format = format.replace(/17/g, 'm');
        // 16 durch i ersetzen
        format = format.replace(/16/g, 'i');
        // AM/PM entfernen
        format = format.replace(/AM/gi, '');
        format = format.replace(/PM/gi, '');

        // Trennzeichen entfernen
        format = format.replace(/[^Hhmi]+/g, '').trim();

        // Jetzt sollte tmp entweder  'His', 'Hsi', 'iHs', 'isH', 'sHi' oder 'siH' sein
        // oder das selbe mit einem kleinen h
        if (format.length !== 3) {
            return null;
        }
        
        return format;
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.Dom (Static)
// --------------------------------------------------------------
kijs.Dom = class kijs_Dom {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------

    // Static Properties in this Class
    //__scrollbarWidth {Number|null}    Damit die Funktion getScrollbarWidth() nur einmal rechnen muss,
    //                                  wird das ergebnis hier gemerkt.

   

    /**
     * Erstellt einen Event-Listener auf ein HTMLElement
     *
     * Die Delegates werden dann in der Eigenschaft context._nodeEventListeners gespeichert,
     * damit kann dann ein Listener später auch wieder entfernt werden.
     *
     * context._nodeEventListeners: {
     *     click: [
     *         {node: ..., useCapture: true/false, delegate: ...},
     *         {node: ..., useCapture: true/false, delegate: ...}
     *     ],
     *
     *     mousemove: [
     *         {node: ..., useCapture: true/false, delegate: ...},
     *         {node: ..., useCapture: true/false, delegate: ...}
     *     ]
     * }
     *
     * @param {String} eventName Name des DOM-Events
     * @param {Node} node DOM-Node
     * @param {Function|String} fn  Funktion oder Name des kijs-Events das ausgelöst werden soll
     * @param {kijs.Observable} context
     * @param {Boolean} [useCapture=false] false: Event wird in Bubbeling-Phase ausgelöst
     *                                     true:  Event wird in Capturing-Phase ausgelöst
     * @returns {undefined}
     */
    static addEventListener(eventName, node, fn, context, useCapture) {
        useCapture = !!useCapture;

        context._nodeEventListeners = context._nodeEventListeners || {};
        context._nodeEventListeners[eventName] = context._nodeEventListeners[eventName] || [];

        // Wenn noch kein Delegate existiert: eines erstellen
        if (!this.hasEventListener(eventName, node, context, useCapture)) {
            let delegate = null;

            // Falls keine Funktion, sondern ein kijs-Eventname übergeben wurde, so wird ein kijs-Event ausgelöst
            if (kijs.isString(fn)) {
                let kijsEventName = fn;
                delegate = function(e) {
                    return context.raiseEvent(kijsEventName, {
                        eventName: kijsEventName,
                        nodeEventName: eventName,
                        useCapture: useCapture,
                        nodeEvent: e,
                        context: context
                    }, this);
                };
            } else if (kijs.isFunction(fn)) {
                delegate = function(e) {
                    return fn.apply(context, [{
                        nodeEventName: eventName,
                        useCapture: useCapture,
                        nodeEvent: e,
                        context: context
                    }]);
                };

            } else {
                throw new kijs.Error(`Parameter "fn" can not be empty`);
            }

            context._nodeEventListeners[eventName].push({node:node, useCapture:useCapture, delegate:delegate });
            node.addEventListener(eventName, delegate, useCapture);
        }
    }


    /**
     * Fügt eine CSS Datei hinzu
     * @param {String} src Beispiel: 'kijs.theme.myTheme.css'
     * @param {String} [srcReference=''] Referenznode vor oder nach diesem wird eingefügt. Beispiel: 'kijs.gui.css'
     * @param {Boolean} [before=false] Vor oder nach dem Referenznode
     * @returns {Promise}
     */
    static cssFileAdd(src, srcReference='', before=false) {
        return new Promise((resolve, reject) => {
            let nodeReference = null;
            if (srcReference) {
                nodeReference = document.querySelector('link[href*="' + srcReference + '"]');
            }
           
            let node = document.createElement('link');
            node.href = src;
            node.rel = 'stylesheet';
            
            node.onload = () => resolve(node);
            node.onerror = () => reject(new Error(`CSS-File load error for "${src}"`));

            if (nodeReference) {
                if (before) {
                    document.head.insertBefore(node, nodeReference);
                } else if (nodeReference.nextElementSibling) {
                    document.head.insertBefore(node, nodeReference.nextElementSibling);
                } else {
                    nodeReference = null;
                }
                
            } else {
                document.head.append(node);
                
            }
        });
    }
    
    /**
     * Gibt zurück, ob sich eine CSS-Datei im DOM befindet
     * @param {String} src Beispiel: 'kijs.theme.myTheme.css'
     * @returns {Boolean}
     */
    static cssFileHas(src) {
        return !!document.querySelector('link[href*="' + src + '"]');
    }
    
    /**
     * Entfernt eine CSS Datei
     * @param {String} src Beispiel: 'kijs.theme.myTheme.css'
     * @returns {undefined}
     */
    static cssFileRemove(src) {
        let node = document.querySelector('link[href*="' + src + '"]');
        if (node) {
            node.parentNode.removeChild(node);
        }
    }
    
    /**
     * Ersetzt eine CSS-Datei durch eine andere
     * @param {String} srcOld   Beispiel: 'kijs.theme.default.css'
     * @param {String} srcNew   Beispiel: 'kijs.theme.myTheme.css'
     * @param {Boolean} [sameBaseDir=true]
     * @returns {Promise}
     */
    static cssFileReplace(srcOld, srcNew, sameBaseDir=true) {
        return new Promise((resolve, reject) => {
            let node = document.querySelector('link[href*="' + srcOld + '"]');
            
            if (node) {
                if (sameBaseDir) {
                    let baseDir = node.href;
                    baseDir = baseDir.split('?')[0];                            // remove any ?query
                    baseDir = baseDir.split('/').slice(0, -1).join('/')+'/';    // remove last filename part of path
                    srcNew = baseDir + srcNew;
                }

                node.href = srcNew;
                node.onload = () => resolve(node);
                node.onerror = () => reject(new Error(`CSS-File load error for "${srcNew}"`));
                 
            } else {
                reject(new Error(`CSS-File "${srcOld}" not found`));
                
            }
        });
    }



    /**
     * Gibt die absolute Position eines HTMLElements bezogen zum Browserrand zurück
     * @param {Node} node
     * @returns {Object} im Format {x: 100, y: 80, w: 20, h: 40}
     */
    static getAbsolutePos(node) {
        let x = 0;
        let y = 0;
        let w = node.offsetWidth;
        let h = node.offsetHeight;

        while (node) {
            x += node.offsetLeft - node.scrollLeft;
            y += node.offsetTop - node.scrollTop;
            node = node.offsetParent;
        }
        return {x: x,y: y, w: w, h: h};
    }

    /**
     * Gibt das erste untegeordnete Element zurück, dass Selektiert werden kann (tabIndex >= 0).
     *     undefined: nicht fokussierbar (bei undefined muss die Eigenschaft mit removeAttribute('tabIndex') entfernt werden. Sonst klappts nicht)
     *     tabIndex -1: nur via focus() Befehl fokussierbar
     *     tabIndex  0: Fokussierbar - Browser betimmt die Tabreihenfolge
     *     tabIndex >0: Fokussierbar - in der Reihenfolge wie der tabIndex
     * @param {Node} node
     * @returns {Node|null}
     */
    static getFirstFocusableNode(node) {
        let subNode = null;

        if (node.tabIndex >= 0) {
            return node;

        } else {
            if (node.hasChildNodes()) {
                for (let i=0, len=node.children.length; i<len; i++) {
                    subNode = this.getFirstFocusableNode(node.children[i]);
                    if (subNode) {
                        return subNode;
                    }
                }
            }
        }

        return null;
    }
    
    /**
     * Berechnet die Breite einer Scrollbar und gibt diese zurück
     * @returns {Number}
     */
    static getScrollbarWidth() {
        // Scrollbarbreite berechnen, falls noch nicht geschehen
        if (!this.__scrollbarWidth) {
            // Siehe https://stackoverflow.com/questions/13382516/getting-scroll-bar-width-using-javascript#13382873
            const outer = document.createElement("div");
            outer.style.visibility = "hidden";
            outer.style.width = "100px";
            outer.style.msOverflowStyle = "scrollbar"; // needed for WinJS apps

            document.body.appendChild(outer);

            const widthNoScroll = outer.offsetWidth;
            // Scrollbar einschalten
            outer.style.overflow = "scroll";

            // inner-DIV einfügen
            const inner = document.createElement("div");
            inner.style.width = "100%";
            outer.appendChild(inner);

            const widthWithScroll = inner.offsetWidth;

            // Aufräumen
            outer.parentNode.removeChild(outer);

            // Breite der Scrollbar berechnen
            this.__scrollbarWidth = widthNoScroll - widthWithScroll;
        }

        return this.__scrollbarWidth;
    }
    
    /**
     * Überprüft, ob ein Event-Listener auf ein HTMLElement existiert
     * @param {String} eventName Name des DOM-Events
     * @param {Node} node DOM-Node
     * @param {kijs.Observable} context
     * @param {Boolean} [useCapture=false] false: Event wird in Bubbeling-Phase ausgelöst
     *                                     true:  Event wird in Capturing-Phase ausgelöst
     * @returns {undefined}
     */
    static hasEventListener(eventName, node, context, useCapture) {
        useCapture = !!useCapture;

        context._nodeEventListeners = context._nodeEventListeners || {};
        context._nodeEventListeners[eventName] = context._nodeEventListeners[eventName] || [];

        // Ist der Listener bereits vorhanden?
        let ret = false;
        if (context._nodeEventListeners[eventName]) {
            kijs.Array.each(context._nodeEventListeners[eventName], function(listener) {
                if (listener.node === node && listener.useCapture === useCapture) {
                    ret = true;
                    return false;
                }
            }, this);
        }

        return ret;
    }

    /**
     * Gibt den index einer childNode in einer Node oder NodeList zurück
     * @param {Node|NodeList} parentNode
     * @param {Node} childNode
     * @returns {Number} -1, wenn nicht gefunden
     */
    static indexOf(parentNode, childNode) {
        let nodeList = parentNode instanceof NodeList ? parentNode : parentNode.childNodes;

        if (nodeList) {
            for (let i=0; i<nodeList.length; i++) {
                if (nodeList[i] === childNode) {
                    return i;
                }
            }
        }
        return -1;
    }

    /**
     * Fügt einen Node in den Dom ein, direkt nach einem anderen Knoten
     * @param {Node} node
     * @param {Node} targetNode
     * @returns {undefined}
     */
    static insertNodeAfter(node, targetNode) {
        targetNode.parentNode.insertBefore(node, targetNode.nextSibling);
    }

    /**
     * Schaut, ob ein Node ein Kindknoten (oder Grosskind, etc.) von einem anderen Node ist (rekursiv).
     * @param {Node} childNode
     * @param {Node} parentNode
     * @param {Boolean} [sameAlso=false] Soll bei childNode===parentNode auch true zurückgegeben werden?
     * @returns {Boolean}
     */
    static isChildOf(childNode, parentNode, sameAlso) {
        if (childNode === parentNode) {
            return !!sameAlso;
        }

        if (childNode.parentNode) {
            if (this.isChildOf(childNode.parentNode, parentNode, true)) {
                return true;
            }
        }

        return false;
    }
    
    /**
     * Fügt eine Javascript Datei hinzu
     * @param {String} src Beispiel: 'myFile.js'
     * @param {String} [srcReference=''] Referenznode vor oder nach diesem wird eingefügt. Beispiel: 'myPreviousFile.js'
     * @param {Boolean} [before=false] Vor oder nach dem Referenznode
     * @returns {Promise}
     */
    static jsFileAdd(src, srcReference='', before=false) {
        return new Promise((resolve, reject) => {
            let nodeReference = null;
            if (srcReference) {
                nodeReference = document.querySelector('script[src*="' + srcReference + '"]');
            }
           
            let node = document.createElement('script');
            node.src = src;
            node.type = 'text/javascript';
            
            node.onload = () => resolve(node);
            node.onerror = () => reject(new Error(`Script-File load error for "${src}"`));

            if (nodeReference) {
                if (before) {
                    document.head.insertBefore(node, nodeReference);
                } else if (nodeReference.nextElementSibling) {
                    document.head.insertBefore(node, nodeReference.nextElementSibling);
                } else {
                    nodeReference = null;
                }
                
            } else {
                document.head.append(node);
                
            }
        });
    }
    
    /**
     * Gibt zurück, ob sich eine Javascript-Datei im DOM befindet
     * @param {String} src Beispiel: 'myFile.js'
     * @returns {Boolean}
     */
    static jsFileHas(src) {
        return !!document.querySelector('script[src*="' + src + '"]');
    }
    
    /**
     * Entfernt eine Javascript Datei
     * @param {String} src Beispiel: 'myFile.js'
     * @returns {undefined}
     */
    static jsFileRemove(src) {
        let node = document.querySelector('script[src*="' + src + '"]');
        if (node) {
            node.parentNode.removeChild(node);
        }
    }
    
    /**
     * Ersetzt eine Javascript-Datei durch eine andere
     * @param {String} srcOld   Beispiel: 'myOldFile.js'
     * @param {String} srcNew   Beispiel: 'myFile.js'
     * @param {Boolean} [sameBaseDir=true]
     * @returns {Promise}
     */
    static jsFileReplace(srcOld, srcNew, sameBaseDir=true) {
        return new Promise((resolve, reject) => {
            let node = document.querySelector('script[src*="' + srcOld + '"]');
            
            if (node) {
                if (sameBaseDir) {
                    let baseDir = node.src;
                    baseDir = baseDir.split('?')[0];                            // remove any ?query
                    baseDir = baseDir.split('/').slice(0, -1).join('/')+'/';    // remove last filename part of path
                    srcNew = baseDir + srcNew;
                }

                node.src = srcNew;
                node.onload = () => resolve(node);
                node.onerror = () => reject(new Error(`Script-File load error for "${srcNew}"`));
                 
            } else {
                reject(new Error(`Script-File "${srcOld}" not found`));
                
            }
        });
    }
    
    
    

    /**
     * Entfernt alle Unterelemente eines DOM-Elements
     * @param {Node} node
     */
    static removeAllChildNodes(node) {
        if (node.replaceChildren) {
            // faster (firefox 78+, chrome 86+, ..)
            node.replaceChildren();
        }

        // Bugfix: replaceChildren funktioniert in Safari 14.0.1 nicht korrekt,
        // daher das while auch ausführen, wenn replaceChildren ausgeführt wurde.
        while (node.hasChildNodes()) {
            node.removeChild(node.lastChild);
        }
    }

    /**
     * Entfernt alle Event-Listeners eines Context
     * @param {kijs.Observable} context
     * @returns {undefined}
     */
    static removeAllEventListenersFromContext(context) {
        if (!kijs.isEmpty(context._nodeEventListeners)) {
            kijs.Object.each(context._nodeEventListeners, function(eventName, listeners) {
                kijs.Array.each(listeners, function(listener) {
                    listener.node.removeEventListener(eventName, listener.delegate, listener.useCapture);
                }, this);
            }, this);
        }

        context._nodeEventListeners = {};
    }
    
    
    /**
     * Entfernt einen Event-Listener von einem Node
     * @param {String} eventName
     * @param {Node} node
     * @param {kijs.Observable} context
     * @param {Boolean} [useCapture=false] false: Event wird in Bubbeling-Phase ausgelöst
     *                                     true:  Event wird in Capturing-Phase ausgelöst
     * @returns {undefined}
     */
    static removeEventListener(eventName, node, context, useCapture) {
        useCapture = !!useCapture;

        context._nodeEventListeners = context._nodeEventListeners || {};
        context._nodeEventListeners[eventName] = context._nodeEventListeners[eventName] || [];

        // Delegate ermitteln und Listener aus Array entfernen
        let delegate = null;
        if (!kijs.isEmpty(context._nodeEventListeners[eventName])) {
            const arr = [];

            kijs.Array.each(context._nodeEventListeners[eventName], function(listener) {
                if (listener.node === node && listener.useCapture === useCapture) {
                    delegate = listener.delegate;
                } else {
                    arr.push(listener);
                }
            }, this);

            context._nodeEventListeners[eventName] = arr;
        }

        // Listener entfernen
        if (delegate) {
            node.removeEventListener(eventName, delegate, useCapture);
        }
    }


    /**
     * Fügt html-Code in einen Node. Je nach htmlDisplayType geschieht dies auf unterschiedliche Weise.
     * Bereits vorhandener Inhalt wird gelöscht.
     * @param {HTMLELement} node
     * @param {String} html
     * @param {String} htmlDisplayType [optional]   'html': als html-Inhalt (innerHtml)
     *                                              'code': Tags werden als als Text angezeigt
     *                                              'text': Tags werden entfernt
     * @returns {undefined}
     */
    static setInnerHtml(node, html, htmlDisplayType) {
        html = kijs.toString(html);

        switch (htmlDisplayType) {
            case 'code':
                node.textContent = html;
                break;

            case 'text':
                let d = document.createElement('div');
                d.innerHTML = html;
                node.textContent = d.innerText || d.textContent || '';
                d = null;
                break;

            case 'html':
            default:
                node.innerHTML = html;
                break;
        }
    }
    
    /**
     * Scrollt den Node in den sichtbaren Bereich
     * (rekursiv)
     * @param {HTMLELement} node
     * @param {Object} options
     *  - verticalPosition (String) default='auto'
     *     - 'start'  Node wird am Anfang (oben) positioniert
     *     - 'end'    Node wird am Ende (unten) positioniert
     *     - 'center' Node wird in der Mitte positioniert
     *     - 'auto'   Es wird nur gescrollt, wenn der Node ausserhalb ist und nur 
     *                sowenig, dass der node im sichtbaren Bereich ist.
     *  - horizontalPosition (String) default='auto'
     *     - 'start'  Node wird am Anfang (links) positioniert
     *     - 'end'    Node wird am Ende (rechts) positioniert
     *     - 'center' Node wird in der Mitte positioniert
     *     - 'auto'   Es wird nur gescrollt, wenn der Node ausserhalb ist und nur 
     *                sowenig, dass der node ganz im sichtbaren Bereich ist.
     *  - verticalOffset (Number) default=0 Versatz auf Y-Achse
     *  - horizontalOffset (Number) default=0 Versatz auf X-Achse
     *  - behavior  (String) default='auto'
     *     - 'smooth' Animiertes Scrollen
     *     - 'instant' Scrollen ohne Animation
     *     - 'auto'    Die CSS Eintellung 'scroll-behavior' wird berücksichtigt.
     *  - scrollParentsTo (Boolean) default=false. Sollen Eltern-Knoten auch gescrollt werden?
     * @returns {undefined}
     */
    static scrollIntoView(node, options) {
        if (!node.offsetParent) {
            return;
        }
        
        if (kijs.isEmpty(options)) {
            options = {};
        }
        
        options.horizontalPosition = options.horizontalPosition ? options.horizontalPosition : 'auto';
        options.verticalPosition = options.verticalPosition ? options.verticalPosition : 'auto';
        
        options.horizontalOffset = options.horizontalOffset ? parseInt(options.horizontalOffset) : 0;
        options.verticalOffset = options.verticalOffset ? parseInt(options.verticalOffset) : 0;
        
        options.behavior = options.behavior ? options.behavior : 'auto';
        
        options.scrollParentsTo = !!options.scrollParentsTo;
        
        // Bei den offeset den Kehwert nehmen
        options.horizontalOffset = options.horizontalOffset * -1;
        options.verticalOffset = options.verticalOffset * -1;
        
        
        // Masse des node
        const rNode = {
            x: node.offsetLeft,
            y: node.offsetTop,
            w: node.offsetWidth,
            h: node.offsetHeight
        };
        
        // Elternknoten mit Scrollbar ermitteln
        let parentNode = node.offsetParent;
        
        // Eltern duchgehen bis ein Scrollbarer gefunden wurde
        while (parentNode) {
            
            // Ist der parentNode gültig?
            if (!parentNode || !parentNode.offsetParent || parentNode.offsetParent.tagName.toLowerCase() === 'html') {
                return;
            }
            
            // hat der parentNode eine Scrollbar?
            const hasXScrollbar = ["scroll", "auto"].indexOf(getComputedStyle(parentNode).overflowX) >= 0;
            const hasYScrollbar = ["scroll", "auto"].indexOf(getComputedStyle(parentNode).overflowY) >= 0;
            // oder overflow: hidden und hat einen übergrossen Inhalt (z.B. bei kijs.gui.container.Scrollable)
            const hasXOverflowContent = getComputedStyle(parentNode).overflowX === 'hidden' && parentNode.scrollWidth > parentNode.clientWidth;
            const hasYOverflowContent = getComputedStyle(parentNode).overflowY === 'hidden' && parentNode.scrollHeight > parentNode.clientHeight;
            
            // scrollbar: ja
            if (hasXScrollbar || hasYScrollbar || hasXOverflowContent || hasYOverflowContent) {
                break;
                
            // scrollbar: nein
            } else {
                // X- und Y-Position zum Node addieren
                rNode.x += parentNode.offsetLeft;
                rNode.y += parentNode.offsetTop;
                
                parentNode = parentNode.offsetParent;
                
            }
        }
        
        // Masse des parentNode
        const rParent = {
            innerW: parentNode.clientWidth,
            innerH: parentNode.clientHeight,
            scrollX: parentNode.scrollLeft,
            scrollY: parentNode.scrollTop,
            scrollW: parentNode.scrollWidth,
            scrollH: parentNode.scrollHeight,
            isXScrollable: parentNode.scrollWidth > parentNode.clientWidth,
            isYScrollable: parentNode.scrollHeight > parentNode.clientHeight
        };
        
        
        // Scrollkoordinaten, zu denen gescrollt werden soll. Null=Nicht scrollen
        let scrollToX = null;
        let scrollToY = null;
        
        // Horizontale Scrollkoordinaten ermitteln (scrollToX)
        if (rParent.isXScrollable) {
            switch (options.horizontalPosition) {
                case 'start':
                    scrollToX = rNode.x;
                    break;

                case 'end':
                    scrollToX = rNode.x;
                    scrollToX -= (rParent.innerW - rNode.w);
                    break;

                case 'center':
                    let xOffsetFromScreenLeft = (rParent.innerW - rNode.w) / 2;
                    scrollToX =  rNode.x;
                    scrollToX -= xOffsetFromScreenLeft;
                    break;

                case 'auto':
                    // Ist der Node im sichtbaren Scrollbereich?
                    let x = rNode.x - rParent.scrollX;

                    // position ist zuweit links
                    if (x < 0) {
                        // start
                        scrollToX = rNode.x;

                    // position ist zweit rechts
                    } else if (x + rNode.w > rParent.innerW) {
                        // end
                        scrollToX = rNode.x;
                        scrollToX -= (rParent.innerW - rNode.w);

                    }
                    break;
                    
                default:
                    throw new kijs.Error(`Option "horizontalPosition" is not valid`);
            }
        }
        
        // Verticale Scrollkoordinaten ermitteln (scrollToY)
        if (rParent.isYScrollable) {
            switch (options.verticalPosition) {
                case 'start':
                    scrollToY = rNode.y;
                    break;

                case 'end':
                    scrollToY = rNode.y - (rParent.innerH - rNode.h);
                    break;

                case 'center':
                    let yOffsetFromScreenTop = (rParent.innerH - rNode.h) / 2;
                    scrollToY =  rNode.y - yOffsetFromScreenTop;
                    break;

                case 'auto':
                    // Ist der Node im sichtbaren Scrollbereich?
                    let y = rNode.y - rParent.scrollY;

                    // position ist oberhalb
                    if (y < 0) {
                        // start
                        scrollToY = rNode.y;

                    // position ist unterhalb
                    } else if (y + rNode.h > rParent.innerH) {
                        // end
                        scrollToY = rNode.y - (rParent.innerH - rNode.h);

                    }
                    break;
                    
                default:
                    throw new kijs.Error(`Option "verticalPosition" is not valid`);
            }
        }
        
        // Horizontaler Offset + Validierung
        if (scrollToX !== null) {
            // horizontalOffset
            scrollToX += options.horizontalOffset;
            
            // Validierung
            if (scrollToX > rParent.scrollW - rNode.w) {
                scrollToX = rParent.scrollW - rNode.w;
            }
            if (scrollToX < 0) {
                scrollToX = 0;
            }
        }
        
        // Vertikaler Offset + Validierung
        if (scrollToY !== null) {
            // verticalOffset
            scrollToY += options.verticalOffset;
            
            // Validierung
            if (scrollToY > rParent.scrollH - rNode.h) {
                scrollToY = rParent.scrollH - rNode.h;
            }
            if (scrollToY < 0) {
                scrollToY = 0;
            }
        }
        
        // scrollen, wenn nötig
        if (scrollToX !== null || scrollToY !== null) {
            let args = {};
            
            if (scrollToX !== null) {
                args.left = scrollToX;
            }
            
            if (scrollToY !== null) {
                args.top = scrollToY;
            }
            
            args.behavior = options.behavior;
            
            parentNode.scrollTo(args);
        }
        
        // Evtl. die Eltern auch scrollen
        if (options.scrollParentsTo && parentNode !== document.body && parentNode.offsetParent) {
            
            let args = {
                horizontalPosition: options.horizontalPosition,
                verticalPosition: options.verticalPosition,
                horizontalOffset: options.horizontalOffset * -1,
                verticalOffset: options.verticalOffset * -1,
                behavior: options.behavior,
                scrollParentsTo: true
            };
            
            // falls gescrollt wurde, den Offset zurücksetzen
            if (scrollToX !== null) {
                args.horizontalOffset = 0;
            }
            if (scrollToY !== null) {
                args.verticalOffset = 0;
            }
            
            // rekursiver Aufruf
            kijs.Dom.scrollIntoView(parentNode, args);
        }
        
    }
    
    
    // Aktuelles Farbschema zurückgeben
    static themeGet() {
        return document.querySelector('html').dataset.theme;
    }

    // Farbschema aktivieren. 'light', 'dark' oder null=auto oder einen benutzerdefiniertes Farbschema
    static themeSet(theme) {
        if (theme === null) {
            if (!!window.matchMedia('(prefers-color-scheme: dark)').matches) {
                theme = 'dark';
            } else {
                theme = 'light';
            }
        }
        document.querySelector('html').dataset.theme = theme;
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.Graphic (Static)
// --------------------------------------------------------------
kijs.Graphic = class kijs_Graphic {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Gibt die Positionierung für ein Rechteck zurück, wenn dieses anhand eines anderen Rechtecks positioniert werden soll
     * @param {Object} rect im Format: {x:..., y:..., w:..., h:...}
     * @param {Object} targetRect im Format: {x:..., y:..., w:..., h:...}
     * @param {String} [targetPos='bl'] Ankerpunkt beim Zielelement
     *                                   tl --- t --- tr
     *                                   |             |
     *                                   l      c      r
     *                                   |             |
     *                                   bl --- b --- br
     *
     * @param {String} [pos='tl'] Ankerpunkt beim neuen Element
     * @param {Number} [offsetX=0]
     * @param {Number} [offsetY=0]
     * @returns {Object} {x:..., y:..., w:..., h:...}
     */
    static alignRectToRect(rect, targetRect, targetPos, pos, offsetX, offsetY) {
        const ret = {
            x: rect.x,
            y: rect.y,
            w: rect.w,
            h: rect.h
        };
        targetPos = targetPos || 'bl';
        pos = pos || 'tl';

        offsetX = offsetX || 0;
        offsetY = offsetY || 0;

        // Position des Zielankers ermitteln
        const tAnchor = this.getAnchorPos(targetRect, targetPos);

        // Position des Element-Ankers ermitteln
        const eAnchor = this.getAnchorPos({x:0, y:0, w:rect.w, h:rect.h}, pos);

        ret.x = tAnchor.x - eAnchor.x + offsetX;
        ret.y = tAnchor.y - eAnchor.y + offsetY;

        return ret;
    }


    /**
     * Gibt die Position eines Ankers zu einem Rechteck zurück
     * @param {Object} rect       Rechteck  im Format: {x:..., y:..., w:..., h:...}
     * @param {String} [pos='tl'] Ankerpunkt
     *                            tl --- t --- tr
     *                            |             |
     *                            l      c      r
     *                            |             |
     *                            bl --- b --- br
     * @returns {Object} Position im Format {x:..., y:...}
     */
    static getAnchorPos(rect, pos) {
        const ret = { x: 0, y: 0 };

        // Y-Achse oben
        if (pos.indexOf('t') !== -1) {
            ret.y = rect.y;

        // Y-Achse unten
        } else if (pos.indexOf('b') !== -1) {
            ret.y = rect.y + rect.h;

        // Y-Achse mitte
        } else {
            ret.y = rect.y + Math.floor(rect.h / 2);

        }

        // X-Achse links
        if (pos.indexOf('l') !== -1) {
            ret.x = rect.x;

        // X-Achse rechts
        } else if (pos.indexOf('r') !== -1) {
            ret.x = rect.x + rect.w;

        // X-Achse mitte
        } else {
            ret.x = rect.x + Math.floor(rect.w / 2);

        }

        return ret;
    }
    
    
    /**
     * Gibt die Distanz zwischen zwei Rechtecken zurück.
     * Die Distanz wird jeweils von der Mitte des Rechtecks aus gemessen.
     * @param {Object} rectA    Rechteck  im Format: {x:..., y:..., w:..., h:...}
     * @param {Object} rectB    Rechteck  im Format: {x:..., y:..., w:..., h:...}
     * @returns {Number}        Distanz in Pixel
     */
    static rectsDistance(rectA, rectB) {
        const aX = rectA.x + rectA.w/2;
        const aY = rectA.y + rectA.h/2;
        
        const bX = rectB.x + rectB.w/2;
        const bY = rectB.y + rectB.h/2;
        
        return Math.hypot(bX-aX, bY-aY);
    }
    
    
    /**
     * Schaut ob ein Rechteck in einem anderen Platz hat
     * @param {Object} rect Masse des Rechtecks im Format: {x:..., y:..., w:..., h:...}
     * @param {Object} rectOuter Masse des äusseren Rechtecks im Format: {x:..., y:..., w:..., h:...}
     * @returns {Object} Beispiel: {
     *                              fit: false      // Hat das Rechteck ganz im äusseren platz?
     *                              fitX: false,    // Hat es auf der X-Achse platz?
     *                              fitY: true,     // Hat es auf der Y-Achse platz?
     *                              sizeL: 0,       // Abstand zwischen den linken Rändern der beiden Rechtecke (Minuswert=inneres ragt heraus)
     *                              sizeR: -10,
     *                              sizeT: 10,
     *                              sizeB: 0,
     *                             }
     *
     */
    static rectsOverlap(rect, rectOuter) {
        const ret = {};

        ret.sizeL = rect.x - rectOuter.x;
        ret.sizeR = (rectOuter.x + rectOuter.w) - (rect.x + rect.w);

        ret.sizeT = rect.y - rectOuter.y;
        ret.sizeB = (rectOuter.y + rectOuter.h) - (rect.y + rect.h);


        ret.fitX = ret.sizeL >= 0 && ret.sizeR >= 0;
        ret.fitY = ret.sizeT >= 0 && ret.sizeB >= 0;

        ret.fit = ret.fitX && ret.fitY;

        return ret;
    }


    // FUNKTIONEN ZUR MANIPULATION VON FARBEN
    // --------------------------------------

    /**
     * Ändert die Helligkeit einer Farbe.
     * @param {String|Object} color
     * @param {Number} brightness Helligkeit 0-100%
     * @returns {Object}
     */
    static colorChangeBrightness(color, brightness) {
        let hsv = kijs.Graphic.colorRGBtoHSV(kijs.Graphic.colorGet(color));
        hsv.v = 1 / 100 * brightness;
        return kijs.Graphic.colorHSVtoRGB(hsv);
    }


    /**
     * Parst eine Farbe in einem beliebigen Format zu einem RGB-Objekt
     * @param {String|Array|Object} color
     * @returns {Object|null}
     */
    static colorGet(color) {
        if (kijs.isString(color)) {
            switch (color.toLowerCase()) {
                case 'black':     color = '#000000'; break;
                case 'blue':      color = '#0000FF'; break;
                case 'brown':     color = '#A52A2A'; break;
                case 'cyan':      color = '#00FFFF'; break;
                case 'gold':      color = '#FFD700'; break;
                case 'gray':      color = '#808080'; break;
                case 'grey':      color = '#808080'; break;
                case 'green':     color = '#008000'; break;
                case 'lime':      color = '#00FF00'; break;
                case 'magenta':   color = '#FF00FF'; break;
                case 'navy':      color = '#000080'; break;
                case 'olive':     color = '#808000'; break;
                case 'orange':    color = '#FFA500'; break;
                case 'orchid':    color = '#DA70D6'; break;
                case 'pink':      color = '#FFC0CB'; break;
                case 'red':       color = '#FF0000'; break;
                case 'silver':    color = '#C0C0C0'; break;
                case 'snow':      color = '#FFFAFA'; break;
                case 'turquoise': color = '#40E0D0'; break;
                case 'violet':    color = '#EE82EE'; break;
                case 'white':     color = '#FFFFFF'; break;
                case 'yellow':    color = '#FFFF00'; break;
            }

            if (color.match(/^#?[0-9a-f]{3}$/i)) { // #FFF
                let mt = color.match(/^#?([0-9a-f])([0-9a-f])([0-9a-f])$/i);
                return {
                    r: parseInt(mt[1] + '' + mt[1], 16),
                    g: parseInt(mt[2] + '' + mt[2], 16),
                    b: parseInt(mt[3] + '' + mt[3], 16)
                };

            } else if (color.match(/^#?[0-9a-f]{6}$/i)) { // #FF0011
                let mt = color.match(/^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i);
                return {
                    r: parseInt(mt[1], 16),
                    g: parseInt(mt[2], 16),
                    b: parseInt(mt[3], 16)
                };

            } else if (color.match(/^rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)$/i)) { // rgb(0,255,255)
                let mt = color.match(/^rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)$/i);
                return {
                    r: parseInt(mt[1], 10),
                    g: parseInt(mt[2], 10),
                    b: parseInt(mt[3], 10)
                };
            }

        } else if (kijs.isArray(color) && kijs.isNumber(color[0])  && kijs.isNumber(color[1])  && kijs.isNumber(color[2])) {
            return {
                r: parseInt(color[0], 10),
                g: parseInt(color[1], 10),
                b: parseInt(color[2], 10)
            };

        } else if (kijs.isObject(color) && kijs.isDefined(color.r)  && kijs.isDefined(color.g)  && kijs.isDefined(color.b)) {
            return color;

        } else if (kijs.isObject(color) && kijs.isDefined(color.h)  && kijs.isDefined(color.s)  && kijs.isDefined(color.v)) {
            return kijs.Graphic.colorHSVtoRGB(color);
        }

        throw new kijs.Error('kijs.Graphic: invalid argument for color');
    }
    
    
    /**
     * Gibt die Helligkeit einer Farbe zurück (0-100)
     * @param {String|Object} color
     * @returns {Number}
     */
    static colorGetBrightness(color) {
        let hsv = kijs.Graphic.colorRGBtoHSV(kijs.Graphic.colorGet(color));
        return Math.round(100 * hsv.v);
    }

    /**
     * Gibt den Hex-String einer Farbe zurück.
     * @param {String|Object} color
     * @returns {String}
     */
    static colorGetHex(color) {
        color = kijs.Graphic.colorGet(color);
        let hex = '#';
        hex += kijs.String.padding(color.r.toString(16), 2, '0', 'left');
        hex += kijs.String.padding(color.g.toString(16), 2, '0', 'left');
        hex += kijs.String.padding(color.b.toString(16), 2, '0', 'left');
        return hex.toUpperCase();
    }


    /**
     * HSV in RGB konvertieren
     * @param {Number} h 0-1
     * @param {Number} s 0-1
     * @param {Number} v 0-1
     * @returns {Object}
     */
    static colorHSVtoRGB(h, s, v) {
        let r, g, b, i, f, p, q, t;

        if (arguments.length === 1) {
            s = h.s, v = h.v, h = h.h;
        }

        i = Math.floor(h * 6);
        f = h * 6 - i;
        p = v * (1 - s);
        q = v * (1 - f * s);
        t = v * (1 - (1 - f) * s);
        switch (i % 6) {
            case 0: r = v, g = t, b = p; break;
            case 1: r = q, g = v, b = p; break;
            case 2: r = p, g = v, b = t; break;
            case 3: r = p, g = q, b = v; break;
            case 4: r = t, g = p, b = v; break;
            case 5: r = v, g = p, b = q; break;
        }
        return {
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255)
        };
    }


    /**
     * RGB in HSV konvertieren
     * @param {Number} r 0-255
     * @param {Number} g 0-255
     * @param {Number} b 0-255
     * @returns {Object}
     */
    static colorRGBtoHSV(r, g, b) {
        if (arguments.length === 1) {
            g = r.g, b = r.b, r = r.r;
        }

        let max = Math.max(r, g, b), min = Math.min(r, g, b),
            d = max - min,
            h,
            s = (max === 0 ? 0 : d / max),
            v = max / 255;

        switch (max) {
            case min: h = 0; break;
            case r: h = (g - b) + d * (g < b ? 6: 0); h /= 6 * d; break;
            case g: h = (b - r) + d * 2; h /= 6 * d; break;
            case b: h = (r - g) + d * 4; h /= 6 * d; break;
        }

        return {
            h: h,
            s: s,
            v: v
        };
    }

    // FUNKTIONEN ZUR MANIPULATION VON BILDER
    // --------------------------------------

    /**
     * Konvertiert ein Bild in ein anderes Dateiformat.
     * @param {Blob} sourceImage (jpg, png, gif, svg, etc.)
     * @param {String} targetType Mime der Zieldatei, default image/png.
     * @returns {Promise} Mit dem Blob der neuen Datei.
     */
    static imageConvert(sourceImage, targetType='image/png') {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.src = URL.createObjectURL(sourceImage);

            img.onload = () => {
                try {
                    if ('OffscreenCanvas' in window) {
                        const osc = new OffscreenCanvas(img.width, img.height);
                        const ctx = osc.getContext('2d');

                        if (targetType === 'image/jpeg') {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, img.width, img.height);
                        }
                        ctx.drawImage(img, 0, 0);

                        osc.convertToBlob({type: targetType}).then((blob) => {
                            resolve(blob);
                        }).catch((ex) => {
                            reject(ex);
                        });

                    } else {
                        const cvs = document.createElement('canvas');
                        cvs.width = img.width;
                        cvs.height = img.height;
                        const ctx = cvs.getContext('2d');

                        if (targetType === 'image/jpeg') {
                            ctx.fillStyle = 'white';
                            ctx.fillRect(0, 0, img.width, img.height);
                        }
                        ctx.drawImage(img, 0, 0);

                        cvs.toBlob((blob) => {
                            resolve(blob);
                        }, targetType);
                    }
                    
                } catch(ex) {
                    reject(ex);
                }
            };

            img.onerror = (e) => {
                reject(e);
            };
        });
    }

};/* global kijs */

// --------------------------------------------------------------
// kijs.Navigator (Static)
// --------------------------------------------------------------
/**
 * Klasse gibt Angaben zu Browser und Betriebssystem des Browsers zurück.
 */
kijs.Navigator = class kijs_Navigator {


    // --------------------------------------------------------------
    // STATIC GETTERS / SETTERS
    // --------------------------------------------------------------
    static get browser() { return kijs.Navigator.getBrowserInfo().browser; }
    static get browserVendor() { return kijs.Navigator.getBrowserInfo().browserVendor; }
    static get browserVersion() { return kijs.Navigator.getBrowserInfo().browserVersion; }

    static get isChrome() { return kijs.Navigator.getBrowserInfo().isChrome; }
    static get isChromium() { return kijs.Navigator.getBrowserInfo().isChromium; }
    static get isFirefox() { return kijs.Navigator.getBrowserInfo().isFirefox; }
    static get isEdge() { return kijs.Navigator.getBrowserInfo().isEdge; }
    static get isIE() { return kijs.Navigator.getBrowserInfo().isIE; }
    static get isSafari() { return kijs.Navigator.getBrowserInfo().isSafari; }

    static get isWindows() { return kijs.Navigator.getBrowserInfo().isWindows; }
    static get isMac() { return kijs.Navigator.getBrowserInfo().isMac; }
    static get isAndroid() { return kijs.Navigator.getBrowserInfo().isAndroid; }
    static get isIOS() { return kijs.Navigator.getBrowserInfo().isIOS; }
    static get isLinux() { return kijs.Navigator.getBrowserInfo().isLinux; }

    static get isTouch() { return navigator.maxTouchPoints > 0;}
    
    static get os() { return kijs.Navigator.getBrowserInfo().os; }
    static get osVendor()  { return kijs.Navigator.getBrowserInfo().osVendor; }
    static get osVersion() { return kijs.Navigator.getBrowserInfo().osVersion; }

    static get getParams() { return kijs.Navigator.getGetParams(); }



    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    static getBrowserInfo(userAgent=null) {
        let ua = userAgent || window.navigator.userAgent;

        // antwort aus cache
        if (userAgent === null && kijs.Navigator._bi) {
            return kijs.Navigator._bi;
        }

        let bi = {
            browserVersion: '',
            browserVendor: '',
            browser: '',
            os: '',
            osVersion: '',
            osVendor: '',
            isChrome: false,
            isChromium: false,
            isFirefox: false,
            isEdge: false,
            isIE: false,
            isSafari: false,
            isWindows: false,
            isMac: false,
            isAndroid: false,
            isIOS: false,
            isLinux: false
        };

        // Edge
        if (kijs.Navigator._browserVersion(ua, 'Edge')) {
            bi.browser = 'Edge';
            bi.browserVendor = 'Microsoft';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Edge');
            bi.isEdge = true;

        // Edge (Chromium)
        } else if (kijs.Navigator._browserVersion(ua, 'Edg')) {
            bi.browser = 'Edge';
            bi.browserVendor = 'Microsoft';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Edg');
            bi.isEdge = true;
            bi.isChromium = true;

        // Firefox
        } else if (kijs.Navigator._browserVersion(ua, 'Firefox')) {
            bi.browser = 'Firefox';
            bi.browserVendor = 'Mozilla';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Firefox');
            bi.isFirefox = true;

        // IE 11
        } else if (ua.match(/Trident/i) && ua.match(/rv:11/i)) {
            bi.browser = 'Internet Explorer';
            bi.browserVendor = 'Microsoft';
            bi.browserVersion = '11.0';
            bi.isIE = true;

        // Vivaldi (Chromium)
        } else if (kijs.Navigator._browserVersion(ua, 'Vivaldi')) {
            bi.browser = 'Vivaldi';
            bi.browserVendor = 'Vivaldi';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Vivaldi');
            bi.isChromium = true;

        // Opera (Chromium)
        } else if (kijs.Navigator._browserVersion(ua, 'Opera')) {
            bi.browser = 'Opera';
            bi.browserVendor = 'Opera';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Opera');
            bi.isChromium = true;

        // Samsung Browser (Chromium)
        } else if (kijs.Navigator._browserVersion(ua, 'SamsungBrowser')) {
            bi.browser = 'Internet Browser';
            bi.browserVendor = 'Samsung';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'SamsungBrowser');
            bi.isChromium = true;

        // Chrome
        } else if (kijs.Navigator._browserVersion(ua, 'Chrome')) {
            bi.browser = 'Chrome';
            bi.browserVendor = 'Google';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Chrome');
            bi.isChrome = true;
            bi.isChromium = true;

        // Safari
        } else if (kijs.Navigator._browserVersion(ua, 'Safari')) {
            bi.browser = 'Safari';
            bi.browserVendor = 'Apple';
            bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Version');
            if (!bi.browserVersion) {
                bi.browserVersion = kijs.Navigator._browserVersion(ua, 'Safari');
            }
            bi.isSafari = true;
        }

        // Windows
        let win = ua.match(/Windows NT ([0-9\.]+)/i);
        if (win && win[1]){
            let NtVersion = parseFloat(win[1]);
            bi.isWindows = true;
            bi.os = 'Windows';
            bi.osVendor = 'Microsoft';
            switch (NtVersion) {
                case 5.1:
                case 5.2: bi.osVersion = 'XP'; break;
                case 6.0: bi.osVersion = 'Vista'; break;
                case 6.1: bi.osVersion = '7'; break;
                case 6.2: bi.osVersion = '8'; break;
                case 6.3: bi.osVersion = '8.1'; break;
                case 6.4:
                case 10.0: bi.osVersion = '10'; break;
                default: bi.osVersion = 'NT ' + NtVersion; break;
            }
        }

        // iPad / Iphone
        if (!bi.os && ua.match(/(iPad|iPhone|iPod)/i)) {
            bi.isIOS = true;
            bi.os = ua.match(/iPad/i) ? 'iPadOS' : 'iOS';
            bi.osVendor = 'Apple';
            let os = ua.match(/OS ([0-9_]+)/i);
            if (os) {
                bi.osVersion = kijs.String.replaceAll(os[1], '_', '.');
            }
        }

        // Mac
        if (!bi.os && ua.match(/Macintosh/i)) {
            bi.isMac = true;
            bi.os = 'macOS';
            bi.osVendor = 'Apple';
            let os = ua.match(/OS (?:X )?([0-9_]+)/i);
            if (os) {
                bi.osVersion = kijs.String.replaceAll(os[1], '_', '.');
            }
        }

        // Android
        if (!bi.os && ua.match(/Android/i)) {
            bi.isAndroid = true;
            bi.os = 'Android';
            bi.osVendor = 'Google';
            let os = ua.match(/Android ([0-9\.]+)/i);
            if (os) {
                bi.osVersion = os[1];
            }
        }

        // Linux
        if (!bi.os && ua.match(/Linux/i)) {
            bi.isLinux = true;
            bi.os = 'Linux';
            let os = ua.match(/rv:([0-9\.]+)/i);
            if (os) {
                bi.osVersion = os[1];
            }
        }

        // Speichern für schnellerer Zugriff
        if (userAgent === null) {
            kijs.Navigator._bi = bi;
        }

        return bi;
    }

    /**
     * Fragt 'GET' Parameter aus der URL ab.
     * @param {String|Null} parameterName Null=alle
     */
    static getGetParameter(parameterName) {
        const params = {};
        if ('search' in window.location && window.location.search && 
                window.location.search.length > 1) {
            const pt = window.location.search.substr(1).split('&');
            for (let i=0; i<pt.length; i++) {
                let tmp = pt[i].split('='), key, val;
                key = decodeURIComponent(tmp[0]);
                val = tmp.length === 2 ? decodeURIComponent(tmp[1]) : null;
                params[key] = val;
            };
        }

        if (!kijs.isDefined(parameterName)) {
            return params;
        } else {
            return params[parameterName];
        }
    }

    /**
     * Öffnet einen mailto oder tel Link, so dass kein neues Fenster geöffnet wird
     * und auch das beforeunload Event nicht ausgelöst wird.
     * @param {String} href
     * @returns {undefined}
     */
    static openEmailPhoneLink(href) {
        // kleiner Murgs, damit das Event window.onbeforeunload abgemurgst wird.
        // Dafür werden im Listener kijs.Navigator.__onWindowBeforeUnload alle 
        // anderen Listeners ausschaltet.
        kijs.Navigator.__disableBeforeUnload = true;
        
        // Link öffnen
        window.location.href = href;
        
        kijs.Navigator.__disableBeforeUnload = false;
    }


    // PROTECTED
    static _browserVersion(ua, browser) {
        let re = new RegExp(browser + '/([0-9\\.]+)', 'i');
        let match = ua.match(re);

        if (match && match[1]) {
            return match[1];
        }
        return '';
    }
    
    
    // LISTENERS
    // Listener, der verhindert, dass beim Aufruf von kijs.Navigator.openEmailPhoneLink()
    // ein anderer beforeunload Listener aufgerufen werden kann.
    static __onWindowBeforeUnload(nodeEvent) {
        if (kijs.Navigator.__disableBeforeUnload) {
            nodeEvent.stopImmediatePropagation();
        }
    }
    
};

// Fügt den Listener kijs.Navigator.__onWindowBeforeUnload hinzu. 
// Dies muss hier geschehen, damit er noch vor allen anderen Listener gesetzt
// wird und dann auch aufgerufen wird.
addEventListener("beforeunload", kijs.Navigator.__onWindowBeforeUnload);
/* global kijs */

// --------------------------------------------------------------
// kijs.Char (Static)
// --------------------------------------------------------------

kijs.Char = class kijs_Char {

    // --------------------------------------------------------------
    // STATIC GETTERS / SETTERS
    // --------------------------------------------------------------
    static get charTable() {
        return {
            A: [     // capital A
                0x00C1, // Á    capital A with ACUTE
                0x0102, // Ă    capital A with BREVE
                0x1EAE, // Ắ    capital A with BREVE and ACUTE
                0x1EB6, // Ặ    capital A with BREVE and DOT BELOW
                0x1EB0, // Ằ    capital A with BREVE and GRAVE
                0x1EB2, // Ẳ    capital A with BREVE and HOOK ABOVE
                0x1EB4, // Ẵ    capital A with BREVE and TILDE
                0x01CD, // Ǎ    capital A with CARON
                0x00C2, // Â    capital A with CIRCUMFLEX
                0x1EA4, // Ấ    capital A with CIRCUMFLEX and ACUTE
                0x1EAC, // Ậ    capital A with CIRCUMFLEX and DOT BELOW
                0x1EA6, // Ầ    capital A with CIRCUMFLEX and GRAVE
                0x1EA8, // Ẩ    capital A with CIRCUMFLEX and HOOK ABOVE
                0x1EAA, // Ẫ    capital A with CIRCUMFLEX and TILDE
                0x00C4, // Ä    capital A with DIAERESIS
                0x1EA0, // Ạ    capital A with DOT BELOW
                0x00C0, // À    capital A with GRAVE
                0x1EA2, // Ả    capital A with HOOK ABOVE
                0x0100, // Ā    capital A with MACRON
                0x0104, // Ą    capital A with OGONEK
                0x00C5, // Å    capital A with RING ABOVE
                0x01FA, // Ǻ    capital A with RING ABOVE and ACUTE
                0x00C3, // Ã    capital A with TILDE
                0x00C6, // Æ    capital AE
                0x01FC  // Ǽ    capital AE with ACUTE
            ],

            B: [     // capital B
                0x1E04, // Ḅ    capital B with DOT BELOW
                0x0181  // Ɓ    capital B with HOOK
            ],

            C: [     // capital C
                0x0106, // Ć    capital C with ACUTE
                0x010C, // Č    capital C with CARON
                0x00C7, // Ç    capital C with CEDILLA
                0x0108, // Ĉ    capital C with CIRCUMFLEX
                0x010A, // Ċ    capital C with DOT ABOVE
                0x0186, // Ɔ    capital OPEN O
                0x0297  // ʗ    LATIN LETTER STRETCHED C
            ],

            D: [     // capital D
                0x010E, // Ď    capital D with CARON
                0x1E12, // Ḓ    capital D with CIRCUMFLEX BELOW
                0x1E0C, // Ḍ    capital D with DOT BELOW
                0x018A, // Ɗ    capital D with HOOK
                0x1E0E, // Ḏ    capital D with LINE BELOW
                0x01F2, // ǲ    capital D with SMALL LETTER Z
                0x01C5, // ǅ    capital D with SMALL LETTER Z with CARON
                0x0110, // Đ    capital D with STROKE
                0x00D0, // Ð    capital ETH
                0x01F1, // Ǳ    capital DZ
                0x01C4  // Ǆ    capital DZ with CARON
            ],

            E: [     // capital E
                0x00C9, // É    capital E with ACUTE
                0x0114, // Ĕ    capital E with BREVE
                0x011A, // Ě    capital E with CARON
                0x00CA, // Ê    capital E with CIRCUMFLEX
                0x1EBE, // Ế    capital E with CIRCUMFLEX and ACUTE
                0x1EC6, // Ệ    capital E with CIRCUMFLEX and DOT BELOW
                0x1EC0, // Ề    capital E with CIRCUMFLEX and GRAVE
                0x1EC2, // Ể    capital E with CIRCUMFLEX and HOOK ABOVE
                0x1EC4, // Ễ    capital E with CIRCUMFLEX and TILDE
                0x00CB, // Ë    capital E with DIAERESIS
                0x0116, // Ė    capital E with DOT ABOVE
                0x1EB8, // Ẹ    capital E with DOT BELOW
                0x00C8, // È    capital E with GRAVE
                0x1EBA, // Ẻ    capital E with HOOK ABOVE
                0x0112, // Ē    capital E with MACRON
                0x0118, // Ę    capital E with OGONEK
                0x1EBC, // Ẽ    capital E with TILDE
                0x0190, // Ɛ    capital OPEN E
                0x018F  // Ə    capital SCHWA
            ],

            F: [     // capital F
                0x0191  // Ƒ    capital F with HOOK
            ],

            G: [     // capital G
                0x01F4, // Ǵ    capital G with ACUTE
                0x011E, // Ğ    capital G with BREVE
                0x01E6, // Ǧ    capital G with CARON
                0x0122, // Ģ    capital G with CEDILLA
                0x011C, // Ĝ    capital G with CIRCUMFLEX
                0x0120, // Ġ    capital G with DOT ABOVE
                0x1E20, // Ḡ    capital G with MACRON
                0x029B  // ʛ    LATIN LETTER SMALL CAPITAL G with HOOK
            ],

            H: [     // capital H
                0x1E2A, // Ḫ    capital H with BREVE BELOW
                0x0124, // Ĥ    capital H with CIRCUMFLEX
                0x1E24, // Ḥ    capital H with DOT BELOW
                0x0126  // Ħ    capital H with STROKE
            ],

            I: [     // capital I
                0x00CD, // Í    capital I with ACUTE
                0x012C, // Ĭ    capital I with BREVE
                0x01CF, // Ǐ    capital I with CARON
                0x00CE, // Î    capital I with CIRCUMFLEX
                0x00CF, // Ï    capital I with DIAERESIS
                0x0130, // İ    capital I with DOT ABOVE
                0x1ECA, // Ị    capital I with DOT BELOW
                0x00CC, // Ì    capital I with GRAVE
                0x1EC8, // Ỉ    capital I with HOOK ABOVE
                0x012A, // Ī    capital I with MACRON
                0x012E, // Į    capital I with OGONEK
                0x0128, // Ĩ    capital I with TILDE
                0x0132  // Ĳ    LATIN CAPITAL LIGATURE IJ
            ],

            J: [     // capital J
                0x0134  // Ĵ    capital J with CIRCUMFLEX
            ],

            K: [     // capital K
                0x0136, // Ķ    capital K with CEDILLA
                0x1E32, // Ḳ    capital K with DOT BELOW
                0x0198, // Ƙ    capital K with HOOK
                0x1E34  // Ḵ    capital K with LINE BELOW
            ],

            L: [     // capital L
                0x0139, // Ĺ    capital L with ACUTE
                0x023D, // Ƚ    capital L with BAR
                0x013D, // Ľ    capital L with CARON
                0x013B, // Ļ    capital L with CEDILLA
                0x1E3C, // Ḽ    capital L with CIRCUMFLEX BELOW
                0x1E36, // Ḷ    capital L with DOT BELOW
                0x1E38, // Ḹ    capital L with DOT BELOW and MACRON
                0x1E3A, // Ḻ    capital L with LINE BELOW
                0x013F, // Ŀ    capital L with MIDDLE DOT
                0x01C8, // ǈ    capital L with SMALL LETTER J
                0x0141, // Ł    capital L with STROKE
                0x01C7  // Ǉ    capital LJ
            ],

            M: [     // capital M
                0x1E3E, // Ḿ    capital M with ACUTE
                0x1E40, // Ṁ    capital M with DOT ABOVE
                0x1E42  // Ṃ    capital M with DOT BELOW
            ],

            N: [     // capital N
                0x0143, // Ń    capital N with ACUTE
                0x0147, // Ň    capital N with CARON
                0x0145, // Ņ    capital N with CEDILLA
                0x1E4A, // Ṋ    capital N with CIRCUMFLEX BELOW
                0x1E44, // Ṅ    capital N with DOT ABOVE
                0x1E46, // Ṇ    capital N with DOT BELOW
                0x01F8, // Ǹ    capital N with GRAVE
                0x019D, // Ɲ    capital N with LEFT HOOK
                0x1E48, // Ṉ    capital N with LINE BELOW
                0x01CB, // ǋ    capital N with SMALL LETTER J
                0x00D1, // Ñ    capital N with TILDE
                0x01CA  // Ǌ    capital NJ
            ],

            O: [     // capital O
                0x00D3, // Ó    capital O with ACUTE
                0x014E, // Ŏ    capital O with BREVE
                0x01D1, // Ǒ    capital O with CARON
                0x00D4, // Ô    capital O with CIRCUMFLEX
                0x1ED0, // Ố    capital O with CIRCUMFLEX and ACUTE
                0x1ED8, // Ộ    capital O with CIRCUMFLEX and DOT BELOW
                0x1ED2, // Ồ    capital O with CIRCUMFLEX and GRAVE
                0x1ED4, // Ổ    capital O with CIRCUMFLEX and HOOK ABOVE
                0x1ED6, // Ỗ    capital O with CIRCUMFLEX and TILDE
                0x00D6, // Ö    capital O with DIAERESIS
                0x1ECC, // Ọ    capital O with DOT BELOW
                0x0150, // Ő    capital O with DOUBLE ACUTE
                0x00D2, // Ò    capital O with GRAVE
                0x1ECE, // Ỏ    capital O with HOOK ABOVE
                0x01A0, // Ơ    capital O with HORN
                0x1EDA, // Ớ    capital O with HORN and ACUTE
                0x1EE2, // Ợ    capital O with HORN and DOT BELOW
                0x1EDC, // Ờ    capital O with HORN and GRAVE
                0x1EDE, // Ở    capital O with HORN and HOOK ABOVE
                0x1EE0, // Ỡ    capital O with HORN and TILDE
                0x014C, // Ō    capital O with MACRON
                0x019F, // Ɵ    capital O with MIDDLE TILDE
                0x01EA, // Ǫ    capital O with OGONEK
                0x00D8, // Ø    capital O with STROKE
                0x01FE, // Ǿ    capital O with STROKE and ACUTE
                0x00D5, // Õ    capital O with TILDE
                0x0152, // Œ    LATIN CAPITAL LIGATURE OE
                0x0276  // ɶ    LATIN LETTER SMALL CAPITAL OE
            ],

            P: [     // capital P
                0x00DE  // Þ    capital THORN
            ],

            Q: [     // capital Q
            ],

            R: [     // capital R
                0x0154, // Ŕ    capital R with ACUTE
                0x0158, // Ř    capital R with CARON
                0x0156, // Ŗ    capital R with CEDILLA
                0x1E58, // Ṙ    capital R with DOT ABOVE
                0x1E5A, // Ṛ    capital R with DOT BELOW
                0x1E5C, // Ṝ    capital R with DOT BELOW and MACRON
                0x1E5E, // Ṟ    capital R with LINE BELOW
                0x0281  // ʁ    LATIN LETTER SMALL CAPITAL INVERTED R
            ],

            S: [     // capital S
                0x015A, // Ś    capital S with ACUTE
                0x0160, // Š    capital S with CARON
                0x015E, // Ş    capital S with CEDILLA
                0x015C, // Ŝ    capital S with CIRCUMFLEX
                0x0218, // Ș    capital S with COMMA BELOW
                0x1E60, // Ṡ    capital S with DOT ABOVE
                0x1E62, // Ṣ    capital S with DOT BELOW
                0x1E9E  // ẞ    capital SHARP S
            ],

            T: [     // capital T
                0x0164, // Ť    capital T with CARON
                0x0162, // Ţ    capital T with CEDILLA
                0x1E70, // Ṱ    capital T with CIRCUMFLEX BELOW
                0x021A, // Ț    capital T with COMMA BELOW
                0x1E6C, // Ṭ    capital T with DOT BELOW
                0x1E6E, // Ṯ    capital T with LINE BELOW
                0x0166, // Ŧ    capital T with STROKE
                0x00DE, // Þ    capital THORN
                0x00D0  // Ð    capital ETH
            ],

            U: [     // capital U
                0x00DA, // Ú    capital U with ACUTE
                0x016C, // Ŭ    capital U with BREVE
                0x01D3, // Ǔ    capital U with CARON
                0x00DB, // Û    capital U with CIRCUMFLEX
                0x00DC, // Ü    capital U with DIAERESIS
                0x01D7, // Ǘ    capital U with DIAERESIS and ACUTE
                0x01D9, // Ǚ    capital U with DIAERESIS and CARON
                0x01DB, // Ǜ    capital U with DIAERESIS and GRAVE
                0x01D5, // Ǖ    capital U with DIAERESIS and MACRON
                0x1EE4, // Ụ    capital U with DOT BELOW
                0x0170, // Ű    capital U with DOUBLE ACUTE
                0x00D9, // Ù    capital U with GRAVE
                0x1EE6, // Ủ    capital U with HOOK ABOVE
                0x01AF, // Ư    capital U with HORN
                0x1EE8, // Ứ    capital U with HORN and ACUTE
                0x1EF0, // Ự    capital U with HORN and DOT BELOW
                0x1EEA, // Ừ    capital U with HORN and GRAVE
                0x1EEC, // Ử    capital U with HORN and HOOK ABOVE
                0x1EEE, // Ữ    capital U with HORN and TILDE
                0x016A, // Ū    capital U with MACRON
                0x0172, // Ų    capital U with OGONEK
                0x016E, // Ů    capital U with RING ABOVE
                0x0168  // Ũ    capital U with TILDE
            ],

            V: [     // capital V
            ],

            W: [     // capital W
                0x1E82, // Ẃ    capital W with ACUTE
                0x0174, // Ŵ    capital W with CIRCUMFLEX
                0x1E84, // Ẅ    capital W with DIAERESIS
                0x1E80, // Ẁ    capital W with GRAVE
                0x02AC  // ʬ    LATIN LETTER BILABIAL PERCUSSIVE
            ],

            X: [     // capital X
            ],

            Y: [     // capital Y
                0x00DD, // Ý    capital Y with ACUTE
                0x0176, // Ŷ    capital Y with CIRCUMFLEX
                0x0178, // Ÿ    capital Y with DIAERESIS
                0x1E8E, // Ẏ    capital Y with DOT ABOVE
                0x1EF4, // Ỵ    capital Y with DOT BELOW
                0x1EF2, // Ỳ    capital Y with GRAVE
                0x01B3, // Ƴ    capital Y with HOOK
                0x1EF6, // Ỷ    capital Y with HOOK ABOVE
                0x0232, // Ȳ    capital Y with MACRON
                0x1EF8  // Ỹ    capital Y with TILDE
            ],

            Z: [     // capital Z
                0x0179, // Ź    capital Z with ACUTE
                0x017D, // Ž    capital Z with CARON
                0x017B, // Ż    capital Z with DOT ABOVE
                0x1E92, // Ẓ    capital Z with DOT BELOW
                0x1E94, // Ẕ    capital Z with LINE BELOW
                0x01B5  // Ƶ    capital Z with STROKE
            ],

            a: [     // lowercase A
                0x00E1, // á    lowercase A with ACUTE
                0x0103, // ă    lowercase A with BREVE
                0x1EAF, // ắ    lowercase A with BREVE and ACUTE
                0x1EB7, // ặ    lowercase A with BREVE and DOT BELOW
                0x1EB1, // ằ    lowercase A with BREVE and GRAVE
                0x1EB3, // ẳ    lowercase A with BREVE and HOOK ABOVE
                0x1EB5, // ẵ    lowercase A with BREVE and TILDE
                0x01CE, // ǎ    lowercase A with CARON
                0x00E2, // â    lowercase A with CIRCUMFLEX
                0x1EA5, // ấ    lowercase A with CIRCUMFLEX and ACUTE
                0x1EAD, // ậ    lowercase A with CIRCUMFLEX and DOT BELOW
                0x1EA7, // ầ    lowercase A with CIRCUMFLEX and GRAVE
                0x1EA9, // ẩ    lowercase A with CIRCUMFLEX and HOOK ABOVE
                0x1EAB, // ẫ    lowercase A with CIRCUMFLEX and TILDE
                0x00E4, // ä    lowercase A with DIAERESIS
                0x1EA1, // ạ    lowercase A with DOT BELOW
                0x00E0, // à    lowercase A with GRAVE
                0x1EA3, // ả    lowercase A with HOOK ABOVE
                0x0101, // ā    lowercase A with MACRON
                0x0105, // ą    lowercase A with OGONEK
                0x00E5, // å    lowercase A with RING ABOVE
                0x01FB, // ǻ    lowercase A with RING ABOVE and ACUTE
                0x00E3, // ã    lowercase A with TILDE
                0x00E6, // æ    lowercase AE
                0x01FD, // ǽ    lowercase AE with ACUTE
                0x0251, // ɑ    lowercase ALPHA
                0x0250, // ɐ    lowercase TURNED A
                0x0252  // ɒ    lowercase TURNED ALPHA
            ],

            b: [     // lowercase B
                0x1E05, // ḅ    lowercase B with DOT BELOW
                0x0253, // ɓ    lowercase B with HOOK
                0x00DF  // ß    lowercase SHARP S
            ],

            c: [     // lowercase C
                0x0107, // ć    lowercase C with ACUTE
                0x010D, // č    lowercase C with CARON
                0x00E7, // ç    lowercase C with CEDILLA
                0x0109, // ĉ    lowercase C with CIRCUMFLEX
                0x0255, // ɕ    lowercase C with CURL
                0x010B  // ċ    lowercase C with DOT ABOVE
            ],

            d: [     // lowercase D
                0x010F, // ď    lowercase D with CARON
                0x1E13, // ḓ    lowercase D with CIRCUMFLEX BELOW
                0x1E0D, // ḍ    lowercase D with DOT BELOW
                0x0257, // ɗ    lowercase D with HOOK
                0x1E0F, // ḏ    lowercase D with LINE BELOW
                0x0111, // đ    lowercase D with STROKE
                0x0256, // ɖ    lowercase D with TAIL
                0x02A4, // ʤ    lowercase DEZH DIGRAPH
                0x01F3, // ǳ    lowercase DZ
                0x02A3, // ʣ    lowercase DZ DIGRAPH
                0x02A5, // ʥ    lowercase DZ DIGRAPH with CURL
                0x01C6, // ǆ    lowercase DZ with CARON
                0x00F0  // ð    lowercase ETH
            ],

            e: [     // lowercase E
                0x00E9, // é    lowercase E with ACUTE
                0x0115, // ĕ    lowercase E with BREVE
                0x011B, // ě    lowercase E with CARON
                0x00EA, // ê    lowercase E with CIRCUMFLEX
                0x1EBF, // ế    lowercase E with CIRCUMFLEX and ACUTE
                0x1EC7, // ệ    lowercase E with CIRCUMFLEX and DOT BELOW
                0x1EC1, // ề    lowercase E with CIRCUMFLEX and GRAVE
                0x1EC3, // ể    lowercase E with CIRCUMFLEX and HOOK ABOVE
                0x1EC5, // ễ    lowercase E with CIRCUMFLEX and TILDE
                0x00EB, // ë    lowercase E with DIAERESIS
                0x0117, // ė    lowercase E with DOT ABOVE
                0x1EB9, // ẹ    lowercase E with DOT BELOW
                0x00E8, // è    lowercase E with GRAVE
                0x1EBB, // ẻ    lowercase E with HOOK ABOVE
                0x0113, // ē    lowercase E with MACRON
                0x0119, // ę    lowercase E with OGONEK
                0x1EBD, // ẽ    lowercase E with TILDE
                0x0292, // ʒ    lowercase EZH
                0x01EF, // ǯ    lowercase EZH with CARON
                0x0293, // ʓ    lowercase EZH with CURL
                0x0258, // ɘ    lowercase REVERSED E
                0x025C, // ɜ    lowercase REVERSED OPEN E
                0x025D, // ɝ    lowercase REVERSED OPEN E with HOOK
                0x0259, // ə    lowercase SCHWA
                0x025A, // ɚ    lowercase SCHWA with HOOK
                0x029A, // ʚ    lowercase CLOSED OPEN E
                0x025E  // ɞ    lowercase CLOSED REVERSED OPEN E
            ],

            f: [     // lowercase F
                0x0192, // ƒ    lowercase F with HOOK
                0x017F, // ſ    lowercase LONG S
                0x02A9, // ʩ    lowercase FENG DIGRAPH
                0xFB01, // ﬁ    LATIN SMALL LIGATURE FI
                0xFB02, // ﬂ    LATIN SMALL LIGATURE FL
                0x0283, // ʃ    lowercase ESH
                0x0286, // ʆ    lowercase ESH with CURL
                0x0285, // ʅ    lowercase SQUAT REVERSED ESH
                0x025F, // ɟ    lowercase DOTLESS J with STROKE
                0x0284  // ʄ    lowercase DOTLESS J with STROKE and HOOK
            ],

            g: [     // lowercase G
                0x01F5, // ǵ    lowercase G with ACUTE
                0x011F, // ğ    lowercase G with BREVE
                0x01E7, // ǧ    lowercase G with CARON
                0x0123, // ģ    lowercase G with CEDILLA
                0x011D, // ĝ    lowercase G with CIRCUMFLEX
                0x0121, // ġ    lowercase G with DOT ABOVE
                0x0260, // ɠ    lowercase G with HOOK
                0x1E21, // ḡ    lowercase G with MACRON
                0x0261, // ɡ    lowercase SCRIPT G
                0x0263  // ɣ    lowercase GAMMA
            ],

            h: [     // lowercase H
                0x1E2B, // ḫ    lowercase H with BREVE BELOW
                0x0125, // ĥ    lowercase H with CIRCUMFLEX
                0x1E25, // ḥ    lowercase H with DOT BELOW
                0x0266, // ɦ    lowercase H with HOOK
                0x1E96, // ẖ    lowercase H with LINE BELOW
                0x0127, // ħ    lowercase H with STROKE
                0x0267, // ɧ    lowercase HENG with HOOK
                0x0265, // ɥ    lowercase TURNED H
                0x02AE, // ʮ    lowercase TURNED H with FISHHOOK
                0x02AF, // ʯ    lowercase TURNED H with FISHHOOK and TAIL
                0x0173  // ų    lowercase U with OGONEK
            ],

            i: [     // lowercase I
                0x00ED, // í    lowercase I with ACUTE
                0x012D, // ĭ    lowercase I with BREVE
                0x01D0, // ǐ    lowercase I with CARON
                0x00EE, // î    lowercase I with CIRCUMFLEX
                0x00EF, // ï    lowercase I with DIAERESIS
                0x1ECB, // ị    lowercase I with DOT BELOW
                0x00EC, // ì    lowercase I with GRAVE
                0x1EC9, // ỉ    lowercase I with HOOK ABOVE
                0x012B, // ī    lowercase I with MACRON
                0x012F, // į    lowercase I with OGONEK
                0x0268, // ɨ    lowercase I with STROKE
                0x0129, // ĩ    lowercase I with TILDE
                0x0269, // ɩ    lowercase IOTA
                0x0131, // ı    lowercase DOTLESS I
                0x0133, // ĳ    LATIN SMALL LIGATURE IJ
                0x025F  // ɟ    lowercase DOTLESS J with STROKE
            ],

            j: [     // lowercase J
                0x01F0, // ǰ    lowercase J with CARON
                0x0135, // ĵ    lowercase J with CIRCUMFLEX
                0x029D, // ʝ    lowercase J with CROSSED-TAIL
                0x0237, // ȷ    lowercase DOTLESS J
                0x025F, // ɟ    lowercase DOTLESS J with STROKE
                0x0284  // ʄ    lowercase DOTLESS J with STROKE and HOOK
            ],

            k: [     // lowercase K
                0x0137, // ķ    lowercase K with CEDILLA
                0x1E33, // ḳ    lowercase K with DOT BELOW
                0x0199, // ƙ    lowercase K with HOOK
                0x1E35, // ḵ    lowercase K with LINE BELOW
                0x0138, // ĸ    lowercase KRA
                0x029E  // ʞ    lowercase TURNED K
            ],

            l: [     // lowercase L
                0x013A, // ĺ    lowercase L with ACUTE
                0x019A, // ƚ    lowercase L with BAR
                0x026C, // ɬ    lowercase L with BELT
                0x013E, // ľ    lowercase L with CARON
                0x013C, // ļ    lowercase L with CEDILLA
                0x1E3D, // ḽ    lowercase L with CIRCUMFLEX BELOW
                0x1E37, // ḷ    lowercase L with DOT BELOW
                0x1E39, // ḹ    lowercase L with DOT BELOW and MACRON
                0x1E3B, // ḻ    lowercase L with LINE BELOW
                0x0140, // ŀ    lowercase L with MIDDLE DOT
                0x026B, // ɫ    lowercase L with MIDDLE TILDE
                0x026D, // ɭ    lowercase L with RETROFLEX HOOK
                0x0142, // ł    lowercase L with STROKE
                0x019B, // ƛ    lowercase LAMBDA with STROKE
                0x026E, // ɮ    lowercase LEZH
                0x01C9, // ǉ    lowercase LJ
                0x02AA, // ʪ    lowercase LS DIGRAPH
                0x02AB  // ʫ    lowercase LZ DIGRAPH
            ],

            m: [     // lowercase M
                0x1E3F, // ḿ    lowercase M with ACUTE
                0x1E41, // ṁ    lowercase M with DOT ABOVE
                0x1E43, // ṃ    lowercase M with DOT BELOW
                0x0271, // ɱ    lowercase M with HOOK
                0x026F, // ɯ    lowercase TURNED M
                0x0270  // ɰ    lowercase TURNED M with LONG LEG
            ],

            n: [     // lowercase N
                0x0149, // ŉ    lowercase N PRECEDED BY APOSTROPHE
                0x0144, // ń    lowercase N with ACUTE
                0x0148, // ň    lowercase N with CARON
                0x0146, // ņ    lowercase N with CEDILLA
                0x1E4B, // ṋ    lowercase N with CIRCUMFLEX BELOW
                0x1E45, // ṅ    lowercase N with DOT ABOVE
                0x1E47, // ṇ    lowercase N with DOT BELOW
                0x01F9, // ǹ    lowercase N with GRAVE
                0x0272, // ɲ    lowercase N with LEFT HOOK
                0x1E49, // ṉ    lowercase N with LINE BELOW
                0x0273, // ɳ    lowercase N with RETROFLEX HOOK
                0x00F1, // ñ    lowercase N with TILDE
                0x01CC, // ǌ    lowercase NJ
                0x014B, // ŋ    lowercase ENG
                0x014A  // Ŋ    capital ENG
            ],

            o: [     // lowercase O
                0x00F3, // ó    lowercase O with ACUTE
                0x014F, // ŏ    lowercase O with BREVE
                0x01D2, // ǒ    lowercase O with CARON
                0x00F4, // ô    lowercase O with CIRCUMFLEX
                0x1ED1, // ố    lowercase O with CIRCUMFLEX and ACUTE
                0x1ED9, // ộ    lowercase O with CIRCUMFLEX and DOT BELOW
                0x1ED3, // ồ    lowercase O with CIRCUMFLEX and GRAVE
                0x1ED5, // ổ    lowercase O with CIRCUMFLEX and HOOK ABOVE
                0x1ED7, // ỗ    lowercase O with CIRCUMFLEX and TILDE
                0x00F6, // ö    lowercase O with DIAERESIS
                0x1ECD, // ọ    lowercase O with DOT BELOW
                0x0151, // ő    lowercase O with DOUBLE ACUTE
                0x00F2, // ò    lowercase O with GRAVE
                0x1ECF, // ỏ    lowercase O with HOOK ABOVE
                0x01A1, // ơ    lowercase O with HORN
                0x1EDB, // ớ    lowercase O with HORN and ACUTE
                0x1EE3, // ợ    lowercase O with HORN and DOT BELOW
                0x1EDD, // ờ    lowercase O with HORN and GRAVE
                0x1EDF, // ở    lowercase O with HORN and HOOK ABOVE
                0x1EE1, // ỡ    lowercase O with HORN and TILDE
                0x014D, // ō    lowercase O with MACRON
                0x01EB, // ǫ    lowercase O with OGONEK
                0x00F8, // ø    lowercase O with STROKE
                0x01FF, // ǿ    lowercase O with STROKE and ACUTE
                0x00F5, // õ    lowercase O with TILDE
                0x025B, // ɛ    lowercase OPEN E
                0x0254, // ɔ    lowercase OPEN O
                0x0275, // ɵ    lowercase BARRED O
                0x0298, // ʘ    LATIN LETTER BILABIAL CLICK
                0x0153  // œ    LATIN SMALL LIGATURE OE
            ],

            p: [     // lowercase P
                0x0278, // ɸ    lowercase PHI
                0x00FE  // þ    lowercase THORN
            ],

            q: [     // lowercase Q
                0x02A0  // ʠ    lowercase Q with HOOK
            ],

            r: [     // lowercase R
                0x0155, // ŕ    lowercase R with ACUTE
                0x0159, // ř    lowercase R with CARON
                0x0157, // ŗ    lowercase R with CEDILLA
                0x1E59, // ṙ    lowercase R with DOT ABOVE
                0x1E5B, // ṛ    lowercase R with DOT BELOW
                0x1E5D, // ṝ    lowercase R with DOT BELOW and MACRON
                0x027E, // ɾ    lowercase R with FISHHOOK
                0x1E5F, // ṟ    lowercase R with LINE BELOW
                0x027C, // ɼ    lowercase R with LONG LEG
                0x027D, // ɽ    lowercase R with TAIL
                0x027F, // ɿ    lowercase REVERSED R with FISHHOOK
                0x0279, // ɹ    lowercase TURNED R
                0x027B, // ɻ    lowercase TURNED R with HOOK
                0x027A  // ɺ    lowercase TURNED R with LONG LEG
            ],

            s: [     // lowercase S
                0x015B, // ś    lowercase S with ACUTE
                0x0161, // š    lowercase S with CARON
                0x015F, // ş    lowercase S with CEDILLA
                0x015D, // ŝ    lowercase S with CIRCUMFLEX
                0x0219, // ș    lowercase S with COMMA BELOW
                0x1E61, // ṡ    lowercase S with DOT ABOVE
                0x1E63, // ṣ    lowercase S with DOT BELOW
                0x0282, // ʂ    lowercase S with HOOK
                0x017F, // ſ    lowercase LONG S
                0x0283, // ʃ    lowercase ESH
                0x0286, // ʆ    lowercase ESH with CURL
                0x00DF, // ß    lowercase SHARP S
                0x0285  // ʅ    lowercase SQUAT REVERSED ESH
            ],

            t: [     // lowercase T
                0x0165, // ť    lowercase T with CARON
                0x0163, // ţ    lowercase T with CEDILLA
                0x1E71, // ṱ    lowercase T with CIRCUMFLEX BELOW
                0x021B, // ț    lowercase T with COMMA BELOW
                0x1E97, // ẗ    lowercase T with DIAERESIS
                0x1E6D, // ṭ    lowercase T with DOT BELOW
                0x1E6F, // ṯ    lowercase T with LINE BELOW
                0x0288, // ʈ    lowercase T with RETROFLEX HOOK
                0x0167, // ŧ    lowercase T with STROKE
                0x02A8, // ʨ    lowercase TC DIGRAPH with CURL
                0x02A7, // ʧ    lowercase TESH DIGRAPH
                0x00FE, // þ    lowercase THORN
                0x00F0, // ð    lowercase ETH
                0x02A6, // ʦ    lowercase TS DIGRAPH
                0x0287  // ʇ    lowercase TURNED T
            ],

            u: [     // lowercase U
                0x0289, // ʉ    lowercase U BAR
                0x00FA, // ú    lowercase U with ACUTE
                0x016D, // ŭ    lowercase U with BREVE
                0x01D4, // ǔ    lowercase U with CARON
                0x00FB, // û    lowercase U with CIRCUMFLEX
                0x00FC, // ü    lowercase U with DIAERESIS
                0x01D8, // ǘ    lowercase U with DIAERESIS and ACUTE
                0x01DA, // ǚ    lowercase U with DIAERESIS and CARON
                0x01DC, // ǜ    lowercase U with DIAERESIS and GRAVE
                0x01D6, // ǖ    lowercase U with DIAERESIS and MACRON
                0x1EE5, // ụ    lowercase U with DOT BELOW
                0x0171, // ű    lowercase U with DOUBLE ACUTE
                0x00F9, // ù    lowercase U with GRAVE
                0x1EE7, // ủ    lowercase U with HOOK ABOVE
                0x01B0, // ư    lowercase U with HORN
                0x1EE9, // ứ    lowercase U with HORN and ACUTE
                0x1EF1, // ự    lowercase U with HORN and DOT BELOW
                0x1EEB, // ừ    lowercase U with HORN and GRAVE
                0x1EED, // ử    lowercase U with HORN and HOOK ABOVE
                0x1EEF, // ữ    lowercase U with HORN and TILDE
                0x016B, // ū    lowercase U with MACRON
                0x0173, // ų    lowercase U with OGONEK
                0x016F, // ů    lowercase U with RING ABOVE
                0x0169, // ũ    lowercase U with TILDE
                0x028A  // ʊ    lowercase UPSILON
            ],

            v: [     // lowercase V
                0x028B, // ʋ    lowercase V with HOOK
                0x028C  // ʌ    lowercase TURNED V
            ],

            w: [     // lowercase W
                0x1E83, // ẃ    lowercase W with ACUTE
                0x0175, // ŵ    lowercase W with CIRCUMFLEX
                0x1E85, // ẅ    lowercase W with DIAERESIS
                0x1E81, // ẁ    lowercase W with GRAVE
                0x028D  // ʍ    lowercase TURNED W
            ],

            x: [     // lowercase X
            ],

            y: [     // lowercase Y
                0x00FD, // ý    lowercase Y with ACUTE
                0x0177, // ŷ    lowercase Y with CIRCUMFLEX
                0x00FF, // ÿ    lowercase Y with DIAERESIS
                0x1E8F, // ẏ    lowercase Y with DOT ABOVE
                0x1EF5, // ỵ    lowercase Y with DOT BELOW
                0x1EF3, // ỳ    lowercase Y with GRAVE
                0x01B4, // ƴ    lowercase Y with HOOK
                0x1EF7, // ỷ    lowercase Y with HOOK ABOVE
                0x0233, // ȳ    lowercase Y with MACRON
                0x1EF9, // ỹ    lowercase Y with TILDE
                0x028E  // ʎ    lowercase TURNED Y
            ],

            z: [     // lowercase Z
                0x017A, // ź    lowercase Z with ACUTE
                0x017E, // ž    lowercase Z with CARON
                0x0291, // ʑ    lowercase Z with CURL
                0x017C, // ż    lowercase Z with DOT ABOVE
                0x1E93, // ẓ    lowercase Z with DOT BELOW
                0x1E95, // ẕ    lowercase Z with LINE BELOW
                0x0290, // ʐ    lowercase Z with RETROFLEX HOOK
                0x01B6  // ƶ    lowercase Z with STROKE
            ]
        };
    };


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------

    /**
     * Returns a RegExp String with every letter (a-zA-Z) replaced with all variants of this letter.
     * Ex.: 'a' => '[aáăắặằẳẵǎâấậầẩẫäạàảāąåǻãæǽɑɐɒ]'
     * @param {String} text
     * @returns {String}
     */
    static getRegexPattern(text) {

        // String in Buchstabenarray aufteilen
        let letters = null;
        if (kijs.isFunction(Array.from)) {
            letters = Array.from(text);
            
        } else { // Fallback für IE
            letters = text.split('');
        }

        let regex = '';
        kijs.Array.each(letters, function(letter) {
            if (kijs.isArray(kijs.Char.charTable[letter]) && kijs.Char.charTable[letter].length > 0) {
                regex += '[' + letter;
                kijs.Array.each(kijs.Char.charTable[letter], function(specialLetter) {
                    regex += String.fromCodePoint ? String.fromCodePoint(specialLetter) : String.fromCharCode(specialLetter);
                }, this);
                regex += ']';
            } else {
                regex += '' + letter;
            }
        }, this);

        return regex;
    }

    /**
     * Replaces special chars with their base char (öüä => oua).
     * @param {String} text
     * @returns {String}
     */
    static replaceSpecialChars(text) {

        // String in Buchstabenarray aufteilen
        let letters = null;
        if (kijs.isFunction(Array.from)) {
            letters = Array.from(text);
        } else { // Fallback für IE
            letters = text.split('');
        }

        let responseText = '';
        kijs.Array.each(letters, function(letter) {
           for (let char in kijs.Char.charTable) {
               if (kijs.Array.contains(kijs.Char.charTable[char], letter.codePointAt ? letter.codePointAt(0) : letter.charCodeAt(0))) {
                   responseText += char;
                   return;
               }
           }

           // no match
           responseText += letter;
        });

        return responseText;
    }
};/* global kijs */

// --------------------------------------------------------------
// kijs.Storage (Static)
// --------------------------------------------------------------
/**
 * Klasse zum Lesen und Schreiben in den Local- oder Sessionstorage.
 * Damit keine Konflikte entstehen, wenn mehrere KIJS-Frameworks unter
 * der selben Domain laufen, wird standardmässig der Titel der Webseite
 * als prefix verwendet. Wenn dieses nicht sein soll, kann als argument
 * ein anderes Prefix übergeben werden.
 */
kijs.Storage = class kijs_Storage {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------

    /**
     * Liest einen Wert aus dem Storage.
     * @param {String} key
     * @param {String} [mode]                  'local' für LocalStorage oder 'session' für SessionStorage
     * @param {Boolean|String} [keyPrefix]     individuelles prefix, falls nicht der titel verwendet werden soll.
     * @returns {Mixed}
     */
    static getItem(key, mode='local', keyPrefix=true) {
        let prefix = kijs.Storage._getPrefix(keyPrefix),
                storage = kijs.Storage._getStorage(mode);
        try {
            if (!storage) {
                return false;
            }

            let val = storage.getItem(prefix + key);
            if (val) {
                val = JSON.parse(val);
                if (val && kijs.isObject(val) && val.value !== undefined) {
                    return val.value;
                }
            }
            return null;

        } catch(ex) {
            return false;
        }
    }

    /**
     * Gibt alle gespeicherten Schlüssel in einem Array zurück
     * @param {String} [mode]                  'local' für LocalStorage oder 'session' für SessionStorage
     * @param {Boolean|String} [keyPrefix]     individuelles prefix, falls nicht der titel verwendet werden soll.
     * @returns {Array}
     */
    static getKeys(mode='local', keyPrefix=true) {
        let prefix = kijs.Storage._getPrefix(keyPrefix),
                storage = kijs.Storage._getStorage(mode);
        try {
            if (!storage || !storage.key) {
                return false;
            }
            let keys = [], i, k;
            for (i=0; i< storage.length; i++) {
                k = storage.key(i);
                if (k && k.substr(0, prefix.length) === prefix) {
                    keys.push(k.substr(prefix.length));
                }
            }
            return keys;

        } catch(ex) {
            return false;
        }
    }

    /**
     * Löscht alle Elemente aus dem localStorage.
     * @param {String} [mode]                  'local' für LocalStorage oder 'session' für SessionStorage
     * @param {Boolean|String} [keyPrefix]     individuelles prefix, falls nicht der titel verwendet werden soll.
     * @returns {Boolean}
     */
    static removeAll(mode='local', keyPrefix=true) {
        let keys = kijs.Storage.getKeys(mode, keyPrefix);

        if (keys === false) {
            return false;
        }

        for (let i=0; i<keys.length; i++) {
            kijs.Storage.removeItem(keys[i], mode, keyPrefix);
        }
        return true;
    }

    /**
     * Löscht ein Wert aus dem LocalStorage.
     * @param {String} key
     * @param {String} [mode]                  'local' für LocalStorage oder 'session' für SessionStorage
     * @param {Boolean|String} [keyPrefix]     individuelles prefix, falls nicht der titel verwendet werden soll.
     * @returns {Boolean}
     */
    static removeItem(key, mode='local', keyPrefix=true) {
        let prefix = kijs.Storage._getPrefix(keyPrefix),
                storage = kijs.Storage._getStorage(mode);
        try {
            if (!storage) {
                return false;
            }
            storage.removeItem(prefix + key);

        } catch(ex) {
            return false;
        }
    }

    /**
     * Speichert einen Wert im LocalStorage.
     * @param {String} key
     * @param {Mixed} value
     * @param {String} [mode]                  'local' für LocalStorage oder 'session' für SessionStorage
     * @param {Boolean|String} [keyPrefix]     individuelles prefix, falls nicht der titel verwendet werden soll.
     * @returns {Boolean}
     */
    static setItem(key, value, mode='local', keyPrefix=true) {
        let prefix = kijs.Storage._getPrefix(keyPrefix),
                storage = kijs.Storage._getStorage(mode);
        try {
            if (!storage || !storage.setItem) {
                return false;
            }
            storage.setItem(prefix + key, JSON.stringify({value: value}));
            return true;

        } catch(ex) {
            return false;
        }
    }

    /**
     * Aktualisiert ein Objekt im LocalStorage
     * @param {String} key
     * @param {Object} value
     * @param {String} [mode]                  'local' für LocalStorage oder 'session' für SessionStorage
     * @param {Boolean|String} [keyPrefix]     individuelles prefix, falls nicht der titel verwendet werden soll.
     * @returns {Boolean}
     */
    static updateItem(key, value, mode='local', keyPrefix=true) {
        if (!kijs.isObject(value)) {
            return false;
        }
        
        let oldValue = kijs.Storage.getItem(key, mode, keyPrefix);
        if (!kijs.isObject(oldValue)) {
            oldValue = {};
        }

        // update
        for (let k in value) {
            oldValue[k] = value[k];
        }

        return kijs.Storage.setItem(key, oldValue, mode, keyPrefix);
    }

    // --------------------------------------------------------------
    // PROTECTED STATICS
    // --------------------------------------------------------------

    /**
     * Gibt die instanz auf den Storage zurück.
     * @param {String} mode 'session' oder 'local'
     * @returns {window.localStorage|window.sessionStorage}
     */
    static _getStorage(mode) {
        if (!kijs.Array.contains(['session', 'local'], mode)) {
            throw new kijs.Error('invalid storage mode');
        }
        return mode === 'session' ? window.sessionStorage : window.localStorage;
    }

    /**
     * Gibt das Prefix zurück
     * @param {String|Boolean} pref
     * @returns {String}
     */
    static _getPrefix(pref) {
        let prefix = 'kijs-';
        if (pref === true && document.title) {
            prefix += document.title.toLowerCase().replace(/[^a-z0-9]/, '') + '-';
        } else if (kijs.isString(pref) && pref) {
            prefix += pref + '-';
        }
        return prefix;
    }
};/* global kijs */

// --------------------------------------------------------------
// kijs.Observable (Abstract)
// --------------------------------------------------------------
kijs.Observable = class kijs_Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    constructor() {
        this._nodeEventListeners = {};
        this._events = this._events || {};  // Beispiel: {
                                            //              click: [
                                            //                {
                                            //                  callback: fn,
                                            //                  context: context
                                            //                },{
                                            //                  callback: fn,
                                            //                  context: context
                                            //                }
                                            //              ],
                                            //              mouseOver: [
                                            //                {
                                            //                  callback: fn,
                                            //                  context: context
                                            //                },{
                                            //                  callback: fn,
                                            //                  context: context
                                            //                }
                                            //              ]
                                            //           }
    }

    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------

    /**
     * Gibt den Namen der Javascript-Klasse zurück
     * @returns {String|null}
     */
    get jsClassName() {
        if (kijs.isString(this.constructor.name)) {
            return kijs.String.replaceAll(this.constructor.name, '_', '.');
        }

        return null;
    }

    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Überprüft ob ein Listener existiert
     * @param {String} name                     Name des Listeners
     * @param {function|null} [callback=null]   Callback Funktion oder null für alle
     * @param {object|null} [context=null]      Kontext oder null für alle
     * @returns {Boolean}
     */
    hasListener(name, callback=null, context=null) {
        let listeners = this._events[name];

        if (listeners) {
            if (!callback && !context) {
                return true;

            } else {
                for (let i=0; i<listeners.length; i++) {
                    let listener = listeners[i];

                    const callbackOk = !callback || callback === listener.callback;
                    const contextOk = !context || context === listener.context;

                    if (callbackOk && contextOk) {
                        return true;
                    }
                }

            }
        }

        return false;
    }

    /**
     * Entfernt ein oder mehrere Listeners
     * @param {string|array|null} [names] - Name oder Array mit Namen der Listeners oder leer um alle zu löschen.
     *
     * @param {function|null} [callback]  - Callback Funktion, deren Listeners gelöscht werden sollen.
     *                                      Wenn leer, werden alle gelöscht.
     *
     * @param {object|null} [context]     - Kontext der Callback Funktion, deren Listeners gelöscht werden sollen.
     *                                      Wenn leer, werden alle gelöscht.
     *
     * @returns {undefined}
     */
    off(names=null, callback=null, context=null) {

        // Wenn kein Argument übergeben wurde: alle Listeners entfernen
        if (!names && !callback && !context) {
            this._events = {};
            return;
        }

        if (kijs.isEmpty(names)) {
            names = Object.keys(this._events);
        } else if (!kijs.isArray(names)) {
            names = [names];
        }

        // Listeners durchgehen und wenn sie mit den übergebenen Argumenten übereinstimmen: entfernen
        kijs.Array.each(names, function(name) {
            let skip = false;

            // Wenn kein Listener existiert: skip
            let listeners = this._events[name];
            if (!listeners) {
                skip = true;
            }

            // Wenn alle callbacks & context entfernt werden können: entfernen
            if (!skip && !callback && !context) {
                delete this._events[name];
                skip = true;
            }

            // ... sonst nur die listeners entfernen, die den Argumenten entsprechen
            // dafür die Listeners durchgehen und die noch gewünschten merken
            if (!skip) {
                let remaining = [];
                for (let j=0; j<listeners.length; j++) {
                    let listener = listeners[j];
                    if ( (callback && callback !== listener.callback)
                            || (context && context !== listener.context) ) {
                        remaining.push(listener);
                    }
                }

                if (remaining.length) {
                    this._events[name] = remaining;
                } else {
                    delete this._events[name];
                }
            }
        }, this);
    }

    /**
     * Erstellt einen Listener
     * @param {string|array} names - Name oder Array mit Namen des Listeners
     * @param {function} callback - Callback-Funktion oder bei name=Object: Standard-Callback-Fn
     * @param {Object} context - Kontext für die Callback-Funktion
     * @returns {undefined}
     */
    on(names, callback, context) {

        if (!kijs.isString(names) && !kijs.isArray(names)) {
            throw new kijs.Error(`invalid argument 1 for on(names, callback, context): string or array expected`);
        }
        if (!kijs.isFunction(callback)) {
            throw new kijs.Error(`invalid argument 2 for on(names, callback, context): function expected`);
        }

        names = kijs.isArray(names) ? names : [names];

        kijs.Array.each(names, function(name) {
            // Falls der Listener noch nicht existiert: einfügen
            if (!this.hasListener(name, callback, context)) {
                if (!this._events[name]) {
                    this._events[name] = [];
                }

                this._events[name].push({
                    callback: callback,
                    context: context
                });
            }

        }, this);
    }

    /**
     * Erstellt einen Listener, der nur einmal ausgeführt wird und sich dann selber wieder entfernt
     * @param {string|array} names - Name oder Array mit Namen des Listeners
     * @param {function} callback - Callback-Funktion oder bei name=Object: Standard-Callback-Fn
     * @param {Object} context - Kontext für die Callback-Funktion
     * @returns {undefined}
     */
    once(names, callback, context) {
        // Wrapper, der anstelle der Callback-Funktion aufgerufen wird.
        // Dieser entfernt den Listener und ruft die Callback-Funktion auf.
        const callbackWrapper = function(e) {
            this.off(names, callbackWrapper, context);
            return callback.apply(context, arguments);
        };

        this.on(names, callbackWrapper, this);
    }

    /**
     * Löst einen Event aus
     * @param {String} [name] - Name des Events oder leer um alle Events auszulösen
     * @param {Mixed} [args] - beliebig viele Argumente, die dem Event übergeben werden
     * @returns {Boolean} - Falls ein Listener false zurückgibt, ist die Rückgabe false, sonst true
     */
    raiseEvent(name, ...args) {
        this._events = this._events || {};

        if (kijs.isEmpty(this._events)) {
            return true;
        }

        // Wenn kein Name übergeben wurde: alle Events auslösen
        if (!kijs.isDefined(name)) {
            name = Object.keys(this._events);
        }

        if (!kijs.isArray(name)) {
            name = [name];
        }

        // Listeners durchgehen und auslösen
        const names = name;
        let returnValue = true;
        for (let i=0; i<names.length; i++) {
            name = names[i];
            const listeners = this._events[name];
            if (listeners) {
                for (let j=0; j<listeners.length; j++) {
                    const listener = listeners[j];
                    if (listener.callback.apply(listener.context, args) === false) {
                        returnValue = false;
                    }
                }
            }

        }

        return returnValue;
    }


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    destruct() {
        this.off();
    }

};/* global kijs */

// --------------------------------------------------------------
// kijs.Ajax (Static)
// --------------------------------------------------------------
kijs.Ajax = class kijs_Ajax {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
    * Führt einen Ajax Request aus
    * Es wird immer ein Promise zurückgegeben. Bei diesem wird immer (auch im Fehlerfall) resolve ausgeführt.
    * 
    * @param {Object} config
    *  config Eigenschaften:
    *     {String} url
    *     {Object} [parameters]        Objekt mit gewünschten Parametern
    *     {object|string} [postData]   Daten die gesendet werden (nur bei POST)
    *     {String} [method='GET']      'GET' oder 'POST'
    *     {Number} [timeout=0]         Timeout des Requests in Millisekunden
    *     {String} [format='json']     'json', 'xml' oder 'text'
    *     {function} fn                Callback Funktion
    *     {function} progressFn        Progress Funktion
    *     {Object} context             Kontext für die Callback Funktion
    *     {Object} [headers]           Objekt mit heders die mitgesendet werden
    *                                  Bsp: {"content-type":"application/x-www-form-urlencoded; charset=UTF-8"}
    *     {Boolean} [disableCaching=false]    Um Antworten aus dem Cache zu verhindern wird ein Parameter
    *                                         'noCache' mit dem aktuellen Timestamp als Wert erstellt
    * @returns {Promise}
    */
    static request(config={}) {
        return new Promise((resolve) => {
            let postData;

            config.method = config.method || 'GET';
            config.format = config.format || 'json';
            config.parameters = config.parameters || {};
            config.abortHappened = false;
            config.timeoutHappened = false;

            if (config.disableCaching) {
                config.parameters.noCache = (new Date()).getTime();
            }

            // Content-Type in den Header schreiben
            if (!config.headers || !config.headers['Content-Type']) {
                let contentType = '';
                switch (config.format) {
                    case 'json': contentType = 'application/json'; break;
                    case 'xml': contentType = 'application/xml'; break;
                    case 'text': contentType = 'text/plain'; break;
                }
                if (contentType) {
                    config.headers = config.headers || {};
                    config.headers['Content-Type'] = contentType;
                }
            }

            // GET-Parameters
            if (config.parameters) {
                const parString = kijs.Ajax.createQueryStringFromObject(config.parameters);
                if (parString) {
                    config.url += (/\?/.test(config.url) ? '&' : '?') + parString;
                }
            }

            // postData
            if (config.method === 'GET') {
                postData = null;

            } else {
                postData = config.postData || null;
                if (kijs.isObject(postData) || kijs.isArray(postData)) {
                    postData = JSON.stringify(postData);
                }

            }

            const xmlhttp = new XMLHttpRequest();

            // Timeout übergeben
            if ('timeout' in config && kijs.isInteger(config.timeout)) {
                xmlhttp.timeout = config.timeout;
            }

            // Fortschritt überwachen
            if (kijs.isFunction(config.progressFn)) {
                xmlhttp.onprogress = function(e) {
                    config.progressFn.call(config.context || this, {
                        nodeEventName : 'onprogress',
                        ajaxConfig: config,
                        useCapture: false,
                        nodeEvent: e,
                        context: config.context
                    });
                };
            }

            xmlhttp.onabort = function() {
                config.abortHappened = true;
            };
            xmlhttp.ontimeout = function() {
                config.timeoutHappened = true;
            };

            xmlhttp.onloadend = function() {
                let val = null;
                
                // Progress Listener wieder entfernen
                xmlhttp.onprogress = null;
                
                if (xmlhttp.status >= 200 && xmlhttp.status <= 299) {
                    switch (config.format) {
                        case 'text':
                            val = xmlhttp.responseText;
                            break;

                        case 'json':
                            try {
                                val = JSON.parse(xmlhttp.responseText);
                            } catch (ex) {
                                val = xmlhttp.responseText;
                            }
                            break;

                        case 'xml':
                            val = kijs.Ajax.parseXml(xmlhttp.responseXML);
                            break;
                    }
                    
                    if (kijs.isFunction(config.fn)) {
                        config.fn.call(config.context || this, {
                            response: val,
                            request: config
                        });
                    }
                    
                    resolve({
                        response: val,
                        request: config
                    });
                    
                } else {
                    let error = '';
                    if (xmlhttp.status > 0) {
                        error = kijs.getText('Der Server hat mit einem Fehler geantwortet') + ': ' + xmlhttp.statusText + ' (Code ' + xmlhttp.status + ')';

                    } else if (config.abortHappened) {
                        error = kijs.getText('Die Verbindung wurde abgebrochen') + '.';

                    } else if (config.timeoutHappened) {
                        error = kijs.getText('Der Server brauchte zu lange, um eine Antwort zu senden') + '. ' +
                                kijs.getText('Die Verbindung wurde abgebrochen') + '.';

                    } else {
                        error = kijs.getText('Die Verbindung konnte nicht aufgebaut werden') + '.';
                    }
                    if (kijs.isFunction(config.fn)) {
                        config.fn.call(config.context || this, {
                            response: val,
                            request: config,
                            errorMsg: error
                        });
                    }
                    resolve({
                        response: null,
                        request: config,
                        errorMsg: error
                    });
                }
            };

            xmlhttp.open(config.method, config.url, true);
            if (config.headers) {
                for (let name in config.headers) {
                    if (config.headers[name] !== null) {
                        xmlhttp.setRequestHeader(name, config.headers[name]);
                    }
                }
            }
            xmlhttp.send(postData);
        });
    }

    /**
     * Erstellt aus einem XML-Document ein Objekt
     * @param {HTMLElement} xml
     * @returns {Object}
     */
     static parseXml(xml) {
        let ret = {};

        // element
        if (xml.nodeType === 1) {
            // do attributes
            if (xml.attributes.length > 0) {
                for (let j=0; j<xml.attributes.length; j++) {
                    let attribute = xml.attributes.item(j);
                    ret[attribute.nodeName] = attribute.nodeValue;
                }
            }

        // text
        } else if (xml.nodeType === 3) {
            ret = xml.nodeValue.trim();
        }

        // do children
        if (xml.hasChildNodes()) {
            for(let i=0; i<xml.childNodes.length; i++) {
                let item = xml.childNodes.item(i);
                let nodeName = item.nodeName;

                if (typeof(ret[nodeName]) === 'undefined') {
                    let tmp = kijs.Ajax.parseXml(item);
                    if (tmp !== '') {
                        ret[nodeName] = tmp;
                    }
                } else {
                    if (typeof(ret[nodeName].push) === "undefined") {
                        let old = ret[nodeName];
                        ret[nodeName] = [];
                        ret[nodeName].push(old);
                    }
                    let tmp = kijs.Ajax.parseXml(item);
                    if (tmp !== '') {
                        ret[nodeName].push(tmp);
                    }
                }
            }
        }
        return ret;
    }

    /**
     * Generiert aus einem parameters-Object einen String, der an die URL angehängt werden kann
     * @param {Object} obj
     * @returns {String}
     */
    static createQueryStringFromObject(obj) {
        let params = [];

        for (let key in obj) {
            let name = encodeURIComponent(key);
            let val = obj[key];

            // object
            if (kijs.isObject(val)) {
                throw new kijs.Error('Objects can not be convert to query strings.');

            // array
            } else if (kijs.isArray(val)) {
                kijs.Array.each(val, function(v) {
                    v = encodeURIComponent(v);
                    params.push(name + '=' + v);
                }, this);

            // string, number, boolean
            } else {
                val = encodeURIComponent(val);
                params.push(name + '=' + val);
            }
        }
        return params.join('&');
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.Rpc
// --------------------------------------------------------------
kijs.Rpc = class kijs_Rpc {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    constructor(config={}) {
        this._defaultConfig = {};

        this._url = '.';                        // URL Beispiel: '.' oder 'index.php'
        this._parameters = {};                  // Objekt mit optionalem GET-Parametern
        this._headers = {'X-LIBRARY': 'kijs'};  // Objekt mit Header
        this._defaultErrorType = 'errorNotice';
        this._defer = 10;
        this._timeout = 0;

        this._deferId = null;
        this._tid = 0;

        this._queue = [];

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            defaultErrorType: true, // Standard errorType, wenn eine errorMsg vorhanden ist ohne errorType
            defer: true,        // millisekunden, in denen auf weitere RPC gewartet wird
            timeout: true,      // millisekunden, nach denen der RPC abgebrochen wird
            url: true,          // server URL
            parameters: true    // optionale GET-Parameter
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config);
        }
    }


    // --------------------------------------------------------------
    // STATIC GETTERS / SETTERS
    // --------------------------------------------------------------
    static get states() {
        return {
            QUEUE: 1,
            TRANSMITTED: 2,
            CANCELED_BEFORE_TRANSMIT: 3,
            CANCELED_AFTER_TRANSMIT: 4
        };
    }


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get defaultErrorType() { return this._defaultErrorType; }
    set defaultErrorType(val) { this._defaultErrorType = val; }

    get defer() { return this._defer; }
    set defer(val) { this._defer = val; }

    get headers() { return this._headers; }
    set headers(val) { this._headers = kijs.isObject(val) ? val : {}; }

    get url() { return this._url; }
    set url(val) { this._url = val; }

    get timeout() { return this._timeout; }
    set timeout(val) { this._timeout = parseInt(val); }


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @returns {undefined}
     */
    applyConfig(config={}) {
        kijs.Object.assignConfig(this, config, this._configMap);
    }

    /**
     * Führt einen RPC aus.
     * - Wird eine fn übergeben, wird diese bei erhalt der Antwort ausgeführt (auch im Fehlerfall).
     *   Die Rückgabe der Funktion ist dann immer Null.
     * - Es wird ein Promise zurückgegeben. Bei diesem wird immer (auch im Fehlerfall) resolve ausgeführt.
     * - Um festzustellen, ob es einen Fehler gegeben hat können errorType und errorMsg abgefragen
     *   werden.
     *
     * @param {Object} config   onfig-Objekt mit folgenden Eingenschaften
     *     {String} remoteFn                     Modul/Facaden-name und Methodenname Bsp: 'address.save'
     *     {Mixed} requestData                   Argumente/Daten, die an die Server-RPC Funktion übergeben werden.
     *     {Object} [owner]                      Verweis auf das Aufzurufende Element oder eine ID,
     *                                           die das Element eindeutig identifiziert.
     *                                           Wird verwendet um bei cancelRunningRpcs den Eigentümmer zu identifizieren.
     *     {Function} [fn]                       Callback-Funktion
     *     {Object} [context]                    Kontext für die Callback-Funktion
     *     {Boolean} [cancelRunningRpcs=false]   Bei true, werden alle laufenden Requests vom selben owner an dieselbe remoteFn abgebrochen
     *     {Boolean} [exclusive=false]           Bei true, wird der RPC sofort gesendet
     *                                           und nicht mit anderen RPCs zusammengefasst.
     *     {Object} [rpcParams]                  Hier können weitere Argumente, zum Datenverkehr (z.B. ignoreWarnings)
     *     {Mixed} [responseArgs]                Hier können Daten übergeben werden,
     *                                           die in der Callback-Fn dann wieder zur Verfügung stehen.
     *                                           z.B. die loadMask, damit sie in der Callback-fn wieder entfernt
     *                                           werden kann.
     * @returns {Promise|Null}
     */
    do(config) {
        // Validierung / Pflichtfelder
        if (!kijs.isObject(config)) {
            throw new kijs.Error('RPC call without config object');
        }
        if (!config.remoteFn) {
            throw new kijs.Error('RPC call without remote function');
        }

        if (this._deferId && !config.exclusive) {
            clearTimeout(this._deferId);
        }

        // Evtl. bestehende RPCs vom gleichen owner an die gleiche remoteFn abbrechen
        // Der  owner ist wichtig, weil z.B. mehrere Combos in einem Formular existieren, 
        // die die gleiche remoteFn benutzen. 
        if (config.cancelRunningRpcs) {
            for (let i=0; i<this._queue.length; i++) {
                if (this._queue[i].owner === config.owner && this._queue[i].remoteFn === config.remoteFn) {
                    switch (this._queue[i].state) {
                        case 1: // queue
                            this._queue[i].state = kijs.Rpc.states.CANCELED_BEFORE_TRANSMIT;
                            this._receive({
                                response: [ { tid: this._queue[i].tid, responseData: {} } ],
                                request: { postData:[this._queue[i]] }
                            });
                            break;

                        case 2: // transmitted
                            this._queue[i].state = kijs.Rpc.states.CANCELED_AFTER_TRANSMIT;
                            break;
                    }
                }
            }
        }

        const queueEl = {
            remoteFn: config.remoteFn,
            requestData: config.requestData,
            type: 'rpc',
            tid: this._createTid(),
            owner: config.owner,
            fn: config.fn,
            context: config.context,
            rpcParams: config.rpcParams,
            responseArgs: config.responseArgs,
            state: kijs.Rpc.states.QUEUE
        };

        let ret = new Promise((resolve) => {
            queueEl.promiseResolve = resolve;
        });

        this._queue.push(queueEl);

        if (config.exclusive) {
            this._transmit(queueEl.tid);
        } else {
            this._deferId = kijs.defer(this._transmit, this.defer, this);
        }

        return ret;
    }


    // PROTECTED
    /**
     * Generiert die nächste Transfer-ID und gibt sie zurück
     * @returns {Number}
     */
    _createTid() {
        this._tid++;
        return this._tid;
    }

    /**
     * Holt einen Request aufgrund der Transfer-ID aus der Queue zurück.
     * @param {Number} tid
     * @returns {Array}
     */
     _getByTid(tid) {
        for (let i=0; i<this._queue.length; i++) {
            if (this._queue[i].tid === tid) {
                return this._queue[i];
            }
        }
        return null;
    }

    /**
     * Interne callback-Funktion für den Ajax-Request
     * @param {Object} ajaxData Objekt mit folgenden Eigenschaften
     *     {Array} response Array mit den Antworten (subResponses) auf die einzelnen subRequests
     *     {Object} request Request der gesendet wurde
     *     {String} errorMsg Falls ein übertragungsfehler vorliegt, wird hier der Fehlertext übergeben
     * @returns {undefined}
     */
   _receive(ajaxData) {
        // Antworten für die einzelnen Requests durchgehen
        for (let i=0; i<ajaxData.request.postData.length; i++) {
            let subResponse = kijs.isArray(ajaxData.response) ? ajaxData.response[i] : null;

            // Passenden subRequest aus Queue holen
            let subRequest = this._getByTid(ajaxData.request.postData[i].tid);

            if (!kijs.isObject(subResponse)) {
                subResponse = {
                    errorMsg: 'RPC response in wrong format'
                };
            }

            // Behandlung von Übertragungsfehlern
            if (ajaxData.errorMsg) {
                subResponse.errorMsg = ajaxData.errorMsg;
            } else if (!subResponse.errorMsg && subResponse.tid !== subRequest.tid) {
                subResponse.errorMsg = 'The RPC response does not match the request';
            }

            // Abbruch durch neueren Request?
            if (subRequest.state === kijs.Rpc.states.CANCELED_BEFORE_TRANSMIT ||
                    subRequest.state === kijs.Rpc.states.CANCELED_AFTER_TRANSMIT) {
                subResponse.errorType = 'cancel';
                //subResponse.canceled = true;
            }

            // Transfer-ID aus der Queue entfernen
            this._removeTid(subRequest.tid);


            //if (!subResponse.canceled) {
                // Standard errorType
                if (!kijs.isEmpty(subResponse.errorMsg) && kijs.isEmpty(subResponse.errorType)) {
                    subResponse.errorType = this._defaultErrorType;
                }

                // Argument vorbereiten
                const e = {
                    response: subResponse,
                    request: subRequest,
                    errorType: subResponse.errorType,
                    errorMsg: subResponse.errorMsg
                };

                // callback-fn ausführen
                if (kijs.isFunction(subRequest.fn)) {
                    subRequest.fn.call(subRequest.context || this, e);
                }

                // Promise auslösen
                if (subRequest.promiseResolve) {
                    subRequest.promiseResolve(e);
                }
            //}
        }
    }


    /**
     * Entfernt eine Transfer-ID aus der Queue
     * @param {Number} tid
     * @returns {undefined}
     */
    _removeTid(tid) {
        const newQueue = [];
        for (let i=0; i<this._queue.length; i++) {
            if (this._queue[i].tid !== tid) {
                newQueue.push(this._queue[i]);
            }
        }
        this._queue = newQueue;
    }

    /**
     * Übermittelt die subRequests in der queue an den Server
     * @param {Number} tid tid des Requests, der gesendet werden soll oder null für alle
     * @returns {undefined}
     */
    _transmit(tid=null) {
        const transmitData = [];

        // Defer nur löschen, wenn es kein exklusiver Request ist
        if (!tid && this._deferId) {
            clearTimeout(this._deferId);
            this._deferId = null;
        }

        for (let i=0; i<this._queue.length; i++) {
            if (!tid || tid === this._queue[i].tid) {
                if (this._queue[i].state === kijs.Rpc.states.QUEUE) {
                    const subRequest = kijs.isObject(this._queue[i].rpcParams) ? this._queue[i].rpcParams : {};
                    subRequest.remoteFn = this._queue[i].remoteFn;
                    subRequest.requestData = this._queue[i].requestData;
                    subRequest.type = this._queue[i].type;
                    subRequest.tid = this._queue[i].tid;

                    transmitData.push(subRequest);
                    this._queue[i].state = kijs.Rpc.states.TRANSMITTED;
                }
            }
        }

        if (transmitData.length > 0) {
            kijs.Ajax.request({
                method      : 'POST',
                headers     : this._headers,
                postData    : transmitData,
                url         : this.url,
                parameters  : this._parameters,
                fn          : this._receive,
                context     : this,
                timeout     : this.timeout
            });
        }

    }


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    destruct() {
        // timer abbrechen
        if (this._deferId) {
            clearTimeout(this._deferId);
            this._deferId = null;
        }

        // Variablen
        this._parameters = null;
        this._queue = null;
    }
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.UploadDialog
// --------------------------------------------------------------

// TODO: Umbenennen zu kijs.FileUpload !!!!!
// TODO: Events sollten nur ein Argument (e) haben!


/**
 * Die Klasse öffnet ein Fenster zum Auswählen einer Datei zum Upload
 * oder nimmt die Datei über eine Dropzone entgegen. Nach Auswahl wird
 * die Datei an den Server gesendet.
 *
 *  * EVENTS
 * ----------
 * fileSelected -- wird ausgeführt, wenn eine Datei ausgewählt wurde
 * failUpload   -- MIME nicht erlaubt
 * startUpload  -- Upload wird gestartet
 * progress     -- Fortschritt beim Upload
 * upload       -- Upload abgeschlossen
 * endUpload    -- alle Uploads in der Schlange abgeschlossen
 *
 */
kijs.UploadDialog = class kijs_UploadDialog extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    constructor(config={}) {
        super(false);

        this._ajaxUrl = 'index.php';
        this._contentTypes = [];
        this._currentUploadIds = [];
        this._directory = false;
        this._disabled = false;
        this._dropZones = [];
        this._fileExtensions = [];
        this._maxFilesize = null;
        this._multiple = true;
        this._sanitizeFilename = false;
        this._uploadId = 1;
        this._uploadResponses = {};

        this._observePaste = false;
        this._pasteCb = null;

        this._filenameHeader = 'X-Filename';
        this._pathnameHeader = 'X-Filepath';

        this._validMediaTypes = [
            'application',
            'audio',
            'example',
            'image',
            'message',
            'model',
            'multipart',
            'text',
            'video'
        ];

        // Standard-config-Eigenschaften mergen
        config = Object.assign({}, {
            // keine
        }, config);

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            ajaxUrl: true,
            directory: { target: 'directory' },
            multiple: { target: 'multiple' },
            fileExtensions:  { target: 'fileExtensions' },
            filenameHeader: true,
            pathnameHeader: true,
            maxFilesize: true,
            sanitizeFilename: true,
            dropZones: { target: 'dropZones' },
            contentTypes: { target: 'contentTypes' },
            observePaste: { target: 'observePaste' }
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            this.applyConfig(config, true);
        }

        // Paste überwachen (Dateien ab Chrome 91)
        this._pasteCb = this.#onFilePaste.bind(this);
        window.addEventListener('paste', this._pasteCb);

    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get contentTypes() { return this._contentTypes; }
    set contentTypes(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }

        this._contentTypes = [];

        // prüfen, ob der media-type gültig ist.
        kijs.Array.each(val, function(contentType) {
            let parts = contentType.toLowerCase().split('/', 2);
            if (!kijs.Array.contains(this._validMediaTypes, parts[0])) {
                throw new kijs.Error('invalid content type "' + contentType + '"');
            }
            if (parts.length === 1) {
                parts.push('*');
            }
            this._contentTypes.push(parts.join('/'));
        }, this);
    }

    get disabled() { return this._disabled; }
    set disabled(val) { this._disabled = val; }

    get dropZones() { return this._dropZones; }
    set dropZones(val) { this.bindDropZones(val); }

    get directory() { return this._directory; }
    set directory(val) { this._directory = !!val && this._browserSupportsDirectoryUpload(); }

    get fileExtensions() { return this._fileExtensions; }
    set fileExtensions(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }

        this._fileExtensions = [];

        kijs.Array.each(val, function(type) {
            if (type.charAt(0) !== '.') {
                type = '.' + type;
            }

            this._fileExtensions.push(type);
        }, this);
    }
    
    get maxFilesize() {
        return this._maxFilesize;
    }
    
    set maxFilesize(val) {
        this._maxFilesize = val;
    }

    get multiple() { return this._multiple; }
    set multiple(val) { this._multiple = !!val; }

    get observePaste() { return this._observePaste; }
    set observePaste(val) { this._observePaste = !!val; }


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Verbindet eine Dropzone mit dem UploadDialog. Wird eine
     * Datei auf die Dropzone gezogen, wird sie mit der Upload-Funktion
     * von dieser Klasse hochgeladen.
     * @param {kijs.gui.DropZone|Array} dropZones
     * @returns {undefined}
     */
    bindDropZones(dropZones) {
        if (!kijs.isArray(dropZones)) {
            dropZones = [dropZones];
        }
        kijs.Array.each(dropZones, function(dropZone) {
            if (!(dropZone instanceof kijs.gui.DropZone)) {
                throw new kijs.Error('added zone not of type kijs.gui.DropZone');
            }

            // hinzufügen falls noch nicht da.
            if (!kijs.Array.contains(this._dropZones, dropZone)) {

                // Events entfernen und wieder setzen.
                dropZone.off(null, null, this);
                dropZone.on('drop', this.#onDropZoneDrop, this);
                this._dropZones.push(dropZone);
            }
        }, this);
    }

    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @returns {undefined}
     */
    applyConfig(config={}) {
        kijs.Object.assignConfig(this, config, this._configMap);
    }

    /**
     * Zeit den "Datei öffnen" Dialog vom Browser an.
     * @param {Boolean} [multiple] Dürfen mehrere Dateien ausgewählt werden?
     * @param {Boolean} [directory] Soll statt einer Datei ein ganzer Ordner hochgeladen werden?
     * @returns {undefined}
     */
    // TODO: Umbenennen zu showFileOpenDialog !!!!!
    showFileSelectDialog(multiple=null, directory=null) {
        if (!this.disabled) {
            multiple = multiple === null ? this._multiple : multiple;
            directory = directory === null ? this._directory : directory;

            let input = document.createElement('input');
            input.setAttribute('type', 'file');
            if (multiple) {
                input.setAttribute('multiple', 'multiple');
            }
            if (directory) {
                input.setAttribute('directory', 'directory');
                input.setAttribute('webkitdirectory', 'webkitdirectory');
                input.setAttribute('mozdirectory', 'mozdirectory');
            }

            let acceptTypes = kijs.Array.concat(this._contentTypes, this._fileExtensions);

            if (acceptTypes.length > 0) {
                input.setAttribute('accept', acceptTypes.join(','));
            }

            kijs.Dom.addEventListener('change', input, function (e) {
                if (e.nodeEvent.target && e.nodeEvent.target.files) {
                    this._uploadFiles(e.nodeEvent.target.files);
                }
            }, this);

            // öffnen
            input.click();
        }
    }


    // PROTECTED
    /**
     * Prüft, ob der Browser das hochladen von ganzen Ordner unterstützt.
     * @returns {Boolean}
     */
    _browserSupportsDirectoryUpload() {
        let uploadEl = document.createElement('input'), support = false;
        uploadEl.setAttribute('type', 'file');
        uploadEl.setAttribute('multiple', 'multiple');

        if (kijs.isBoolean(uploadEl.webkitdirectory) || kijs.isBoolean(uploadEl.directory)) {
            support = true;
        }
        uploadEl = null;
        return support;
    }

    /**
     * Prüft, ob der übergebene MIME type einem der erlaubten MIME entspricht
     * @param {String} mime
     * @returns {Boolean}
     */
    _checkMime(mime) {
        let match=false;
        if (mime.type && this._contentTypes.length > 0) {
            mime = mime.type.toLowerCase();
            let mimeParts = mime.split('/', 2);

            kijs.Array.each(this._contentTypes, function(contentType) {
                if (mime === contentType || contentType === mimeParts[0] + '/*') {
                    match = true;
                }
            }, this);
        } else {

            let extension = mime.name.split('.').pop();

            if (extension && this._fileExtensions.length > 0) {
                kijs.Array.each(this._fileExtensions, function(ext) {
                    if (ext === '.' + extension) {
                        match = true;
                    }
                }, this);
            }
        }

        return match;
    }

    /**
     * Prüft, ob die übergebene MIME-Grösse der maximal erlaubten Grösse entspricht
     * @param {String} mime
     * @returns {Boolean}
     */
    _checkSize(mime) {
        if (this._maxFilesize) {
            if (mime.size > this._maxFilesize) {
                return false;
            }
        }

        return true;
    }

    _getFilename(filename) {
        if (this._sanitizeFilename) {
            filename = kijs.Char.replaceSpecialChars(filename);
            let filenameParts = filename.split('.'), extension = '';
            if (filenameParts.length > 1) {
                extension = filenameParts.pop().replace(/[^a-zA-Z0-9]/g, '');
            }
            filename = filenameParts.join('_').replace(/[^a-zA-Z0-9\-]/g, '_');

            if (extension) {
                filename += '.' + extension;
            }
        }

        return filename;
    }

    /**
     * Schneidet den Dateinamen vom Pfad ab,
     * gibt das Verzeichnis zurück.
     * @param {String} name
     * @param {String} path
     * @returns {String}
     */
    _getRelativeDir(name, path) {
        if (path && path.substr(path.length - name.length) === name) {
            return path.substr(0, path.length - name.length - 1);
        }
        return '';
    }

    _uploadFile(file) {
        let uploadId = this._uploadId++,
            headers = {},
            filename = this._getFilename(file.name),
            filedir = this._getRelativeDir(file.name, file.relativePath || file.webkitRelativePath),
            filetype = file.type || 'application/octet-stream';

        // event
        this.raiseEvent('fileSelected', this, filename, filedir, filetype, file);

        // Upload
        if (this._ajaxUrl) {
            headers[this._filenameHeader] = encodeURIComponent(filename);
            headers[this._pathnameHeader] = encodeURIComponent(filedir);
            headers['Content-Type'] = filetype;

            kijs.Ajax.request({
                url: this._ajaxUrl,
                method: 'POST',
                format: 'json',
                headers: headers,
                postData: file,
                fn: this.#onEndUpload,
                progressFn: this.#onProgress,
                context: this,
                uploadId: uploadId
            });

            this._currentUploadIds.push(uploadId);
            this.raiseEvent('startUpload', this, filename, filedir, filetype, uploadId);
        }
    }

    _uploadFiles(fileList) {
        this._uploadResponses = {};
        if (fileList) {
            for (let i=0; i<fileList.length; i++) {
                if (this._checkMime(fileList[i])) {
                    if (this._checkSize(fileList[i])) {
                        this._uploadFile(fileList[i]);
                    } else {
                        const errMsg = this._getFilename(fileList[i].name) + ' ' + kijs.getText('ist zu gross');
                        this.raiseEvent('failUpload', { errMsg: errMsg });
                    }
                } else {
                    this.raiseEvent('failUpload', this, this._getFilename(fileList[i].name), fileList[i].type);
                }
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onDropZoneDrop(e) {
        if (!this.disabled && e.validMime && e.allowed) {
            this._uploadFiles(e.nodeEvent.dataTransfer.files);
        }
    }

    #onEndUpload(e) {
        kijs.Array.remove(this._currentUploadIds, e.request.uploadId);

        // Fehlermeldung vom server
        let error = '';
        if (!e.response || !e.response.success) {
            error = error || e.response.msg || kijs.getText('Es ist ein unbekannter Fehler aufgetreten') + '.';
        }

        // Antwort vom Server
        let uploadResponse = e.response ? (e.response.upload || null) : null;

        // Responses in Objekt sammeln
        this._uploadResponses[e.request.uploadId] = uploadResponse;

        // Event werfen
        this.raiseEvent('upload', this, uploadResponse, error, e.request.uploadId);

        // wenn alle laufenden Uploads abgeschlossen sind, endUpload ausführen.
        if (this._currentUploadIds.length === 0) {
            this.raiseEvent('endUpload', this, this._uploadResponses);   // TODO: Events sollten nur ein Argument (e) haben!
        }
    }

    #onFilePaste(e) {
        if (this.disabled || !this._observePaste || !kijs.isArray(this._dropZones)) {
            return;
        }

        // Wenn die Klasse mit einer DropZone verknüpft ist, nur pasten wenn gerendert
        if (this._dropZones.length > 0) {
            let rendered = false;
            kijs.Array.each(this._dropZones, function(dz) {
                if (dz.parent) {
                    rendered = true;
                }
            }, this);

            if (!rendered) {
                return;
            }
        }

        // Dateien aus Zwischenablage lesen
        let files = e.clipboardData ? e.clipboardData.files : null;
        if (!files || !files.length || files.length === 0) {
            return;
        }

        e.preventDefault();
        this._uploadFiles(files);
    }

    #onProgress(e) {
        let percent = null;

        if (e.nodeEvent.lengthComputable && e.nodeEvent.total > 0) {
            percent = Math.round(100 / e.nodeEvent.total * e.nodeEvent.loaded);
            percent = Math.min(100, Math.max(0, percent)); // Wert zwischen 0-100
        }

        this.raiseEvent('progress', this, e.nodeEvent, e.ajaxConfig.uploadId, percent);   // TODO: Events sollten nur ein Argument (e) haben!
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    destruct() {
        this._dropZones = null;
        this._contentTypes = null;
        this._currentUploadIds = null;
        this._directory = null;
        this._disabled = null;
        this._dropZones = null;
        this._fileExtensions = null;
        this._maxFilesize = null;
        this._multiple = null;
        this._sanitizeFilename = null;
        this._uploadId = null;
        this._uploadResponses = null;
        this._filenameHeader = null;
        this._pathnameHeader = null;
        this._validMediaTypes = null;
        super.destruct();

        // remove paste listener
        if (this._pasteCb) {
            window.removeEventListener('paste', this._pasteCb);
            this._pasteCb = null;
        }
    }
};
kijs.translation = kijs.translation || {};
kijs.translation["en"] = {
    "": {
        "Copyright": "2024 by Netas AG (www.netas.ch)",
        "Erstelldatum": "2024-09-04",
        "Info": "kijs Sprachdatei",
        "Sprachdatei": "en",
        "Letzte \u00c4nderungen": "admin"
    },
    "%1 bis %2": "%1 to %2",
    "%1 ist keine g\u00fcltige Nummer": "%1 is not a valid number",
    "Abbrechen": "Cancel",
    "Absteigend sortieren": "Sort descending",
    "Akt. Monat": "Act. month",
    "Alle Filter l\u00f6schen": "Delete all filters",
    "Alle angew\u00e4hlten": "All selected",
    "Alle nicht angew\u00e4hlten": "All not selected",
    "Alle schliessen": "Close all",
    "Andere schliessen": "Others close",
    "Anrufen": "Call",
    "Aufsteigend sortieren": "Sort in ascending order",
    "Beginnt mit...": "Begins with...",
    "Das Datum darf nicht leer sein": "The date must not be blank",
    "Der Server brauchte zu lange, um eine Antwort zu senden": "The server took too long to send a response",
    "Der Server hat mit einem Fehler geantwortet": "The server responded with an error",
    "Der Wert \"%1\" ist nicht in der Liste enthalten": "The value \"%1\" is not included in the list",
    "Der maximale Wert f\u00fcr dieses Feld ist %1": "The maximum value for this field is %1",
    "Der minimale Wert f\u00fcr dieses Feld ist %1": "The minimum value for this field is %1",
    "Die Uhrzeit darf nicht leer sein": "The time must not be empty",
    "Die Verbindung konnte nicht aufgebaut werden": "The connection could not be established",
    "Die Verbindung wurde abgebrochen": "The connection was interrupted",
    "Dieses Feld darf maximal %1 Zeichen enthalten": "This field may contain a maximum of %1 characters",
    "Dieses Feld darf nicht leer sein": "This field must not be empty",
    "Dieses Feld hat einen ung\u00fcltigen Wert": "This field has an invalid value",
    "Dieses Feld muss mindestens %1 Zeichen enthalten": "This field must contain at least %1 characters",
    "E-Mail erstellen": "Create e-mail",
    "Endet mit...": "Ends with...",
    "Enth\u00e4lt nicht...": "Does not contain...",
    "Enth\u00e4lt...": "Contains...",
    "Es fehlt das Start- oder Enddatum": "The start or end date is missing",
    "Es ist ein unbekannter Fehler aufgetreten": "An unknown error has occurred",
    "Fehler": "Error",
    "Filter": "Filter",
    "Filter l\u00f6schen": "Delete filter",
    "Filtern": "Filter",
    "Gr\u00f6sser als...": "Bigger than...",
    "Heute": "Today",
    "Info": "Info",
    "Ist gleich...": "Is the same...",
    "Ist nicht gleich...": "Is not the same...",
    "Ja": "Yes",
    "Jetzt": "Now",
    "KW %1": {
        "week number": "CW %1"
    },
    "Kleiner als...": "Smaller than...",
    "Leeren": "Empty",
    "Link in neuem Tab \u00f6ffnen": "Open link in new tab",
    "Nein": "No",
    "OK": "OK",
    "Schliessen": "Close",
    "Schreiben Sie mindestens %1 Zeichen, um die Suche zu starten": "Write at least %1 characters to start the search",
    "Spalten": "Columns",
    "Suche": "Search",
    "Uhrzeit": "Time",
    "Ung\u00fcltige E-Mail-Adresse": "Invalid e-mail address",
    "Ung\u00fcltige IBAN": "Invalid IBAN",
    "Ung\u00fcltige Sozialversicherungs-Nr.": "Invalid social security no.",
    "Upload": "Upload",
    "Warnung": "Warning",
    "ist zu gross": "is too big"
};kijs.translation = kijs.translation || {};
kijs.translation["fr"] = {
    "": {
        "Copyright": "2024 by Netas AG (www.netas.ch)",
        "Erstelldatum": "2024-09-04",
        "Info": "kijs Sprachdatei",
        "Sprachdatei": "fr",
        "Letzte \u00c4nderungen": "admin"
    },
    "%1 bis %2": "%1 \u00e0 %2",
    "%1 ist keine g\u00fcltige Nummer": "%1 n'est pas un num\u00e9ro valide",
    "Abbrechen": "Annuler",
    "Absteigend sortieren": "Trier par ordre d\u00e9croissant",
    "Akt. Monat": "Act. Mois",
    "Alle Filter l\u00f6schen": "Supprimer tous les filtres",
    "Alle angew\u00e4hlten": "Tous les messages s\u00e9lectionn\u00e9s",
    "Alle nicht angew\u00e4hlten": "Tous les non s\u00e9lectionn\u00e9s",
    "Alle schliessen": "Tout fermer",
    "Andere schliessen": "D'autres ferment",
    "Anrufen": "Appeler",
    "Aufsteigend sortieren": "Trier par ordre croissant",
    "Beginnt mit...": "Commencer par...",
    "Das Datum darf nicht leer sein": "La date ne doit pas \u00eatre vide",
    "Der Server brauchte zu lange, um eine Antwort zu senden": "Le serveur a mis trop de temps \u00e0 envoyer une r\u00e9ponse",
    "Der Server hat mit einem Fehler geantwortet": "Le serveur a r\u00e9pondu par une erreur",
    "Der Wert \"%1\" ist nicht in der Liste enthalten": "La valeur \"%1\" ne figure pas dans la liste",
    "Der maximale Wert f\u00fcr dieses Feld ist %1": "La valeur maximale de ce champ est %1",
    "Der minimale Wert f\u00fcr dieses Feld ist %1": "La valeur minimale de ce champ est %1",
    "Die Uhrzeit darf nicht leer sein": "L'heure ne doit pas \u00eatre vide",
    "Die Verbindung konnte nicht aufgebaut werden": "La connexion n'a pas pu \u00eatre \u00e9tablie",
    "Die Verbindung wurde abgebrochen": "La connexion a \u00e9t\u00e9 interrompue",
    "Dieses Feld darf maximal %1 Zeichen enthalten": "Ce champ peut contenir au maximum %1 caract\u00e8res",
    "Dieses Feld darf nicht leer sein": "Ce champ ne doit pas \u00eatre vide",
    "Dieses Feld hat einen ung\u00fcltigen Wert": "Ce champ a une valeur non valide",
    "Dieses Feld muss mindestens %1 Zeichen enthalten": "Ce champ doit contenir au moins %1 caract\u00e8res",
    "E-Mail erstellen": "Cr\u00e9er un e-mail",
    "Endet mit...": "Se termine par ...",
    "Enth\u00e4lt nicht...": "Ne contient pas de...",
    "Enth\u00e4lt...": "Contient...",
    "Es fehlt das Start- oder Enddatum": "Il manque la date de d\u00e9but ou de fin",
    "Es ist ein unbekannter Fehler aufgetreten": "Une erreur inconnue est survenue",
    "Fehler": "Erreur",
    "Filter": "Filtre",
    "Filter l\u00f6schen": "Supprimer le filtre",
    "Filtern": "Filtrer",
    "Gr\u00f6sser als...": "Plus grand que...",
    "Heute": "Aujourd'hui",
    "Info": "Info",
    "Ist gleich...": "Est \u00e9gal \u00e0...",
    "Ist nicht gleich...": "N'est pas \u00e9gal \u00e0...",
    "Ja": "Oui",
    "Jetzt": "Maintenant",
    "KW %1": {
        "week number": "SEM %1"
    },
    "Kleiner als...": "Plus petit que...",
    "Leeren": "Vider",
    "Link in neuem Tab \u00f6ffnen": "Ouvrir le lien dans un nouvel onglet",
    "Nein": "Non",
    "OK": "OK",
    "Schliessen": "Fermer",
    "Schreiben Sie mindestens %1 Zeichen, um die Suche zu starten": "\u00c9crivez au moins %1 caract\u00e8re pour lancer la recherche",
    "Spalten": "Colonnes",
    "Suche": "Recherche",
    "Uhrzeit": "Heure",
    "Ung\u00fcltige E-Mail-Adresse": "Adresse e-mail non valide",
    "Ung\u00fcltige IBAN": "IBAN non valide",
    "Ung\u00fcltige Sozialversicherungs-Nr.": "N\u00b0 de s\u00e9curit\u00e9 sociale non valide",
    "Upload": "T\u00e9l\u00e9chargement",
    "Warnung": "Avertissement",
    "ist zu gross": "est trop grand"
};/* global kijs */

// --------------------------------------------------------------
// kijs.iconMap (namespace)
// --------------------------------------------------------------
kijs.iconMap = {
    blank                                     : { char: 0x20, cls: "" }
};
/* global kijs */

// --------------------------------------------------------------
// kijs.iconMap.Fa
// --------------------------------------------------------------

kijs.iconMap.Fa = {

    // Font Awesome Icons
    // Version 6.5.2
    // --------------------------------
    '0'                                     : { char: 0x0030, cls: "fa-solid" },
    '1'                                     : { char: 0x0031, cls: "fa-solid" },
    '2'                                     : { char: 0x0032, cls: "fa-solid" },
    '3'                                     : { char: 0x0033, cls: "fa-solid" },
    '4'                                     : { char: 0x0034, cls: "fa-solid" },
    '5'                                     : { char: 0x0035, cls: "fa-solid" },
    '6'                                     : { char: 0x0036, cls: "fa-solid" },
    '7'                                     : { char: 0x0037, cls: "fa-solid" },
    '8'                                     : { char: 0x0038, cls: "fa-solid" },
    '9'                                     : { char: 0x0039, cls: "fa-solid" },
    'a'                                     : { char: 0x0041, cls: "fa-solid" },
    'address-book'                          : { char: 0xf2b9, cls: "fa-solid" },
    'address-card'                          : { char: 0xf2bb, cls: "fa-solid" },
    'align-center'                          : { char: 0xf037, cls: "fa-solid" },
    'align-justify'                         : { char: 0xf039, cls: "fa-solid" },
    'align-left'                            : { char: 0xf036, cls: "fa-solid" },
    'align-right'                           : { char: 0xf038, cls: "fa-solid" },
    'anchor'                                : { char: 0xf13d, cls: "fa-solid" },
    'anchor-circle-check'                   : { char: 0xe4aa, cls: "fa-solid" },
    'anchor-circle-exclamation'             : { char: 0xe4ab, cls: "fa-solid" },
    'anchor-circle-xmark'                   : { char: 0xe4ac, cls: "fa-solid" },
    'anchor-lock'                           : { char: 0xe4ad, cls: "fa-solid" },
    'angle-down'                            : { char: 0xf107, cls: "fa-solid" },
    'angle-left'                            : { char: 0xf104, cls: "fa-solid" },
    'angle-right'                           : { char: 0xf105, cls: "fa-solid" },
    'angle-up'                              : { char: 0xf106, cls: "fa-solid" },
    'angles-down'                           : { char: 0xf103, cls: "fa-solid" },
    'angles-left'                           : { char: 0xf100, cls: "fa-solid" },
    'angles-right'                          : { char: 0xf101, cls: "fa-solid" },
    'angles-up'                             : { char: 0xf102, cls: "fa-solid" },
    'ankh'                                  : { char: 0xf644, cls: "fa-solid" },
    'apple-whole'                           : { char: 0xf5d1, cls: "fa-solid" },
    'archway'                               : { char: 0xf557, cls: "fa-solid" },
    'arrow-down'                            : { char: 0xf063, cls: "fa-solid" },
    'arrow-down-1-9'                        : { char: 0xf162, cls: "fa-solid" },
    'arrow-down-9-1'                        : { char: 0xf886, cls: "fa-solid" },
    'arrow-down-a-z'                        : { char: 0xf15d, cls: "fa-solid" },
    'arrow-down-long'                       : { char: 0xf175, cls: "fa-solid" },
    'arrow-down-short-wide'                 : { char: 0xf884, cls: "fa-solid" },
    'arrow-down-up-across-line'             : { char: 0xe4af, cls: "fa-solid" },
    'arrow-down-up-lock'                    : { char: 0xe4b0, cls: "fa-solid" },
    'arrow-down-wide-short'                 : { char: 0xf160, cls: "fa-solid" },
    'arrow-down-z-a'                        : { char: 0xf881, cls: "fa-solid" },
    'arrow-left'                            : { char: 0xf060, cls: "fa-solid" },
    'arrow-left-long'                       : { char: 0xf177, cls: "fa-solid" },
    'arrow-pointer'                         : { char: 0xf245, cls: "fa-solid" },
    'arrow-right'                           : { char: 0xf061, cls: "fa-solid" },
    'arrow-right-arrow-left'                : { char: 0xf0ec, cls: "fa-solid" },
    'arrow-right-from-bracket'              : { char: 0xf08b, cls: "fa-solid" },
    'arrow-right-long'                      : { char: 0xf178, cls: "fa-solid" },
    'arrow-right-to-bracket'                : { char: 0xf090, cls: "fa-solid" },
    'arrow-right-to-city'                   : { char: 0xe4b3, cls: "fa-solid" },
    'arrow-rotate-left'                     : { char: 0xf0e2, cls: "fa-solid" },
    'arrow-rotate-right'                    : { char: 0xf01e, cls: "fa-solid" },
    'arrow-trend-down'                      : { char: 0xe097, cls: "fa-solid" },
    'arrow-trend-up'                        : { char: 0xe098, cls: "fa-solid" },
    'arrow-turn-down'                       : { char: 0xf149, cls: "fa-solid" },
    'arrow-turn-up'                         : { char: 0xf148, cls: "fa-solid" },
    'arrow-up'                              : { char: 0xf062, cls: "fa-solid" },
    'arrow-up-1-9'                          : { char: 0xf163, cls: "fa-solid" },
    'arrow-up-9-1'                          : { char: 0xf887, cls: "fa-solid" },
    'arrow-up-a-z'                          : { char: 0xf15e, cls: "fa-solid" },
    'arrow-up-from-bracket'                 : { char: 0xe09a, cls: "fa-solid" },
    'arrow-up-from-ground-water'            : { char: 0xe4b5, cls: "fa-solid" },
    'arrow-up-from-water-pump'              : { char: 0xe4b6, cls: "fa-solid" },
    'arrow-up-long'                         : { char: 0xf176, cls: "fa-solid" },
    'arrow-up-right-dots'                   : { char: 0xe4b7, cls: "fa-solid" },
    'arrow-up-right-from-square'            : { char: 0xf08e, cls: "fa-solid" },
    'arrow-up-short-wide'                   : { char: 0xf885, cls: "fa-solid" },
    'arrow-up-wide-short'                   : { char: 0xf161, cls: "fa-solid" },
    'arrow-up-z-a'                          : { char: 0xf882, cls: "fa-solid" },
    'arrows-down-to-line'                   : { char: 0xe4b8, cls: "fa-solid" },
    'arrows-down-to-people'                 : { char: 0xe4b9, cls: "fa-solid" },
    'arrows-left-right'                     : { char: 0xf07e, cls: "fa-solid" },
    'arrows-left-right-to-line'             : { char: 0xe4ba, cls: "fa-solid" },
    'arrows-rotate'                         : { char: 0xf021, cls: "fa-solid" },
    'arrows-spin'                           : { char: 0xe4bb, cls: "fa-solid" },
    'arrows-split-up-and-left'              : { char: 0xe4bc, cls: "fa-solid" },
    'arrows-to-circle'                      : { char: 0xe4bd, cls: "fa-solid" },
    'arrows-to-dot'                         : { char: 0xe4be, cls: "fa-solid" },
    'arrows-to-eye'                         : { char: 0xe4bf, cls: "fa-solid" },
    'arrows-turn-right'                     : { char: 0xe4c0, cls: "fa-solid" },
    'arrows-turn-to-dots'                   : { char: 0xe4c1, cls: "fa-solid" },
    'arrows-up-down'                        : { char: 0xf07d, cls: "fa-solid" },
    'arrows-up-down-left-right'             : { char: 0xf047, cls: "fa-solid" },
    'arrows-up-to-line'                     : { char: 0xe4c2, cls: "fa-solid" },
    'asterisk'                              : { char: 0x002a, cls: "fa-solid" },
    'at'                                    : { char: 0x0040, cls: "fa-solid" },
    'atom'                                  : { char: 0xf5d2, cls: "fa-solid" },
    'audio-description'                     : { char: 0xf29e, cls: "fa-solid" },
    'austral-sign'                          : { char: 0xe0a9, cls: "fa-solid" },
    'award'                                 : { char: 0xf559, cls: "fa-solid" },
    'b'                                     : { char: 0x0042, cls: "fa-solid" },
    'baby'                                  : { char: 0xf77c, cls: "fa-solid" },
    'baby-carriage'                         : { char: 0xf77d, cls: "fa-solid" },
    'backward'                              : { char: 0xf04a, cls: "fa-solid" },
    'backward-fast'                         : { char: 0xf049, cls: "fa-solid" },
    'backward-step'                         : { char: 0xf048, cls: "fa-solid" },
    'bacon'                                 : { char: 0xf7e5, cls: "fa-solid" },
    'bacteria'                              : { char: 0xe059, cls: "fa-solid" },
    'bacterium'                             : { char: 0xe05a, cls: "fa-solid" },
    'bag-shopping'                          : { char: 0xf290, cls: "fa-solid" },
    'bahai'                                 : { char: 0xf666, cls: "fa-solid" },
    'baht-sign'                             : { char: 0xe0ac, cls: "fa-solid" },
    'ban'                                   : { char: 0xf05e, cls: "fa-solid" },
    'ban-smoking'                           : { char: 0xf54d, cls: "fa-solid" },
    'bandage'                               : { char: 0xf462, cls: "fa-solid" },
    'bangladeshi-taka-sign'                 : { char: 0xe2e6, cls: "fa-solid" },
    'barcode'                               : { char: 0xf02a, cls: "fa-solid" },
    'bars'                                  : { char: 0xf0c9, cls: "fa-solid" },
    'bars-progress'                         : { char: 0xf828, cls: "fa-solid" },
    'bars-staggered'                        : { char: 0xf550, cls: "fa-solid" },
    'baseball'                              : { char: 0xf433, cls: "fa-solid" },
    'baseball-bat-ball'                     : { char: 0xf432, cls: "fa-solid" },
    'basket-shopping'                       : { char: 0xf291, cls: "fa-solid" },
    'basketball'                            : { char: 0xf434, cls: "fa-solid" },
    'bath'                                  : { char: 0xf2cd, cls: "fa-solid" },
    'battery-empty'                         : { char: 0xf244, cls: "fa-solid" },
    'battery-full'                          : { char: 0xf240, cls: "fa-solid" },
    'battery-half'                          : { char: 0xf242, cls: "fa-solid" },
    'battery-quarter'                       : { char: 0xf243, cls: "fa-solid" },
    'battery-three-quarters'                : { char: 0xf241, cls: "fa-solid" },
    'bed'                                   : { char: 0xf236, cls: "fa-solid" },
    'bed-pulse'                             : { char: 0xf487, cls: "fa-solid" },
    'beer-mug-empty'                        : { char: 0xf0fc, cls: "fa-solid" },
    'bell'                                  : { char: 0xf0f3, cls: "fa-solid" },
    'bell-concierge'                        : { char: 0xf562, cls: "fa-solid" },
    'bell-slash'                            : { char: 0xf1f6, cls: "fa-solid" },
    'bezier-curve'                          : { char: 0xf55b, cls: "fa-solid" },
    'bicycle'                               : { char: 0xf206, cls: "fa-solid" },
    'binoculars'                            : { char: 0xf1e5, cls: "fa-solid" },
    'biohazard'                             : { char: 0xf780, cls: "fa-solid" },
    'bitcoin-sign'                          : { char: 0xe0b4, cls: "fa-solid" },
    'blender'                               : { char: 0xf517, cls: "fa-solid" },
    'blender-phone'                         : { char: 0xf6b6, cls: "fa-solid" },
    'blog'                                  : { char: 0xf781, cls: "fa-solid" },
    'bold'                                  : { char: 0xf032, cls: "fa-solid" },
    'bolt'                                  : { char: 0xf0e7, cls: "fa-solid" },
    'bolt-lightning'                        : { char: 0xe0b7, cls: "fa-solid" },
    'bomb'                                  : { char: 0xf1e2, cls: "fa-solid" },
    'bone'                                  : { char: 0xf5d7, cls: "fa-solid" },
    'bong'                                  : { char: 0xf55c, cls: "fa-solid" },
    'book'                                  : { char: 0xf02d, cls: "fa-solid" },
    'book-atlas'                            : { char: 0xf558, cls: "fa-solid" },
    'book-bible'                            : { char: 0xf647, cls: "fa-solid" },
    'book-bookmark'                         : { char: 0xe0bb, cls: "fa-solid" },
    'book-journal-whills'                   : { char: 0xf66a, cls: "fa-solid" },
    'book-medical'                          : { char: 0xf7e6, cls: "fa-solid" },
    'book-open'                             : { char: 0xf518, cls: "fa-solid" },
    'book-open-reader'                      : { char: 0xf5da, cls: "fa-solid" },
    'book-quran'                            : { char: 0xf687, cls: "fa-solid" },
    'book-skull'                            : { char: 0xf6b7, cls: "fa-solid" },
    'book-tanakh'                           : { char: 0xf827, cls: "fa-solid" },
    'bookmark'                              : { char: 0xf02e, cls: "fa-solid" },
    'border-all'                            : { char: 0xf84c, cls: "fa-solid" },
    'border-none'                           : { char: 0xf850, cls: "fa-solid" },
    'border-top-left'                       : { char: 0xf853, cls: "fa-solid" },
    'bore-hole'                             : { char: 0xe4c3, cls: "fa-solid" },
    'bottle-droplet'                        : { char: 0xe4c4, cls: "fa-solid" },
    'bottle-water'                          : { char: 0xe4c5, cls: "fa-solid" },
    'bowl-food'                             : { char: 0xe4c6, cls: "fa-solid" },
    'bowl-rice'                             : { char: 0xe2eb, cls: "fa-solid" },
    'bowling-ball'                          : { char: 0xf436, cls: "fa-solid" },
    'box'                                   : { char: 0xf466, cls: "fa-solid" },
    'box-archive'                           : { char: 0xf187, cls: "fa-solid" },
    'box-open'                              : { char: 0xf49e, cls: "fa-solid" },
    'box-tissue'                            : { char: 0xe05b, cls: "fa-solid" },
    'boxes-packing'                         : { char: 0xe4c7, cls: "fa-solid" },
    'boxes-stacked'                         : { char: 0xf468, cls: "fa-solid" },
    'braille'                               : { char: 0xf2a1, cls: "fa-solid" },
    'brain'                                 : { char: 0xf5dc, cls: "fa-solid" },
    'brazilian-real-sign'                   : { char: 0xe46c, cls: "fa-solid" },
    'bread-slice'                           : { char: 0xf7ec, cls: "fa-solid" },
    'bridge'                                : { char: 0xe4c8, cls: "fa-solid" },
    'bridge-circle-check'                   : { char: 0xe4c9, cls: "fa-solid" },
    'bridge-circle-exclamation'             : { char: 0xe4ca, cls: "fa-solid" },
    'bridge-circle-xmark'                   : { char: 0xe4cb, cls: "fa-solid" },
    'bridge-lock'                           : { char: 0xe4cc, cls: "fa-solid" },
    'bridge-water'                          : { char: 0xe4ce, cls: "fa-solid" },
    'briefcase'                             : { char: 0xf0b1, cls: "fa-solid" },
    'briefcase-medical'                     : { char: 0xf469, cls: "fa-solid" },
    'broom'                                 : { char: 0xf51a, cls: "fa-solid" },
    'broom-ball'                            : { char: 0xf458, cls: "fa-solid" },
    'brush'                                 : { char: 0xf55d, cls: "fa-solid" },
    'bucket'                                : { char: 0xe4cf, cls: "fa-solid" },
    'bug'                                   : { char: 0xf188, cls: "fa-solid" },
    'bug-slash'                             : { char: 0xe490, cls: "fa-solid" },
    'bugs'                                  : { char: 0xe4d0, cls: "fa-solid" },
    'building'                              : { char: 0xf1ad, cls: "fa-solid" },
    'building-circle-arrow-right'           : { char: 0xe4d1, cls: "fa-solid" },
    'building-circle-check'                 : { char: 0xe4d2, cls: "fa-solid" },
    'building-circle-exclamation'           : { char: 0xe4d3, cls: "fa-solid" },
    'building-circle-xmark'                 : { char: 0xe4d4, cls: "fa-solid" },
    'building-columns'                      : { char: 0xf19c, cls: "fa-solid" },
    'building-flag'                         : { char: 0xe4d5, cls: "fa-solid" },
    'building-lock'                         : { char: 0xe4d6, cls: "fa-solid" },
    'building-ngo'                          : { char: 0xe4d7, cls: "fa-solid" },
    'building-shield'                       : { char: 0xe4d8, cls: "fa-solid" },
    'building-un'                           : { char: 0xe4d9, cls: "fa-solid" },
    'building-user'                         : { char: 0xe4da, cls: "fa-solid" },
    'building-wheat'                        : { char: 0xe4db, cls: "fa-solid" },
    'bullhorn'                              : { char: 0xf0a1, cls: "fa-solid" },
    'bullseye'                              : { char: 0xf140, cls: "fa-solid" },
    'burger'                                : { char: 0xf805, cls: "fa-solid" },
    'burst'                                 : { char: 0xe4dc, cls: "fa-solid" },
    'bus'                                   : { char: 0xf207, cls: "fa-solid" },
    'bus-simple'                            : { char: 0xf55e, cls: "fa-solid" },
    'business-time'                         : { char: 0xf64a, cls: "fa-solid" },
    'c'                                     : { char: 0x0043, cls: "fa-solid" },
    'cable-car'                             : { char: 0xf7da, cls: "fa-solid" },
    'cake-candles'                          : { char: 0xf1fd, cls: "fa-solid" },
    'calculator'                            : { char: 0xf1ec, cls: "fa-solid" },
    'calendar'                              : { char: 0xf133, cls: "fa-solid" },
    'calendar-check'                        : { char: 0xf274, cls: "fa-solid" },
    'calendar-day'                          : { char: 0xf783, cls: "fa-solid" },
    'calendar-days'                         : { char: 0xf073, cls: "fa-solid" },
    'calendar-minus'                        : { char: 0xf272, cls: "fa-solid" },
    'calendar-plus'                         : { char: 0xf271, cls: "fa-solid" },
    'calendar-week'                         : { char: 0xf784, cls: "fa-solid" },
    'calendar-xmark'                        : { char: 0xf273, cls: "fa-solid" },
    'camera'                                : { char: 0xf030, cls: "fa-solid" },
    'camera-retro'                          : { char: 0xf083, cls: "fa-solid" },
    'camera-rotate'                         : { char: 0xe0d8, cls: "fa-solid" },
    'campground'                            : { char: 0xf6bb, cls: "fa-solid" },
    'candy-cane'                            : { char: 0xf786, cls: "fa-solid" },
    'cannabis'                              : { char: 0xf55f, cls: "fa-solid" },
    'capsules'                              : { char: 0xf46b, cls: "fa-solid" },
    'car'                                   : { char: 0xf1b9, cls: "fa-solid" },
    'car-battery'                           : { char: 0xf5df, cls: "fa-solid" },
    'car-burst'                             : { char: 0xf5e1, cls: "fa-solid" },
    'car-on'                                : { char: 0xe4dd, cls: "fa-solid" },
    'car-rear'                              : { char: 0xf5de, cls: "fa-solid" },
    'car-side'                              : { char: 0xf5e4, cls: "fa-solid" },
    'car-tunnel'                            : { char: 0xe4de, cls: "fa-solid" },
    'caravan'                               : { char: 0xf8ff, cls: "fa-solid" },
    'caret-down'                            : { char: 0xf0d7, cls: "fa-solid" },
    'caret-left'                            : { char: 0xf0d9, cls: "fa-solid" },
    'caret-right'                           : { char: 0xf0da, cls: "fa-solid" },
    'caret-up'                              : { char: 0xf0d8, cls: "fa-solid" },
    'carrot'                                : { char: 0xf787, cls: "fa-solid" },
    'cart-arrow-down'                       : { char: 0xf218, cls: "fa-solid" },
    'cart-flatbed'                          : { char: 0xf474, cls: "fa-solid" },
    'cart-flatbed-suitcase'                 : { char: 0xf59d, cls: "fa-solid" },
    'cart-plus'                             : { char: 0xf217, cls: "fa-solid" },
    'cart-shopping'                         : { char: 0xf07a, cls: "fa-solid" },
    'cash-register'                         : { char: 0xf788, cls: "fa-solid" },
    'cat'                                   : { char: 0xf6be, cls: "fa-solid" },
    'cedi-sign'                             : { char: 0xe0df, cls: "fa-solid" },
    'cent-sign'                             : { char: 0xe3f5, cls: "fa-solid" },
    'certificate'                           : { char: 0xf0a3, cls: "fa-solid" },
    'chair'                                 : { char: 0xf6c0, cls: "fa-solid" },
    'chalkboard'                            : { char: 0xf51b, cls: "fa-solid" },
    'chalkboard-user'                       : { char: 0xf51c, cls: "fa-solid" },
    'champagne-glasses'                     : { char: 0xf79f, cls: "fa-solid" },
    'charging-station'                      : { char: 0xf5e7, cls: "fa-solid" },
    'chart-area'                            : { char: 0xf1fe, cls: "fa-solid" },
    'chart-bar'                             : { char: 0xf080, cls: "fa-solid" },
    'chart-column'                          : { char: 0xe0e3, cls: "fa-solid" },
    'chart-gantt'                           : { char: 0xe0e4, cls: "fa-solid" },
    'chart-line'                            : { char: 0xf201, cls: "fa-solid" },
    'chart-pie'                             : { char: 0xf200, cls: "fa-solid" },
    'chart-simple'                          : { char: 0xe473, cls: "fa-solid" },
    'check'                                 : { char: 0xf00c, cls: "fa-solid" },
    'check-double'                          : { char: 0xf560, cls: "fa-solid" },
    'check-to-slot'                         : { char: 0xf772, cls: "fa-solid" },
    'cheese'                                : { char: 0xf7ef, cls: "fa-solid" },
    'chess'                                 : { char: 0xf439, cls: "fa-solid" },
    'chess-bishop'                          : { char: 0xf43a, cls: "fa-solid" },
    'chess-board'                           : { char: 0xf43c, cls: "fa-solid" },
    'chess-king'                            : { char: 0xf43f, cls: "fa-solid" },
    'chess-knight'                          : { char: 0xf441, cls: "fa-solid" },
    'chess-pawn'                            : { char: 0xf443, cls: "fa-solid" },
    'chess-queen'                           : { char: 0xf445, cls: "fa-solid" },
    'chess-rook'                            : { char: 0xf447, cls: "fa-solid" },
    'chevron-down'                          : { char: 0xf078, cls: "fa-solid" },
    'chevron-left'                          : { char: 0xf053, cls: "fa-solid" },
    'chevron-right'                         : { char: 0xf054, cls: "fa-solid" },
    'chevron-up'                            : { char: 0xf077, cls: "fa-solid" },
    'child'                                 : { char: 0xf1ae, cls: "fa-solid" },
    'child-combatant'                       : { char: 0xe4e0, cls: "fa-solid" },
    'child-dress'                           : { char: 0xe59c, cls: "fa-solid" },
    'child-reaching'                        : { char: 0xe59d, cls: "fa-solid" },
    'children'                              : { char: 0xe4e1, cls: "fa-solid" },
    'church'                                : { char: 0xf51d, cls: "fa-solid" },
    'circle'                                : { char: 0xf111, cls: "fa-solid" },
    'circle-arrow-down'                     : { char: 0xf0ab, cls: "fa-solid" },
    'circle-arrow-left'                     : { char: 0xf0a8, cls: "fa-solid" },
    'circle-arrow-right'                    : { char: 0xf0a9, cls: "fa-solid" },
    'circle-arrow-up'                       : { char: 0xf0aa, cls: "fa-solid" },
    'circle-check'                          : { char: 0xf058, cls: "fa-solid" },
    'circle-chevron-down'                   : { char: 0xf13a, cls: "fa-solid" },
    'circle-chevron-left'                   : { char: 0xf137, cls: "fa-solid" },
    'circle-chevron-right'                  : { char: 0xf138, cls: "fa-solid" },
    'circle-chevron-up'                     : { char: 0xf139, cls: "fa-solid" },
    'circle-dollar-to-slot'                 : { char: 0xf4b9, cls: "fa-solid" },
    'circle-dot'                            : { char: 0xf192, cls: "fa-solid" },
    'circle-down'                           : { char: 0xf358, cls: "fa-solid" },
    'circle-exclamation'                    : { char: 0xf06a, cls: "fa-solid" },
    'circle-h'                              : { char: 0xf47e, cls: "fa-solid" },
    'circle-half-stroke'                    : { char: 0xf042, cls: "fa-solid" },
    'circle-info'                           : { char: 0xf05a, cls: "fa-solid" },
    'circle-left'                           : { char: 0xf359, cls: "fa-solid" },
    'circle-minus'                          : { char: 0xf056, cls: "fa-solid" },
    'circle-nodes'                          : { char: 0xe4e2, cls: "fa-solid" },
    'circle-notch'                          : { char: 0xf1ce, cls: "fa-solid" },
    'circle-pause'                          : { char: 0xf28b, cls: "fa-solid" },
    'circle-play'                           : { char: 0xf144, cls: "fa-solid" },
    'circle-plus'                           : { char: 0xf055, cls: "fa-solid" },
    'circle-question'                       : { char: 0xf059, cls: "fa-solid" },
    'circle-radiation'                      : { char: 0xf7ba, cls: "fa-solid" },
    'circle-right'                          : { char: 0xf35a, cls: "fa-solid" },
    'circle-stop'                           : { char: 0xf28d, cls: "fa-solid" },
    'circle-up'                             : { char: 0xf35b, cls: "fa-solid" },
    'circle-user'                           : { char: 0xf2bd, cls: "fa-solid" },
    'circle-xmark'                          : { char: 0xf057, cls: "fa-solid" },
    'city'                                  : { char: 0xf64f, cls: "fa-solid" },
    'clapperboard'                          : { char: 0xe131, cls: "fa-solid" },
    'clipboard'                             : { char: 0xf328, cls: "fa-solid" },
    'clipboard-check'                       : { char: 0xf46c, cls: "fa-solid" },
    'clipboard-list'                        : { char: 0xf46d, cls: "fa-solid" },
    'clipboard-question'                    : { char: 0xe4e3, cls: "fa-solid" },
    'clipboard-user'                        : { char: 0xf7f3, cls: "fa-solid" },
    'clock'                                 : { char: 0xf017, cls: "fa-solid" },
    'clock-rotate-left'                     : { char: 0xf1da, cls: "fa-solid" },
    'clone'                                 : { char: 0xf24d, cls: "fa-solid" },
    'closed-captioning'                     : { char: 0xf20a, cls: "fa-solid" },
    'cloud'                                 : { char: 0xf0c2, cls: "fa-solid" },
    'cloud-arrow-down'                      : { char: 0xf0ed, cls: "fa-solid" },
    'cloud-arrow-up'                        : { char: 0xf0ee, cls: "fa-solid" },
    'cloud-bolt'                            : { char: 0xf76c, cls: "fa-solid" },
    'cloud-meatball'                        : { char: 0xf73b, cls: "fa-solid" },
    'cloud-moon'                            : { char: 0xf6c3, cls: "fa-solid" },
    'cloud-moon-rain'                       : { char: 0xf73c, cls: "fa-solid" },
    'cloud-rain'                            : { char: 0xf73d, cls: "fa-solid" },
    'cloud-showers-heavy'                   : { char: 0xf740, cls: "fa-solid" },
    'cloud-showers-water'                   : { char: 0xe4e4, cls: "fa-solid" },
    'cloud-sun'                             : { char: 0xf6c4, cls: "fa-solid" },
    'cloud-sun-rain'                        : { char: 0xf743, cls: "fa-solid" },
    'clover'                                : { char: 0xe139, cls: "fa-solid" },
    'code'                                  : { char: 0xf121, cls: "fa-solid" },
    'code-branch'                           : { char: 0xf126, cls: "fa-solid" },
    'code-commit'                           : { char: 0xf386, cls: "fa-solid" },
    'code-compare'                          : { char: 0xe13a, cls: "fa-solid" },
    'code-fork'                             : { char: 0xe13b, cls: "fa-solid" },
    'code-merge'                            : { char: 0xf387, cls: "fa-solid" },
    'code-pull-request'                     : { char: 0xe13c, cls: "fa-solid" },
    'coins'                                 : { char: 0xf51e, cls: "fa-solid" },
    'colon-sign'                            : { char: 0xe140, cls: "fa-solid" },
    'comment'                               : { char: 0xf075, cls: "fa-solid" },
    'comment-dollar'                        : { char: 0xf651, cls: "fa-solid" },
    'comment-dots'                          : { char: 0xf4ad, cls: "fa-solid" },
    'comment-medical'                       : { char: 0xf7f5, cls: "fa-solid" },
    'comment-slash'                         : { char: 0xf4b3, cls: "fa-solid" },
    'comment-sms'                           : { char: 0xf7cd, cls: "fa-solid" },
    'comments'                              : { char: 0xf086, cls: "fa-solid" },
    'comments-dollar'                       : { char: 0xf653, cls: "fa-solid" },
    'compact-disc'                          : { char: 0xf51f, cls: "fa-solid" },
    'compass'                               : { char: 0xf14e, cls: "fa-solid" },
    'compass-drafting'                      : { char: 0xf568, cls: "fa-solid" },
    'compress'                              : { char: 0xf066, cls: "fa-solid" },
    'computer'                              : { char: 0xe4e5, cls: "fa-solid" },
    'computer-mouse'                        : { char: 0xf8cc, cls: "fa-solid" },
    'cookie'                                : { char: 0xf563, cls: "fa-solid" },
    'cookie-bite'                           : { char: 0xf564, cls: "fa-solid" },
    'copy'                                  : { char: 0xf0c5, cls: "fa-solid" },
    'copyright'                             : { char: 0xf1f9, cls: "fa-solid" },
    'couch'                                 : { char: 0xf4b8, cls: "fa-solid" },
    'cow'                                   : { char: 0xf6c8, cls: "fa-solid" },
    'credit-card'                           : { char: 0xf09d, cls: "fa-solid" },
    'crop'                                  : { char: 0xf125, cls: "fa-solid" },
    'crop-simple'                           : { char: 0xf565, cls: "fa-solid" },
    'cross'                                 : { char: 0xf654, cls: "fa-solid" },
    'crosshairs'                            : { char: 0xf05b, cls: "fa-solid" },
    'crow'                                  : { char: 0xf520, cls: "fa-solid" },
    'crown'                                 : { char: 0xf521, cls: "fa-solid" },
    'crutch'                                : { char: 0xf7f7, cls: "fa-solid" },
    'cruzeiro-sign'                         : { char: 0xe152, cls: "fa-solid" },
    'cube'                                  : { char: 0xf1b2, cls: "fa-solid" },
    'cubes'                                 : { char: 0xf1b3, cls: "fa-solid" },
    'cubes-stacked'                         : { char: 0xe4e6, cls: "fa-solid" },
    'd'                                     : { char: 0x0044, cls: "fa-solid" },
    'database'                              : { char: 0xf1c0, cls: "fa-solid" },
    'delete-left'                           : { char: 0xf55a, cls: "fa-solid" },
    'democrat'                              : { char: 0xf747, cls: "fa-solid" },
    'desktop'                               : { char: 0xf390, cls: "fa-solid" },
    'dharmachakra'                          : { char: 0xf655, cls: "fa-solid" },
    'diagram-next'                          : { char: 0xe476, cls: "fa-solid" },
    'diagram-predecessor'                   : { char: 0xe477, cls: "fa-solid" },
    'diagram-project'                       : { char: 0xf542, cls: "fa-solid" },
    'diagram-successor'                     : { char: 0xe47a, cls: "fa-solid" },
    'diamond'                               : { char: 0xf219, cls: "fa-solid" },
    'diamond-turn-right'                    : { char: 0xf5eb, cls: "fa-solid" },
    'dice'                                  : { char: 0xf522, cls: "fa-solid" },
    'dice-d20'                              : { char: 0xf6cf, cls: "fa-solid" },
    'dice-d6'                               : { char: 0xf6d1, cls: "fa-solid" },
    'dice-five'                             : { char: 0xf523, cls: "fa-solid" },
    'dice-four'                             : { char: 0xf524, cls: "fa-solid" },
    'dice-one'                              : { char: 0xf525, cls: "fa-solid" },
    'dice-six'                              : { char: 0xf526, cls: "fa-solid" },
    'dice-three'                            : { char: 0xf527, cls: "fa-solid" },
    'dice-two'                              : { char: 0xf528, cls: "fa-solid" },
    'disease'                               : { char: 0xf7fa, cls: "fa-solid" },
    'display'                               : { char: 0xe163, cls: "fa-solid" },
    'divide'                                : { char: 0xf529, cls: "fa-solid" },
    'dna'                                   : { char: 0xf471, cls: "fa-solid" },
    'dog'                                   : { char: 0xf6d3, cls: "fa-solid" },
    'dollar-sign'                           : { char: 0x0024, cls: "fa-solid" },
    'dolly'                                 : { char: 0xf472, cls: "fa-solid" },
    'dong-sign'                             : { char: 0xe169, cls: "fa-solid" },
    'door-closed'                           : { char: 0xf52a, cls: "fa-solid" },
    'door-open'                             : { char: 0xf52b, cls: "fa-solid" },
    'dove'                                  : { char: 0xf4ba, cls: "fa-solid" },
    'down-left-and-up-right-to-center'      : { char: 0xf422, cls: "fa-solid" },
    'down-long'                             : { char: 0xf309, cls: "fa-solid" },
    'download'                              : { char: 0xf019, cls: "fa-solid" },
    'dragon'                                : { char: 0xf6d5, cls: "fa-solid" },
    'draw-polygon'                          : { char: 0xf5ee, cls: "fa-solid" },
    'droplet'                               : { char: 0xf043, cls: "fa-solid" },
    'droplet-slash'                         : { char: 0xf5c7, cls: "fa-solid" },
    'drum'                                  : { char: 0xf569, cls: "fa-solid" },
    'drum-steelpan'                         : { char: 0xf56a, cls: "fa-solid" },
    'drumstick-bite'                        : { char: 0xf6d7, cls: "fa-solid" },
    'dumbbell'                              : { char: 0xf44b, cls: "fa-solid" },
    'dumpster'                              : { char: 0xf793, cls: "fa-solid" },
    'dumpster-fire'                         : { char: 0xf794, cls: "fa-solid" },
    'dungeon'                               : { char: 0xf6d9, cls: "fa-solid" },
    'e'                                     : { char: 0x0045, cls: "fa-solid" },
    'ear-deaf'                              : { char: 0xf2a4, cls: "fa-solid" },
    'ear-listen'                            : { char: 0xf2a2, cls: "fa-solid" },
    'earth-africa'                          : { char: 0xf57c, cls: "fa-solid" },
    'earth-americas'                        : { char: 0xf57d, cls: "fa-solid" },
    'earth-asia'                            : { char: 0xf57e, cls: "fa-solid" },
    'earth-europe'                          : { char: 0xf7a2, cls: "fa-solid" },
    'earth-oceania'                         : { char: 0xe47b, cls: "fa-solid" },
    'egg'                                   : { char: 0xf7fb, cls: "fa-solid" },
    'eject'                                 : { char: 0xf052, cls: "fa-solid" },
    'elevator'                              : { char: 0xe16d, cls: "fa-solid" },
    'ellipsis'                              : { char: 0xf141, cls: "fa-solid" },
    'ellipsis-vertical'                     : { char: 0xf142, cls: "fa-solid" },
    'envelope'                              : { char: 0xf0e0, cls: "fa-solid" },
    'envelope-circle-check'                 : { char: 0xe4e8, cls: "fa-solid" },
    'envelope-open'                         : { char: 0xf2b6, cls: "fa-solid" },
    'envelope-open-text'                    : { char: 0xf658, cls: "fa-solid" },
    'envelopes-bulk'                        : { char: 0xf674, cls: "fa-solid" },
    'equals'                                : { char: 0x003d, cls: "fa-solid" },
    'eraser'                                : { char: 0xf12d, cls: "fa-solid" },
    'ethernet'                              : { char: 0xf796, cls: "fa-solid" },
    'euro-sign'                             : { char: 0xf153, cls: "fa-solid" },
    'exclamation'                           : { char: 0x0021, cls: "fa-solid" },
    'expand'                                : { char: 0xf065, cls: "fa-solid" },
    'explosion'                             : { char: 0xe4e9, cls: "fa-solid" },
    'eye'                                   : { char: 0xf06e, cls: "fa-solid" },
    'eye-dropper'                           : { char: 0xf1fb, cls: "fa-solid" },
    'eye-low-vision'                        : { char: 0xf2a8, cls: "fa-solid" },
    'eye-slash'                             : { char: 0xf070, cls: "fa-solid" },
    'f'                                     : { char: 0x0046, cls: "fa-solid" },
    'face-angry'                            : { char: 0xf556, cls: "fa-solid" },
    'face-dizzy'                            : { char: 0xf567, cls: "fa-solid" },
    'face-flushed'                          : { char: 0xf579, cls: "fa-solid" },
    'face-frown'                            : { char: 0xf119, cls: "fa-solid" },
    'face-frown-open'                       : { char: 0xf57a, cls: "fa-solid" },
    'face-grimace'                          : { char: 0xf57f, cls: "fa-solid" },
    'face-grin'                             : { char: 0xf580, cls: "fa-solid" },
    'face-grin-beam'                        : { char: 0xf582, cls: "fa-solid" },
    'face-grin-beam-sweat'                  : { char: 0xf583, cls: "fa-solid" },
    'face-grin-hearts'                      : { char: 0xf584, cls: "fa-solid" },
    'face-grin-squint'                      : { char: 0xf585, cls: "fa-solid" },
    'face-grin-squint-tears'                : { char: 0xf586, cls: "fa-solid" },
    'face-grin-stars'                       : { char: 0xf587, cls: "fa-solid" },
    'face-grin-tears'                       : { char: 0xf588, cls: "fa-solid" },
    'face-grin-tongue'                      : { char: 0xf589, cls: "fa-solid" },
    'face-grin-tongue-squint'               : { char: 0xf58a, cls: "fa-solid" },
    'face-grin-tongue-wink'                 : { char: 0xf58b, cls: "fa-solid" },
    'face-grin-wide'                        : { char: 0xf581, cls: "fa-solid" },
    'face-grin-wink'                        : { char: 0xf58c, cls: "fa-solid" },
    'face-kiss'                             : { char: 0xf596, cls: "fa-solid" },
    'face-kiss-beam'                        : { char: 0xf597, cls: "fa-solid" },
    'face-kiss-wink-heart'                  : { char: 0xf598, cls: "fa-solid" },
    'face-laugh'                            : { char: 0xf599, cls: "fa-solid" },
    'face-laugh-beam'                       : { char: 0xf59a, cls: "fa-solid" },
    'face-laugh-squint'                     : { char: 0xf59b, cls: "fa-solid" },
    'face-laugh-wink'                       : { char: 0xf59c, cls: "fa-solid" },
    'face-meh'                              : { char: 0xf11a, cls: "fa-solid" },
    'face-meh-blank'                        : { char: 0xf5a4, cls: "fa-solid" },
    'face-rolling-eyes'                     : { char: 0xf5a5, cls: "fa-solid" },
    'face-sad-cry'                          : { char: 0xf5b3, cls: "fa-solid" },
    'face-sad-tear'                         : { char: 0xf5b4, cls: "fa-solid" },
    'face-smile'                            : { char: 0xf118, cls: "fa-solid" },
    'face-smile-beam'                       : { char: 0xf5b8, cls: "fa-solid" },
    'face-smile-wink'                       : { char: 0xf4da, cls: "fa-solid" },
    'face-surprise'                         : { char: 0xf5c2, cls: "fa-solid" },
    'face-tired'                            : { char: 0xf5c8, cls: "fa-solid" },
    'fan'                                   : { char: 0xf863, cls: "fa-solid" },
    'faucet'                                : { char: 0xe005, cls: "fa-solid" },
    'faucet-drip'                           : { char: 0xe006, cls: "fa-solid" },
    'fax'                                   : { char: 0xf1ac, cls: "fa-solid" },
    'feather'                               : { char: 0xf52d, cls: "fa-solid" },
    'feather-pointed'                       : { char: 0xf56b, cls: "fa-solid" },
    'ferry'                                 : { char: 0xe4ea, cls: "fa-solid" },
    'file'                                  : { char: 0xf15b, cls: "fa-solid" },
    'file-arrow-down'                       : { char: 0xf56d, cls: "fa-solid" },
    'file-arrow-up'                         : { char: 0xf574, cls: "fa-solid" },
    'file-audio'                            : { char: 0xf1c7, cls: "fa-solid" },
    'file-circle-check'                     : { char: 0xe5a0, cls: "fa-solid" },
    'file-circle-exclamation'               : { char: 0xe4eb, cls: "fa-solid" },
    'file-circle-minus'                     : { char: 0xe4ed, cls: "fa-solid" },
    'file-circle-plus'                      : { char: 0xe494, cls: "fa-solid" },
    'file-circle-question'                  : { char: 0xe4ef, cls: "fa-solid" },
    'file-circle-xmark'                     : { char: 0xe5a1, cls: "fa-solid" },
    'file-code'                             : { char: 0xf1c9, cls: "fa-solid" },
    'file-contract'                         : { char: 0xf56c, cls: "fa-solid" },
    'file-csv'                              : { char: 0xf6dd, cls: "fa-solid" },
    'file-excel'                            : { char: 0xf1c3, cls: "fa-solid" },
    'file-export'                           : { char: 0xf56e, cls: "fa-solid" },
    'file-image'                            : { char: 0xf1c5, cls: "fa-solid" },
    'file-import'                           : { char: 0xf56f, cls: "fa-solid" },
    'file-invoice'                          : { char: 0xf570, cls: "fa-solid" },
    'file-invoice-dollar'                   : { char: 0xf571, cls: "fa-solid" },
    'file-lines'                            : { char: 0xf15c, cls: "fa-solid" },
    'file-medical'                          : { char: 0xf477, cls: "fa-solid" },
    'file-pdf'                              : { char: 0xf1c1, cls: "fa-solid" },
    'file-pen'                              : { char: 0xf31c, cls: "fa-solid" },
    'file-powerpoint'                       : { char: 0xf1c4, cls: "fa-solid" },
    'file-prescription'                     : { char: 0xf572, cls: "fa-solid" },
    'file-shield'                           : { char: 0xe4f0, cls: "fa-solid" },
    'file-signature'                        : { char: 0xf573, cls: "fa-solid" },
    'file-video'                            : { char: 0xf1c8, cls: "fa-solid" },
    'file-waveform'                         : { char: 0xf478, cls: "fa-solid" },
    'file-word'                             : { char: 0xf1c2, cls: "fa-solid" },
    'file-zipper'                           : { char: 0xf1c6, cls: "fa-solid" },
    'fill'                                  : { char: 0xf575, cls: "fa-solid" },
    'fill-drip'                             : { char: 0xf576, cls: "fa-solid" },
    'film'                                  : { char: 0xf008, cls: "fa-solid" },
    'filter'                                : { char: 0xf0b0, cls: "fa-solid" },
    'filter-circle-dollar'                  : { char: 0xf662, cls: "fa-solid" },
    'filter-circle-xmark'                   : { char: 0xe17b, cls: "fa-solid" },
    'fingerprint'                           : { char: 0xf577, cls: "fa-solid" },
    'fire'                                  : { char: 0xf06d, cls: "fa-solid" },
    'fire-burner'                           : { char: 0xe4f1, cls: "fa-solid" },
    'fire-extinguisher'                     : { char: 0xf134, cls: "fa-solid" },
    'fire-flame-curved'                     : { char: 0xf7e4, cls: "fa-solid" },
    'fire-flame-simple'                     : { char: 0xf46a, cls: "fa-solid" },
    'fish'                                  : { char: 0xf578, cls: "fa-solid" },
    'fish-fins'                             : { char: 0xe4f2, cls: "fa-solid" },
    'flag'                                  : { char: 0xf024, cls: "fa-solid" },
    'flag-checkered'                        : { char: 0xf11e, cls: "fa-solid" },
    'flag-usa'                              : { char: 0xf74d, cls: "fa-solid" },
    'flask'                                 : { char: 0xf0c3, cls: "fa-solid" },
    'flask-vial'                            : { char: 0xe4f3, cls: "fa-solid" },
    'floppy-disk'                           : { char: 0xf0c7, cls: "fa-solid" },
    'florin-sign'                           : { char: 0xe184, cls: "fa-solid" },
    'folder'                                : { char: 0xf07b, cls: "fa-solid" },
    'folder-closed'                         : { char: 0xe185, cls: "fa-solid" },
    'folder-minus'                          : { char: 0xf65d, cls: "fa-solid" },
    'folder-open'                           : { char: 0xf07c, cls: "fa-solid" },
    'folder-plus'                           : { char: 0xf65e, cls: "fa-solid" },
    'folder-tree'                           : { char: 0xf802, cls: "fa-solid" },
    'font'                                  : { char: 0xf031, cls: "fa-solid" },
    'football'                              : { char: 0xf44e, cls: "fa-solid" },
    'forward'                               : { char: 0xf04e, cls: "fa-solid" },
    'forward-fast'                          : { char: 0xf050, cls: "fa-solid" },
    'forward-step'                          : { char: 0xf051, cls: "fa-solid" },
    'franc-sign'                            : { char: 0xe18f, cls: "fa-solid" },
    'frog'                                  : { char: 0xf52e, cls: "fa-solid" },
    'futbol'                                : { char: 0xf1e3, cls: "fa-solid" },
    'g'                                     : { char: 0x0047, cls: "fa-solid" },
    'gamepad'                               : { char: 0xf11b, cls: "fa-solid" },
    'gas-pump'                              : { char: 0xf52f, cls: "fa-solid" },
    'gauge'                                 : { char: 0xf624, cls: "fa-solid" },
    'gauge-high'                            : { char: 0xf625, cls: "fa-solid" },
    'gauge-simple'                          : { char: 0xf629, cls: "fa-solid" },
    'gauge-simple-high'                     : { char: 0xf62a, cls: "fa-solid" },
    'gavel'                                 : { char: 0xf0e3, cls: "fa-solid" },
    'gear'                                  : { char: 0xf013, cls: "fa-solid" },
    'gears'                                 : { char: 0xf085, cls: "fa-solid" },
    'gem'                                   : { char: 0xf3a5, cls: "fa-solid" },
    'genderless'                            : { char: 0xf22d, cls: "fa-solid" },
    'ghost'                                 : { char: 0xf6e2, cls: "fa-solid" },
    'gift'                                  : { char: 0xf06b, cls: "fa-solid" },
    'gifts'                                 : { char: 0xf79c, cls: "fa-solid" },
    'glass-water'                           : { char: 0xe4f4, cls: "fa-solid" },
    'glass-water-droplet'                   : { char: 0xe4f5, cls: "fa-solid" },
    'glasses'                               : { char: 0xf530, cls: "fa-solid" },
    'globe'                                 : { char: 0xf0ac, cls: "fa-solid" },
    'golf-ball-tee'                         : { char: 0xf450, cls: "fa-solid" },
    'gopuram'                               : { char: 0xf664, cls: "fa-solid" },
    'graduation-cap'                        : { char: 0xf19d, cls: "fa-solid" },
    'greater-than'                          : { char: 0x003e, cls: "fa-solid" },
    'greater-than-equal'                    : { char: 0xf532, cls: "fa-solid" },
    'grip'                                  : { char: 0xf58d, cls: "fa-solid" },
    'grip-lines'                            : { char: 0xf7a4, cls: "fa-solid" },
    'grip-lines-vertical'                   : { char: 0xf7a5, cls: "fa-solid" },
    'grip-vertical'                         : { char: 0xf58e, cls: "fa-solid" },
    'group-arrows-rotate'                   : { char: 0xe4f6, cls: "fa-solid" },
    'guarani-sign'                          : { char: 0xe19a, cls: "fa-solid" },
    'guitar'                                : { char: 0xf7a6, cls: "fa-solid" },
    'gun'                                   : { char: 0xe19b, cls: "fa-solid" },
    'h'                                     : { char: 0x0048, cls: "fa-solid" },
    'hammer'                                : { char: 0xf6e3, cls: "fa-solid" },
    'hamsa'                                 : { char: 0xf665, cls: "fa-solid" },
    'hand'                                  : { char: 0xf256, cls: "fa-solid" },
    'hand-back-fist'                        : { char: 0xf255, cls: "fa-solid" },
    'hand-dots'                             : { char: 0xf461, cls: "fa-solid" },
    'hand-fist'                             : { char: 0xf6de, cls: "fa-solid" },
    'hand-holding'                          : { char: 0xf4bd, cls: "fa-solid" },
    'hand-holding-dollar'                   : { char: 0xf4c0, cls: "fa-solid" },
    'hand-holding-droplet'                  : { char: 0xf4c1, cls: "fa-solid" },
    'hand-holding-hand'                     : { char: 0xe4f7, cls: "fa-solid" },
    'hand-holding-heart'                    : { char: 0xf4be, cls: "fa-solid" },
    'hand-holding-medical'                  : { char: 0xe05c, cls: "fa-solid" },
    'hand-lizard'                           : { char: 0xf258, cls: "fa-solid" },
    'hand-middle-finger'                    : { char: 0xf806, cls: "fa-solid" },
    'hand-peace'                            : { char: 0xf25b, cls: "fa-solid" },
    'hand-point-down'                       : { char: 0xf0a7, cls: "fa-solid" },
    'hand-point-left'                       : { char: 0xf0a5, cls: "fa-solid" },
    'hand-point-right'                      : { char: 0xf0a4, cls: "fa-solid" },
    'hand-point-up'                         : { char: 0xf0a6, cls: "fa-solid" },
    'hand-pointer'                          : { char: 0xf25a, cls: "fa-solid" },
    'hand-scissors'                         : { char: 0xf257, cls: "fa-solid" },
    'hand-sparkles'                         : { char: 0xe05d, cls: "fa-solid" },
    'hand-spock'                            : { char: 0xf259, cls: "fa-solid" },
    'handcuffs'                             : { char: 0xe4f8, cls: "fa-solid" },
    'hands'                                 : { char: 0xf2a7, cls: "fa-solid" },
    'hands-asl-interpreting'                : { char: 0xf2a3, cls: "fa-solid" },
    'hands-bound'                           : { char: 0xe4f9, cls: "fa-solid" },
    'hands-bubbles'                         : { char: 0xe05e, cls: "fa-solid" },
    'hands-clapping'                        : { char: 0xe1a8, cls: "fa-solid" },
    'hands-holding'                         : { char: 0xf4c2, cls: "fa-solid" },
    'hands-holding-child'                   : { char: 0xe4fa, cls: "fa-solid" },
    'hands-holding-circle'                  : { char: 0xe4fb, cls: "fa-solid" },
    'hands-praying'                         : { char: 0xf684, cls: "fa-solid" },
    'handshake'                             : { char: 0xf2b5, cls: "fa-solid" },
    'handshake-angle'                       : { char: 0xf4c4, cls: "fa-solid" },
    'handshake-simple'                      : { char: 0xf4c6, cls: "fa-solid" },
    'handshake-simple-slash'                : { char: 0xe05f, cls: "fa-solid" },
    'handshake-slash'                       : { char: 0xe060, cls: "fa-solid" },
    'hanukiah'                              : { char: 0xf6e6, cls: "fa-solid" },
    'hard-drive'                            : { char: 0xf0a0, cls: "fa-solid" },
    'hashtag'                               : { char: 0x0023, cls: "fa-solid" },
    'hat-cowboy'                            : { char: 0xf8c0, cls: "fa-solid" },
    'hat-cowboy-side'                       : { char: 0xf8c1, cls: "fa-solid" },
    'hat-wizard'                            : { char: 0xf6e8, cls: "fa-solid" },
    'head-side-cough'                       : { char: 0xe061, cls: "fa-solid" },
    'head-side-cough-slash'                 : { char: 0xe062, cls: "fa-solid" },
    'head-side-mask'                        : { char: 0xe063, cls: "fa-solid" },
    'head-side-virus'                       : { char: 0xe064, cls: "fa-solid" },
    'heading'                               : { char: 0xf1dc, cls: "fa-solid" },
    'headphones'                            : { char: 0xf025, cls: "fa-solid" },
    'headphones-simple'                     : { char: 0xf58f, cls: "fa-solid" },
    'headset'                               : { char: 0xf590, cls: "fa-solid" },
    'heart'                                 : { char: 0xf004, cls: "fa-solid" },
    'heart-circle-bolt'                     : { char: 0xe4fc, cls: "fa-solid" },
    'heart-circle-check'                    : { char: 0xe4fd, cls: "fa-solid" },
    'heart-circle-exclamation'              : { char: 0xe4fe, cls: "fa-solid" },
    'heart-circle-minus'                    : { char: 0xe4ff, cls: "fa-solid" },
    'heart-circle-plus'                     : { char: 0xe500, cls: "fa-solid" },
    'heart-circle-xmark'                    : { char: 0xe501, cls: "fa-solid" },
    'heart-crack'                           : { char: 0xf7a9, cls: "fa-solid" },
    'heart-pulse'                           : { char: 0xf21e, cls: "fa-solid" },
    'helicopter'                            : { char: 0xf533, cls: "fa-solid" },
    'helicopter-symbol'                     : { char: 0xe502, cls: "fa-solid" },
    'helmet-safety'                         : { char: 0xf807, cls: "fa-solid" },
    'helmet-un'                             : { char: 0xe503, cls: "fa-solid" },
    'highlighter'                           : { char: 0xf591, cls: "fa-solid" },
    'hill-avalanche'                        : { char: 0xe507, cls: "fa-solid" },
    'hill-rockslide'                        : { char: 0xe508, cls: "fa-solid" },
    'hippo'                                 : { char: 0xf6ed, cls: "fa-solid" },
    'hockey-puck'                           : { char: 0xf453, cls: "fa-solid" },
    'holly-berry'                           : { char: 0xf7aa, cls: "fa-solid" },
    'horse'                                 : { char: 0xf6f0, cls: "fa-solid" },
    'horse-head'                            : { char: 0xf7ab, cls: "fa-solid" },
    'hospital'                              : { char: 0xf0f8, cls: "fa-solid" },
    'hospital-user'                         : { char: 0xf80d, cls: "fa-solid" },
    'hot-tub-person'                        : { char: 0xf593, cls: "fa-solid" },
    'hotdog'                                : { char: 0xf80f, cls: "fa-solid" },
    'hotel'                                 : { char: 0xf594, cls: "fa-solid" },
    'hourglass'                             : { char: 0xf254, cls: "fa-solid" },
    'hourglass-end'                         : { char: 0xf253, cls: "fa-solid" },
    'hourglass-half'                        : { char: 0xf252, cls: "fa-solid" },
    'hourglass-start'                       : { char: 0xf251, cls: "fa-solid" },
    'house'                                 : { char: 0xf015, cls: "fa-solid" },
    'house-chimney'                         : { char: 0xe3af, cls: "fa-solid" },
    'house-chimney-crack'                   : { char: 0xf6f1, cls: "fa-solid" },
    'house-chimney-medical'                 : { char: 0xf7f2, cls: "fa-solid" },
    'house-chimney-user'                    : { char: 0xe065, cls: "fa-solid" },
    'house-chimney-window'                  : { char: 0xe00d, cls: "fa-solid" },
    'house-circle-check'                    : { char: 0xe509, cls: "fa-solid" },
    'house-circle-exclamation'              : { char: 0xe50a, cls: "fa-solid" },
    'house-circle-xmark'                    : { char: 0xe50b, cls: "fa-solid" },
    'house-crack'                           : { char: 0xe3b1, cls: "fa-solid" },
    'house-fire'                            : { char: 0xe50c, cls: "fa-solid" },
    'house-flag'                            : { char: 0xe50d, cls: "fa-solid" },
    'house-flood-water'                     : { char: 0xe50e, cls: "fa-solid" },
    'house-flood-water-circle-arrow-right'  : { char: 0xe50f, cls: "fa-solid" },
    'house-laptop'                          : { char: 0xe066, cls: "fa-solid" },
    'house-lock'                            : { char: 0xe510, cls: "fa-solid" },
    'house-medical'                         : { char: 0xe3b2, cls: "fa-solid" },
    'house-medical-circle-check'            : { char: 0xe511, cls: "fa-solid" },
    'house-medical-circle-exclamation'      : { char: 0xe512, cls: "fa-solid" },
    'house-medical-circle-xmark'            : { char: 0xe513, cls: "fa-solid" },
    'house-medical-flag'                    : { char: 0xe514, cls: "fa-solid" },
    'house-signal'                          : { char: 0xe012, cls: "fa-solid" },
    'house-tsunami'                         : { char: 0xe515, cls: "fa-solid" },
    'house-user'                            : { char: 0xe1b0, cls: "fa-solid" },
    'hryvnia-sign'                          : { char: 0xf6f2, cls: "fa-solid" },
    'hurricane'                             : { char: 0xf751, cls: "fa-solid" },
    'i'                                     : { char: 0x0049, cls: "fa-solid" },
    'i-cursor'                              : { char: 0xf246, cls: "fa-solid" },
    'ice-cream'                             : { char: 0xf810, cls: "fa-solid" },
    'icicles'                               : { char: 0xf7ad, cls: "fa-solid" },
    'icons'                                 : { char: 0xf86d, cls: "fa-solid" },
    'id-badge'                              : { char: 0xf2c1, cls: "fa-solid" },
    'id-card'                               : { char: 0xf2c2, cls: "fa-solid" },
    'id-card-clip'                          : { char: 0xf47f, cls: "fa-solid" },
    'igloo'                                 : { char: 0xf7ae, cls: "fa-solid" },
    'image'                                 : { char: 0xf03e, cls: "fa-solid" },
    'image-portrait'                        : { char: 0xf3e0, cls: "fa-solid" },
    'images'                                : { char: 0xf302, cls: "fa-solid" },
    'inbox'                                 : { char: 0xf01c, cls: "fa-solid" },
    'indent'                                : { char: 0xf03c, cls: "fa-solid" },
    'indian-rupee-sign'                     : { char: 0xe1bc, cls: "fa-solid" },
    'industry'                              : { char: 0xf275, cls: "fa-solid" },
    'infinity'                              : { char: 0xf534, cls: "fa-solid" },
    'info'                                  : { char: 0xf129, cls: "fa-solid" },
    'italic'                                : { char: 0xf033, cls: "fa-solid" },
    'j'                                     : { char: 0x004a, cls: "fa-solid" },
    'jar'                                   : { char: 0xe516, cls: "fa-solid" },
    'jar-wheat'                             : { char: 0xe517, cls: "fa-solid" },
    'jedi'                                  : { char: 0xf669, cls: "fa-solid" },
    'jet-fighter'                           : { char: 0xf0fb, cls: "fa-solid" },
    'jet-fighter-up'                        : { char: 0xe518, cls: "fa-solid" },
    'joint'                                 : { char: 0xf595, cls: "fa-solid" },
    'jug-detergent'                         : { char: 0xe519, cls: "fa-solid" },
    'k'                                     : { char: 0x004b, cls: "fa-solid" },
    'kaaba'                                 : { char: 0xf66b, cls: "fa-solid" },
    'key'                                   : { char: 0xf084, cls: "fa-solid" },
    'keyboard'                              : { char: 0xf11c, cls: "fa-solid" },
    'khanda'                                : { char: 0xf66d, cls: "fa-solid" },
    'kip-sign'                              : { char: 0xe1c4, cls: "fa-solid" },
    'kit-medical'                           : { char: 0xf479, cls: "fa-solid" },
    'kitchen-set'                           : { char: 0xe51a, cls: "fa-solid" },
    'kiwi-bird'                             : { char: 0xf535, cls: "fa-solid" },
    'l'                                     : { char: 0x004c, cls: "fa-solid" },
    'land-mine-on'                          : { char: 0xe51b, cls: "fa-solid" },
    'landmark'                              : { char: 0xf66f, cls: "fa-solid" },
    'landmark-dome'                         : { char: 0xf752, cls: "fa-solid" },
    'landmark-flag'                         : { char: 0xe51c, cls: "fa-solid" },
    'language'                              : { char: 0xf1ab, cls: "fa-solid" },
    'laptop'                                : { char: 0xf109, cls: "fa-solid" },
    'laptop-code'                           : { char: 0xf5fc, cls: "fa-solid" },
    'laptop-file'                           : { char: 0xe51d, cls: "fa-solid" },
    'laptop-medical'                        : { char: 0xf812, cls: "fa-solid" },
    'lari-sign'                             : { char: 0xe1c8, cls: "fa-solid" },
    'layer-group'                           : { char: 0xf5fd, cls: "fa-solid" },
    'leaf'                                  : { char: 0xf06c, cls: "fa-solid" },
    'left-long'                             : { char: 0xf30a, cls: "fa-solid" },
    'left-right'                            : { char: 0xf337, cls: "fa-solid" },
    'lemon'                                 : { char: 0xf094, cls: "fa-solid" },
    'less-than'                             : { char: 0x003c, cls: "fa-solid" },
    'less-than-equal'                       : { char: 0xf537, cls: "fa-solid" },
    'life-ring'                             : { char: 0xf1cd, cls: "fa-solid" },
    'lightbulb'                             : { char: 0xf0eb, cls: "fa-solid" },
    'lines-leaning'                         : { char: 0xe51e, cls: "fa-solid" },
    'link'                                  : { char: 0xf0c1, cls: "fa-solid" },
    'link-slash'                            : { char: 0xf127, cls: "fa-solid" },
    'lira-sign'                             : { char: 0xf195, cls: "fa-solid" },
    'list'                                  : { char: 0xf03a, cls: "fa-solid" },
    'list-check'                            : { char: 0xf0ae, cls: "fa-solid" },
    'list-ol'                               : { char: 0xf0cb, cls: "fa-solid" },
    'list-ul'                               : { char: 0xf0ca, cls: "fa-solid" },
    'litecoin-sign'                         : { char: 0xe1d3, cls: "fa-solid" },
    'location-arrow'                        : { char: 0xf124, cls: "fa-solid" },
    'location-crosshairs'                   : { char: 0xf601, cls: "fa-solid" },
    'location-dot'                          : { char: 0xf3c5, cls: "fa-solid" },
    'location-pin'                          : { char: 0xf041, cls: "fa-solid" },
    'location-pin-lock'                     : { char: 0xe51f, cls: "fa-solid" },
    'lock'                                  : { char: 0xf023, cls: "fa-solid" },
    'lock-open'                             : { char: 0xf3c1, cls: "fa-solid" },
    'locust'                                : { char: 0xe520, cls: "fa-solid" },
    'lungs'                                 : { char: 0xf604, cls: "fa-solid" },
    'lungs-virus'                           : { char: 0xe067, cls: "fa-solid" },
    'm'                                     : { char: 0x004d, cls: "fa-solid" },
    'magnet'                                : { char: 0xf076, cls: "fa-solid" },
    'magnifying-glass'                      : { char: 0xf002, cls: "fa-solid" },
    'magnifying-glass-arrow-right'          : { char: 0xe521, cls: "fa-solid" },
    'magnifying-glass-chart'                : { char: 0xe522, cls: "fa-solid" },
    'magnifying-glass-dollar'               : { char: 0xf688, cls: "fa-solid" },
    'magnifying-glass-location'             : { char: 0xf689, cls: "fa-solid" },
    'magnifying-glass-minus'                : { char: 0xf010, cls: "fa-solid" },
    'magnifying-glass-plus'                 : { char: 0xf00e, cls: "fa-solid" },
    'manat-sign'                            : { char: 0xe1d5, cls: "fa-solid" },
    'map'                                   : { char: 0xf279, cls: "fa-solid" },
    'map-location'                          : { char: 0xf59f, cls: "fa-solid" },
    'map-location-dot'                      : { char: 0xf5a0, cls: "fa-solid" },
    'map-pin'                               : { char: 0xf276, cls: "fa-solid" },
    'marker'                                : { char: 0xf5a1, cls: "fa-solid" },
    'mars'                                  : { char: 0xf222, cls: "fa-solid" },
    'mars-and-venus'                        : { char: 0xf224, cls: "fa-solid" },
    'mars-and-venus-burst'                  : { char: 0xe523, cls: "fa-solid" },
    'mars-double'                           : { char: 0xf227, cls: "fa-solid" },
    'mars-stroke'                           : { char: 0xf229, cls: "fa-solid" },
    'mars-stroke-right'                     : { char: 0xf22b, cls: "fa-solid" },
    'mars-stroke-up'                        : { char: 0xf22a, cls: "fa-solid" },
    'martini-glass'                         : { char: 0xf57b, cls: "fa-solid" },
    'martini-glass-citrus'                  : { char: 0xf561, cls: "fa-solid" },
    'martini-glass-empty'                   : { char: 0xf000, cls: "fa-solid" },
    'mask'                                  : { char: 0xf6fa, cls: "fa-solid" },
    'mask-face'                             : { char: 0xe1d7, cls: "fa-solid" },
    'mask-ventilator'                       : { char: 0xe524, cls: "fa-solid" },
    'masks-theater'                         : { char: 0xf630, cls: "fa-solid" },
    'mattress-pillow'                       : { char: 0xe525, cls: "fa-solid" },
    'maximize'                              : { char: 0xf31e, cls: "fa-solid" },
    'medal'                                 : { char: 0xf5a2, cls: "fa-solid" },
    'memory'                                : { char: 0xf538, cls: "fa-solid" },
    'menorah'                               : { char: 0xf676, cls: "fa-solid" },
    'mercury'                               : { char: 0xf223, cls: "fa-solid" },
    'message'                               : { char: 0xf27a, cls: "fa-solid" },
    'meteor'                                : { char: 0xf753, cls: "fa-solid" },
    'microchip'                             : { char: 0xf2db, cls: "fa-solid" },
    'microphone'                            : { char: 0xf130, cls: "fa-solid" },
    'microphone-lines'                      : { char: 0xf3c9, cls: "fa-solid" },
    'microphone-lines-slash'                : { char: 0xf539, cls: "fa-solid" },
    'microphone-slash'                      : { char: 0xf131, cls: "fa-solid" },
    'microscope'                            : { char: 0xf610, cls: "fa-solid" },
    'mill-sign'                             : { char: 0xe1ed, cls: "fa-solid" },
    'minimize'                              : { char: 0xf78c, cls: "fa-solid" },
    'minus'                                 : { char: 0xf068, cls: "fa-solid" },
    'mitten'                                : { char: 0xf7b5, cls: "fa-solid" },
    'mobile'                                : { char: 0xf3ce, cls: "fa-solid" },
    'mobile-button'                         : { char: 0xf10b, cls: "fa-solid" },
    'mobile-retro'                          : { char: 0xe527, cls: "fa-solid" },
    'mobile-screen'                         : { char: 0xf3cf, cls: "fa-solid" },
    'mobile-screen-button'                  : { char: 0xf3cd, cls: "fa-solid" },
    'money-bill'                            : { char: 0xf0d6, cls: "fa-solid" },
    'money-bill-1'                          : { char: 0xf3d1, cls: "fa-solid" },
    'money-bill-1-wave'                     : { char: 0xf53b, cls: "fa-solid" },
    'money-bill-transfer'                   : { char: 0xe528, cls: "fa-solid" },
    'money-bill-trend-up'                   : { char: 0xe529, cls: "fa-solid" },
    'money-bill-wave'                       : { char: 0xf53a, cls: "fa-solid" },
    'money-bill-wheat'                      : { char: 0xe52a, cls: "fa-solid" },
    'money-bills'                           : { char: 0xe1f3, cls: "fa-solid" },
    'money-check'                           : { char: 0xf53c, cls: "fa-solid" },
    'money-check-dollar'                    : { char: 0xf53d, cls: "fa-solid" },
    'monument'                              : { char: 0xf5a6, cls: "fa-solid" },
    'moon'                                  : { char: 0xf186, cls: "fa-solid" },
    'mortar-pestle'                         : { char: 0xf5a7, cls: "fa-solid" },
    'mosque'                                : { char: 0xf678, cls: "fa-solid" },
    'mosquito'                              : { char: 0xe52b, cls: "fa-solid" },
    'mosquito-net'                          : { char: 0xe52c, cls: "fa-solid" },
    'motorcycle'                            : { char: 0xf21c, cls: "fa-solid" },
    'mound'                                 : { char: 0xe52d, cls: "fa-solid" },
    'mountain'                              : { char: 0xf6fc, cls: "fa-solid" },
    'mountain-city'                         : { char: 0xe52e, cls: "fa-solid" },
    'mountain-sun'                          : { char: 0xe52f, cls: "fa-solid" },
    'mug-hot'                               : { char: 0xf7b6, cls: "fa-solid" },
    'mug-saucer'                            : { char: 0xf0f4, cls: "fa-solid" },
    'music'                                 : { char: 0xf001, cls: "fa-solid" },
    'n'                                     : { char: 0x004e, cls: "fa-solid" },
    'naira-sign'                            : { char: 0xe1f6, cls: "fa-solid" },
    'network-wired'                         : { char: 0xf6ff, cls: "fa-solid" },
    'neuter'                                : { char: 0xf22c, cls: "fa-solid" },
    'newspaper'                             : { char: 0xf1ea, cls: "fa-solid" },
    'not-equal'                             : { char: 0xf53e, cls: "fa-solid" },
    'notdef'                                : { char: 0xe1fe, cls: "fa-solid" },
    'note-sticky'                           : { char: 0xf249, cls: "fa-solid" },
    'notes-medical'                         : { char: 0xf481, cls: "fa-solid" },
    'o'                                     : { char: 0x004f, cls: "fa-solid" },
    'object-group'                          : { char: 0xf247, cls: "fa-solid" },
    'object-ungroup'                        : { char: 0xf248, cls: "fa-solid" },
    'oil-can'                               : { char: 0xf613, cls: "fa-solid" },
    'oil-well'                              : { char: 0xe532, cls: "fa-solid" },
    'om'                                    : { char: 0xf679, cls: "fa-solid" },
    'otter'                                 : { char: 0xf700, cls: "fa-solid" },
    'outdent'                               : { char: 0xf03b, cls: "fa-solid" },
    'p'                                     : { char: 0x0050, cls: "fa-solid" },
    'pager'                                 : { char: 0xf815, cls: "fa-solid" },
    'paint-roller'                          : { char: 0xf5aa, cls: "fa-solid" },
    'paintbrush'                            : { char: 0xf1fc, cls: "fa-solid" },
    'palette'                               : { char: 0xf53f, cls: "fa-solid" },
    'pallet'                                : { char: 0xf482, cls: "fa-solid" },
    'panorama'                              : { char: 0xe209, cls: "fa-solid" },
    'paper-plane'                           : { char: 0xf1d8, cls: "fa-solid" },
    'paperclip'                             : { char: 0xf0c6, cls: "fa-solid" },
    'parachute-box'                         : { char: 0xf4cd, cls: "fa-solid" },
    'paragraph'                             : { char: 0xf1dd, cls: "fa-solid" },
    'passport'                              : { char: 0xf5ab, cls: "fa-solid" },
    'paste'                                 : { char: 0xf0ea, cls: "fa-solid" },
    'pause'                                 : { char: 0xf04c, cls: "fa-solid" },
    'paw'                                   : { char: 0xf1b0, cls: "fa-solid" },
    'peace'                                 : { char: 0xf67c, cls: "fa-solid" },
    'pen'                                   : { char: 0xf304, cls: "fa-solid" },
    'pen-clip'                              : { char: 0xf305, cls: "fa-solid" },
    'pen-fancy'                             : { char: 0xf5ac, cls: "fa-solid" },
    'pen-nib'                               : { char: 0xf5ad, cls: "fa-solid" },
    'pen-ruler'                             : { char: 0xf5ae, cls: "fa-solid" },
    'pen-to-square'                         : { char: 0xf044, cls: "fa-solid" },
    'pencil'                                : { char: 0xf303, cls: "fa-solid" },
    'people-arrows'                         : { char: 0xe068, cls: "fa-solid" },
    'people-carry-box'                      : { char: 0xf4ce, cls: "fa-solid" },
    'people-group'                          : { char: 0xe533, cls: "fa-solid" },
    'people-line'                           : { char: 0xe534, cls: "fa-solid" },
    'people-pulling'                        : { char: 0xe535, cls: "fa-solid" },
    'people-robbery'                        : { char: 0xe536, cls: "fa-solid" },
    'people-roof'                           : { char: 0xe537, cls: "fa-solid" },
    'pepper-hot'                            : { char: 0xf816, cls: "fa-solid" },
    'percent'                               : { char: 0x0025, cls: "fa-solid" },
    'person'                                : { char: 0xf183, cls: "fa-solid" },
    'person-arrow-down-to-line'             : { char: 0xe538, cls: "fa-solid" },
    'person-arrow-up-from-line'             : { char: 0xe539, cls: "fa-solid" },
    'person-biking'                         : { char: 0xf84a, cls: "fa-solid" },
    'person-booth'                          : { char: 0xf756, cls: "fa-solid" },
    'person-breastfeeding'                  : { char: 0xe53a, cls: "fa-solid" },
    'person-burst'                          : { char: 0xe53b, cls: "fa-solid" },
    'person-cane'                           : { char: 0xe53c, cls: "fa-solid" },
    'person-chalkboard'                     : { char: 0xe53d, cls: "fa-solid" },
    'person-circle-check'                   : { char: 0xe53e, cls: "fa-solid" },
    'person-circle-exclamation'             : { char: 0xe53f, cls: "fa-solid" },
    'person-circle-minus'                   : { char: 0xe540, cls: "fa-solid" },
    'person-circle-plus'                    : { char: 0xe541, cls: "fa-solid" },
    'person-circle-question'                : { char: 0xe542, cls: "fa-solid" },
    'person-circle-xmark'                   : { char: 0xe543, cls: "fa-solid" },
    'person-digging'                        : { char: 0xf85e, cls: "fa-solid" },
    'person-dots-from-line'                 : { char: 0xf470, cls: "fa-solid" },
    'person-dress'                          : { char: 0xf182, cls: "fa-solid" },
    'person-dress-burst'                    : { char: 0xe544, cls: "fa-solid" },
    'person-drowning'                       : { char: 0xe545, cls: "fa-solid" },
    'person-falling'                        : { char: 0xe546, cls: "fa-solid" },
    'person-falling-burst'                  : { char: 0xe547, cls: "fa-solid" },
    'person-half-dress'                     : { char: 0xe548, cls: "fa-solid" },
    'person-harassing'                      : { char: 0xe549, cls: "fa-solid" },
    'person-hiking'                         : { char: 0xf6ec, cls: "fa-solid" },
    'person-military-pointing'              : { char: 0xe54a, cls: "fa-solid" },
    'person-military-rifle'                 : { char: 0xe54b, cls: "fa-solid" },
    'person-military-to-person'             : { char: 0xe54c, cls: "fa-solid" },
    'person-praying'                        : { char: 0xf683, cls: "fa-solid" },
    'person-pregnant'                       : { char: 0xe31e, cls: "fa-solid" },
    'person-rays'                           : { char: 0xe54d, cls: "fa-solid" },
    'person-rifle'                          : { char: 0xe54e, cls: "fa-solid" },
    'person-running'                        : { char: 0xf70c, cls: "fa-solid" },
    'person-shelter'                        : { char: 0xe54f, cls: "fa-solid" },
    'person-skating'                        : { char: 0xf7c5, cls: "fa-solid" },
    'person-skiing'                         : { char: 0xf7c9, cls: "fa-solid" },
    'person-skiing-nordic'                  : { char: 0xf7ca, cls: "fa-solid" },
    'person-snowboarding'                   : { char: 0xf7ce, cls: "fa-solid" },
    'person-swimming'                       : { char: 0xf5c4, cls: "fa-solid" },
    'person-through-window'                 : { char: 0xe5a9, cls: "fa-solid" },
    'person-walking'                        : { char: 0xf554, cls: "fa-solid" },
    'person-walking-arrow-loop-left'        : { char: 0xe551, cls: "fa-solid" },
    'person-walking-arrow-right'            : { char: 0xe552, cls: "fa-solid" },
    'person-walking-dashed-line-arrow-right': { char: 0xe553, cls: "fa-solid" },
    'person-walking-luggage'                : { char: 0xe554, cls: "fa-solid" },
    'person-walking-with-cane'              : { char: 0xf29d, cls: "fa-solid" },
    'peseta-sign'                           : { char: 0xe221, cls: "fa-solid" },
    'peso-sign'                             : { char: 0xe222, cls: "fa-solid" },
    'phone'                                 : { char: 0xf095, cls: "fa-solid" },
    'phone-flip'                            : { char: 0xf879, cls: "fa-solid" },
    'phone-slash'                           : { char: 0xf3dd, cls: "fa-solid" },
    'phone-volume'                          : { char: 0xf2a0, cls: "fa-solid" },
    'photo-film'                            : { char: 0xf87c, cls: "fa-solid" },
    'piggy-bank'                            : { char: 0xf4d3, cls: "fa-solid" },
    'pills'                                 : { char: 0xf484, cls: "fa-solid" },
    'pizza-slice'                           : { char: 0xf818, cls: "fa-solid" },
    'place-of-worship'                      : { char: 0xf67f, cls: "fa-solid" },
    'plane'                                 : { char: 0xf072, cls: "fa-solid" },
    'plane-arrival'                         : { char: 0xf5af, cls: "fa-solid" },
    'plane-circle-check'                    : { char: 0xe555, cls: "fa-solid" },
    'plane-circle-exclamation'              : { char: 0xe556, cls: "fa-solid" },
    'plane-circle-xmark'                    : { char: 0xe557, cls: "fa-solid" },
    'plane-departure'                       : { char: 0xf5b0, cls: "fa-solid" },
    'plane-lock'                            : { char: 0xe558, cls: "fa-solid" },
    'plane-slash'                           : { char: 0xe069, cls: "fa-solid" },
    'plane-up'                              : { char: 0xe22d, cls: "fa-solid" },
    'plant-wilt'                            : { char: 0xe5aa, cls: "fa-solid" },
    'plate-wheat'                           : { char: 0xe55a, cls: "fa-solid" },
    'play'                                  : { char: 0xf04b, cls: "fa-solid" },
    'plug'                                  : { char: 0xf1e6, cls: "fa-solid" },
    'plug-circle-bolt'                      : { char: 0xe55b, cls: "fa-solid" },
    'plug-circle-check'                     : { char: 0xe55c, cls: "fa-solid" },
    'plug-circle-exclamation'               : { char: 0xe55d, cls: "fa-solid" },
    'plug-circle-minus'                     : { char: 0xe55e, cls: "fa-solid" },
    'plug-circle-plus'                      : { char: 0xe55f, cls: "fa-solid" },
    'plug-circle-xmark'                     : { char: 0xe560, cls: "fa-solid" },
    'plus'                                  : { char: 0x002b, cls: "fa-solid" },
    'plus-minus'                            : { char: 0xe43c, cls: "fa-solid" },
    'podcast'                               : { char: 0xf2ce, cls: "fa-solid" },
    'poo'                                   : { char: 0xf2fe, cls: "fa-solid" },
    'poo-storm'                             : { char: 0xf75a, cls: "fa-solid" },
    'poop'                                  : { char: 0xf619, cls: "fa-solid" },
    'power-off'                             : { char: 0xf011, cls: "fa-solid" },
    'prescription'                          : { char: 0xf5b1, cls: "fa-solid" },
    'prescription-bottle'                   : { char: 0xf485, cls: "fa-solid" },
    'prescription-bottle-medical'           : { char: 0xf486, cls: "fa-solid" },
    'print'                                 : { char: 0xf02f, cls: "fa-solid" },
    'pump-medical'                          : { char: 0xe06a, cls: "fa-solid" },
    'pump-soap'                             : { char: 0xe06b, cls: "fa-solid" },
    'puzzle-piece'                          : { char: 0xf12e, cls: "fa-solid" },
    'q'                                     : { char: 0x0051, cls: "fa-solid" },
    'qrcode'                                : { char: 0xf029, cls: "fa-solid" },
    'question'                              : { char: 0x003f, cls: "fa-solid" },
    'quote-left'                            : { char: 0xf10d, cls: "fa-solid" },
    'quote-right'                           : { char: 0xf10e, cls: "fa-solid" },
    'r'                                     : { char: 0x0052, cls: "fa-solid" },
    'radiation'                             : { char: 0xf7b9, cls: "fa-solid" },
    'radio'                                 : { char: 0xf8d7, cls: "fa-solid" },
    'rainbow'                               : { char: 0xf75b, cls: "fa-solid" },
    'ranking-star'                          : { char: 0xe561, cls: "fa-solid" },
    'receipt'                               : { char: 0xf543, cls: "fa-solid" },
    'record-vinyl'                          : { char: 0xf8d9, cls: "fa-solid" },
    'rectangle-ad'                          : { char: 0xf641, cls: "fa-solid" },
    'rectangle-list'                        : { char: 0xf022, cls: "fa-solid" },
    'rectangle-xmark'                       : { char: 0xf410, cls: "fa-solid" },
    'recycle'                               : { char: 0xf1b8, cls: "fa-solid" },
    'registered'                            : { char: 0xf25d, cls: "fa-solid" },
    'repeat'                                : { char: 0xf363, cls: "fa-solid" },
    'reply'                                 : { char: 0xf3e5, cls: "fa-solid" },
    'reply-all'                             : { char: 0xf122, cls: "fa-solid" },
    'republican'                            : { char: 0xf75e, cls: "fa-solid" },
    'restroom'                              : { char: 0xf7bd, cls: "fa-solid" },
    'retweet'                               : { char: 0xf079, cls: "fa-solid" },
    'ribbon'                                : { char: 0xf4d6, cls: "fa-solid" },
    'right-from-bracket'                    : { char: 0xf2f5, cls: "fa-solid" },
    'right-left'                            : { char: 0xf362, cls: "fa-solid" },
    'right-long'                            : { char: 0xf30b, cls: "fa-solid" },
    'right-to-bracket'                      : { char: 0xf2f6, cls: "fa-solid" },
    'ring'                                  : { char: 0xf70b, cls: "fa-solid" },
    'road'                                  : { char: 0xf018, cls: "fa-solid" },
    'road-barrier'                          : { char: 0xe562, cls: "fa-solid" },
    'road-bridge'                           : { char: 0xe563, cls: "fa-solid" },
    'road-circle-check'                     : { char: 0xe564, cls: "fa-solid" },
    'road-circle-exclamation'               : { char: 0xe565, cls: "fa-solid" },
    'road-circle-xmark'                     : { char: 0xe566, cls: "fa-solid" },
    'road-lock'                             : { char: 0xe567, cls: "fa-solid" },
    'road-spikes'                           : { char: 0xe568, cls: "fa-solid" },
    'robot'                                 : { char: 0xf544, cls: "fa-solid" },
    'rocket'                                : { char: 0xf135, cls: "fa-solid" },
    'rotate'                                : { char: 0xf2f1, cls: "fa-solid" },
    'rotate-left'                           : { char: 0xf2ea, cls: "fa-solid" },
    'rotate-right'                          : { char: 0xf2f9, cls: "fa-solid" },
    'route'                                 : { char: 0xf4d7, cls: "fa-solid" },
    'rss'                                   : { char: 0xf09e, cls: "fa-solid" },
    'ruble-sign'                            : { char: 0xf158, cls: "fa-solid" },
    'rug'                                   : { char: 0xe569, cls: "fa-solid" },
    'ruler'                                 : { char: 0xf545, cls: "fa-solid" },
    'ruler-combined'                        : { char: 0xf546, cls: "fa-solid" },
    'ruler-horizontal'                      : { char: 0xf547, cls: "fa-solid" },
    'ruler-vertical'                        : { char: 0xf548, cls: "fa-solid" },
    'rupee-sign'                            : { char: 0xf156, cls: "fa-solid" },
    'rupiah-sign'                           : { char: 0xe23d, cls: "fa-solid" },
    's'                                     : { char: 0x0053, cls: "fa-solid" },
    'sack-dollar'                           : { char: 0xf81d, cls: "fa-solid" },
    'sack-xmark'                            : { char: 0xe56a, cls: "fa-solid" },
    'sailboat'                              : { char: 0xe445, cls: "fa-solid" },
    'satellite'                             : { char: 0xf7bf, cls: "fa-solid" },
    'satellite-dish'                        : { char: 0xf7c0, cls: "fa-solid" },
    'scale-balanced'                        : { char: 0xf24e, cls: "fa-solid" },
    'scale-unbalanced'                      : { char: 0xf515, cls: "fa-solid" },
    'scale-unbalanced-flip'                 : { char: 0xf516, cls: "fa-solid" },
    'school'                                : { char: 0xf549, cls: "fa-solid" },
    'school-circle-check'                   : { char: 0xe56b, cls: "fa-solid" },
    'school-circle-exclamation'             : { char: 0xe56c, cls: "fa-solid" },
    'school-circle-xmark'                   : { char: 0xe56d, cls: "fa-solid" },
    'school-flag'                           : { char: 0xe56e, cls: "fa-solid" },
    'school-lock'                           : { char: 0xe56f, cls: "fa-solid" },
    'scissors'                              : { char: 0xf0c4, cls: "fa-solid" },
    'screwdriver'                           : { char: 0xf54a, cls: "fa-solid" },
    'screwdriver-wrench'                    : { char: 0xf7d9, cls: "fa-solid" },
    'scroll'                                : { char: 0xf70e, cls: "fa-solid" },
    'scroll-torah'                          : { char: 0xf6a0, cls: "fa-solid" },
    'sd-card'                               : { char: 0xf7c2, cls: "fa-solid" },
    'section'                               : { char: 0xe447, cls: "fa-solid" },
    'seedling'                              : { char: 0xf4d8, cls: "fa-solid" },
    'server'                                : { char: 0xf233, cls: "fa-solid" },
    'shapes'                                : { char: 0xf61f, cls: "fa-solid" },
    'share'                                 : { char: 0xf064, cls: "fa-solid" },
    'share-from-square'                     : { char: 0xf14d, cls: "fa-solid" },
    'share-nodes'                           : { char: 0xf1e0, cls: "fa-solid" },
    'sheet-plastic'                         : { char: 0xe571, cls: "fa-solid" },
    'shekel-sign'                           : { char: 0xf20b, cls: "fa-solid" },
    'shield'                                : { char: 0xf132, cls: "fa-solid" },
    'shield-cat'                            : { char: 0xe572, cls: "fa-solid" },
    'shield-dog'                            : { char: 0xe573, cls: "fa-solid" },
    'shield-halved'                         : { char: 0xf3ed, cls: "fa-solid" },
    'shield-heart'                          : { char: 0xe574, cls: "fa-solid" },
    'shield-virus'                          : { char: 0xe06c, cls: "fa-solid" },
    'ship'                                  : { char: 0xf21a, cls: "fa-solid" },
    'shirt'                                 : { char: 0xf553, cls: "fa-solid" },
    'shoe-prints'                           : { char: 0xf54b, cls: "fa-solid" },
    'shop'                                  : { char: 0xf54f, cls: "fa-solid" },
    'shop-lock'                             : { char: 0xe4a5, cls: "fa-solid" },
    'shop-slash'                            : { char: 0xe070, cls: "fa-solid" },
    'shower'                                : { char: 0xf2cc, cls: "fa-solid" },
    'shrimp'                                : { char: 0xe448, cls: "fa-solid" },
    'shuffle'                               : { char: 0xf074, cls: "fa-solid" },
    'shuttle-space'                         : { char: 0xf197, cls: "fa-solid" },
    'sign-hanging'                          : { char: 0xf4d9, cls: "fa-solid" },
    'signal'                                : { char: 0xf012, cls: "fa-solid" },
    'signature'                             : { char: 0xf5b7, cls: "fa-solid" },
    'signs-post'                            : { char: 0xf277, cls: "fa-solid" },
    'sim-card'                              : { char: 0xf7c4, cls: "fa-solid" },
    'sink'                                  : { char: 0xe06d, cls: "fa-solid" },
    'sitemap'                               : { char: 0xf0e8, cls: "fa-solid" },
    'skull'                                 : { char: 0xf54c, cls: "fa-solid" },
    'skull-crossbones'                      : { char: 0xf714, cls: "fa-solid" },
    'slash'                                 : { char: 0xf715, cls: "fa-solid" },
    'sleigh'                                : { char: 0xf7cc, cls: "fa-solid" },
    'sliders'                               : { char: 0xf1de, cls: "fa-solid" },
    'smog'                                  : { char: 0xf75f, cls: "fa-solid" },
    'smoking'                               : { char: 0xf48d, cls: "fa-solid" },
    'snowflake'                             : { char: 0xf2dc, cls: "fa-solid" },
    'snowman'                               : { char: 0xf7d0, cls: "fa-solid" },
    'snowplow'                              : { char: 0xf7d2, cls: "fa-solid" },
    'soap'                                  : { char: 0xe06e, cls: "fa-solid" },
    'socks'                                 : { char: 0xf696, cls: "fa-solid" },
    'solar-panel'                           : { char: 0xf5ba, cls: "fa-solid" },
    'sort'                                  : { char: 0xf0dc, cls: "fa-solid" },
    'sort-down'                             : { char: 0xf0dd, cls: "fa-solid" },
    'sort-up'                               : { char: 0xf0de, cls: "fa-solid" },
    'spa'                                   : { char: 0xf5bb, cls: "fa-solid" },
    'spaghetti-monster-flying'              : { char: 0xf67b, cls: "fa-solid" },
    'spell-check'                           : { char: 0xf891, cls: "fa-solid" },
    'spider'                                : { char: 0xf717, cls: "fa-solid" },
    'spinner'                               : { char: 0xf110, cls: "fa-solid" },
    'splotch'                               : { char: 0xf5bc, cls: "fa-solid" },
    'spoon'                                 : { char: 0xf2e5, cls: "fa-solid" },
    'spray-can'                             : { char: 0xf5bd, cls: "fa-solid" },
    'spray-can-sparkles'                    : { char: 0xf5d0, cls: "fa-solid" },
    'square'                                : { char: 0xf0c8, cls: "fa-solid" },
    'square-arrow-up-right'                 : { char: 0xf14c, cls: "fa-solid" },
    'square-caret-down'                     : { char: 0xf150, cls: "fa-solid" },
    'square-caret-left'                     : { char: 0xf191, cls: "fa-solid" },
    'square-caret-right'                    : { char: 0xf152, cls: "fa-solid" },
    'square-caret-up'                       : { char: 0xf151, cls: "fa-solid" },
    'square-check'                          : { char: 0xf14a, cls: "fa-solid" },
    'square-envelope'                       : { char: 0xf199, cls: "fa-solid" },
    'square-full'                           : { char: 0xf45c, cls: "fa-solid" },
    'square-h'                              : { char: 0xf0fd, cls: "fa-solid" },
    'square-minus'                          : { char: 0xf146, cls: "fa-solid" },
    'square-nfi'                            : { char: 0xe576, cls: "fa-solid" },
    'square-parking'                        : { char: 0xf540, cls: "fa-solid" },
    'square-pen'                            : { char: 0xf14b, cls: "fa-solid" },
    'square-person-confined'                : { char: 0xe577, cls: "fa-solid" },
    'square-phone'                          : { char: 0xf098, cls: "fa-solid" },
    'square-phone-flip'                     : { char: 0xf87b, cls: "fa-solid" },
    'square-plus'                           : { char: 0xf0fe, cls: "fa-solid" },
    'square-poll-horizontal'                : { char: 0xf682, cls: "fa-solid" },
    'square-poll-vertical'                  : { char: 0xf681, cls: "fa-solid" },
    'square-root-variable'                  : { char: 0xf698, cls: "fa-solid" },
    'square-rss'                            : { char: 0xf143, cls: "fa-solid" },
    'square-share-nodes'                    : { char: 0xf1e1, cls: "fa-solid" },
    'square-up-right'                       : { char: 0xf360, cls: "fa-solid" },
    'square-virus'                          : { char: 0xe578, cls: "fa-solid" },
    'square-xmark'                          : { char: 0xf2d3, cls: "fa-solid" },
    'staff-snake'                           : { char: 0xe579, cls: "fa-solid" },
    'stairs'                                : { char: 0xe289, cls: "fa-solid" },
    'stamp'                                 : { char: 0xf5bf, cls: "fa-solid" },
    'stapler'                               : { char: 0xe5af, cls: "fa-solid" },
    'star'                                  : { char: 0xf005, cls: "fa-solid" },
    'star-and-crescent'                     : { char: 0xf699, cls: "fa-solid" },
    'star-half'                             : { char: 0xf089, cls: "fa-solid" },
    'star-half-stroke'                      : { char: 0xf5c0, cls: "fa-solid" },
    'star-of-david'                         : { char: 0xf69a, cls: "fa-solid" },
    'star-of-life'                          : { char: 0xf621, cls: "fa-solid" },
    'sterling-sign'                         : { char: 0xf154, cls: "fa-solid" },
    'stethoscope'                           : { char: 0xf0f1, cls: "fa-solid" },
    'stop'                                  : { char: 0xf04d, cls: "fa-solid" },
    'stopwatch'                             : { char: 0xf2f2, cls: "fa-solid" },
    'stopwatch-20'                          : { char: 0xe06f, cls: "fa-solid" },
    'store'                                 : { char: 0xf54e, cls: "fa-solid" },
    'store-slash'                           : { char: 0xe071, cls: "fa-solid" },
    'street-view'                           : { char: 0xf21d, cls: "fa-solid" },
    'strikethrough'                         : { char: 0xf0cc, cls: "fa-solid" },
    'stroopwafel'                           : { char: 0xf551, cls: "fa-solid" },
    'subscript'                             : { char: 0xf12c, cls: "fa-solid" },
    'suitcase'                              : { char: 0xf0f2, cls: "fa-solid" },
    'suitcase-medical'                      : { char: 0xf0fa, cls: "fa-solid" },
    'suitcase-rolling'                      : { char: 0xf5c1, cls: "fa-solid" },
    'sun'                                   : { char: 0xf185, cls: "fa-solid" },
    'sun-plant-wilt'                        : { char: 0xe57a, cls: "fa-solid" },
    'superscript'                           : { char: 0xf12b, cls: "fa-solid" },
    'swatchbook'                            : { char: 0xf5c3, cls: "fa-solid" },
    'synagogue'                             : { char: 0xf69b, cls: "fa-solid" },
    'syringe'                               : { char: 0xf48e, cls: "fa-solid" },
    't'                                     : { char: 0x0054, cls: "fa-solid" },
    'table'                                 : { char: 0xf0ce, cls: "fa-solid" },
    'table-cells'                           : { char: 0xf00a, cls: "fa-solid" },
    'table-cells-column-lock'               : { char: 0xe678, cls: "fa-solid" },
    'table-cells-large'                     : { char: 0xf009, cls: "fa-solid" },
    'table-cells-row-lock'                  : { char: 0xe67a, cls: "fa-solid" },
    'table-columns'                         : { char: 0xf0db, cls: "fa-solid" },
    'table-list'                            : { char: 0xf00b, cls: "fa-solid" },
    'table-tennis-paddle-ball'              : { char: 0xf45d, cls: "fa-solid" },
    'tablet'                                : { char: 0xf3fb, cls: "fa-solid" },
    'tablet-button'                         : { char: 0xf10a, cls: "fa-solid" },
    'tablet-screen-button'                  : { char: 0xf3fa, cls: "fa-solid" },
    'tablets'                               : { char: 0xf490, cls: "fa-solid" },
    'tachograph-digital'                    : { char: 0xf566, cls: "fa-solid" },
    'tag'                                   : { char: 0xf02b, cls: "fa-solid" },
    'tags'                                  : { char: 0xf02c, cls: "fa-solid" },
    'tape'                                  : { char: 0xf4db, cls: "fa-solid" },
    'tarp'                                  : { char: 0xe57b, cls: "fa-solid" },
    'tarp-droplet'                          : { char: 0xe57c, cls: "fa-solid" },
    'taxi'                                  : { char: 0xf1ba, cls: "fa-solid" },
    'teeth'                                 : { char: 0xf62e, cls: "fa-solid" },
    'teeth-open'                            : { char: 0xf62f, cls: "fa-solid" },
    'temperature-arrow-down'                : { char: 0xe03f, cls: "fa-solid" },
    'temperature-arrow-up'                  : { char: 0xe040, cls: "fa-solid" },
    'temperature-empty'                     : { char: 0xf2cb, cls: "fa-solid" },
    'temperature-full'                      : { char: 0xf2c7, cls: "fa-solid" },
    'temperature-half'                      : { char: 0xf2c9, cls: "fa-solid" },
    'temperature-high'                      : { char: 0xf769, cls: "fa-solid" },
    'temperature-low'                       : { char: 0xf76b, cls: "fa-solid" },
    'temperature-quarter'                   : { char: 0xf2ca, cls: "fa-solid" },
    'temperature-three-quarters'            : { char: 0xf2c8, cls: "fa-solid" },
    'tenge-sign'                            : { char: 0xf7d7, cls: "fa-solid" },
    'tent'                                  : { char: 0xe57d, cls: "fa-solid" },
    'tent-arrow-down-to-line'               : { char: 0xe57e, cls: "fa-solid" },
    'tent-arrow-left-right'                 : { char: 0xe57f, cls: "fa-solid" },
    'tent-arrow-turn-left'                  : { char: 0xe580, cls: "fa-solid" },
    'tent-arrows-down'                      : { char: 0xe581, cls: "fa-solid" },
    'tents'                                 : { char: 0xe582, cls: "fa-solid" },
    'terminal'                              : { char: 0xf120, cls: "fa-solid" },
    'text-height'                           : { char: 0xf034, cls: "fa-solid" },
    'text-slash'                            : { char: 0xf87d, cls: "fa-solid" },
    'text-width'                            : { char: 0xf035, cls: "fa-solid" },
    'thermometer'                           : { char: 0xf491, cls: "fa-solid" },
    'thumbs-down'                           : { char: 0xf165, cls: "fa-solid" },
    'thumbs-up'                             : { char: 0xf164, cls: "fa-solid" },
    'thumbtack'                             : { char: 0xf08d, cls: "fa-solid" },
    'ticket'                                : { char: 0xf145, cls: "fa-solid" },
    'ticket-simple'                         : { char: 0xf3ff, cls: "fa-solid" },
    'timeline'                              : { char: 0xe29c, cls: "fa-solid" },
    'toggle-off'                            : { char: 0xf204, cls: "fa-solid" },
    'toggle-on'                             : { char: 0xf205, cls: "fa-solid" },
    'toilet'                                : { char: 0xf7d8, cls: "fa-solid" },
    'toilet-paper'                          : { char: 0xf71e, cls: "fa-solid" },
    'toilet-paper-slash'                    : { char: 0xe072, cls: "fa-solid" },
    'toilet-portable'                       : { char: 0xe583, cls: "fa-solid" },
    'toilets-portable'                      : { char: 0xe584, cls: "fa-solid" },
    'toolbox'                               : { char: 0xf552, cls: "fa-solid" },
    'tooth'                                 : { char: 0xf5c9, cls: "fa-solid" },
    'torii-gate'                            : { char: 0xf6a1, cls: "fa-solid" },
    'tornado'                               : { char: 0xf76f, cls: "fa-solid" },
    'tower-broadcast'                       : { char: 0xf519, cls: "fa-solid" },
    'tower-cell'                            : { char: 0xe585, cls: "fa-solid" },
    'tower-observation'                     : { char: 0xe586, cls: "fa-solid" },
    'tractor'                               : { char: 0xf722, cls: "fa-solid" },
    'trademark'                             : { char: 0xf25c, cls: "fa-solid" },
    'traffic-light'                         : { char: 0xf637, cls: "fa-solid" },
    'trailer'                               : { char: 0xe041, cls: "fa-solid" },
    'train'                                 : { char: 0xf238, cls: "fa-solid" },
    'train-subway'                          : { char: 0xf239, cls: "fa-solid" },
    'train-tram'                            : { char: 0xe5b4, cls: "fa-solid" },
    'transgender'                           : { char: 0xf225, cls: "fa-solid" },
    'trash'                                 : { char: 0xf1f8, cls: "fa-solid" },
    'trash-arrow-up'                        : { char: 0xf829, cls: "fa-solid" },
    'trash-can'                             : { char: 0xf2ed, cls: "fa-solid" },
    'trash-can-arrow-up'                    : { char: 0xf82a, cls: "fa-solid" },
    'tree'                                  : { char: 0xf1bb, cls: "fa-solid" },
    'tree-city'                             : { char: 0xe587, cls: "fa-solid" },
    'triangle-exclamation'                  : { char: 0xf071, cls: "fa-solid" },
    'trophy'                                : { char: 0xf091, cls: "fa-solid" },
    'trowel'                                : { char: 0xe589, cls: "fa-solid" },
    'trowel-bricks'                         : { char: 0xe58a, cls: "fa-solid" },
    'truck'                                 : { char: 0xf0d1, cls: "fa-solid" },
    'truck-arrow-right'                     : { char: 0xe58b, cls: "fa-solid" },
    'truck-droplet'                         : { char: 0xe58c, cls: "fa-solid" },
    'truck-fast'                            : { char: 0xf48b, cls: "fa-solid" },
    'truck-field'                           : { char: 0xe58d, cls: "fa-solid" },
    'truck-field-un'                        : { char: 0xe58e, cls: "fa-solid" },
    'truck-front'                           : { char: 0xe2b7, cls: "fa-solid" },
    'truck-medical'                         : { char: 0xf0f9, cls: "fa-solid" },
    'truck-monster'                         : { char: 0xf63b, cls: "fa-solid" },
    'truck-moving'                          : { char: 0xf4df, cls: "fa-solid" },
    'truck-pickup'                          : { char: 0xf63c, cls: "fa-solid" },
    'truck-plane'                           : { char: 0xe58f, cls: "fa-solid" },
    'truck-ramp-box'                        : { char: 0xf4de, cls: "fa-solid" },
    'tty'                                   : { char: 0xf1e4, cls: "fa-solid" },
    'turkish-lira-sign'                     : { char: 0xe2bb, cls: "fa-solid" },
    'turn-down'                             : { char: 0xf3be, cls: "fa-solid" },
    'turn-up'                               : { char: 0xf3bf, cls: "fa-solid" },
    'tv'                                    : { char: 0xf26c, cls: "fa-solid" },
    'u'                                     : { char: 0x0055, cls: "fa-solid" },
    'umbrella'                              : { char: 0xf0e9, cls: "fa-solid" },
    'umbrella-beach'                        : { char: 0xf5ca, cls: "fa-solid" },
    'underline'                             : { char: 0xf0cd, cls: "fa-solid" },
    'universal-access'                      : { char: 0xf29a, cls: "fa-solid" },
    'unlock'                                : { char: 0xf09c, cls: "fa-solid" },
    'unlock-keyhole'                        : { char: 0xf13e, cls: "fa-solid" },
    'up-down'                               : { char: 0xf338, cls: "fa-solid" },
    'up-down-left-right'                    : { char: 0xf0b2, cls: "fa-solid" },
    'up-long'                               : { char: 0xf30c, cls: "fa-solid" },
    'up-right-and-down-left-from-center'    : { char: 0xf424, cls: "fa-solid" },
    'up-right-from-square'                  : { char: 0xf35d, cls: "fa-solid" },
    'upload'                                : { char: 0xf093, cls: "fa-solid" },
    'user'                                  : { char: 0xf007, cls: "fa-solid" },
    'user-astronaut'                        : { char: 0xf4fb, cls: "fa-solid" },
    'user-check'                            : { char: 0xf4fc, cls: "fa-solid" },
    'user-clock'                            : { char: 0xf4fd, cls: "fa-solid" },
    'user-doctor'                           : { char: 0xf0f0, cls: "fa-solid" },
    'user-gear'                             : { char: 0xf4fe, cls: "fa-solid" },
    'user-graduate'                         : { char: 0xf501, cls: "fa-solid" },
    'user-group'                            : { char: 0xf500, cls: "fa-solid" },
    'user-injured'                          : { char: 0xf728, cls: "fa-solid" },
    'user-large'                            : { char: 0xf406, cls: "fa-solid" },
    'user-large-slash'                      : { char: 0xf4fa, cls: "fa-solid" },
    'user-lock'                             : { char: 0xf502, cls: "fa-solid" },
    'user-minus'                            : { char: 0xf503, cls: "fa-solid" },
    'user-ninja'                            : { char: 0xf504, cls: "fa-solid" },
    'user-nurse'                            : { char: 0xf82f, cls: "fa-solid" },
    'user-pen'                              : { char: 0xf4ff, cls: "fa-solid" },
    'user-plus'                             : { char: 0xf234, cls: "fa-solid" },
    'user-secret'                           : { char: 0xf21b, cls: "fa-solid" },
    'user-shield'                           : { char: 0xf505, cls: "fa-solid" },
    'user-slash'                            : { char: 0xf506, cls: "fa-solid" },
    'user-tag'                              : { char: 0xf507, cls: "fa-solid" },
    'user-tie'                              : { char: 0xf508, cls: "fa-solid" },
    'user-xmark'                            : { char: 0xf235, cls: "fa-solid" },
    'users'                                 : { char: 0xf0c0, cls: "fa-solid" },
    'users-between-lines'                   : { char: 0xe591, cls: "fa-solid" },
    'users-gear'                            : { char: 0xf509, cls: "fa-solid" },
    'users-line'                            : { char: 0xe592, cls: "fa-solid" },
    'users-rays'                            : { char: 0xe593, cls: "fa-solid" },
    'users-rectangle'                       : { char: 0xe594, cls: "fa-solid" },
    'users-slash'                           : { char: 0xe073, cls: "fa-solid" },
    'users-viewfinder'                      : { char: 0xe595, cls: "fa-solid" },
    'utensils'                              : { char: 0xf2e7, cls: "fa-solid" },
    'v'                                     : { char: 0x0056, cls: "fa-solid" },
    'van-shuttle'                           : { char: 0xf5b6, cls: "fa-solid" },
    'vault'                                 : { char: 0xe2c5, cls: "fa-solid" },
    'vector-square'                         : { char: 0xf5cb, cls: "fa-solid" },
    'venus'                                 : { char: 0xf221, cls: "fa-solid" },
    'venus-double'                          : { char: 0xf226, cls: "fa-solid" },
    'venus-mars'                            : { char: 0xf228, cls: "fa-solid" },
    'vest'                                  : { char: 0xe085, cls: "fa-solid" },
    'vest-patches'                          : { char: 0xe086, cls: "fa-solid" },
    'vial'                                  : { char: 0xf492, cls: "fa-solid" },
    'vial-circle-check'                     : { char: 0xe596, cls: "fa-solid" },
    'vial-virus'                            : { char: 0xe597, cls: "fa-solid" },
    'vials'                                 : { char: 0xf493, cls: "fa-solid" },
    'video'                                 : { char: 0xf03d, cls: "fa-solid" },
    'video-slash'                           : { char: 0xf4e2, cls: "fa-solid" },
    'vihara'                                : { char: 0xf6a7, cls: "fa-solid" },
    'virus'                                 : { char: 0xe074, cls: "fa-solid" },
    'virus-covid'                           : { char: 0xe4a8, cls: "fa-solid" },
    'virus-covid-slash'                     : { char: 0xe4a9, cls: "fa-solid" },
    'virus-slash'                           : { char: 0xe075, cls: "fa-solid" },
    'viruses'                               : { char: 0xe076, cls: "fa-solid" },
    'voicemail'                             : { char: 0xf897, cls: "fa-solid" },
    'volcano'                               : { char: 0xf770, cls: "fa-solid" },
    'volleyball'                            : { char: 0xf45f, cls: "fa-solid" },
    'volume-high'                           : { char: 0xf028, cls: "fa-solid" },
    'volume-low'                            : { char: 0xf027, cls: "fa-solid" },
    'volume-off'                            : { char: 0xf026, cls: "fa-solid" },
    'volume-xmark'                          : { char: 0xf6a9, cls: "fa-solid" },
    'vr-cardboard'                          : { char: 0xf729, cls: "fa-solid" },
    'w'                                     : { char: 0x0057, cls: "fa-solid" },
    'walkie-talkie'                         : { char: 0xf8ef, cls: "fa-solid" },
    'wallet'                                : { char: 0xf555, cls: "fa-solid" },
    'wand-magic'                            : { char: 0xf0d0, cls: "fa-solid" },
    'wand-magic-sparkles'                   : { char: 0xe2ca, cls: "fa-solid" },
    'wand-sparkles'                         : { char: 0xf72b, cls: "fa-solid" },
    'warehouse'                             : { char: 0xf494, cls: "fa-solid" },
    'water'                                 : { char: 0xf773, cls: "fa-solid" },
    'water-ladder'                          : { char: 0xf5c5, cls: "fa-solid" },
    'wave-square'                           : { char: 0xf83e, cls: "fa-solid" },
    'weight-hanging'                        : { char: 0xf5cd, cls: "fa-solid" },
    'weight-scale'                          : { char: 0xf496, cls: "fa-solid" },
    'wheat-awn'                             : { char: 0xe2cd, cls: "fa-solid" },
    'wheat-awn-circle-exclamation'          : { char: 0xe598, cls: "fa-solid" },
    'wheelchair'                            : { char: 0xf193, cls: "fa-solid" },
    'wheelchair-move'                       : { char: 0xe2ce, cls: "fa-solid" },
    'whiskey-glass'                         : { char: 0xf7a0, cls: "fa-solid" },
    'wifi'                                  : { char: 0xf1eb, cls: "fa-solid" },
    'wind'                                  : { char: 0xf72e, cls: "fa-solid" },
    'window-maximize'                       : { char: 0xf2d0, cls: "fa-solid" },
    'window-minimize'                       : { char: 0xf2d1, cls: "fa-solid" },
    'window-restore'                        : { char: 0xf2d2, cls: "fa-solid" },
    'wine-bottle'                           : { char: 0xf72f, cls: "fa-solid" },
    'wine-glass'                            : { char: 0xf4e3, cls: "fa-solid" },
    'wine-glass-empty'                      : { char: 0xf5ce, cls: "fa-solid" },
    'won-sign'                              : { char: 0xf159, cls: "fa-solid" },
    'worm'                                  : { char: 0xe599, cls: "fa-solid" },
    'wrench'                                : { char: 0xf0ad, cls: "fa-solid" },
    'x'                                     : { char: 0x0058, cls: "fa-solid" },
    'x-ray'                                 : { char: 0xf497, cls: "fa-solid" },
    'xmark'                                 : { char: 0xf00d, cls: "fa-solid" },
    'xmarks-lines'                          : { char: 0xe59a, cls: "fa-solid" },
    'y'                                     : { char: 0x0059, cls: "fa-solid" },
    'yen-sign'                              : { char: 0xf157, cls: "fa-solid" },
    'yin-yang'                              : { char: 0xf6ad, cls: "fa-solid" },
    'z'                                     : { char: 0x005a, cls: "fa-solid" },
    'bluetooth'                             : { char: 0xf293, cls: "fa-solid" },
    'font-awesome'                          : { char: 0xf2b4, cls: "fa-solid" },
    'nfc-symbol'                            : { char: 0xe531, cls: "fa-solid" },
    'web-awesome'                           : { char: 0xe682, cls: "fa-solid" },
    '42-group'                              : { char: 0xe080, cls: "fa-brands" },
    '500px'                                 : { char: 0xf26e, cls: "fa-brands" },
    'accessible-icon'                       : { char: 0xf368, cls: "fa-brands" },
    'accusoft'                              : { char: 0xf369, cls: "fa-brands" },
    'adn'                                   : { char: 0xf170, cls: "fa-brands" },
    'adversal'                              : { char: 0xf36a, cls: "fa-brands" },
    'affiliatetheme'                        : { char: 0xf36b, cls: "fa-brands" },
    'airbnb'                                : { char: 0xf834, cls: "fa-brands" },
    'algolia'                               : { char: 0xf36c, cls: "fa-brands" },
    'alipay'                                : { char: 0xf642, cls: "fa-brands" },
    'amazon'                                : { char: 0xf270, cls: "fa-brands" },
    'amazon-pay'                            : { char: 0xf42c, cls: "fa-brands" },
    'amilia'                                : { char: 0xf36d, cls: "fa-brands" },
    'android'                               : { char: 0xf17b, cls: "fa-brands" },
    'angellist'                             : { char: 0xf209, cls: "fa-brands" },
    'angrycreative'                         : { char: 0xf36e, cls: "fa-brands" },
    'angular'                               : { char: 0xf420, cls: "fa-brands" },
    'app-store'                             : { char: 0xf36f, cls: "fa-brands" },
    'app-store-ios'                         : { char: 0xf370, cls: "fa-brands" },
    'apper'                                 : { char: 0xf371, cls: "fa-brands" },
    'apple'                                 : { char: 0xf179, cls: "fa-brands" },
    'apple-pay'                             : { char: 0xf415, cls: "fa-brands" },
    'artstation'                            : { char: 0xf77a, cls: "fa-brands" },
    'asymmetrik'                            : { char: 0xf372, cls: "fa-brands" },
    'atlassian'                             : { char: 0xf77b, cls: "fa-brands" },
    'audible'                               : { char: 0xf373, cls: "fa-brands" },
    'autoprefixer'                          : { char: 0xf41c, cls: "fa-brands" },
    'avianex'                               : { char: 0xf374, cls: "fa-brands" },
    'aviato'                                : { char: 0xf421, cls: "fa-brands" },
    'aws'                                   : { char: 0xf375, cls: "fa-brands" },
    'bandcamp'                              : { char: 0xf2d5, cls: "fa-brands" },
    'battle-net'                            : { char: 0xf835, cls: "fa-brands" },
    'behance'                               : { char: 0xf1b4, cls: "fa-brands" },
    'bilibili'                              : { char: 0xe3d9, cls: "fa-brands" },
    'bimobject'                             : { char: 0xf378, cls: "fa-brands" },
    'bitbucket'                             : { char: 0xf171, cls: "fa-brands" },
    'bitcoin'                               : { char: 0xf379, cls: "fa-brands" },
    'bity'                                  : { char: 0xf37a, cls: "fa-brands" },
    'black-tie'                             : { char: 0xf27e, cls: "fa-brands" },
    'blackberry'                            : { char: 0xf37b, cls: "fa-brands" },
    'blogger'                               : { char: 0xf37c, cls: "fa-brands" },
    'blogger-b'                             : { char: 0xf37d, cls: "fa-brands" },
    'bluesky'                               : { char: 0xe671, cls: "fa-brands" },
    'bluetooth-b'                           : { char: 0xf294, cls: "fa-brands" },
    'bootstrap'                             : { char: 0xf836, cls: "fa-brands" },
    'bots'                                  : { char: 0xe340, cls: "fa-brands" },
    'brave'                                 : { char: 0xe63c, cls: "fa-brands" },
    'brave-reverse'                         : { char: 0xe63d, cls: "fa-brands" },
    'btc'                                   : { char: 0xf15a, cls: "fa-brands" },
    'buffer'                                : { char: 0xf837, cls: "fa-brands" },
    'buromobelexperte'                      : { char: 0xf37f, cls: "fa-brands" },
    'buy-n-large'                           : { char: 0xf8a6, cls: "fa-brands" },
    'buysellads'                            : { char: 0xf20d, cls: "fa-brands" },
    'canadian-maple-leaf'                   : { char: 0xf785, cls: "fa-brands" },
    'cc-amazon-pay'                         : { char: 0xf42d, cls: "fa-brands" },
    'cc-amex'                               : { char: 0xf1f3, cls: "fa-brands" },
    'cc-apple-pay'                          : { char: 0xf416, cls: "fa-brands" },
    'cc-diners-club'                        : { char: 0xf24c, cls: "fa-brands" },
    'cc-discover'                           : { char: 0xf1f2, cls: "fa-brands" },
    'cc-jcb'                                : { char: 0xf24b, cls: "fa-brands" },
    'cc-mastercard'                         : { char: 0xf1f1, cls: "fa-brands" },
    'cc-paypal'                             : { char: 0xf1f4, cls: "fa-brands" },
    'cc-stripe'                             : { char: 0xf1f5, cls: "fa-brands" },
    'cc-visa'                               : { char: 0xf1f0, cls: "fa-brands" },
    'centercode'                            : { char: 0xf380, cls: "fa-brands" },
    'centos'                                : { char: 0xf789, cls: "fa-brands" },
    'chrome'                                : { char: 0xf268, cls: "fa-brands" },
    'chromecast'                            : { char: 0xf838, cls: "fa-brands" },
    'cloudflare'                            : { char: 0xe07d, cls: "fa-brands" },
    'cloudscale'                            : { char: 0xf383, cls: "fa-brands" },
    'cloudsmith'                            : { char: 0xf384, cls: "fa-brands" },
    'cloudversify'                          : { char: 0xf385, cls: "fa-brands" },
    'cmplid'                                : { char: 0xe360, cls: "fa-brands" },
    'codepen'                               : { char: 0xf1cb, cls: "fa-brands" },
    'codiepie'                              : { char: 0xf284, cls: "fa-brands" },
    'confluence'                            : { char: 0xf78d, cls: "fa-brands" },
    'connectdevelop'                        : { char: 0xf20e, cls: "fa-brands" },
    'contao'                                : { char: 0xf26d, cls: "fa-brands" },
    'cotton-bureau'                         : { char: 0xf89e, cls: "fa-brands" },
    'cpanel'                                : { char: 0xf388, cls: "fa-brands" },
    'creative-commons'                      : { char: 0xf25e, cls: "fa-brands" },
    'creative-commons-by'                   : { char: 0xf4e7, cls: "fa-brands" },
    'creative-commons-nc'                   : { char: 0xf4e8, cls: "fa-brands" },
    'creative-commons-nc-eu'                : { char: 0xf4e9, cls: "fa-brands" },
    'creative-commons-nc-jp'                : { char: 0xf4ea, cls: "fa-brands" },
    'creative-commons-nd'                   : { char: 0xf4eb, cls: "fa-brands" },
    'creative-commons-pd'                   : { char: 0xf4ec, cls: "fa-brands" },
    'creative-commons-pd-alt'               : { char: 0xf4ed, cls: "fa-brands" },
    'creative-commons-remix'                : { char: 0xf4ee, cls: "fa-brands" },
    'creative-commons-sa'                   : { char: 0xf4ef, cls: "fa-brands" },
    'creative-commons-sampling'             : { char: 0xf4f0, cls: "fa-brands" },
    'creative-commons-sampling-plus'        : { char: 0xf4f1, cls: "fa-brands" },
    'creative-commons-share'                : { char: 0xf4f2, cls: "fa-brands" },
    'creative-commons-zero'                 : { char: 0xf4f3, cls: "fa-brands" },
    'critical-role'                         : { char: 0xf6c9, cls: "fa-brands" },
    'css3'                                  : { char: 0xf13c, cls: "fa-brands" },
    'css3-alt'                              : { char: 0xf38b, cls: "fa-brands" },
    'cuttlefish'                            : { char: 0xf38c, cls: "fa-brands" },
    'd-and-d'                               : { char: 0xf38d, cls: "fa-brands" },
    'd-and-d-beyond'                        : { char: 0xf6ca, cls: "fa-brands" },
    'dailymotion'                           : { char: 0xe052, cls: "fa-brands" },
    'dashcube'                              : { char: 0xf210, cls: "fa-brands" },
    'debian'                                : { char: 0xe60b, cls: "fa-brands" },
    'deezer'                                : { char: 0xe077, cls: "fa-brands" },
    'delicious'                             : { char: 0xf1a5, cls: "fa-brands" },
    'deploydog'                             : { char: 0xf38e, cls: "fa-brands" },
    'deskpro'                               : { char: 0xf38f, cls: "fa-brands" },
    'dev'                                   : { char: 0xf6cc, cls: "fa-brands" },
    'deviantart'                            : { char: 0xf1bd, cls: "fa-brands" },
    'dhl'                                   : { char: 0xf790, cls: "fa-brands" },
    'diaspora'                              : { char: 0xf791, cls: "fa-brands" },
    'digg'                                  : { char: 0xf1a6, cls: "fa-brands" },
    'digital-ocean'                         : { char: 0xf391, cls: "fa-brands" },
    'discord'                               : { char: 0xf392, cls: "fa-brands" },
    'discourse'                             : { char: 0xf393, cls: "fa-brands" },
    'dochub'                                : { char: 0xf394, cls: "fa-brands" },
    'docker'                                : { char: 0xf395, cls: "fa-brands" },
    'draft2digital'                         : { char: 0xf396, cls: "fa-brands" },
    'dribbble'                              : { char: 0xf17d, cls: "fa-brands" },
    'dropbox'                               : { char: 0xf16b, cls: "fa-brands" },
    'drupal'                                : { char: 0xf1a9, cls: "fa-brands" },
    'dyalog'                                : { char: 0xf399, cls: "fa-brands" },
    'earlybirds'                            : { char: 0xf39a, cls: "fa-brands" },
    'ebay'                                  : { char: 0xf4f4, cls: "fa-brands" },
    'edge'                                  : { char: 0xf282, cls: "fa-brands" },
    'edge-legacy'                           : { char: 0xe078, cls: "fa-brands" },
    'elementor'                             : { char: 0xf430, cls: "fa-brands" },
    'ello'                                  : { char: 0xf5f1, cls: "fa-brands" },
    'ember'                                 : { char: 0xf423, cls: "fa-brands" },
    'empire'                                : { char: 0xf1d1, cls: "fa-brands" },
    'envira'                                : { char: 0xf299, cls: "fa-brands" },
    'erlang'                                : { char: 0xf39d, cls: "fa-brands" },
    'ethereum'                              : { char: 0xf42e, cls: "fa-brands" },
    'etsy'                                  : { char: 0xf2d7, cls: "fa-brands" },
    'evernote'                              : { char: 0xf839, cls: "fa-brands" },
    'expeditedssl'                          : { char: 0xf23e, cls: "fa-brands" },
    'facebook'                              : { char: 0xf09a, cls: "fa-brands" },
    'facebook-f'                            : { char: 0xf39e, cls: "fa-brands" },
    'facebook-messenger'                    : { char: 0xf39f, cls: "fa-brands" },
    'fantasy-flight-games'                  : { char: 0xf6dc, cls: "fa-brands" },
    'fedex'                                 : { char: 0xf797, cls: "fa-brands" },
    'fedora'                                : { char: 0xf798, cls: "fa-brands" },
    'figma'                                 : { char: 0xf799, cls: "fa-brands" },
    'firefox'                               : { char: 0xf269, cls: "fa-brands" },
    'firefox-browser'                       : { char: 0xe007, cls: "fa-brands" },
    'first-order'                           : { char: 0xf2b0, cls: "fa-brands" },
    'first-order-alt'                       : { char: 0xf50a, cls: "fa-brands" },
    'firstdraft'                            : { char: 0xf3a1, cls: "fa-brands" },
    'flickr'                                : { char: 0xf16e, cls: "fa-brands" },
    'flipboard'                             : { char: 0xf44d, cls: "fa-brands" },
    'fly'                                   : { char: 0xf417, cls: "fa-brands" },
    'fonticons'                             : { char: 0xf280, cls: "fa-brands" },
    'fonticons-fi'                          : { char: 0xf3a2, cls: "fa-brands" },
    'fort-awesome'                          : { char: 0xf286, cls: "fa-brands" },
    'fort-awesome-alt'                      : { char: 0xf3a3, cls: "fa-brands" },
    'forumbee'                              : { char: 0xf211, cls: "fa-brands" },
    'foursquare'                            : { char: 0xf180, cls: "fa-brands" },
    'free-code-camp'                        : { char: 0xf2c5, cls: "fa-brands" },
    'freebsd'                               : { char: 0xf3a4, cls: "fa-brands" },
    'fulcrum'                               : { char: 0xf50b, cls: "fa-brands" },
    'galactic-republic'                     : { char: 0xf50c, cls: "fa-brands" },
    'galactic-senate'                       : { char: 0xf50d, cls: "fa-brands" },
    'get-pocket'                            : { char: 0xf265, cls: "fa-brands" },
    'gg'                                    : { char: 0xf260, cls: "fa-brands" },
    'gg-circle'                             : { char: 0xf261, cls: "fa-brands" },
    'git'                                   : { char: 0xf1d3, cls: "fa-brands" },
    'git-alt'                               : { char: 0xf841, cls: "fa-brands" },
    'github'                                : { char: 0xf09b, cls: "fa-brands" },
    'github-alt'                            : { char: 0xf113, cls: "fa-brands" },
    'gitkraken'                             : { char: 0xf3a6, cls: "fa-brands" },
    'gitlab'                                : { char: 0xf296, cls: "fa-brands" },
    'gitter'                                : { char: 0xf426, cls: "fa-brands" },
    'glide'                                 : { char: 0xf2a5, cls: "fa-brands" },
    'glide-g'                               : { char: 0xf2a6, cls: "fa-brands" },
    'gofore'                                : { char: 0xf3a7, cls: "fa-brands" },
    'golang'                                : { char: 0xe40f, cls: "fa-brands" },
    'goodreads'                             : { char: 0xf3a8, cls: "fa-brands" },
    'goodreads-g'                           : { char: 0xf3a9, cls: "fa-brands" },
    'google'                                : { char: 0xf1a0, cls: "fa-brands" },
    'google-drive'                          : { char: 0xf3aa, cls: "fa-brands" },
    'google-pay'                            : { char: 0xe079, cls: "fa-brands" },
    'google-play'                           : { char: 0xf3ab, cls: "fa-brands" },
    'google-plus'                           : { char: 0xf2b3, cls: "fa-brands" },
    'google-plus-g'                         : { char: 0xf0d5, cls: "fa-brands" },
    'google-scholar'                        : { char: 0xe63b, cls: "fa-brands" },
    'google-wallet'                         : { char: 0xf1ee, cls: "fa-brands" },
    'gratipay'                              : { char: 0xf184, cls: "fa-brands" },
    'grav'                                  : { char: 0xf2d6, cls: "fa-brands" },
    'gripfire'                              : { char: 0xf3ac, cls: "fa-brands" },
    'grunt'                                 : { char: 0xf3ad, cls: "fa-brands" },
    'guilded'                               : { char: 0xe07e, cls: "fa-brands" },
    'gulp'                                  : { char: 0xf3ae, cls: "fa-brands" },
    'hacker-news'                           : { char: 0xf1d4, cls: "fa-brands" },
    'hackerrank'                            : { char: 0xf5f7, cls: "fa-brands" },
    'hashnode'                              : { char: 0xe499, cls: "fa-brands" },
    'hips'                                  : { char: 0xf452, cls: "fa-brands" },
    'hire-a-helper'                         : { char: 0xf3b0, cls: "fa-brands" },
    'hive'                                  : { char: 0xe07f, cls: "fa-brands" },
    'hooli'                                 : { char: 0xf427, cls: "fa-brands" },
    'hornbill'                              : { char: 0xf592, cls: "fa-brands" },
    'hotjar'                                : { char: 0xf3b1, cls: "fa-brands" },
    'houzz'                                 : { char: 0xf27c, cls: "fa-brands" },
    'html5'                                 : { char: 0xf13b, cls: "fa-brands" },
    'hubspot'                               : { char: 0xf3b2, cls: "fa-brands" },
    'ideal'                                 : { char: 0xe013, cls: "fa-brands" },
    'imdb'                                  : { char: 0xf2d8, cls: "fa-brands" },
    'instagram'                             : { char: 0xf16d, cls: "fa-brands" },
    'instalod'                              : { char: 0xe081, cls: "fa-brands" },
    'intercom'                              : { char: 0xf7af, cls: "fa-brands" },
    'internet-explorer'                     : { char: 0xf26b, cls: "fa-brands" },
    'invision'                              : { char: 0xf7b0, cls: "fa-brands" },
    'ioxhost'                               : { char: 0xf208, cls: "fa-brands" },
    'itch-io'                               : { char: 0xf83a, cls: "fa-brands" },
    'itunes'                                : { char: 0xf3b4, cls: "fa-brands" },
    'itunes-note'                           : { char: 0xf3b5, cls: "fa-brands" },
    'java'                                  : { char: 0xf4e4, cls: "fa-brands" },
    'jedi-order'                            : { char: 0xf50e, cls: "fa-brands" },
    'jenkins'                               : { char: 0xf3b6, cls: "fa-brands" },
    'jira'                                  : { char: 0xf7b1, cls: "fa-brands" },
    'joget'                                 : { char: 0xf3b7, cls: "fa-brands" },
    'joomla'                                : { char: 0xf1aa, cls: "fa-brands" },
    'js'                                    : { char: 0xf3b8, cls: "fa-brands" },
    'jsfiddle'                              : { char: 0xf1cc, cls: "fa-brands" },
    'jxl'                                   : { char: 0xe67b, cls: "fa-brands" },
    'kaggle'                                : { char: 0xf5fa, cls: "fa-brands" },
    'keybase'                               : { char: 0xf4f5, cls: "fa-brands" },
    'keycdn'                                : { char: 0xf3ba, cls: "fa-brands" },
    'kickstarter'                           : { char: 0xf3bb, cls: "fa-brands" },
    'kickstarter-k'                         : { char: 0xf3bc, cls: "fa-brands" },
    'korvue'                                : { char: 0xf42f, cls: "fa-brands" },
    'laravel'                               : { char: 0xf3bd, cls: "fa-brands" },
    'lastfm'                                : { char: 0xf202, cls: "fa-brands" },
    'leanpub'                               : { char: 0xf212, cls: "fa-brands" },
    'less'                                  : { char: 0xf41d, cls: "fa-brands" },
    'letterboxd'                            : { char: 0xe62d, cls: "fa-brands" },
    'line'                                  : { char: 0xf3c0, cls: "fa-brands" },
    'linkedin'                              : { char: 0xf08c, cls: "fa-brands" },
    'linkedin-in'                           : { char: 0xf0e1, cls: "fa-brands" },
    'linode'                                : { char: 0xf2b8, cls: "fa-brands" },
    'linux'                                 : { char: 0xf17c, cls: "fa-brands" },
    'lyft'                                  : { char: 0xf3c3, cls: "fa-brands" },
    'magento'                               : { char: 0xf3c4, cls: "fa-brands" },
    'mailchimp'                             : { char: 0xf59e, cls: "fa-brands" },
    'mandalorian'                           : { char: 0xf50f, cls: "fa-brands" },
    'markdown'                              : { char: 0xf60f, cls: "fa-brands" },
    'mastodon'                              : { char: 0xf4f6, cls: "fa-brands" },
    'maxcdn'                                : { char: 0xf136, cls: "fa-brands" },
    'mdb'                                   : { char: 0xf8ca, cls: "fa-brands" },
    'medapps'                               : { char: 0xf3c6, cls: "fa-brands" },
    'medium'                                : { char: 0xf23a, cls: "fa-brands" },
    'medrt'                                 : { char: 0xf3c8, cls: "fa-brands" },
    'meetup'                                : { char: 0xf2e0, cls: "fa-brands" },
    'megaport'                              : { char: 0xf5a3, cls: "fa-brands" },
    'mendeley'                              : { char: 0xf7b3, cls: "fa-brands" },
    'meta'                                  : { char: 0xe49b, cls: "fa-brands" },
    'microblog'                             : { char: 0xe01a, cls: "fa-brands" },
    'microsoft'                             : { char: 0xf3ca, cls: "fa-brands" },
    'mintbit'                               : { char: 0xe62f, cls: "fa-brands" },
    'mix'                                   : { char: 0xf3cb, cls: "fa-brands" },
    'mixcloud'                              : { char: 0xf289, cls: "fa-brands" },
    'mixer'                                 : { char: 0xe056, cls: "fa-brands" },
    'mizuni'                                : { char: 0xf3cc, cls: "fa-brands" },
    'modx'                                  : { char: 0xf285, cls: "fa-brands" },
    'monero'                                : { char: 0xf3d0, cls: "fa-brands" },
    'napster'                               : { char: 0xf3d2, cls: "fa-brands" },
    'neos'                                  : { char: 0xf612, cls: "fa-brands" },
    'nfc-directional'                       : { char: 0xe530, cls: "fa-brands" },
    'nimblr'                                : { char: 0xf5a8, cls: "fa-brands" },
    'node'                                  : { char: 0xf419, cls: "fa-brands" },
    'node-js'                               : { char: 0xf3d3, cls: "fa-brands" },
    'npm'                                   : { char: 0xf3d4, cls: "fa-brands" },
    'ns8'                                   : { char: 0xf3d5, cls: "fa-brands" },
    'nutritionix'                           : { char: 0xf3d6, cls: "fa-brands" },
    'octopus-deploy'                        : { char: 0xe082, cls: "fa-brands" },
    'odnoklassniki'                         : { char: 0xf263, cls: "fa-brands" },
    'odysee'                                : { char: 0xe5c6, cls: "fa-brands" },
    'old-republic'                          : { char: 0xf510, cls: "fa-brands" },
    'opencart'                              : { char: 0xf23d, cls: "fa-brands" },
    'openid'                                : { char: 0xf19b, cls: "fa-brands" },
    'opensuse'                              : { char: 0xe62b, cls: "fa-brands" },
    'opera'                                 : { char: 0xf26a, cls: "fa-brands" },
    'optin-monster'                         : { char: 0xf23c, cls: "fa-brands" },
    'orcid'                                 : { char: 0xf8d2, cls: "fa-brands" },
    'osi'                                   : { char: 0xf41a, cls: "fa-brands" },
    'padlet'                                : { char: 0xe4a0, cls: "fa-brands" },
    'page4'                                 : { char: 0xf3d7, cls: "fa-brands" },
    'pagelines'                             : { char: 0xf18c, cls: "fa-brands" },
    'palfed'                                : { char: 0xf3d8, cls: "fa-brands" },
    'patreon'                               : { char: 0xf3d9, cls: "fa-brands" },
    'paypal'                                : { char: 0xf1ed, cls: "fa-brands" },
    'perbyte'                               : { char: 0xe083, cls: "fa-brands" },
    'periscope'                             : { char: 0xf3da, cls: "fa-brands" },
    'phabricator'                           : { char: 0xf3db, cls: "fa-brands" },
    'phoenix-framework'                     : { char: 0xf3dc, cls: "fa-brands" },
    'phoenix-squadron'                      : { char: 0xf511, cls: "fa-brands" },
    'php'                                   : { char: 0xf457, cls: "fa-brands" },
    'pied-piper'                            : { char: 0xf2ae, cls: "fa-brands" },
    'pied-piper-alt'                        : { char: 0xf1a8, cls: "fa-brands" },
    'pied-piper-hat'                        : { char: 0xf4e5, cls: "fa-brands" },
    'pied-piper-pp'                         : { char: 0xf1a7, cls: "fa-brands" },
    'pinterest'                             : { char: 0xf0d2, cls: "fa-brands" },
    'pinterest-p'                           : { char: 0xf231, cls: "fa-brands" },
    'pix'                                   : { char: 0xe43a, cls: "fa-brands" },
    'pixiv'                                 : { char: 0xe640, cls: "fa-brands" },
    'playstation'                           : { char: 0xf3df, cls: "fa-brands" },
    'product-hunt'                          : { char: 0xf288, cls: "fa-brands" },
    'pushed'                                : { char: 0xf3e1, cls: "fa-brands" },
    'python'                                : { char: 0xf3e2, cls: "fa-brands" },
    'qq'                                    : { char: 0xf1d6, cls: "fa-brands" },
    'quinscape'                             : { char: 0xf459, cls: "fa-brands" },
    'quora'                                 : { char: 0xf2c4, cls: "fa-brands" },
    'r-project'                             : { char: 0xf4f7, cls: "fa-brands" },
    'raspberry-pi'                          : { char: 0xf7bb, cls: "fa-brands" },
    'ravelry'                               : { char: 0xf2d9, cls: "fa-brands" },
    'react'                                 : { char: 0xf41b, cls: "fa-brands" },
    'reacteurope'                           : { char: 0xf75d, cls: "fa-brands" },
    'readme'                                : { char: 0xf4d5, cls: "fa-brands" },
    'rebel'                                 : { char: 0xf1d0, cls: "fa-brands" },
    'red-river'                             : { char: 0xf3e3, cls: "fa-brands" },
    'reddit'                                : { char: 0xf1a1, cls: "fa-brands" },
    'reddit-alien'                          : { char: 0xf281, cls: "fa-brands" },
    'redhat'                                : { char: 0xf7bc, cls: "fa-brands" },
    'renren'                                : { char: 0xf18b, cls: "fa-brands" },
    'replyd'                                : { char: 0xf3e6, cls: "fa-brands" },
    'researchgate'                          : { char: 0xf4f8, cls: "fa-brands" },
    'resolving'                             : { char: 0xf3e7, cls: "fa-brands" },
    'rev'                                   : { char: 0xf5b2, cls: "fa-brands" },
    'rocketchat'                            : { char: 0xf3e8, cls: "fa-brands" },
    'rockrms'                               : { char: 0xf3e9, cls: "fa-brands" },
    'rust'                                  : { char: 0xe07a, cls: "fa-brands" },
    'safari'                                : { char: 0xf267, cls: "fa-brands" },
    'salesforce'                            : { char: 0xf83b, cls: "fa-brands" },
    'sass'                                  : { char: 0xf41e, cls: "fa-brands" },
    'schlix'                                : { char: 0xf3ea, cls: "fa-brands" },
    'screenpal'                             : { char: 0xe570, cls: "fa-brands" },
    'scribd'                                : { char: 0xf28a, cls: "fa-brands" },
    'searchengin'                           : { char: 0xf3eb, cls: "fa-brands" },
    'sellcast'                              : { char: 0xf2da, cls: "fa-brands" },
    'sellsy'                                : { char: 0xf213, cls: "fa-brands" },
    'servicestack'                          : { char: 0xf3ec, cls: "fa-brands" },
    'shirtsinbulk'                          : { char: 0xf214, cls: "fa-brands" },
    'shoelace'                              : { char: 0xe60c, cls: "fa-brands" },
    'shopify'                               : { char: 0xe057, cls: "fa-brands" },
    'shopware'                              : { char: 0xf5b5, cls: "fa-brands" },
    'signal-messenger'                      : { char: 0xe663, cls: "fa-brands" },
    'simplybuilt'                           : { char: 0xf215, cls: "fa-brands" },
    'sistrix'                               : { char: 0xf3ee, cls: "fa-brands" },
    'sith'                                  : { char: 0xf512, cls: "fa-brands" },
    'sitrox'                                : { char: 0xe44a, cls: "fa-brands" },
    'sketch'                                : { char: 0xf7c6, cls: "fa-brands" },
    'skyatlas'                              : { char: 0xf216, cls: "fa-brands" },
    'skype'                                 : { char: 0xf17e, cls: "fa-brands" },
    'slack'                                 : { char: 0xf198, cls: "fa-brands" },
    'slideshare'                            : { char: 0xf1e7, cls: "fa-brands" },
    'snapchat'                              : { char: 0xf2ab, cls: "fa-brands" },
    'soundcloud'                            : { char: 0xf1be, cls: "fa-brands" },
    'sourcetree'                            : { char: 0xf7d3, cls: "fa-brands" },
    'space-awesome'                         : { char: 0xe5ac, cls: "fa-brands" },
    'speakap'                               : { char: 0xf3f3, cls: "fa-brands" },
    'speaker-deck'                          : { char: 0xf83c, cls: "fa-brands" },
    'spotify'                               : { char: 0xf1bc, cls: "fa-brands" },
    'square-behance'                        : { char: 0xf1b5, cls: "fa-brands" },
    'square-dribbble'                       : { char: 0xf397, cls: "fa-brands" },
    'square-facebook'                       : { char: 0xf082, cls: "fa-brands" },
    'square-font-awesome'                   : { char: 0xe5ad, cls: "fa-brands" },
    'square-font-awesome-stroke'            : { char: 0xf35c, cls: "fa-brands" },
    'square-git'                            : { char: 0xf1d2, cls: "fa-brands" },
    'square-github'                         : { char: 0xf092, cls: "fa-brands" },
    'square-gitlab'                         : { char: 0xe5ae, cls: "fa-brands" },
    'square-google-plus'                    : { char: 0xf0d4, cls: "fa-brands" },
    'square-hacker-news'                    : { char: 0xf3af, cls: "fa-brands" },
    'square-instagram'                      : { char: 0xe055, cls: "fa-brands" },
    'square-js'                             : { char: 0xf3b9, cls: "fa-brands" },
    'square-lastfm'                         : { char: 0xf203, cls: "fa-brands" },
    'square-letterboxd'                     : { char: 0xe62e, cls: "fa-brands" },
    'square-odnoklassniki'                  : { char: 0xf264, cls: "fa-brands" },
    'square-pied-piper'                     : { char: 0xe01e, cls: "fa-brands" },
    'square-pinterest'                      : { char: 0xf0d3, cls: "fa-brands" },
    'square-reddit'                         : { char: 0xf1a2, cls: "fa-brands" },
    'square-snapchat'                       : { char: 0xf2ad, cls: "fa-brands" },
    'square-steam'                          : { char: 0xf1b7, cls: "fa-brands" },
    'square-threads'                        : { char: 0xe619, cls: "fa-brands" },
    'square-tumblr'                         : { char: 0xf174, cls: "fa-brands" },
    'square-twitter'                        : { char: 0xf081, cls: "fa-brands" },
    'square-upwork'                         : { char: 0xe67c, cls: "fa-brands" },
    'square-viadeo'                         : { char: 0xf2aa, cls: "fa-brands" },
    'square-vimeo'                          : { char: 0xf194, cls: "fa-brands" },
    'square-web-awesome'                    : { char: 0xe683, cls: "fa-brands" },
    'square-web-awesome-stroke'             : { char: 0xe684, cls: "fa-brands" },
    'square-whatsapp'                       : { char: 0xf40c, cls: "fa-brands" },
    'square-x-twitter'                      : { char: 0xe61a, cls: "fa-brands" },
    'square-xing'                           : { char: 0xf169, cls: "fa-brands" },
    'square-youtube'                        : { char: 0xf431, cls: "fa-brands" },
    'squarespace'                           : { char: 0xf5be, cls: "fa-brands" },
    'stack-exchange'                        : { char: 0xf18d, cls: "fa-brands" },
    'stack-overflow'                        : { char: 0xf16c, cls: "fa-brands" },
    'stackpath'                             : { char: 0xf842, cls: "fa-brands" },
    'staylinked'                            : { char: 0xf3f5, cls: "fa-brands" },
    'steam'                                 : { char: 0xf1b6, cls: "fa-brands" },
    'steam-symbol'                          : { char: 0xf3f6, cls: "fa-brands" },
    'sticker-mule'                          : { char: 0xf3f7, cls: "fa-brands" },
    'strava'                                : { char: 0xf428, cls: "fa-brands" },
    'stripe'                                : { char: 0xf429, cls: "fa-brands" },
    'stripe-s'                              : { char: 0xf42a, cls: "fa-brands" },
    'stubber'                               : { char: 0xe5c7, cls: "fa-brands" },
    'studiovinari'                          : { char: 0xf3f8, cls: "fa-brands" },
    'stumbleupon'                           : { char: 0xf1a4, cls: "fa-brands" },
    'stumbleupon-circle'                    : { char: 0xf1a3, cls: "fa-brands" },
    'superpowers'                           : { char: 0xf2dd, cls: "fa-brands" },
    'supple'                                : { char: 0xf3f9, cls: "fa-brands" },
    'suse'                                  : { char: 0xf7d6, cls: "fa-brands" },
    'swift'                                 : { char: 0xf8e1, cls: "fa-brands" },
    'symfony'                               : { char: 0xf83d, cls: "fa-brands" },
    'teamspeak'                             : { char: 0xf4f9, cls: "fa-brands" },
    'telegram'                              : { char: 0xf2c6, cls: "fa-brands" },
    'tencent-weibo'                         : { char: 0xf1d5, cls: "fa-brands" },
    'the-red-yeti'                          : { char: 0xf69d, cls: "fa-brands" },
    'themeco'                               : { char: 0xf5c6, cls: "fa-brands" },
    'themeisle'                             : { char: 0xf2b2, cls: "fa-brands" },
    'think-peaks'                           : { char: 0xf731, cls: "fa-brands" },
    'threads'                               : { char: 0xe618, cls: "fa-brands" },
    'tiktok'                                : { char: 0xe07b, cls: "fa-brands" },
    'trade-federation'                      : { char: 0xf513, cls: "fa-brands" },
    'trello'                                : { char: 0xf181, cls: "fa-brands" },
    'tumblr'                                : { char: 0xf173, cls: "fa-brands" },
    'twitch'                                : { char: 0xf1e8, cls: "fa-brands" },
    'twitter'                               : { char: 0xf099, cls: "fa-brands" },
    'typo3'                                 : { char: 0xf42b, cls: "fa-brands" },
    'uber'                                  : { char: 0xf402, cls: "fa-brands" },
    'ubuntu'                                : { char: 0xf7df, cls: "fa-brands" },
    'uikit'                                 : { char: 0xf403, cls: "fa-brands" },
    'umbraco'                               : { char: 0xf8e8, cls: "fa-brands" },
    'uncharted'                             : { char: 0xe084, cls: "fa-brands" },
    'uniregistry'                           : { char: 0xf404, cls: "fa-brands" },
    'unity'                                 : { char: 0xe049, cls: "fa-brands" },
    'unsplash'                              : { char: 0xe07c, cls: "fa-brands" },
    'untappd'                               : { char: 0xf405, cls: "fa-brands" },
    'ups'                                   : { char: 0xf7e0, cls: "fa-brands" },
    'upwork'                                : { char: 0xe641, cls: "fa-brands" },
    'usb'                                   : { char: 0xf287, cls: "fa-brands" },
    'usps'                                  : { char: 0xf7e1, cls: "fa-brands" },
    'ussunnah'                              : { char: 0xf407, cls: "fa-brands" },
    'vaadin'                                : { char: 0xf408, cls: "fa-brands" },
    'viacoin'                               : { char: 0xf237, cls: "fa-brands" },
    'viadeo'                                : { char: 0xf2a9, cls: "fa-brands" },
    'viber'                                 : { char: 0xf409, cls: "fa-brands" },
    'vimeo'                                 : { char: 0xf40a, cls: "fa-brands" },
    'vimeo-v'                               : { char: 0xf27d, cls: "fa-brands" },
    'vine'                                  : { char: 0xf1ca, cls: "fa-brands" },
    'vk'                                    : { char: 0xf189, cls: "fa-brands" },
    'vnv'                                   : { char: 0xf40b, cls: "fa-brands" },
    'vuejs'                                 : { char: 0xf41f, cls: "fa-brands" },
    'watchman-monitoring'                   : { char: 0xe087, cls: "fa-brands" },
    'waze'                                  : { char: 0xf83f, cls: "fa-brands" },
    'webflow'                               : { char: 0xe65c, cls: "fa-brands" },
    'weebly'                                : { char: 0xf5cc, cls: "fa-brands" },
    'weibo'                                 : { char: 0xf18a, cls: "fa-brands" },
    'weixin'                                : { char: 0xf1d7, cls: "fa-brands" },
    'whatsapp'                              : { char: 0xf232, cls: "fa-brands" },
    'whmcs'                                 : { char: 0xf40d, cls: "fa-brands" },
    'wikipedia-w'                           : { char: 0xf266, cls: "fa-brands" },
    'windows'                               : { char: 0xf17a, cls: "fa-brands" },
    'wirsindhandwerk'                       : { char: 0xe2d0, cls: "fa-brands" },
    'wix'                                   : { char: 0xf5cf, cls: "fa-brands" },
    'wizards-of-the-coast'                  : { char: 0xf730, cls: "fa-brands" },
    'wodu'                                  : { char: 0xe088, cls: "fa-brands" },
    'wolf-pack-battalion'                   : { char: 0xf514, cls: "fa-brands" },
    'wordpress'                             : { char: 0xf19a, cls: "fa-brands" },
    'wordpress-simple'                      : { char: 0xf411, cls: "fa-brands" },
    'wpbeginner'                            : { char: 0xf297, cls: "fa-brands" },
    'wpexplorer'                            : { char: 0xf2de, cls: "fa-brands" },
    'wpforms'                               : { char: 0xf298, cls: "fa-brands" },
    'wpressr'                               : { char: 0xf3e4, cls: "fa-brands" },
    'x-twitter'                             : { char: 0xe61b, cls: "fa-brands" },
    'xbox'                                  : { char: 0xf412, cls: "fa-brands" },
    'xing'                                  : { char: 0xf168, cls: "fa-brands" },
    'y-combinator'                          : { char: 0xf23b, cls: "fa-brands" },
    'yahoo'                                 : { char: 0xf19e, cls: "fa-brands" },
    'yammer'                                : { char: 0xf840, cls: "fa-brands" },
    'yandex'                                : { char: 0xf413, cls: "fa-brands" },
    'yandex-international'                  : { char: 0xf414, cls: "fa-brands" },
    'yarn'                                  : { char: 0xf7e3, cls: "fa-brands" },
    'yelp'                                  : { char: 0xf1e9, cls: "fa-brands" },
    'yoast'                                 : { char: 0xf2b1, cls: "fa-brands" },
    'youtube'                               : { char: 0xf167, cls: "fa-brands" },
    'zhihu'                                 : { char: 0xf63f, cls: "fa-brands" }
};/* global kijs */

// --------------------------------------------------------------
// kijs.gui (namespace)
// --------------------------------------------------------------
kijs.gui = {};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.Dom (Static)
// --------------------------------------------------------------
kijs.gui.DragDrop = class kijs_gui_DragDrop {

    // PRIVATE VARS
    // __source {kijs.gui.Element} Element das aktuell gezogen wird
    // __target {kijs.gui.Element} Ziel-Element
    // __data   {Object} Objekt für die Zuweisung beliebiger Daten
    // __dropMarkerDom {kijs.gui.Dom} Marker, der die Einfügeposition visualisiert
    // __targetDragOverDom {kijs.gui.Dom} Dom, das aktuellen targets, dass die CSS-Klasse kijs-targetDragOver hat

    // --------------------------------------------------------------
    // STATIC GETTERS / SETTERS
    // --------------------------------------------------------------
    static get data() {
        if (!kijs.isDefined(this.__data)) {
            this.__data = {};
        }
        return this.__data;
    }
    static set data(val) {
        if (kijs.isObject(val)) {
            this.__data = val;
        } else {
            throw new kijs.Error(`kijs.gui.DragDrop.data must be an object.`);
        }
    }
    
    // kijs.gui.Element der aktuellen Drag&Drop-Operation
    static get source() {
        if (!kijs.isDefined(this.__source)) {
            this.__source = null;
        }
        return this.__source;
    }
    static set source(val) {
        this.__source = val;
    }

    static get target() {
        if (!kijs.isDefined(this.__target)) {
            this.__target = null;
        }
        return this.__target;
    }
    static set target(val) {
        this.__target = val;
    }

    // CSS-Klasse kijs-targetDragOver einem DOM zuweisen/entfernen
    static get targetDragOverDom() {
        if (!kijs.isDefined(this.__targetDragOverDom)) {
            this.__targetDragOverDom = null;
        }
        return this.__targetDragOverDom;
    }
    static set targetDragOverDom(val) {
        if (kijs.isDefined(this.__targetDragOverDom) && !kijs.isEmpty(this.__targetDragOverDom)) {
            this.__targetDragOverDom.clsRemove('kijs-targetDragOver');
        }

        if (!kijs.isEmpty(val)) {
            this.__targetDragOverDom = val;
            this.__targetDragOverDom.clsAdd('kijs-targetDragOver');
        } else {
            this.__targetDragOverDom = null;
        }
    }



    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Entfernt den Marker, der die Einfügeposition anzeigt
     * @returns {undefined}
     */
    static dropMarkerRemove() {
        if (this.__dropMarkerDom && this.__dropMarkerDom.node && this.__dropMarkerDom.node.parentNode) {
            this.__dropMarkerDom.node.parentNode.removeChild(this.__dropMarkerDom.node);
        }
        this.__dropMarkerDom = null;
    }

    /**
     * Positioniert den dropMarker
     * @param {kijs.gui.Dom|Null} [targetDom=null] Null = ausblenden
     * @param {String|Null|} [targetPos=null] 'before', 'after', 'child' oder null zum ausblenden
     * @param {String|Null|} [tagName=null]
     * @param {Number|Null} [width=null] Breite des Markers
     * @param {Number|Null} [height=null] Höhe des Markers
     * @param {String|Array|Null} [markerCls=null]  zusätzliche CSS Klassen für Marker
     * @param {String|Null|} [markerHtml=null]       innerHTML für Marker
     * @returns {undefined}
     */
    static dropMarkerUpdate(targetDom=null, targetPos=null, tagName=null,
        width=null, height=null, markerCls=null, markerHtml=null) {
        // evtl. nur ausblenden
        if (kijs.isEmpty(targetDom) || kijs.isEmpty(targetPos) || kijs.isEmpty(tagName)) {
            this.dropMarkerRemove();
            return;
        }

        let reCreate = true;
        if (this.__dropMarkerDom && this.__dropMarkerDom.node) {
            const currentTagName = this.__dropMarkerDom.node.tagName.toLowerCase();

            // falls der tagName noch stimmt, muss der node nicht neu erstellt werden
            if (currentTagName === tagName) {
                reCreate = false;
            }
        }

        // Evtl. den Marker neu erstellen
        if (reCreate) {
            this.dropMarkerRemove();

            this.__dropMarkerDom = new kijs.gui.Dom({
                nodeTagName: tagName
            });
        }

        // optionale CSS-Klassen hinzufügen
        this.__dropMarkerDom.clsRemoveAll();
        this.__dropMarkerDom.clsAdd('kijs-dropMarker');
        if (markerCls) {
            this.__dropMarkerDom.clsAdd(markerCls);
        }

        // evtl. HTML-Inhalt einfügen
        if (!kijs.isEmpty(markerHtml)) {
            this.__dropMarkerDom.html = markerHtml;
        } else {
            this.__dropMarkerDom.html = '';
        }

        // Grösse anpassen
        this.__dropMarkerDom.width = width;
        this.__dropMarkerDom.height = height;

        switch (targetPos) {
            case 'before':
            case 'after':
                this.__dropMarkerDom.renderTo(targetDom.node.parentNode, targetDom.node, targetPos);
                break;

            case 'child':
                this.__dropMarkerDom.renderTo(targetDom.node);
                break;
        }
    }

    /**
     * Erstellt den effectAllowed-String aus boolschen Variablen
     * @param {Boolean} ddAllowMove
     * @param {Boolean} ddAllowCopy
     * @param {Boolean} ddAllowLink
     * @returns {String}
     */
    static getddEffect(ddAllowMove, ddAllowCopy, ddAllowLink) {
        let ret = '';

        if (ddAllowCopy) {
            ret += 'Copy';
        }
        if (ddAllowLink) {
            ret += 'Link';
        }
        if (ddAllowMove) {
            ret += 'Move';
        }

        // nichts => 'none'
        if (!ret) {
            ret = 'none';
        }

        // 1. Buchstaben klein machen
        ret = ret.substring(0,1).toLowerCase() + ret.substring(1);

        // 'copyLinkMove' => 'all'
        if (ret === 'copyLinkMove') {
            ret = 'all';
        }

        return ret;
    }



    // --------------------------------------------------------------
    // dropFn-Funktionen für Drag&Drop-mapping
    // --------------------------------------------------------------
    // Verschiebt das Element an den neuen Ort
    static dropFnMoveEl(e) {
        // vom alten Ort entfernen
        e.source.ownerEl.parent.remove(e.source.ownerEl, {
            preventDestruct: true,
            preventUnrender: true,
            preventRender: false,
            preventEvents: false
        });

        // und beim neuen Ort wieder einfügen
        switch (e.target.targetPos){
            case 'child':
                e.target.targetEl.add(e.source.ownerEl);
                break;

            case 'before':
                e.target.targetEl.parent.add(e.source.ownerEl, e.target.targetEl.index);
                break;

            case 'after':
                e.target.targetEl.parent.add(e.source.ownerEl, e.target.targetEl.index+1);
                break;
        }
    }

    static dropFnGetSourceIndex(e) {
        return e.source.ownerEl.index;
    }

    static dropFnGetSourceEl(e) {
        return e.source.ownerEl;
    }

    // Gibt die Einfügeposition im Ziel Container zurück
    static dropFnGetTargetIndex(e) {
        let targetIndex = null;

        // Zielindex ermitteln
        switch (e.target.targetPos){
            case 'child':
                targetIndex = e.target.targetEl.elements.length;
                break;

            case 'before':
                targetIndex =  e.target.targetEl.index;
                break;

            case 'after':
                targetIndex =  e.target.targetEl.index + 1;
                break;
        }

        return targetIndex;
    }

    static dropFnGetTargetEl(e) {
        return e.target.ownerEl;
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.dragDrop (namespace)
// --------------------------------------------------------------
kijs.gui.dragDrop = {};
/* global kijs, this */

// Klasse mit Drag&Drop-Events/Funktionen, für das Element das gezogen wird

// --------------------------------------------------------------
// kijs.gui.dragDrop.Source
// --------------------------------------------------------------
kijs.gui.dragDrop.Source = class kijs_gui_dragDrop_Source extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._ownerEl = null;            // Eigentümmer kijs.gui.Element dieser Instanz
        this._ownerDomProperty = null;   // Property-Name des kijs.gui.Dom, der 
                                         // draggable ist. In der Regel kann dafür 'dom'
                                         // verwendet werden.

        this._name = null;

        this._allowMove = true;
        this._allowCopy = false;
        this._allowLink = false;

        // Grösse des Source-Elements bei DragStart, damit diese später für den 
        // Drop-Marker verwendet werden kann.
        this._width = null;
        this._height = null;

        this._display = null; // CSS-display Wert bei DragStart, damit nach dem 
                              // Ausblenden des Source el wieder eingeblendet werden kann.

        this._defaultConfig = {};

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            allowMove: true,    // Darf das Element per Drag&Drop verschoben werden?
            allowCopy: true,    // Darf das Element per Drag&Drop kopiert werden?
            allowLink: true,    // Darf per Drag&Drop eine Verknüpfung auf das Element erstellt werden?
            name: true,         // Drag&Drop Name
            on: { fn: 'assignListeners' },
            ownerEl: true,
            ownerDomProperty: { prio: 1000, target: 'ownerDomProperty' } // Property-Name des kijs.gui.Dom, der draggable ist
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get allowCopy() { return this._allowCopy; }
    set allowCopy(val) { this._allowCopy = !!val; }

    get allowLink() { return this._allowLink; }
    set allowLink(val) { this._allowLink = !!val; }

    get allowMove() { return this._allowMove; }
    set allowMove(val) { this._allowMove = !!val; }

    get display() { return this._display; }

    get height() { return this._height; }

    // Drag&Drop Name
    get name() { return this._name; }
    set name(val) { this._name = val; }

    // Verweis auf den kijs.gui.Dom, der draggable ist
    get ownerDom() {
        if (kijs.isEmpty(this._ownerEl)) {
            throw new kijs.Error(`draggable Elements must have a 'ddSource.ownerEl'`);
        }

        let dom = kijs.getObjectFromString(this._ownerDomProperty, this._ownerEl);

        if (kijs.isEmpty(dom)) {
            throw new kijs.Error(`draggable Elements must have a valide 'ddSource.ownerDomProperty'`);
        }

        return dom;
    }

    // Property-Name des kijs.gui.Dom, der draggable ist
    get ownerDomProperty() { return this._ownerDomProperty; }
    set ownerDomProperty(val) {
        this._ownerDomProperty = val;

        // DOM draggable machen
        this.ownerDom.nodeAttributeSet('draggable', true);

        // Drag&Drop Listeners
        this.ownerDom.on('dragStart', this.#onDragStart, this);
        this.ownerDom.on('dragEnd', this.#onDragEnd, this);
    }

    // Eigentümer kijs.gui.Element dieser Instanz
    get ownerEl() { return this._ownerEl; }
    set ownerEl(val) {
        this._ownerEl = val;
    }

    get width() { return this._width; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    applyConfig(config={}, preventEvents=false) {
        // Config zuweisen
        kijs.Object.assignConfig(this, config, this._configMap);

        // Objekt versiegeln
        // Bewirkt, dass keine neuen propertys hinzugefügt werden dürfen.
        Object.seal(this);
    }

    // Drag&Drop ist abgeschlossen (durch drop oder Abbruch)
    dragEnd() {
        // dropMarker entfernen
        kijs.gui.DragDrop.dropMarkerRemove();
        
        // CSS-Klassen bei Source entfernen und Source einblenden, falls ausgeblendet
        if (this._ownerEl && this._ownerEl.dom) {
            this._ownerEl.dom.clsRemove('kijs-dragging');
            this._ownerEl.dom.clsRemove('kijs-sourceDragOver');
            this._ownerEl.style.display = this._display;
        }
        
        // CSS-Klasse kijs-targetDragOver entfernen
        kijs.gui.DragDrop.targetDragOverDom = null;
        
        // dragEnd-Event bei source auslösen
        this.raiseEvent('dragEnd', { 
            source: this
        });
        
        // Aufräumen
        this._width = null;
        this._height = null;
        this._display = null;
        kijs.gui.DragDrop.source = null;
        kijs.gui.DragDrop.target = null;
        kijs.gui.DragDrop.data = {};
    }

    // PRIVATE
    // LISTENERS
    #onDragEnd(e) {
        this.dragEnd();
    }

    #onDragStart(e) {
        e.nodeEvent.stopPropagation();

        if (kijs.isEmpty(this._name)) {
            throw new kijs.Error(`draggable Elements must have a 'ddSource.name'`);
        }

        // Grösse des Elements merken, damit diese später für den Drop-Marker 
        // verwendet werden kann.
        this._width = this._ownerEl.width;
        this._height = this._ownerEl.height;
        this._display = this.ownerEl.style.display;

        kijs.gui.DragDrop.source = this;
        kijs.gui.DragDrop.target = null;

        this._ownerEl.dom.clsAdd('kijs-dragging');

        e.nodeEvent.dataTransfer.setData('application/' + this._name, '');

        e.nodeEvent.dataTransfer.effectAllowed = kijs.gui.DragDrop.getddEffect(
                this._allowMove, this._allowCopy, this._allowLink);
        
        // dragStart-Event bei source auslösen
        this.raiseEvent('dragStart', { 
            source: this
        });
        
        // keine weiteren bubbeling-Listeners mehr ausführen
        e.nodeEvent.stopPropagation();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren
        this._defaultConfig = null;
        this._ownerEl = null;

        // Basisklasse entladen
        super.destruct();
    }

};
/* global kijs, this */

// Klasse mit Drag&Drop-Events/Funktionen, für das Ziel-Element

// --------------------------------------------------------------
// kijs.gui.dragDrop.Target
// --------------------------------------------------------------
kijs.gui.dragDrop.Target = class kijs_gui_dragDrop_Target extends kijs.Observable {
     
    
    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._ownerEl = null;            // Eigentümmer kijs.gui.Element dieser Instanz
        this._ownerDomProperty = null;   // Property-Name des kijs.gui.Dom, der als 
                                         // Ziel dient.
        this._mapping = {};
        
        this._targetEl = null;      // Ziel kijs.gui.Element der aktuellen Drag&Drop-Operation
        this._targetPos = null;     // Einfügeposition beim Ziel {String} 'before', 'after', 'child'
        this._operation = 'none';   // operation 'move', 'copy', 'link' oder 'none'
        
        this._ddMarkerTagName = 'div';  // tagName des ddMarkers
        this._posBeforeFactor = 0.666;
        this._posAfterFactor = 0.666;
        
        
        // Workaround, weil das dragLeave auch kommt, wenn die Maus über ein Kind-Element 
        // gezogen wird.
        this._ddEnterTarget = null;
        
        this._defaultConfig = {};
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            ownerEl: true,
            ddMarkerTagName: true,
            posBeforeFactor: true,
            posAfterFactor: true,
            on: { fn: 'assignListeners' },
            mapping: { target: 'mapping' },
            ownerDomProperty: { prio: 1000, target: 'ownerDomProperty' } // Property-Name des kijs.gui.Dom, der als Ziel dient
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    
    
    
    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get ddMarkerTagName() { return this._ddMarkerTagName; }
    set ddMarkerTagName(val) {
        this._ddMarkerTagName = val.toLowerCase();
    }
    
    get mapping() { return this._mapping; }
    set mapping(val) { this._mapping = val; }
    
    get posAfterFactor() { return this._posAfterFactor; }
    set posAfterFactor(val) { 
        if (val < 0 || val > 1) {
            throw new kijs.Error(`'posBeforeFactor' must be between 0 and 1`);
        }
        this._posAfterFactor = val;
    }
    
    get posBeforeFactor() { return this._posBeforeFactor; }
    set posBeforeFactor(val) { 
        if (val < 0 || val > 1) {
            throw new kijs.Error(`'posBeforeFactor' must be between 0 and 1`);
        }
        this._posBeforeFactor = val;
    }

    // Verweis auf den kijs.gui.Dom, das als Ziel dient
    get ownerDom() {
        if (kijs.isEmpty(this._ownerEl)) {
            throw new kijs.Error(`target Elements must have a 'ddTarget.ownerEl'`);
        }
        
        let dom = kijs.getObjectFromString(this._ownerDomProperty, this._ownerEl);
        
        if (kijs.isEmpty(dom)) {
            throw new kijs.Error(`target Elements must have a valide 'ddTarget.ownerDomProperty'`);
        }
        
        return dom;
    }
    
    // Property-Name des kijs.gui.Dom, das als Ziel dient
    get ownerDomProperty() { return this._ownerDomProperty; }
    set ownerDomProperty(val) {
        this._ownerDomProperty = val;
        
        // Drag&Drop Listeners
        this.ownerDom.on('dragEnter', this.#onDragEnter, this);
        this.ownerDom.on('dragLeave', this.#onDragLeave, this);
        this.ownerDom.on('dragOver', this.#onDragOver, this);
        this.ownerDom.on('drop', this.#onDrop, this);
    }
    
    // Eigentümmer kijs.gui.Element dieser Instanz
    get ownerEl() { return this._ownerEl; }
    set ownerEl(val) { 
        this._ownerEl = val;
    }
    
    // Zielelement, auf das, das Element gedroppt wurde
    get targetEl() { return this._targetEl; }
    
    // Einfügeposition beim Ziel {String} 'before', 'after', 'child'
    get targetPos() { return this._targetPos; }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    applyConfig(config={}, preventEvents=false) {
        // Config zuweisen
        kijs.Object.assignConfig(this, config, this._configMap);
        
        // Objekt versiegeln
        // Bewirkt, dass keine neuen propertys hinzugefügt werden dürfen.
        Object.seal(this);
    }

    /**
     * Gibt das Kind Element zurück, dass sich unter dem Mauszeiger oder am nähesten befindet
     * @param {Array} elements  Elements-Array
     * @param {Number} clientX  Maus-Position vom nodeEvent
     * @param {Number} clientY  Maus-Position vom nodeEvent
     * @returns {Object} { el:..., diffX,... diffY:..., w:..., h:... };
     *                   el: Element unter dem Mauszeiger oder nähestes Element
     *                   diffX Abstand des Mauszeiger zum linken Rand des gefundenen Elements
     *                   diffY: Abstand des Mauszeiger zum oberen Rand des gefundenen Elements
     *                   w: Breite des gefundenen Elements
     *                   h: Höhe des gefundenen Elements
     */
    _getDragOverChild(elements, clientX, clientY) {
        let ret = null;
        
        if (kijs.isEmpty(elements)) {
            return ret;
        }
        
        const rectMouse = { 
            x: clientX,
            y: clientY, 
            w: 0,
            h: 0
        };
        
        // Ausrichtung der Elemente ermitteln
        const ndeParent = elements[0].dom.node.parentElement;
        const ndeParentTagName = this.ownerDom.node.tagName.toLowerCase();
        const ndeParentStyle = window.getComputedStyle(ndeParent);
        const flexDirection = ndeParentStyle.flexDirection;
        const flexWrap = ndeParentStyle.flexWrap;
        const isFlex = ndeParentStyle.display === 'flex';
        const isWrap = isFlex && flexWrap !== 'nowrap';
        const isHorizontal = (isFlex && !!flexDirection.startsWith('row')) || ndeParentTagName === 'tr';
        
        let minDistance = null;
        
        // Elemente durchgehen und das näheste Element ermitteln
        kijs.Array.each(elements, function(el) {
            let rectEl = kijs.Dom.getAbsolutePos(el.node);
            
            let ok = false;
            
            // Falls das Layout umgebrochen wird, muss sichergestellt werden, dass
            // nicht zwischen zwei Einfügepositionen hin und her geflackert wird.
            // Dies erreichen wir, indem der Mauszeiger in der aktuellen Spalte oder Zeile
            // auch in der richtigen Spalte oder Zeile sein muss.
            if (isWrap) {
                if (isHorizontal) {
                    let distanceY = clientY - rectEl.y;
                    ok = distanceY >= 0 && distanceY <= rectEl.h;
                } else {
                    let distanceX = clientX - rectEl.x;
                    ok = distanceX >= 0 && distanceX <= rectEl.w;
                }

            } else {
                ok = true;
                
            }
            
            if (ok) {
                // Distanz zwischen Mauszeiger und Mitte des Elements ermitteln
                let distance = kijs.Graphic.rectsDistance(rectMouse, rectEl);

                if (minDistance === null || distance < minDistance) {
                    ret = { 
                        el: el, 
                        diffX: clientX - rectEl.x,  // Abstand des Mauszeigers zum linken Rand
                        diffY: clientY - rectEl.y,  // Abstand des Mauszeigers zum oberen Rand
                        w: rectEl.w,
                        h: rectEl.h
                    };
                    minDistance = distance;
                }
            }
        }, this);
        
        return ret;
    }
    
    // Ermittelt die Operation 'move', 'copy', 'link' oder 'none'
    _getOperation(e, mapping) {
        let operation = 'none';
        
        // operation ermitteln
        if (!kijs.isEmpty(mapping)) {
            
            // Operation gemäss Tastenkombination ermitteln
            let keyOperation = 'move';
            
            // Mac
            if (kijs.Navigator.isMac) {
                // Workaround für Safari
                // Safari kann nicht auf die aktuellen Tastenkombinationen zugreifen, 
                // sondern hat noch den Stand vom DragStart
                if (kijs.Navigator.isSafari) {
                    // Was gedrückt wurde kann man aber teilweise aus dem effectAllowed lesen
                    switch (e.nodeEvent.dataTransfer.effectAllowed) {
                        case 'move':
                        case 'copyMove':
                        case 'all':
                            keyOperation = 'move';
                            break;
                        case 'copy':
                            keyOperation = 'copy';
                            break;
                        case 'link': // link kommt in Safari leider nie vor :(
                            keyOperation = 'link';
                    }
                    
                } else {
                    if (e.nodeEvent.altKey) {
                        if (e.nodeEvent.metaKey) {
                            keyOperation = 'link';
                        } else {
                            keyOperation = 'copy';
                        }
                    }
                }
                
            // Windows + andere
            } else {
                if (e.nodeEvent.ctrlKey) {
                    if (e.nodeEvent.shiftKey) {
                        keyOperation = 'link';
                    } else {
                        keyOperation = 'copy';
                    }
                }
            }
            
            // Falls es nur eine Variante gibt (move, copy, link) braucht es keine 
            // Tastenkombination
            let countSource = 0;
            countSource += kijs.gui.DragDrop.source.allowMove && mapping.allowMove ? 1 : 0;
            countSource += kijs.gui.DragDrop.source.allowCopy && mapping.allowCopy ? 1 : 0;
            countSource += kijs.gui.DragDrop.source.allowLink && mapping.allowLink ? 1 : 0;
            if (countSource === 1) {
                if (kijs.gui.DragDrop.source.allowMove && mapping.allowMove) {
                    keyOperation = 'move';
                } else if (kijs.gui.DragDrop.source.allowCopy && mapping.allowCopy) {
                    keyOperation = 'copy';
                } else if (kijs.gui.DragDrop.source.allowLink && mapping.allowLink) {
                    keyOperation = 'link';
                }
            }
            
            // Operation übernehmen, falls erlaubt
            switch (keyOperation) {
                case 'move':
                    if (kijs.gui.DragDrop.source.allowMove && mapping.allowMove) {
                        operation = 'move';
                    }
                    break;
                    
                case 'copy':
                    if (kijs.gui.DragDrop.source.allowCopy && mapping.allowCopy) {
                        operation = 'copy';
                    }
                    break;
                    
                case 'link':
                    if (kijs.gui.DragDrop.source.allowLink && mapping.allowLink) {
                        operation = 'link';
                    }
                    break;
                    
            }
        }
        return operation;
    }
    
    // Marker positionieren, Source ein-/ausblenden, CSS aktualisieren
    _updateGuiIndicator(e, targetEl=null, targetPos=null, operation='none', mapping=null, targetOwnerEl=null) {
        if (kijs.isEmpty(operation)) {
            operation = 'none';
        }
        
        // icon bei Mauszeiger (move, copy, link, none) aktualisieren
        e.nodeEvent.dataTransfer.dropEffect = operation;
        
        // Bei move Source-Element ausblenden, sonst einblenden
        if (targetPos && operation === 'move') {
            kijs.gui.DragDrop.source.ownerEl.style.display = 'none';
        } else {
            kijs.gui.DragDrop.source.ownerEl.style.display = kijs.gui.DragDrop.source.display;
        }

        // CSS Klassen hinzufügen/entfernen
        // bei gültigem Target
        if (targetPos && targetOwnerEl && mapping) {
            // kijs-sourceDragOver bei Source entfernen
            kijs.gui.DragDrop.source.ownerEl.dom.clsRemove('kijs-sourceDragOver');
            
            // kijs-targetDragOver beim aktuellen target hinzufügen
            kijs.gui.DragDrop.targetDragOverDom = targetOwnerEl.dom;
            
        // kein gültiges Target
        } else {
            // kijs-sourceDragOver wieder bei Source hinzufügen
            kijs.gui.DragDrop.source.ownerEl.dom.clsAdd('kijs-sourceDragOver');
            
            // kijs-targetDragOver beim letzten target wieder entfernen
            kijs.gui.DragDrop.targetDragOverDom = null;
        }

        // Marker disabled?
        let disableMarker = mapping && targetPos && mapping.disableMarker;

        // Grösse des Markers an Source-Element anpassen
        let markerWidth = null;
        let markerHeight = null;
        if (mapping && targetPos && !mapping.disableMarkerAutoSize) {
            markerWidth = kijs.gui.DragDrop.source.width;
            markerHeight = kijs.gui.DragDrop.source.height;
        }
        // Fixe Höhe oder Breite haben Priorität
        if (mapping && !kijs.isEmpty(mapping.markerWidth)) {
            markerWidth = mapping.markerWidth;
        }
        if (mapping && !kijs.isEmpty(mapping.markerHeight)) {
            markerHeight = mapping.markerHeight;
        }

        // Zusätzliche CSS Klasse(n) zuweisen
        let markerCls = null;
        if (mapping && !kijs.isEmpty(mapping.markerCls)) {
            markerCls = mapping.markerCls;
        }

        // evtl. HTML in den Marker einfügen
        let markerHtml = '';
        if (mapping && !kijs.isEmpty(mapping.markerHtml)) {
            markerHtml = mapping.markerHtml;
        }
        
        // Marker positionieren
        if (targetEl && !disableMarker) {
            let domName = targetPos === 'child' ? this._ownerDomProperty : 'dom';
            kijs.gui.DragDrop.dropMarkerUpdate(targetEl[domName], targetPos, 
                    this._ddMarkerTagName, markerWidth, markerHeight, markerCls, markerHtml);
        // oder ausblenden
        } else {
            kijs.gui.DragDrop.dropMarkerUpdate();
        }
        
        this._targetEl = targetEl;
        this._targetPos = targetPos;
        this._operation = operation;
    }
    
    
    // PRIVATE
    // LISTENERS
    #onDragEnter(e) {
        e.nodeEvent.preventDefault();
        // Workaround, weil das dragLeave auch kommt, wenn die Maus von einem Kind-Element weggezogen wird.
        this._ddEnterTarget = e.nodeEvent.target;
    }
    
    #onDragLeave(e) {
        // Workaround, weil das dragLeave auch kommt, wenn die Maus von einem Kind-Element weggezogen wird.
        if (this._ddEnterTarget === e.nodeEvent.target) {
            if (kijs.gui.DragDrop.source) {
                let mapping = this._mapping[kijs.gui.DragDrop.source.name];
                if (mapping) {
                    this._updateGuiIndicator(e);
                } else {
                    return;
                }
            }
        }
    }
    
    #onDragOver(e) {
        // Eventuelle Browser eigene Funktionen ausschalten
        e.nodeEvent.preventDefault();
        
        // Validieren
        if (!kijs.gui.DragDrop.source || !kijs.gui.DragDrop.source.ownerEl) {
            return false;
        }
        
        if (this._posBeforeFactor > this._posAfterFactor) {
            throw new kijs.Error(`'posBeforeFactor' must be smaller than 'posAfterFactor'`);
        }
        
        // Mapping ermitteln
        let mapping = this._mapping[kijs.gui.DragDrop.source.name];
        if (!mapping) {
            return;
        }
        
        let operation = this._getOperation(e, mapping);
        let targetEl = null;
        let targetPos = null;

        // Auf Targets, die disabled sind, kann nichts abgelegt werden.
        if (this.ownerEl.disabled) {
            return false;
        }
        
        // Ausrichtung der Elemente ermitteln
        const ndeParentStyle = window.getComputedStyle(this.ownerDom.node);
        const ndeParentTagName = this.ownerDom.node.tagName.toLowerCase();
        const flexDirection = ndeParentStyle.flexDirection;
        const isFlex = ndeParentStyle.display === 'flex';
        const isHorizontal = (isFlex && !!flexDirection.startsWith('row')) || ndeParentTagName === 'tr';
        const isReverse = isFlex && !!flexDirection.endsWith('-reverse');
        
        // nähestes Element mit Positionen ermitteln {el:..., diffX:..., diffY:..., w:..., h:... }
        // x und y enthallten den Abstand des Mauszeigers zum linken/oberen Rand des Elements
        let ddCPos = this._getDragOverChild(
                this._ownerEl.elements, 
                e.nodeEvent.clientX, 
                e.nodeEvent.clientY);
        
        // Falls kein Element in der Nähe gefunden wurde
        if (kijs.isEmpty(ddCPos)) {
            // gibt es bereits Elemente im Container
            if (!kijs.isEmpty(this._ownerEl.elements)) {
                if (isReverse) {
                    // am Anfang einfügen
                    targetEl = this._ownerEl.elements[0];
                    targetPos = 'after';
                } else {
                    
                    // am Ende einfügen
                    targetEl = this._ownerEl.elements[this._ownerEl.elements.length-1];
                    targetPos = 'after';
                }
            } else {
                targetEl = this._ownerEl;
                targetPos = 'child';
            }
            
        // Es wurde ein Element in der Nähe gefunden
        } else {
            targetEl = ddCPos.el;

            // bei horizontaler Ausrichtung (flex-direction = 'row' oder 'row-reverse')
            if (isHorizontal) {
                if (ddCPos.diffX < ddCPos.w * this._posBeforeFactor) {
                    targetPos = 'before';
                } else if (ddCPos.diffX > ddCPos.w * this._posAfterFactor) {
                    targetPos = 'after';
                }
                
           // bei vertikaler Ausrichtung (flex-direction = 'column' oder 'column-reverse')
           } else {
                if (ddCPos.diffY < ddCPos.h * this._posBeforeFactor) {
                    targetPos = 'before';
                } else if (ddCPos.diffY > ddCPos.h * this._posAfterFactor) {
                    targetPos = 'after';
                }

            }
        }
        
        // Bei flex-direction = '...-reverse' müssen 'before' und 'after' getauscht werden
        if (targetPos && isReverse) {
            if (targetPos === 'before') {
                targetPos = 'after';
            } else if (targetPos === 'after') {
                targetPos = 'before';
            }
        }
        
        // Target = Source (nur bei Move) ?
        let isTargetEqualSource = false;
        if (targetPos && operation === 'move') {
            if (targetEl === kijs.gui.DragDrop.source.ownerEl) {
                isTargetEqualSource = true;
            } else if (targetPos === 'before' && targetEl.previous === kijs.gui.DragDrop.source.ownerEl) {
                isTargetEqualSource = true;
            } else if (targetPos === 'after' && targetEl.next === kijs.gui.DragDrop.source.ownerEl) {
                isTargetEqualSource = true;
            }
        }
        
        // Wenn Target = Source: Nichts tun
        if (isTargetEqualSource) {
            targetEl = null;
            targetPos = null;
        }
        
        // wenn gültiges Target oder Target = Source: keine weiteren bubbeling-Listeners mehr ausführen
        if (targetPos || isTargetEqualSource) {
            e.nodeEvent.stopPropagation();
        }
        
        // GUI aktualisieren (CSS, DropMarker)
        this._updateGuiIndicator(e, targetEl, targetPos, operation, mapping, this._ownerEl);
    }
    
    #onDrop(e) {
        // Validieren
        if (!kijs.gui.DragDrop.source) {
            return false;
        }
        
        // Mapping ermitteln
        let mapping = this._mapping[kijs.gui.DragDrop.source.name];
        if (!mapping) {
            return false;
        }
        
        if (kijs.isEmpty(this._targetEl) || kijs.isEmpty(this._targetPos)) {
            return;
        }
        
        // drop-Event bei source auslösen
        if (kijs.gui.DragDrop.source.raiseEvent('drop', { 
            source: kijs.gui.DragDrop.source, 
            target: this, 
            operation: this._operation,
            mapping: mapping
        }) !== false) {
            // Wenn kein Abbruch: drop-Event bei target auslösen
            this.raiseEvent('drop', { 
                source: kijs.gui.DragDrop.source, 
                target: this, 
                operation: this._operation,
                mapping: mapping
            });
        }
        kijs.gui.DragDrop.source.dragEnd();
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Listeners entfernen
        if (this.ownerDom) {
            this.ownerDom.off(null, null, this);
        }

        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        this._defaultConfig = null;
        this._ownerEl = null;
        this._mapping = null;
        
        this._targetEl = null;
        this._ddEnterTarget = null;

        // Basisklasse entladen
        super.destruct();
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Dom
// --------------------------------------------------------------
/**
 * Hilfsobjekt zum Handeln von DOM-Nodes
 *
 * CONFIG-Parameter
 * ----------------
 * cls          Array|String [optional] CSS-Klassennamen
 *                                      Beispiel: cls:['cls-a','cls-b'] oder cls:'cls-a cls-b'
 *
 * disabled     Boolean
 *
 * disableEnterBubbeling Boolean [optional] Stoppt das Bubbeling der KeyDown-Events von Enter
 *
 * disableEscBubbeling Boolean [optional] Stoppt das Bubbeling der KeyDown-Events von Escape
 *
 * eventMap     Object [optional]
 *
 * html         String [optional]       HTML-Code, der in das Element eingefügt wird
 *                                      Beispiel: html:'<p>Hallo Welt</p>'
 *
 * htmlDisplayType String [optional]    Darstellung der Eigenschaft 'html'. Default: 'html'
 *                                      html: als html-Inhalt (innerHtml)
 *                                      code: Tags werden als als Text angezeigt
 *                                      text: Tags werden entfernt
 *
 * nodeAttribute Object [optional]      Eigenschaften, die in den Node übernommen werden sollen. 
 *                                      Bsp: { id: 123, for: 'meinFeld' }
 *
 * nodeTagName  String [optional]       Tag-Name des DOM-node. Default='div'
 *                                      Beispiel: nodeTagName='section'
 *
 * on           Object [optional]       Objekt mit Listener-Funktionen und optionalem context.
 *                                      Wenn kein context angegeben wird, so wird das aktuelle Objekt genommen.
 *                                      Beispiel: on: {
 *                                          click: function(e) {
 *                                              ...
 *                                          },
 *                                          dblclick: function(e) {
 *                                              ...
 *                                          },
 *                                          context: xy
 *                                      }
 *
 * style        Object [optional]       Objekt mit CSS-Style Anweisungen als Javascript
 *                                      Beispiel: style:{background-color:'#ff8800'}
 *
 *
 * FUNKTIONEN
 * ----------
 * alignToTarget                        Richtet ein Element nach einem Ziel-Element aus.
 * applyConfig                          Wendet ein Konfigurations-Objekt an
 *  Args:
 *   config     Object
 *
 * destruct                             Destruktor ->Entlädt das Objekt samt allen untergeordneten Objekten
 *
 * clsAdd                                  Fügt eine oder mehrere CSS-Klassen hinzu
 *  Args: cls   String|Array
 *
 * clsHas                                  Überprüft, ob das Element eine CSS-Klasse hat
 *  Args:
 *   cls        String
 *  Return: Boolean
 *
 * clsRemove                               Entfernt eine oder mehrere CSS-Klassen
 *  Args:
 *   cls        String|Array
 *
 * clsRemoveAll                            Entfernt alle CSS-Klassen
 *
 * clsToggle                               Schaltet die übergebenen CSS-Klassen ein oder aus
 *  Args:
 *   cls        String|Array
 *
 * keyEventAdd                              Erstellt einen Tastendruck-Listener
 *  Args:
 *   keys       Number|Array                Bezeichnung der Tasten. Bsp: ['Enter', 'A', 'Tab', 'Space']
 *   fn         Function|String             Funktion oder Name des kijs-Events das ausgelöst werden soll
 *   context     [kijs.gui.Element|kijs.gui.Dom]  Kontext
 *   modifier    [Object]                   Muss eine Modifier-Taste gedrückt sein? null=egal
 *                                          modifier={shift:null, ctrl:false, alt:false}
 *   stopPropagation [Boolean]              Bubbeling ausschalten?
 *   preventDefault   [Boolean]             Listeners vom Browser deaktivieren?
 *
 * keyEventStopBubbeling                    Stoppt das Bubbeling der KeyDown-Events
 *  Args:
 *   keys           Array                   Array mit Keys. Bsp: ['Enter', 'Escape']
 *   modifier       [modifier]              Muss eine Modifier-Taste gedrückt sein?
 *                                          modifier = {shift:false, ctrl:false, alt:false}]
 *
 * nodeAttributeGet                         Gibt den Wert einer Eigenschaft des DOM-Nodes zurück
 *  Args:
 *   name           String
 *  Return: Boolean
 *
 * nodeAttributeSet                         Fügt eine oder mehrere Eigenschaften zum DOM-Node hinzu.
 *                                          Bsp. mehrere: name: { tabIndex:-1, type:'button' }
 *  Args:
 *   name           String|Object
 *   value          String|null
 *
 * nodeAttributeHas                         Überprüft, ob der DOM-Node eine Eigenschaft bestimmte hat
 *  Args:
 *   name           String
 *
 * nodeAttributeRemove                      Entfernt eine Eigenschaft vom DOM-Node
 *  Args:
 *   name           String
 *
 * render                               rendert den DOM-Node
 *
 * renderTo                             rendert den DOM-Node und fügt ihn einem Parent-DOM-Node hinzu
 *  Args:
 *   targetNode    HTMLElement
 *   insertBefore  HTMLElement [optional]
 *
 *
 * EIGENSCHAFTEN
 * -------------
 * disabled
 * disableEnterBubbeling
 * disableEscBubbeling
 * height
 * html
 * htmlDisplayType
 * isEmpty          Boolean (readonly)
 * isRendered       Boolean (readonly)
 * left
 * node             HTML-Element            Verweis auf den DOM-Node
 * nodeTagName
 * style
 * top
 * width
 */
kijs.gui.Dom = class kijs_gui_Dom extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._cls = [];
        this._disabledInitial = false;
        this._disableEnterBubbeling = false;
        this._disableEscBubbeling = false;
        this._html = undefined;
        this._htmlDisplayType = 'html'; // Darstellung der Eigenschaft 'html'. Default: 'html'
                                        // html: als html-Inhalt (innerHtml)
                                        // code: Tags werden als Text angezeigt
                                        // text: Tags werden entfernt

        this._node = null;

        this._nodeEventListeners = {};  // Delegates der DOM-Node Events, die mit kijs.Dom.addEventListener gesetzt wurden
                                        // {
                                        //     click: [
                                        //         {node: ..., useCapture: true/false, delegate: ...},
                                        //         {node: ..., useCapture: true/false, delegate: ...}
                                        //     ],
                                        //
                                        //     mousemove: [
                                        //         {node: ..., useCapture: true/false, delegate: ...},
                                        //         {node: ..., useCapture: true/false, delegate: ...}
                                        //     ]
                                        // }

        this._defaultConfig = {};
        this._doubleClickSpeed = 600;

        this._nodeAttribute = {};

        this._left = undefined;
        this._top = undefined;
        this._width = undefined;
        this._height = undefined;

        this._nodeTagName = 'div';

        this._style = {};

        this._tooltip = null;
        
        this._contextMenuDeferId = null;
        this._scrollEndDeferId = null;
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            cls: { fn: 'function', target: this.clsAdd },
            disableEnterBubbeling: { target: 'disableEnterBubbeling' },
            disableEscBubbeling: { target: 'disableEscBubbeling' },
            eventMap: { fn: 'assign' },
            html: true,
            htmlDisplayType: true,
            left: true,
            top: true,
            width: true,
            height: true,
            nodeAttribute: { fn: 'assign' },
            nodeTagName: { target: 'nodeTagName' },
            on: { fn: 'assignListeners' },
            style : { fn: 'assign' },
            tooltip: { target: 'tooltip' },
            
            disabled: { prio: 2000, target: 'disabled' }
        };

        // Mapping das aussagt, welche DOM-Node-Events bei welchem kijs-Event abgefragt werden sollen
        this._eventMap = {
            blur: { nodeEventName: 'blur', useCapture: false },
            change: { nodeEventName: 'change', useCapture: false },
            click: { nodeEventName: 'click', useCapture: false },
            dblClick: { nodeEventName: 'dblclick', useCapture: false },
            contextMenu: { nodeEventName: 'contextmenu', useCapture: false }, // Wird ausgelöst bei rechter Maustaste, einem LongTouch oder mit der Kontext-Menü-Taste
            drag: { nodeEventName: 'drag', useCapture: false },
            dragEnd: { nodeEventName: 'dragend', useCapture: false },
            dragEnter: { nodeEventName: 'dragenter', useCapture: false },
            dragExit: { nodeEventName: 'dragexit', useCapture: false },
            dragLeave: { nodeEventName: 'dragleave', useCapture: false },
            dragOver: { nodeEventName: 'dragover', useCapture: false },
            dragStart: { nodeEventName: 'dragstart', useCapture: false },
            drop: { nodeEventName: 'drop', useCapture: false },
            focus: { nodeEventName: 'focus', useCapture: false },
            mouseDown: { nodeEventName: 'mousedown', useCapture: false },
            mouseEnter: { nodeEventName: 'mouseenter', useCapture: false },
            mouseLeave: { nodeEventName: 'mouseleave', useCapture: false },
            mouseMove: { nodeEventName: 'mousemove', useCapture: false },
            mouseUp: { nodeEventName: 'mouseup', useCapture: false },
            scroll: { nodeEventName: 'scroll', useCapture: false },
            scrollEnd: { nodeEventName: 'scrollend', useCapture: false },
            singleClick: { nodeEventName: 'click', useCapture: false, interrupt: this._doubleClickSpeed },
            wheel: { nodeEventName: 'wheel', useCapture: false },
            
            // key events
            input: { nodeEventName: 'input', useCapture: false },
            keyDown: { nodeEventName: 'keydown', useCapture: false },
            keyUp: { nodeEventName: 'keyup', useCapture: false },
            enterPress: {
                nodeEventName: 'keydown',       // Node-Event Name
                keys: ['Enter'],                // Bei welchen Tasten soll das Event ausgelöst werden?
                shiftKey: null,                 // Muss dazu shift gedrückt werden? (null=egal)
                ctrlKey: null,                  // Muss dazu ctgrl gedrückt werden? (null=egal)
                altKey: null,                   // Muss dazu alt gedrückt werden? (null=egal)
                usecapture: false               // Soll das Event in der Capturing- statt der Bubbeling-Phase ausgelöst werden?
            },
            enterEscPress: {
                nodeEventName: 'keydown',       // Node-Event Name
                keys: ['Enter', 'Escape'],      // Bei welchen Tasten soll das Event ausgelöst werden?
                shiftKey: null,                 // Muss dazu shift gedrückt werden? (null=egal)
                ctrlKey: null,                  // Muss dazu ctgrl gedrückt werden? (null=egal)
                altKey: null,                   // Muss dazu alt gedrückt werden? (null=egal)
                usecapture: false               // Soll das Event in der Capturing- statt der Bubbeling-Phase ausgelöst werden?
            },
            escPress: {
                nodeEventName: 'keydown',       // Node-Event Name
                keys: ['Escape'],               // Bei welchen Tasten soll das Event ausgelöst werden?
                shiftKey: null,                 // Muss dazu shift gedrückt werden? (null=egal)
                ctrlKey: null,                  // Muss dazu ctgrl gedrückt werden? (null=egal)
                altKey: null,                   // Muss dazu alt gedrückt werden? (null=egal)
                usecapture: false               // Soll das Event in der Capturing- statt der Bubbeling-Phase ausgelöst werden?
            },
            spacePress: {
                nodeEventName: 'keydown',       // Node-Event Name
                keys: ['Space'],                // Bei welchen Tasten soll das Event ausgelöst werden?
                shiftKey: null,                 // Muss dazu shift gedrückt werden? (null=egal)
                ctrlKey: null,                  // Muss dazu ctgrl gedrückt werden? (null=egal)
                altKey: null,                   // Muss dazu alt gedrückt werden? (null=egal)
                usecapture: false               // Soll das Event in der Capturing- statt der Bubbeling-Phase ausgelöst werden?
            },
            
            // touch events
            touchStart: { nodeEventName: 'touchstart', useCapture: false },
            touchEnd: { nodeEventName: 'touchend', useCapture: false },
            touchMove: { nodeEventName: 'touchmove', useCapture: false },
            touchCancel: { nodeEventName: 'touchcancel', useCapture: false }
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // sollte nicht überschrieben werden. Bitte die Funktion changeDisabled() überschreiben.
    get disabled() { return !!this.clsHas('kijs-disabled'); }
    set disabled(val) {
        this.changeDisabled(val, false);
    }

    /**
     * Stoppt das Bubbeling der KeyDown-Events von Enter
     * @returns {Boolean}
     */
    get disableEnterBubbeling() { return this._disableEnterBubbeling;  }
    set disableEnterBubbeling(val) {
        this._disableEnterBubbeling = val;
        if (val) {
            this.on('enterPress', this.#onKeyPressStopBubbeling, this);
        } else {
            this.off('enterPress', this.#onKeyPressStopBubbeling, this);
        }
    }

    /**
     * Stoppt das Bubbeling der KeyDown-Events von Escape
     * @returns {Boolean}
     */
    get disableEscBubbeling() { return this._disableEscBubbeling;  }
    set disableEscBubbeling(val) {
        this._disableEscBubbeling = val;
        if (val) {
            this.on('escPress', this.#onKeyPressStopBubbeling, this);
        } else {
            this.off('escPress', this.#onKeyPressStopBubbeling, this);
        }
    }

    get hasFocus() {
        return this._node === document.activeElement;
    }

    /**
     * Wurde die Eigenschaft "height" manuell zugewiesen?
     * @returns {Boolean}
     */
    get hasHeight() {
        if (this._node) {
            return !kijs.isEmpty(this._node.style.height);
        } else {
            return !kijs.isEmpty(this._height);
        }
    }
    
    /**
     * Wurde die Eigenschaft "left" manuell zugewiesen?
     * @returns {Boolean}
     */
    get hasLeft() {
        if (this._node) {
            return !kijs.isEmpty(this._node.style.left);
        } else {
            return !kijs.isEmpty(this._left);
        }
    }

    /**
     * Wurde die Eigenschaft "top" manuell zugewiesen?
     * @returns {Boolean}
     */
    get hasTop() {
        if (this._node) {
            return !kijs.isEmpty(this._node.style.top);
        } else {
            return !kijs.isEmpty(this._top);
        }
    }

    /**
     * Wurde die Eigenschaft "width" manuell zugewiesen?
     * @returns {Boolean}
     */
    get hasWidth() {
        if (this._node) {
            return !kijs.isEmpty(this._node.style.width);
        } else {
            return !kijs.isEmpty(this._width);
        }
    }

    get height() {
        if (this._node) {
            return this._node.offsetHeight;
        } else {
            return this._height;
        }
    }
    set height(val) {
        if (kijs.isEmpty(val)) {
            val = null;
        }
        if (val !== null && !kijs.isNumeric(val)) {
            throw new kijs.Error('set height(x). x must be numeric.');
        }

        this._height = val;

        if (this._node) {
            if (!kijs.isEmpty(val)) {
                val += 'px';
            }
            this._node.style.height = val;
        }
    }

    get html() { return this._html; }
    set html(val) {
        this._html = val;
        if (this._node) {
            kijs.Dom.setInnerHtml(this._node, this._html, this._htmlDisplayType);
        }
    }

    get htmlDisplayType() { return this._htmlDisplayType; }
    set htmlDisplayType(val) { this._htmlDisplayType = val; }
    
    get isEmpty() { return kijs.isEmpty(this.html); }

    get isRendered() { return !!this._node; }

    get left() {
        if (this._node) {
            return this._node.offsetLeft;
        } else {
            return this._left;
        }
    }
    set left(val) {
        if (kijs.isEmpty(val)) {
            val = null;
        }
        if (val !== null && !kijs.isNumeric(val)) {
            throw new kijs.Error('set left(x). x must be numeric.');
        }

        this._left = val;

        if (this._node) {
            if (!kijs.isEmpty(val)) {
                val += 'px';
            }
            this._node.style.left = val;
        }
    }

    get node() { return this._node; }
    set node(val) { this._node = val; }

    get nodeTagName() { return this._nodeTagName; }
    set nodeTagName(val) {
        this._nodeTagName = val;
        if (this._node && this._node.tagName.toLowerCase() !== val) {
            throw new kijs.Error(`Property "nodeTagName" can not be set. The node has allready been rendered.`);
        }
    }

    get style() {
        if (this._node) {
            return this._node.style;
        } else {
            return this._style;
        }
    }
    set style(val) {
        if (!kijs.isEmpty(this._style)) {
            Object.assign(this._style, val);
        } else {
            this._style = val;
        }
        
        // Falls bereits gerendert wurde: styles anwenden
        if (this._node) {
            Object.assign(this._node.style, this._style);
        }
    }

    get tooltip() { return this._tooltip; }
    set tooltip(val) {
        if (kijs.isEmpty(val)) {
            if (this._tooltip) {
                this._tooltip.destruct();
            }
            this._tooltip = null;

        } else if (val instanceof kijs.gui.Tooltip) {
            this._tooltip = val;

        } else if (kijs.isObject(val)) {
            if (this._tooltip) {
                this._tooltip.applyConfig(val);
            } else {
                this._tooltip = new kijs.gui.Tooltip(val);
            }

        } else if (kijs.isArray(val)) {
            if (val.length > 1) {
                let tmp = '<ul>';
                kijs.Array.each(val, function(v) {
                    tmp += '<li>' + v + '</li>';
                }, this);
                tmp += '</ul>';
                val = tmp;
            } else if (val.length === 1) {
                val = val[0];
            } else {
                val = '';
            }
            if (this._tooltip) {
                this._tooltip.html = val;
            } else {
                this._tooltip = new kijs.gui.Tooltip({ html: val });
            }

        } else if (kijs.isString(val)) {
            if (this._tooltip) {
                this._tooltip.html = val;
            } else {
                this._tooltip = new kijs.gui.Tooltip({ html: val });
            }

        } else {
            throw new kijs.Error(`Unknown tooltip format`);

        }

        if (this._tooltip) {
            this._tooltip.target = this;
        }
    }

    get top() {
        if (this._node) {
            return this._node.offsetTop;
        } else {
            return this._top;
        }
    }
    set top(val) {
        if (kijs.isEmpty(val)) {
            val = null;
        }
        if (val !== null && !kijs.isNumeric(val)) {
            throw new kijs.Error('set top(x). x must be numeric.');
        }

        this._top = val;

        if (this._node) {
            if (!kijs.isEmpty(val)) {
                val += 'px';
            }
            this._node.style.top = val;
        }
    }

    get width() {
        if (this._node) {
            return this._node.offsetWidth;
        } else {
            return this._width;
        }
    }
    set width(val) {
        if (kijs.isEmpty(val)) {
            val = null;
        }
        if (val !== null && !kijs.isNumeric(val)) {
            throw new kijs.Error('set width(x). x must be numeric.');
        }

        this._width = val;

        if (this._node) {
            if (!kijs.isEmpty(val)) {
                val += 'px';
            }
            this._node.style.width = val;
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Richtet ein Element nach einem Ziel aus.
     * Dazu wird für beide Elemente ein Ankerpunkt angegeben. Das Element wird dann so positioniert,
     * dass sein Ankerpunkt die gleichen Koordinaten wie der Ankerpunkt des Ziel-Elements hat.
     * Falls das Element an der neuen Position nicht platz haben sollte, kann die Position automatisch
     * gewechselt werden (allowSwapX & allowSwapY)
     * @param {Object} target Objekt mit x, y, w, h
     * @param {String} [targetPos='bl'] Ankerpunkt beim Zielelement
     *                                   tl --- t --- tr
     *                                   |             |
     *                                   l      c      r
     *                                   |             |
     *                                   bl --- b --- br
     *
     * @param {String} [pos='tl'] Ankerpunkt beim Element das Ausgerichtet werden soll
     * @param {Boolean} [allowSwapX=true]   Swappen möglich auf X-Achse?
     * @param {Boolean} [allowSwapY=true]   Swappen möglich auf Y-Achse?
     * @param {Number} [offsetX=0]          Verschiebung aus dem Ankerpunkt auf der X-Achse
     * @param {Number} [offsetY=0]          Verschiebung aus dem Ankerpunkt auf der Y-Achse
     * @param {Boolean} [swapOffset=true]   Der Offset wird Mitgeswappt (* -1 gerechnet), wenn das Element kein Platz hat
     * @returns {Object}    Gibt die endgültige Positionierung zurück: { pos:..., targetPos:... }
     */
    alignToRect(target, targetPos, pos, allowSwapX, allowSwapY, offsetX, offsetY, swapOffset=true) {
        targetPos = targetPos || 'bl';
        pos = pos || 'tl';


        if (allowSwapX === undefined) {
            allowSwapX = true;
        }

        if (allowSwapY === undefined) {
            allowSwapY = true;
        }

        offsetX = offsetX || 0;
        offsetY = offsetY || 0;

        // Wenn der offset geswappt werden soll, wird dieser *-1 gerechnet.
        const swapOffsetFactor = swapOffset ? -1 : 1;

        const b = kijs.Dom.getAbsolutePos(document.body);
        const e = kijs.Dom.getAbsolutePos(this._node);

        let rect = kijs.Graphic.alignRectToRect(e, target, targetPos, pos, offsetX, offsetY);

        const overlap = kijs.Graphic.rectsOverlap(rect, b);
        let posSwap, targetPosSwap;
        let rectSwap, overlapSwap;
        let fit = true;

        let setHeight = false;
        let setWidth = false;

        // Wenns inder Höhe nicht passt...
        if (!overlap.fitY) {
            fit = false;

            // evtl. von oben nach unten oder unten nach oben swappen
            if (allowSwapY) {
                // Swap positionen ermitteln
                posSwap = null;
                if (pos.indexOf('t')!==-1 && targetPos.indexOf('b')!==-1) {
                    posSwap = pos.replace('t', 'b');
                    targetPosSwap = targetPos.replace('b', 't');
                } else if (pos.indexOf('b')!==-1 && targetPos.indexOf('t')!==-1) {
                    posSwap = pos.replace('b', 't');
                    targetPosSwap = targetPos.replace('t', 'b');
                }

                // Kann in der Höhe die Position gewechselt werden? (t->b und b->t)
                if (posSwap) {
                    rectSwap = kijs.Graphic.alignRectToRect(e, target, targetPosSwap, posSwap, offsetX, offsetY*swapOffsetFactor);
                    overlapSwap = kijs.Graphic.rectsOverlap(rectSwap, b);

                    if (overlapSwap.fitY) {
                        rect = rectSwap;
                        fit = true;
                    }
                }
            }

            // Wenns immer noch nicht passt: unten oder oben am Body-Rand beginnen und über das Target hinausfahren
            // Dabei sicherstellen, dass das Element nicht grösser als der Body ist. Sonst Scrollbar.
            if (!fit) {
                // Höhe darf nicht grösser als Body höhe sein, sonst begrenzen und Scrollbar
                if (rect.h > b.h) {
                    rect.h = b.h;
                    setHeight = true;
                }

                // Am unteren/oberen Rand ausrichten
                if (pos.indexOf('t')!==-1) {
                    // Unten ausrichten
                    rect.y = b.h - rect.h;
                } else {
                    // oben ausrichten
                    rect.y = 0;
                }
                fit = true;
            }
        }

        // Wenns in der Breite nicht passt...
        if (!overlap.fitX) {
            fit = false;

            // evtl. von rechts nach links oder links nach rechts swappen
            if (allowSwapX) {
                // Swap positionen ermitteln
                posSwap = null;
                if (pos.indexOf('l')!==-1 && targetPos.indexOf('r')!==-1) {
                    posSwap = pos.replace('l', 'r');
                    targetPosSwap = targetPos.replace('r', 'l');
                } else if (pos.indexOf('r')!==-1 && targetPos.indexOf('l')!==-1) {
                    posSwap = pos.replace('r', 'l');
                    targetPosSwap = targetPos.replace('l', 'r');
                }

                // Kann in der Breite die Position gewechselt werden? (l->r und r->l)
                if (posSwap) {
                    rectSwap = kijs.Graphic.alignRectToRect(e, target, targetPosSwap, posSwap, offsetX*swapOffsetFactor, offsetY);
                    overlapSwap = kijs.Graphic.rectsOverlap(rectSwap, b);

                    if (overlapSwap.fitX) {
                        // Y Achse übernehmen, da vorgängig berechnet
                        rectSwap.y = rect.y;
                        rect = rectSwap;
                        fit = true;
                    }
                }
            }

            // Wenns immer noch nicht passt: links oder rechts am Body-Rand beginnen und über das Target hinausfahren
            // Dabei sicherstellen, dass das Element nicht grösser als der Body ist. Sonst Scrollbar.
            if (!fit) {
                // Breite darf nicht grösser als Body breite sein, sonst begrenzen und Scrollbar
                if (rect.w > b.w) {
                    rect.w = b.w;
                    setWidth = true;
                }

                // Am linken/rechten Rand ausrichten
                if (pos.indexOf('l')!==-1) {
                    rect.x = b.w - rect.w;
                } else if (pos.indexOf('r')!==-1) {
                    rect.x = 0;
                }
                fit = true;
            }
        }

        this.left = rect.x;
        this.top = rect.y;

        // Abmessungen nur setzen, wenn unbedingt nötig.
        if (setWidth) {
            this.width = rect.w;
        }
        if (setHeight) {
            this.height = rect.h;
        }

        return {
            pos: posSwap ? posSwap : pos,
            targetPos: targetPosSwap ? targetPosSwap : targetPos
        };
    }

    /**
     * Richtet ein Element nach einem Ziel-Element aus.
     * Dazu wird für beide Elemente ein Ankerpunkt angegeben. Das Element wird dann so positioniert,
     * dass sein Ankerpunkt die gleichen Koordinaten wie der Ankerpunkt des Ziel-Elements hat.
     * Falls das Element an der neuen Position nicht platz haben sollte, kann die Position automatisch
     * gewechselt werden (allowSwapX & allowSwapY)
     * @param {kijs.gui.Element|HTMLElement} targetNode
     * @param {String} [targetPos='bl'] Ankerpunkt beim Zielelement
     *                                   tl --- t --- tr
     *                                   |             |
     *                                   l      c      r
     *                                   |             |
     *                                   bl --- b --- br
     *
     * @param {String} [pos='tl'] Ankerpunkt beim Element das Ausgerichtet werden soll
     * @param {Boolean} [allowSwapX=true]   Swappen möglich auf X-Achse?
     * @param {Boolean} [allowSwapY=true]   Swappen möglich auf Y-Achse?
     * @param {Number} [offsetX=0]          Verschiebung aus dem Ankerpunkt auf der X-Achse
     * @param {Number} [offsetY=0]          Verschiebung aus dem Ankerpunkt auf der Y-Achse
     * @param {Boolean} [swapOffset=true]   Der Offset wird Mitgeswappt (* -1 gerechnet), wenn das Element kein Platz hat
     * @returns {Object}    Gibt die endgültige Positionierung zurück: { pos:..., targetPos:... }
     */
    alignToTarget(targetNode, targetPos, pos, allowSwapX, allowSwapY, offsetX, offsetY, swapOffset=true)  {
        if (targetNode instanceof kijs.gui.Element) {
            targetNode = targetNode.dom;
        }

        // Position vom Element
        const t = kijs.Dom.getAbsolutePos(targetNode);

        return this.alignToRect(t, targetPos, pos, allowSwapX, allowSwapY, offsetX, offsetY, swapOffset);
    }
    
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @returns {undefined}
     */
    applyConfig(config={}) {
        kijs.Object.assignConfig(this, config, this._configMap);
    }

    /**
     * Ändert die Eigenschaft disabled.
     * Sollte nicht direkt aufgerufen werden.
     * Bitte den Setter disabled verwenden.
     * @param {Boolean} val
     * @param {Boolean} [callFromParent=false]  True, wenn der Aufruf vom changeDisabled 
     *                                          des Elternelements kommt.
     * @returns {undefined}
     */
    changeDisabled(val, callFromParent) {
        // Falls der Aufruf vom Elterncontainer kommt, wird beim zurücksetzen von 
        // disabled wieder der vorherige Wert zugewiesen.
        if (callFromParent) {
            if (!val) {
                val = !!this._disabledInitial;
            }
            
        } else {
            this._disabledInitial = !!val;
            
        }
        
        this.nodeAttributeSet('disabled', !!val);
        if (this._tooltip) {
            this._tooltip.disabled = !!val;
        }
        
        if (val) {
            this.clsAdd('kijs-disabled');
        } else {
            this.clsRemove('kijs-disabled');
        }
    }
    
    /**
     * Ändert die Eigenschaft disabled.
     * Sollte nicht direkt aufgerufen werden.
     * Bitte den Setter disabled verwenden.
     * @param {Boolean} val
     * @param {Boolean} [callFromParent=false]  True, wenn der Aufruf vom changeDisabled 
     *                                          des Elternelements kommt.
     * @returns {undefined}
     */
    changeReadOnly(val, callFromParent) {
        // Falls der Aufruf vom Elterncontainer kommt, wird beim zurücksetzen von 
        // disabled wieder der vorherige Wert zugewiesen.
        if (callFromParent) {
            if (!val) {
                val = !!this._disabledInitial;
            }
            
        } else {
            this._disabledInitial = !!val;
            
        }
        
        this.nodeAttributeSet('disabled', !!val);
        if (this._tooltip) {
            this._tooltip.disabled = !!val;
        }
        
        if (val) {
            this.clsAdd('kijs-disabled');
        } else {
            this.clsRemove('kijs-disabled');
        }
    }
    
    /**
     * Fügt eine oder mehrere CSS-Klassen hinzu
     * @param {String|Array} cls
     * @returns {undefined}
     */
    clsAdd(cls) {
        if (!cls) {
            return;
        }
        if (!kijs.isArray(cls)) {
            cls = cls.split(' ');
        }
        this._cls = kijs.Array.concatUnique(this._cls, cls);

        this._clsApply();
    }

    /**
     * Überprüft, ob das Element eine CSS-Klasse hat
     * @param {String} cls
     * @returns {Boolean}
     */
    clsHas(cls) {
        return kijs.Array.contains(this._cls, cls);
    }

    /**
     * Entfernt eine oder mehrere CSS-Klassen
     * @param {String|Array} cls
     * @returns {undefined}
     */
    clsRemove(cls) {
        if (!cls) {
            return;
        }

        if (!kijs.isArray(cls)) {
            cls = cls.split(' ');
        }
        kijs.Array.removeMultiple(this._cls, cls);

        this._clsApply();
    }

    /**
     * Entfernt alle CSS-Klassen
     * @returns {undefined}
     */
    clsRemoveAll() {
        this._cls = [];
        this._clsApply();
    }

    /**
     * Schaltet die übergebenen CSS-Klassen ein oder aus
     * @param {String|Array} cls
     * @returns {undefined}
     */
    clsToggle(cls) {
        if (!cls) {
            return;
        }

        const newCls = [];
        if (!kijs.isArray(cls)) {
            cls = cls.split(' ');
        }
        kijs.Array.each(this._cls, function(cl) {
            if (kijs.Array.contains(cls, cl)) {
                kijs.Array.remove(cls, cl);
            } else {
                newCls.push(cl);
            }
        }, this);

        if (cls) {
            this._cls = newCls.concat(cls);
        }

        this._clsApply();
    }

    /**
     * Setzt den Fokus auf den Node
     * @param {Boolean} [alsoSetIfNoTabIndex=false]    Fokus auch setzen, wenn tabIndex === -1
     *                                                 undefined: nicht fokussierbar (bei undefined muss die Eigenschaft mit removeAttribute('tabIndex') entfernt werden. Sonst klappts nicht)
     *                                                 tabIndex -1: nur via focus() Befehl oder click fokussierbar
     *                                                 tabIndex  0: Fokussierbar - Browser bestimmt die Tabreihenfolge
     *                                                 tabIndex >0: Fokussierbar - in der Reihenfolge wie der tabIndex
     * @returns {HTMLElement|null|false}               HTML-Node, das den Fokus erhalten hat oder false, wenn nicht gerendert.
     */
    focus(alsoSetIfNoTabIndex) {
        if (this._node) {
            // Darf der Node den Fokus erhalten?
            if (alsoSetIfNoTabIndex) {
                this._node.focus();
                return this._node;

            // sonst den Fokus auf den ersten möglichen untergeordneten Node setzen
            } else {
                const node = kijs.Dom.getFirstFocusableNode(this._node);
                if (node) {
                    node.focus();
                }
                return node;
            }
        } else {
            return false;
        }
    }

    /**
     * Gibt den Wert eine Eigenschaft des DOM-Nodes zurück
     * @param {String} name
     * @returns {String|null|Boolean|undefined}
     */
    nodeAttributeGet(name) {
        if (kijs.isEmpty(name)) {
            return null;
        }

        if (this._node) {
            return this._node[name];

        } else {
            if (this._nodeAttribute.hasOwnProperty(name)) {
                return this._nodeAttribute[name];
            } else {
                return null;
            }
        }
    }

    /**
     * Überprüft, ob der DOM-Node eine bestimmte Eigenschaft hat
     * @param {String} name
     * @returns {Boolean}
     */
    nodeAttributeHas(name) {
        if (this._node) {
            return kijs.isEmpty(this._nodeAttribute[name]);
        } else {
            return !!this._nodeAttribute.hasOwnProperty(name);
        }
    }
    
    /**
     * Fügt eine Eigenschaft zum DOM-Node hinzu, oder löscht sie.
     * @param {String|Object} name oder Objekt mit mehreren:  { tabIndex:-1, type:'button' }
     * @param {String|null|Boolean|undefined} value
     * @returns {undefined}
     */
    nodeAttributeSet(name, value) {
        if (kijs.isEmpty(name)) {
            return;
        }

        // falls ein Objekt mit mehreren Attributen übergeben wurde
        if (kijs.isObject(name)) {
            kijs.Object.each(name, function(key, value) {
                this.nodeAttributeSet(key, value);
            }, this);
            return;
        }

        if (!kijs.isDefined(value) || value === false) {
            if (this._nodeAttribute.hasOwnProperty(name)) {
                delete this._nodeAttribute[name];
            }
        } else {
            this._nodeAttribute[name] = kijs.toString(value);
        }

        if (this._node) {

            // attribute entfernen falls false oder undefiniert.
            if (!kijs.isDefined(value) || value === false) {
                this._node.removeAttribute(name);

            } else {
                this._node[name] = kijs.toString(value);
            }
        }
    }

    // overwrite
    off(names, callback, context) {
        // Anzahl kijs-Events ermitteln
        const eventsCountBefore = Object.keys(this._events).length;

        // Aufruf der Basisfunktion
        super.off(names, callback, context);

        // Anzahl kijs-Events ermitteln
        const eventsCountAfter = Object.keys(this._events).length;

        // Evtl. die Listeners auf den DOM-Node aktualisieren
        if (this._node && eventsCountAfter - eventsCountBefore) {
            this._nodeEventListenersApply();
        }
    }
    
    // overwrite
    on(names, callback, context) {
        // Anzahl kijs-Events ermitteln
        const eventsCountBefore = Object.keys(this._events).length;

        // Aufruf der Basisfunktion
        super.on(names, callback, context);

        // Anzahl kijs-Events ermitteln
        const eventsCountAfter = Object.keys(this._events).length;

        // Evtl. die Listeners auf den DOM-Node aktualisieren
        if (this._node && eventsCountAfter - eventsCountBefore) {
            this._nodeEventListenersApply();
        }
    }

    // overwrite
    raiseEvent(name, e={}) {
        Object.assign(e, {
            dom: this,
            eventName: name
        });
        return super.raiseEvent(name, e);
    }

    /**
     * rendert den DOM-Node
     * @returns {undefined}
     */
    render() {
        // Node erstellen und Events abfragen
        if (!this._node) { // !TODO wenn bereits vorhanden, passiert nichts?
            this._node = document.createElement(this._nodeTagName);

            // Styles mergen
            if (!kijs.isEmpty(this._style)) {
                Object.assign(this._node.style, this._style);
            }

            // Positionierung
            if (!kijs.isEmpty(this._width)) {
                this.width = this._width;
            }
            if (!kijs.isEmpty(this._height)) {
                this.height = this._height;
            }
            if (!kijs.isEmpty(this._top)) {
                this.top = this._top;
            }
            if (!kijs.isEmpty(this._left)) {
                this.left = this._left;
            }

            // nodeAttribute
            this._nodeAttributeApply();
        }

        // HTML
        if (kijs.isDefined(this._html)) {
            kijs.Dom.setInnerHtml(this._node, this._html, this._htmlDisplayType);
        }

        // CSS-Klassen zuweisen
        this._clsApply();

        // DOM-Node-Event Listeners erstellen
        this._nodeEventListenersApply();
    }

    /**
     * rendert den DOM-Node und fügt ihn einem Parent-DOM-Node hinzu
     * @param {HTMLElement} targetNode           Eltern-Node
     * @param {HTMLElement} [referenceNode=null] Referenzknoten, Falls der Node 
     *                                           statt angehängt eingefügt werden soll
     * @param {String} [insertPosition='before'] 'before': Einfügen vor dem referenceNode 
     *                                           'after': Einfügen nach dem referenceNode
     * @returns {undefined}
     */
    renderTo(targetNode, referenceNode=null, insertPosition='before') {
        this.render();

        // Element vor oder nach einem Element einfügen
        if (referenceNode) {
            // Element vor dem referenceNode-Element einfügen
            if (insertPosition === 'before') {
                targetNode.insertBefore(this._node, referenceNode);

            // Element nach dem referenceNode-Element einfügen
            } else if (insertPosition === 'after') {
                targetNode.insertBefore(this._node, referenceNode.nextSibling);

            } else {
                throw new kijs.Error('invalid insertPosition for renderTo');
            }

        // Element anhängen
        } else {
            targetNode.appendChild(this._node);
        }
    }

    /**
     * Scrollt den Node in den sichtbaren Bereich
     * (rekursiv)
     * @param {Object} options
     *  - verticalPosition (String) default='auto'
     *     - 'start'  Node wird am Anfang (oben) positioniert
     *     - 'end'    Node wird am Ende (unten) positioniert
     *     - 'center' Node wird in der Mitte positioniert
     *     - 'auto'   Es wird nur gescrollt, wenn der Node ausserhalb ist und nur 
     *                sowenig, dass der node im sichtbaren Bereich ist.
     *  - horizontalPosition (String) default='auto'
     *     - 'start'  Node wird am Anfang (links) positioniert
     *     - 'end'    Node wird am Ende (rechts) positioniert
     *     - 'center' Node wird in der Mitte positioniert
     *     - 'auto'   Es wird nur gescrollt, wenn der Node ausserhalb ist und nur 
     *                sowenig, dass der node ganz im sichtbaren Bereich ist.
     *  - verticalOffset (Number) default=0 Versatz auf Y-Achse
     *  - horizontalOffset (Number) default=0 Versatz auf X-Achse
     *  - behavior  (String) default='auto'
     *     - 'smooth' Animiertes Scrollen
     *     - 'instant' Scrollen ohne Animation
     *     - 'auto'    Die CSS Eintellung 'scroll-behavior' wird berücksichtigt.
     *  - scrollParentsTo (Boolean) default=false. Sollen Eltern-Knoten auch gescrollt werden?
     * @returns {undefined}
     */
    scrollIntoView(options) {
        kijs.Dom.scrollIntoView(this._node, options);
    }

    /**
     * Node aus DOM entfernen, falls vorhanden
     * @returns {undefined}
     */
    unrender() {
        if (this._node) {
            // timer abbrechen
            if (this._contextMenuDeferId) {
                clearTimeout(this._contextMenuDeferId);
                this._contextMenuDeferId = null;
            }
            if (this._scrollEndDeferId) {
                clearTimeout(this._scrollEndDeferId);
                this._scrollEndDeferId = null;
            }
            
            // Damit beim erneuten Rendern die Werte wieder vorhanden sind
            kijs.Object.each(this._nodeAttribute, function (key) {
                this._nodeAttribute[key] = this.nodeAttributeGet(key);
            }, this);

            // Node-Event-Listeners entfernen
            if (!kijs.isEmpty(this._nodeEventListeners)) {
                kijs.Dom.removeAllEventListenersFromContext(this);
            }

            // Childs löschen
            kijs.Dom.removeAllChildNodes(this._node);

            // Node selber löschen
            if (this._node !== document.body && this._node.parentNode) {
                this._node.parentNode.removeChild(this._node);
            }
        }
        this._node = null;

        if (this._tooltip) {
            this._tooltip.unrender();
        }
    }


    // PROTECTED
    /**
     * Weist die CSS-Klassen dem DOM-Node zu.
     * @returns {undefined}
     */
    _clsApply() {
        if (this._node && (this._node.className || !kijs.isEmpty(this._cls))) {
            this._node.className = this._cls ? this._cls.join(' ') : '';
        }
    }

    /**
     * Weist die Eigenschaften dem DOM-Node zu.
     * @returns {undefined}
     */
    _nodeAttributeApply() {
        kijs.Object.each(this._nodeAttribute, function(name, value) {
            this._node[name] = value;
            // Kleiner murgs, weil obige Zeile nicht zum Entfernen der Eigenschaft 'tabIndex' funktioniert
            if (kijs.isEmpty(value)) {
                this._node.removeAttribute(name);
            }
        }, this);
    }

    /**
     * Erstellt oder entfernt Listeners auf den DOM-Node aufgrund der _events
     * @returns {undefined}
     */
    _nodeEventListenersApply() {
        // kijs-Events-Namen ermitteln
        const kijsEvents = Object.keys(this._events);

        // Falls es bereits Node-Event-Listeners gibt, diese entfernen
        if (!kijs.isEmpty(this._nodeEventListeners)) {
            kijs.Dom.removeAllEventListenersFromContext(this);
        }

        // DOM-Node Listeners erstellen
        kijs.Array.each(kijsEvents, function(kijsEvent) {
            if (this._eventMap[kijsEvent]) {
                const nodeEventName = this._eventMap[kijsEvent].nodeEventName;
                const useCapture = !!this._eventMap[kijsEvent].useCapture;
                
                // unterstützt der Browser das Event?
                let eventIsSupported = ('on'+nodeEventName in this._node);
                
                // Workarounds für nur teilweise unterstütze Events
                if (eventIsSupported) {
                    switch (nodeEventName) {
                        // Das contextmenu-Event wird unter iOS und Mac bei einem longTouch nicht ausgelöst
                        case 'contextmenu':
                            if ((kijs.Navigator.isIOS || kijs.Navigator.isMac) && kijs.Navigator.isTouch) {
                                eventIsSupported = false;
                                
                                // Das normale contextmenu-event trotzdem noch abfragen
                                if (!kijs.Dom.hasEventListener(nodeEventName, this._node, this, useCapture)) {
                                    kijs.Dom.addEventListener(nodeEventName, this._node, this.#onNodeEvent, this, useCapture);
                                }
                            }
                            break;
                     }
                }
                
                // unterstützt der Browser das Event?
                if (eventIsSupported) {
                    // Wenn der DOM-Node Listener noch nicht vorhanden ist: erstellen
                    if (!kijs.Dom.hasEventListener(nodeEventName, this._node, this, useCapture)) {
                        kijs.Dom.addEventListener(nodeEventName, this._node, this.#onNodeEvent, this, useCapture);
                    }
                    
                // Event wird nicht unterstützt
                } else {
                    // Workaround vorhanden?
                    switch (nodeEventName) {
                        // Unter iOS wird contextmenu bei einem longtouch nicht ausgelöst: selber machen
                        case 'contextmenu':
                            // kijs-Listeners auf touchStart und touchEnd erstellen
                            if (!this.hasListener('touchStart', this.#onContextMenu_TouchStart, this)) {
                                this.on('touchStart', this.#onContextMenu_TouchStart, this);
                            }
                            if (!this.hasListener('touchEnd', this.#onContextMenu_TouchEnd, this)) {
                                this.on('touchEnd', this.#onContextMenu_TouchEnd, this);
                            }
                            break;
                            
                        case 'scrollend':
                            // kijs-Listener auf scroll erstellen
                            if (!this.hasListener('scroll', this.#onScrollEnd_Scroll, this)) {
                                this.on('scroll', this.#onScrollEnd_Scroll, this);
                            }
                            break;
                            
                        default:
                            // keine Fehlermeldung, weil nicht alle Browser alle Events unterstützen.
                    }
                    
                }
                
            } else {
                throw new kijs.Error(`kijsEvent "${kijsEvent}" is not mapped`);
            }
        }, this);
    }


    // PRIVATE
    // LISTENERS
    #onKeyPressStopBubbeling(e) {
        e.nodeEvent.stopPropagation();
    }

    /**
     * Listener für alle DOM-Node-Events, der die kijs-Events auslöst.
     * @param {Object} e
     * @returns {Boolean}
     */
    #onNodeEvent(e) {
        let ret = true;

        // kijs-Events ermitteln, die aufgrund des DOM-Node-Events ausgelöst werden sollen
        kijs.Object.each(this._eventMap, function(eventName, val) {
            // Eventname und useCapture muss übereinstimmen
            if (val.nodeEventName !== e.nodeEventName || !!val.useCapture !== !!e.useCapture) {
                return;
            }

            // Tastencode muss übereinstimmen, wenn vorhanden
            if (!kijs.isEmpty(val.keys)) {
                const keys = kijs.isArray(val.keys) ? val.keys : [val.keys];

                // nodeEvent.key enthält bsp.  'Control'     oder ' '     oder '1'          (=Zeichen, das geschrieben wird)
                // nodeEvent.code enthält bsp. 'ControlLeft' oder 'Space' oder 'Numpad1'    (=Taste, die gedrückt wird)
                if (!kijs.Array.contains(keys, e.nodeEvent.key) && !kijs.Array.contains(keys, e.nodeEvent.code)) {
                    return;
                }
            }

            // Zusatztaste shift muss übereinstimmen, wenn vorhanden
            if (!kijs.isEmpty(val.shiftKey)) {
                if (!!val.shiftKey !== !!e.nodeEvent.shiftKey) {
                    return;
                }
            }

            // Zusatztaste ctrl muss übereinstimmen, wenn vorhanden
            if (!kijs.isEmpty(val.ctrlKey)) {
                if (!!val.ctrlKey !== !!e.nodeEvent.ctrlKey) {
                    return;
                }
            }

            // Zusatztaste alt muss übereinstimmen, wenn vorhanden
            if (!kijs.isEmpty(val.altKey)) {
                if (!!val.altKey !== !!e.nodeEvent.altKey) {
                    return;
                }
            }

            // interrupt einhalten (Event wird für die eingestellte Zeit kein zweites mal ausgeführt)
            if (kijs.isNumber(val.interrupt) && val.interrupt > 0) {
                if (val.interruptUntil && val.interruptUntil > Date.now()) {
                    return;
                }
                val.interruptUntil = Date.now() + val.interrupt;
            }

            // kijs-Event auslösen
            e.dom = this;
            e.eventName = eventName;

            if (this.raiseEvent(eventName, e) === false) {
                ret = false;
            }
        }, this);

        return ret;
    }

    
    // PRIVATE
    // Workaround zum Erzeugen des contextMenu Events (wird von iOS oder Mac bei einem longTouch nicht ausgelöst)
    #onContextMenu_TouchEnd(e) {
        // bestehenden timer abbrechen
        if (this._contextMenuDeferId) {
            clearTimeout(this._contextMenuDeferId);
            this._contextMenuDeferId = null;
        }
    }
    #onContextMenu_TouchStart(e) {
        // bestehenden timer abbrechen
        if (this._contextMenuDeferId) {
            clearTimeout(this._contextMenuDeferId);
            this._contextMenuDeferId = null;
        }
        
        if (this.disabled) {
            return;
        }
        
        // und neuen starten
        this._contextMenuDeferId = kijs.defer(function() {
            this._contextMenuDeferId = null;
            
            // falls dieser nicht mehr abgebrochen wurde, kann nun das 
            // contextMenu Event ausgelöst werden.
            e.dom = this;
            e.eventName = 'contextMenu';
            this.raiseEvent('contextMenu', e);
        }, 500, this);
    }
    
    // Workaround zum Erzeugen des Events scrollEnd, das noch nicht von allen 
    // Browsern unterstützt wird (Safari auf Mac und iOS).
    #onScrollEnd_Scroll(e) {
        // bestehenden timer abbrechen
        clearTimeout(this._scrollEndDeferId);
        this._scrollEndDeferId = null;
        
        // und neuen starten
        this._scrollEndDeferId = kijs.defer(function() {
            this._scrollEndDeferId = null;
            
            // falls dieser nicht mehr abgebrochen wurde, kann nun das 
            // scrollEnd Event ausgelöst werden.
            e.dom = this;
            e.eventName = 'scrollEnd';
            this.raiseEvent('scrollEnd', e);
        }, 100, this);
    }
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct() {
        // Unrender
        this.unrender();

        // Tooltip entladen
        if (this._tooltip) {
            this._tooltip.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._cls = null;
        this._configMap = null;
        this._eventMap = null;
        this._node = null;
        this._nodeAttribute = null;
        this._nodeEventListeners = null;
        this._style = null;
        this._tooltip = null;
        this._contextMenuDeferId = null;
        this._scrollEndDeferId = null;
        
        // Basisklasse entladen
        super.destruct();
    }
    
};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.Tooltip
// --------------------------------------------------------------
kijs.gui.Tooltip = class kijs_gui_Tooltip extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._disabled = false;
        this._dom = new kijs.gui.Dom({
            nodeAttribute: {
                popover: 'manual'
            }
        });
        this._followPointer = true;    // Soll sich der TipText mit dem Mauszeiger verschieben?
        this._offsetX = 13;
        this._offsetY = 10;
        this._target = null;
        this._defaultConfig = {};

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenmschaften
        this._configMap = {
            cls             : { fn: 'function', target: this._dom.clsAdd, context: this._dom },
            disabled        : true,
            followPointer   : true,
            html            : { target: 'html', context: this._dom },
            htmlDisplayType : { target: 'htmlDisplayType', context: this._dom },
            offsetX         : true,
            offsetY         : true,
            on              : { fn: 'assignListeners' },
            style           : { fn: 'assign', target: 'style', context: this._dom },
            target          : { target: 'target' }
        };

        this._dom.clsAdd('kijs-tooltip');

        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get disabled() { return this._disabled; }
    set disabled(val) {
        this._disabled = !!val;

        if (this._disabled) {
            this.hide();
        }
    }

    get dom() { return this._dom; }

    get html() { return this._dom.html; }
    set html(val) { this._dom.html = val; }

    get isEmpty() { return this._dom.isEmpty; }

    get target() { return this._target; }
    set target(val) {
        if (this._target !== val) {
            this._target = val;
            this._bindEventsToTarget();
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @returns {undefined}
     */
    applyConfig(config={}) {
        kijs.Object.assignConfig(this, config, this._configMap);
    }


    hide() {
        this.unrender();
    }

    /**
     * rendert den DOM-Node
     * @param {Boolean} [superCall=false]
     * @returns {undefined}
     */
    render(superCall) {
        // DOM Rendern
        this._dom.render();

        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    show(x, y) {
        let updatePos = false;

        // rendern
        if (!this._dom.node) {
            this.render();
        }

        // an body anhängen
        if (this._dom.node.parentNode !== document.body) {
            document.body.appendChild(this._dom.node);

            // listener auf body
            kijs.Dom.addEventListener('mousemove', document.body, this.#onMouseMoveOnBody, this);

            // position aktualisieren
            updatePos = true;
        }

        // show popover
        this._dom.node.showPopover();

        if (this._followPointer) {
            updatePos = true;
        }

        // X
        if (updatePos && kijs.isDefined(x)) {
            // Offset addieren
            if (this._offsetX) {
                x += this._offsetX;
            }

            // Sicherstellen, dass der Tooltip auf dem Bildschirm platz hat
            if (x+this._dom.node.offsetWidth > window.innerWidth) {
                x = Math.abs(window.innerWidth - this._dom.node.offsetWidth - 5);
            }

            // Position zuweisen
            this._dom.style.left = x + 'px';
        }

        // Y
        if (updatePos && kijs.isDefined(y)) {
            // Offset addieren
            if (this._offsetY) {
                y += this._offsetY;
            }

            // Sicherstellen, dass der Tooltip auf dem Bildschirm platz hat
            if (y+this._dom.node.offsetHeight > window.innerHeight) {
                y = Math.abs(window.innerHeight - this._dom.node.offsetHeight - 5);
            }

            // Position zuweisen
            this._dom.style.top = y + 'px';
        }
    }


    /**
     * Node aus DOM entfernen, falls vorhanden
     * @param {bool} superCall true, if called from child
     * @returns {undefined}
     */
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // hide popover
        if (this._dom.node) {
            this._dom.node.hidePopover();
        }

        // Event entfernen
        kijs.Dom.removeEventListener('mousemove', document.body, this);

        this._dom.unrender();
    }


    // PROTECTED
    _bindEventsToTarget() {
        this._target.on('mouseMove', this.#onMouseMoveTarget, this);
        this._target.on('mouseLeave', this.#onMouseLeave, this);
    }
    
    
    // PRIVATE
    // LISTENERS
    #onMouseLeave(e) {
        this.hide();
    }
    
    #onMouseMoveOnBody(e) {
        if (this._target) {
            let mouseX = e.nodeEvent.clientX, mouseY = e.nodeEvent.clientY;
            let top = kijs.Dom.getAbsolutePos(this._target.node).y,
                    left = kijs.Dom.getAbsolutePos(this._target.node).x,
                    width = this._target.width,
                    height = this._target.height;

            if (width && height) {
                // prüfen, ob der Mauszeiger über dem Element ist.
                if (mouseX < left || mouseX > left+width || mouseY < top || mouseY > top+height) {
                    this.hide();
                }
            } else {
                this.hide();
            }
        } else {
            this.hide();
        }
    }

    #onMouseMoveTarget(e) {
        if (!this.disabled) {
            this.show(e.nodeEvent.clientX, e.nodeEvent.clientY);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Listeners entfernen
        if (this._target) {
            this._target.off(null, null, this);
        }

        // Elemente/DOM-Objekte entladen
        if (this._dom) {
            this._dom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._dom = null;
        this._target = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Element
// --------------------------------------------------------------
/**
 * Ein einfaches DOM-Element ohne Positionierungen.
 *
 * CONFIG-Parameter
 * ----------------
 * afterResizeDelay Number [optional=300]
 *
 * cls          Array|String [optional] CSS-Klassennamen
 *                                      Beispiel: cls:['cls-a','cls-b'] oder cls:'cls-a cls-b'
 *
 * displayWaitMask Booelan [optional]   Soll die Lademaske angezeigt werden?
 *
 * height       Number [optional]       Höhe
 *
 * html         String [optional]       HTML-Code, der in das Element eingefügt wird
 *                                      Beispiel: html:'<p>Hallo Welt</p>'
 *
 * htmlDisplayType String [optional]    Darstellung der Eigenschaft 'html'. Default: 'html'
 *                                      html: als html-Inhalt (innerHtml)
 *                                      code: Tags werden als als Text angezeigt
 *                                      text: Tags werden entfernt
 *
 * left         Number [optional]       X-Koordinate
 *
 * name         String [optional]       Element-Namen Siehe dazu auch kijs.gui.Container.getElementByName()
 *
 * nodeAttribute Object [optional]      Eigenschaften, die in den Node übernommen werden sollen.
 *                                      Bsp: { id: 123, for: 'meinFeld' }
 *
 * nodeTagName   String [optional]      Tag-Name des DOM-node. Default='div'
 *                                      Beispiel: nodeTagName='section'
 *
 * on           Object [optional]       Objekt mit Listener-Funktionen und optionalem context.
 *                                      Wenn kein context angegeben wird, so wird das aktuelle Objekt genommen.
 *                                      Beispiel: on: {
 *                                          click: function(e) {
 *                                              ...
 *                                          },
 *                                          dblclick: function(e) {
 *                                              ...
 *                                          },
 *                                          context: xy
 *                                      }
 *
 * parent       kijs.gui.Element [optional] Verweis auf das übergeordenete Element
 *
 * style        Object [optional]       Objekt mit CSS-Style Anweisungen als Javascript
 *                                      Beispiel: style:{background-color:'#ff8800'}
 *
 * tooltip      String|Object|kijs.gui.Tooltip [optional]  Tooltip als
 *                                                   - String (HTML-Code). Beispiel: html:'<p>Hallo Welt</p>'
 *                                                   - Tooltip-Config Objekt
 *                                                   - kijs.gui.Tooltip-Instanz
 *
 * top          Number [optional]       Y-Koordinate
 *
 * visible      Boolean [optional]      Sichtbarkeit des Elements Default=true
 *                                      Beispiel: visible:false
 *
 * width        Number [optional]      Breite
 *
 *
 *
 * FUNKTIONEN
 * ----------
 * applyConfig                          Wendet ein Konfigurations-Objekt an
 *  Args:
 *   config     Object
 *
 * destruct                             Destruktor ->Entlädt das Objekt samt allen untergeordneten Objekten

 * waitMaskAdd                          Zeigt die Lademaske an oder zählt den Zähler hoch, falls sie schon sichtbar ist
 *
 * waitMaskRemove                       Zählt den Zähler nach unten und blendet bei 0 die Lademaske aus
 *
 * render                               rendert den DOM-Node
 *
 * renderTo                             rendert den DOM-Node und fügt ihn einem Parent-DOM-Node hinzu
 *  Args:
 *   targetNode    HTMLElement
 *   insertBefore  HTMLElement [optional]
 *
 * up                                   Durchläuft den Element-Baum nach oben und gibt das erste Element zurück,
 *  Args:                               dass mit dem Namen (Eigenschaft 'name') übereinstimmt.
 *   name          String
 *  Return:        kijs_gui_Element|null
 *
 * upX                                  Durchläuft den Element-Baum nach oben und gibt das erste Element zurück,
 *  Args:                               dass mit dem Klassennamen (Eigenschaft 'xtype') übereinstimmt.
 *   name          String
 *  Return:        kijs_gui_Element|null
 *
 *
 * EIGENSCHAFTEN
 * -------------
 * afterResizeDelay
 *
 * cls          String|Array            CSS-Klassenname(n)
 *
 * height       Number                  Höhe
 *
 * html         String                  Siehe kijs.gui.Dom.html
 *
 * htmlDisplayType String               Siehe kijs.gui.Dom.htmlDisplayType
 *
 * isEmpty      Boolean (readonly)
 *
 * isRendered   Boolean (readonly)
 *
 * left         Number                  X-Koordinate
 *
 * node         HTML-Element (readonly) Verweis auf den DOM-Node
 *
 * name
 *
 * next         kijs.gui.Element|null (readonly)   Gibt das nächste element im elements-Array zurück
 *
 * parent       kijs.gui.Element|null (readonly)   Verweis auf das übergeordnete Element
 *
 * previous     kijs.gui.Element|null (readonly)   Gibt das vorherige element im elements-Array zurück
 *
 * style        (readonly)
 *
 * userData     Objekt mit Daten die einem Element mitgegeben können z.B. eine ID
 *
 * tooltip
 *
 * top          Number                  Y-Koordinate
 *
 * visible
 *
 * width        Number                  Breite
 *
 * xtype        String (readonly)       Gibt den Namen der Klasse zurück
 *
 *
 * EVENTS
 * ----------
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * changeVisibility
 * click
 * dblClick
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseEnter
 * mouseLeave
 * mouseMove
 * mouseUp
 * singleClick
 * touchStart
 * touchEnd
 * touchMove
 * touchCancel
 * unrender
 * wheel
 *
 * // key events
 * keyDown
 * keyUp
 * keyPress
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.Element = class kijs_gui_Element extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._afterResizeDeferId = null;   // intern
        this._afterResizeDelay = 300;    // delay beim Aufruf des afterResize-Events
        this._disabledInitial = false;
        this._dom = new kijs.gui.Dom();
        this._name = null;
        this._ddSource = null;
        this._parentEl = null;
        this._rpc = null;           // Instanz von kijs.gui.Rpc
        this._rpcLoadFn = null;     // Name der remoteFn. Bsp: 'address.load'
        this._rpcLoadArgs = {};     // Standard RPC-Argumente
        this._visible = true;
        this._lastSize = null;    // Grösse beim letzten Aufruf vom afterResize-Event
        this._userData = null;    // Objekt mit Daten die einem Element mitgegeben können z.B. eine ID

        this._waitMaskEl = null;        // Instanz der Lademaske
        this._waitMaskCount = 0;        // Anzahl Lademasken die angezeigt werden sollen.
                                        // bei mehreren wird trotzdem nur eine angezeigt.
                                        // Sobald der Zähler wieder auf 0 ist, wird sie dann entfernt.

        this._waitMaskTarget = this;               // Element, für das die Lademaske angezeigt werden soll
        this._waitMaskTargetDomProperty = 'dom';   // Dom-Property, für das die Lademaske angezeigt werden soll

        this._preventAfterResize = false;    // Auslösen des afterResize-Events verhindern?

        this._defaultConfig = {};

        this._eventForwards = {};   // Events, die an untergeordnete kijs.gui.Dom Objekte weitergeleitet werden sollen
                                    //  {
                                    //    click: [
                                    //      { target: this._dom, targetEventName: 'click' },
                                    //      { target: this._domInner, targetEventName: 'click' }
                                    //    ],
                                    //    dblclick: [
                                    //      { target: this._dom, targetEventName: 'click' }
                                    //    ]
                                    //  }


        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            afterResizeDelay: true,
            autoLoad: { target: 'autoLoad' },   // Soll nach dem ersten Rendern automatisch die Load-Funktion aufgerufen werden?
            cls: { fn: 'function', target: this._dom.clsAdd, context: this._dom },
            disableEnterBubbeling: { target: 'disableEnterBubbeling', context: this._dom },
            disableEscBubbeling: { target: 'disableEscBubbeling', context: this._dom },
            nodeTagName: { target: 'nodeTagName', context: this._dom },
            defaults: { fn: 'manual' }, // wird nur bei containern gebraucht
            ddSource: { target: 'ddSource' },   // Drag&Drop-Source Einstellungen
            height: { target: 'height' },
            html: { target: 'html', context: this._dom },
            htmlDisplayType: { target: 'htmlDisplayType', context: this._dom },
            left: { target: 'left' },
            name: true,
            nodeAttribute: { fn: 'function', target: this._dom.nodeAttributeSet, context: this._dom },
            parent: { target: 'parent' },
            style : { fn: 'assign', target: 'style', context: this._dom },
            tooltip: { target: 'tooltip' },
            top: { target: 'top' },
            userData: { target: 'userData' },
            visible : true,
            displayWaitMask: { target: 'displayWaitMask' },
            waitMaskTarget: { target: 'waitMaskTarget' },
            waitMaskTargetDomProperty: { target: 'waitMaskTargetDomProperty' },
            width: { target: 'width' },
            xtype: { fn: 'manual' },
            rpc: { target: 'rpc' },     // Instanz von kijs.gui.Rpc oder Name einer RPC
            rpcLoadFn: true,
            rpcLoadArgs: true,
            
            on: { prio: 1500,  fn: 'assignListeners' },
            disabled: { prio: 2000, target: 'disabled' }
        };

        // Event-Weiterleitungen von this._dom
        this._eventForwardsAdd('click', this._dom);
        this._eventForwardsAdd('dblClick', this._dom);
        this._eventForwardsAdd('contextMenu', this._dom);
        //this._eventForwardsAdd('drag', this._dom);
        //this._eventForwardsAdd('dragEnter', this._dom);
        //this._eventForwardsAdd('dragOver', this._dom);
        //this._eventForwardsAdd('dragStart', this._dom);
        //this._eventForwardsAdd('dragLeave', this._dom);
        //this._eventForwardsAdd('dragEnd', this._dom);
        //this._eventForwardsAdd('drop', this._dom);
        this._eventForwardsAdd('focus', this._dom);
        this._eventForwardsAdd('mouseDown', this._dom);
        this._eventForwardsAdd('mouseEnter', this._dom);
        this._eventForwardsAdd('mouseLeave', this._dom);
        this._eventForwardsAdd('mouseMove', this._dom);
        this._eventForwardsAdd('mouseUp', this._dom);
        this._eventForwardsAdd('singleClick', this._dom);
        this._eventForwardsAdd('wheel', this._dom);

        // key events
        this._eventForwardsAdd('keyDown', this._dom);
        this._eventForwardsAdd('keyUp', this._dom);
        this._eventForwardsAdd('keyPress', this._dom);
        this._eventForwardsAdd('enterPress', this._dom);
        this._eventForwardsAdd('enterEscPress', this._dom);
        this._eventForwardsAdd('escPress', this._dom);
        this._eventForwardsAdd('spacePress', this._dom);

        // touch events
        this._eventForwardsAdd('touchStart', this._dom);
        this._eventForwardsAdd('touchEnd', this._dom);
        this._eventForwardsAdd('touchMove', this._dom);
        this._eventForwardsAdd('touchCancel', this._dom);
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get afterResizeDelay() { return this._afterResizeDelay; }
    set afterResizeDelay(val) { this._afterResizeDelay = val; }

    get autoLoad() {
        return this.hasListener('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
    }
    set autoLoad(val) {
        if (val) {
            this.on('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
        } else {
            this.off('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
        }
    }

    get ddSource() { 
        return this._ddSource; 
    }
    set ddSource(val) {
        // config-object
        if (kijs.isObject(val)) {
            if (kijs.isEmpty(this._ddSource)) {
                val.ownerEl = this;
                if (kijs.isEmpty(val.ownerDomProperty)) {
                    val.ownerDomProperty = 'dom';
                }
                this._ddSource = new kijs.gui.dragDrop.Source(val);
            } else {
                this._ddSource.applyConfig(val);
            }
            
        // null
        } else if (val === null) {
            if (this._ddSource) {
                this._ddSource.destruct();
            }
            this._ddSource = null;
            
        } else {
            throw new kijs.Error(`ddSource must be a object or null`);
            
        }
    }

    // sollte nicht überschrieben werden. Bitte die Funktion changeDisabled() überschreiben.
    get disabled() {  return this._dom.disabled; }
    set disabled(val) {
        this.changeDisabled(val, false);
    }
    
    get displayWaitMask() { return !kijs.isEmpty(this._waitMaskEl); }
    set displayWaitMask(val) {
        if (val) {
            if (kijs.isEmpty(this._waitMaskEl)) {
                this._waitMaskEl = new kijs.gui.Mask({
                    displayWaitIcon: true,
                    target: this._waitMaskTarget,
                    targetDomProperty: this._waitMaskTargetDomProperty
                });
                this._waitMaskCount = 1;

                this._waitMaskEl.show();
            } else {
                this._waitMaskEl.show();
            }
        } else {
            if (!kijs.isEmpty(this._waitMaskEl)) {
                this._waitMaskEl.destruct();
                this._waitMaskEl = null;
                this._waitMaskCount = 0;
            }
        }
    }

    get dom() { return this._dom; }

    get isAppended() { return !!this._dom.isAppended; }

    get isRendered() { return !!(this._dom && this._dom.isRendered); }

    get node() { return this._dom.node; }
    get nodeTagName() { return this._dom.nodeTagName; }

    get hasFocus() { return this._dom.hasFocus; }

    get height() { return this._dom.height; }
    set height(val) {
        this._dom.height = val;
        // Evtl. afterResize-Event zeitversetzt auslösen
        if (this._hasSizeChanged(val)) {
            this._raiseAfterResizeEvent(true);
        }
    }

    get html() { 
        return this._dom.html;
    }
    set html(val) {
        this._dom.html = val;
        this._raiseAfterResizeEvent(true);
    }

    get htmlDisplayType() { return this._dom.htmlDisplayType; }
    set htmlDisplayType(val) { this._dom.htmlDisplayType = val; }

    /**
     * Index im elements-Array des parent-Containers
     * @returns {Number|null}
     */
    get index() {
        if (kijs.isEmpty(this.parent) || kijs.isEmpty(this.parent.elements)) {
            return null;
        }
        let index = this.parent.elements.indexOf(this);
        if (index === -1) {
            index = null;
        }
        return index;
    }
    
    get isEmpty() { return this._dom.isEmpty; }

    get left() { return this._dom.left; }
    set left(val) { this._dom.left = val; }

    /**
     * Gibt das Element zurück, das grafisch unterhalb liegt.
     * @returns {kijs.gui.Element|null}
     */
    get lowerElement() {
        if (!this._parentEl || !this._parentEl.elements || kijs.isEmpty(this.top)) {
            return null;
        }

        let curTop=null, lowerEl=null;
        kijs.Array.each(this._parentEl.elements, function(el) {
            if (!kijs.isEmpty(el.top) && el.left === this.left && el !== this) {
                if (el.top > this.top && (curTop === null || el.top < curTop)) {
                    lowerEl = el;
                    curTop = el.top;
                }
            }
        }, this);

        return lowerEl;
    }

    get name() { return this._name; }
    set name(val) { this._name = val; }

    /**
     * Gibt das nächste element im elements-Array zurück
     * @returns {kijs.gui.Element|null}
     */
    get next() {
        if (!this._parentEl || !this._parentEl.elements) {
            return null;
        }

        let index = -1;
        for (let i=0; i<this._parentEl.elements.length; i++) {
            if (this._parentEl.elements[i] === this) {
                index = i+1;
                break;
            }
        }

        if (index > -1 && this._parentEl.elements[index]) {
            return this._parentEl.elements[index];
        } else {
            return null;
        }
    }

    /**
     * Gibt das Elternelement zurück
     * @returns {kijs.gui.Element|null}
     */
    get parent() { return this._parentEl; }
    set parent(val) {
        if (val !== this._parentEl) {
            if (this._parentEl) {
                this._parentEl.off('afterResize', this.#onParentAfterResize, this);
                this._parentEl.off('childElementAfterResize', this.#onParentChildElementAfterResize, this);
            }

            this._parentEl = val;
            this._parentEl.on('afterResize', this.#onParentAfterResize, this);
            this._parentEl.on('childElementAfterResize', this.#onParentChildElementAfterResize, this);
            this.applyConfig();
        }
    }

    /**
     * Gibt das vorherige element im elements-Array zurück
     * @returns {kijs.gui.Element|null}
     */
    get previous() {
        if (!this._parentEl || !this._parentEl.elements) {
            return null;
        }

        let index = -1;
        for (let i=0; i<this._parentEl.elements.length; i++) {
            if (this._parentEl.elements[i] === this) {
                index = i-1;
                break;
            }
        }

        if (index > -1 && this._parentEl.elements[index]) {
            return this._parentEl.elements[index];
        } else {
            return null;
        }
    }

    get rpc() {
        return this._rpc || kijs.getRpc('default');
    }
    set rpc(val) {
        if (kijs.isString(val)) {
            val = kijs.getRpc(val);
        }

        if (val instanceof kijs.gui.Rpc) {
            this._rpc = val;
        } else {
            throw new kijs.Error(`Unknown format on config "rpc"`);
        }
    }
    
    get rpcLoadArgs() { return this._rpcLoadArgs; }
    set rpcLoadArgs(val) { this._rpcLoadArgs = val; }

    get rpcLoadFn() { return this._rpcLoadFn; }
    set rpcLoadFn(val) { this._rpcLoadFn = val; }

    get style() { return this._dom.style; }

    get tooltip() { return this._dom.tooltip; }
    set tooltip(val) { this._dom.tooltip = val; };

    get top() { return this._dom.top; }
    set top(val) { this._dom.top = val; }

    /**
     * Gibt das Element zurück, das grafisch oberhalb liegt.
     * @returns {kijs.gui.Element|null}
     */
    get upperElement() {
        if (!this._parentEl || !this._parentEl.elements || kijs.isEmpty(this.top)) {
            return null;
        }

        let curTop=null, upperEl=null;
        kijs.Array.each(this._parentEl.elements, function(el) {
            if (!kijs.isEmpty(el.top) && el.left === this.left && el !== this) {
                if (el.top < this.top && (curTop === null || el.top > curTop)) {
                    upperEl = el;
                    curTop = el.top;
                }
            }
        }, this);

        return upperEl;
    }

    get userData() { return this._userData; }
    set userData(val) {
        if (val === null || kijs.isObject(val)) {
            this._userData = val;
        } else {
            throw new kijs.Error(`userData must be object or null`);
        }
    }

    get visible() {
        return this._visible;
    }
    set visible(val) {
        const changed = !!this._visible !== !!val;

        this._visible = !!val;

        if (this._visible) {
            this._dom.clsRemove('kijs-hidden');
        } else {
            this._dom.clsAdd('kijs-hidden');
        }

        if (changed) {
            this.raiseEvent('changeVisibility', { visible: this._visible });
        }
    }

    get waitMaskTarget() { return this._waitMaskTarget; }
    set waitMaskTarget(val) {
        this._waitMaskTarget = val;
        if (!kijs.isEmpty(this._waitMaskEl)) {
            this._waitMaskEl.target = val;
        }
    }

    get waitMaskTargetDomProperty() { return this._waitMaskTargetDomProperty; }
    set waitMaskTargetDomProperty(val) {
        this._waitMaskTargetDomProperty = val;
        if (!kijs.isEmpty(this._waitMaskEl)) {
            this._waitMaskEl.targetDomProperty = val;
        }
    }

    get width() { return this._dom.width; }
    set width(val) {
        this._dom.width = val;
        // Evtl. afterResize-Event zeitversetzt auslösen
        if (this.isRendered && this._hasSizeChanged(null, val)) {
            this._raiseAfterResizeEvent(true);
        }
    }

    get xtype() {
        if (kijs.isString(this.constructor.name) && !kijs.isEmpty(this.constructor.name)) {
            return this.constructor.name.replace(/_/g, '.');

        // Workaround für IE und Edge
        } else {
            // Wenn der xtype noch nicht ermittelt worden ist, muss er ermittelt werden
            const proto = this;

            // Zuerst den Klassennamen suchen (Edge)
            if (!proto.__xtype) {
                let results = /\s*class\s([a-zA-Z0-9_]+)(\sextends\s[a-zA-Z0-9_.]+)?\s*{/.exec(this.constructor.toString());
                if (results && results.length > 0) {
                    proto.__xtype = results[1].trim().replace(/_/g, '.');
                }
            }

            // Sonst den Funktionsname suchen (IE)
            if (!proto.__xtype) {
                let results = /\s*function\s([a-zA-Z0-9_]+)\s*\(/.exec(this.constructor.toString());
                if (results && results.length > 0) {
                    proto.__xtype = results[1].trim().replace(/_/g, '.');
                }
            }

            if  (proto.__xtype) {
                return proto.__xtype;
            } else {
                throw new kijs.Error(`xtype can not be determined`);
            }
        }

    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    applyConfig(config={}, preventEvents=false) {
        // evtl. afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        if (preventEvents) {
            this._preventAfterResize = true;
        }

        // Config zuweisen
        kijs.Object.assignConfig(this, config, this._configMap);

        // Evtl. afterResize-Event wieder zulassen
        if (preventEvents) {
            this._preventAfterResize = prevAfterRes;
        }

        // Objekt versiegeln
        // Bewirkt, dass keine neuen propertys hinzugefügt werden dürfen.
        Object.seal(this);
    }

    /**
     * Ändert die Eigenschaft disabled.
     * Sollte nicht direkt aufgerufen werden.
     * Bitte den Setter disabled verwenden.
     * @param {Boolean} val
     * @param {Boolean} [callFromParent=false]  True, wenn der Aufruf vom changeDisabled 
     *                                          des Elterncontainers kommt.
     * @returns {undefined}
     */
    changeDisabled(val, callFromParent) {
        // Falls der Aufruf vom Elterncontainer kommt, wird beim Zurücksetzen von
        // disabled wieder der vorherige Wert zugewiesen.
        if (callFromParent) {
            if (!val) {
                val = !!this._disabledInitial;
            }
            
        } else {
            this._disabledInitial = !!val;
            
        }
        
        this._dom.disabled = !!val;
    }
    
    /**
     * Setzt den Fokus auf das Element
     * @param {Boolean} [alsoSetIfNoTabIndex=false]    Fokus auch setzen, wenn tabIndex === -1
     *                                                 undefined: nicht fokussierbar (bei undefined muss die Eigenschaft mit removeAttribute('tabIndex') entfernt werden. Sonst klappts nicht)
     *                                                 tabIndex -1: nur via focus() Befehl fokussierbar
     *                                                 tabIndex  0: Fokussierbar - Browser bestimmt die Tab-Reihenfolge
     *                                                 tabIndex >0: Fokussierbar - in der Reihenfolge wie der tabIndex
     * @returns {HTMLElement|null}                     HTML-Node, das den Fokus erhalten hat
     */
    focus(alsoSetIfNoTabIndex) {
        return this._dom.focus(alsoSetIfNoTabIndex);
    }


    /**
     * Prüft, ob dieses Element ein Kind von einem anderen Element ist.
     * @param {kijs.gui.Element} element
     * @returns {Boolean}
     */
    isChildOf(element) {
        if (this.parent && (this.parent instanceof kijs.gui.Element)) {
            if (this.parent === element) {
                return true;
            } else {
                return this.parent.isChildOf(element);
            }
        } else {
            return false;
        }
    }

    /**
     * Lädt die config via RPC
     * @param {Object}  [args] Objekt mit Argumenten, die an die remoteFn übergeben werden
     * @param {Boolean} [superCall=false]
     * @returns {Promise}
     */
    load(args=null, superCall=false) {
        return new Promise((resolve, reject) => {
            if (this._rpcLoadFn) {

                if (!kijs.isObject(args)) {
                    args = {};
                }
                args = Object.assign({}, args, this._rpcLoadArgs);

                this.rpc.do({
                    remoteFn: this._rpcLoadFn,
                    owner: this,
                    data: args,
                    cancelRunningRpcs: true,
                    waitMaskTarget: this._waitMaskTarget,
                    waitMaskTargetDomProperty: this._waitMaskTargetDomProperty,
                    context: this

                }).then((e) => {
                    // config Properties
                    if (e.responseData.config && this._dom) {
                        // config Properties übernehmen
                        this.applyConfig(e.responseData.config);
                    }
                    
                    // 'afterLoad' auslösen
                    if (!superCall) {
                        this.raiseEvent('afterLoad', e);
                    }

                    // promise ausführen
                    resolve(e);
                    
                }).catch((ex) => {
                    reject(ex);

                });
            }
        });
    }

    // overwrite
    on(names, callback, context) {
        names = kijs.isArray(names) ? names : [names];

        // Event Weiterleitungen erstellen, falls noch nicht vorhanden
        kijs.Array.each(names, function(name) {
            if (kijs.isObject(this._eventForwards) && this._eventForwards[name]) {
                kijs.Array.each(this._eventForwards[name], function(forward) {
                    forward.target.on(forward.targetEventName, this.#onForwardEvent, this);
                }, this);
            }
        }, this);

        // Aufruf der Basisfunktion
        super.on(names, callback, context);
    }

    // overwrite
    raiseEvent(name, e={}) {
        Object.assign(e, {
            element: this,
            eventName: name
        });
        // Das auszulösende Element darf nicht überschrieben werden.
        // Dieses gibt an, welches Element das Event ursprünglich ausgelöst hat
        // und bleibt bestehen, wenn das Event weitergereicht wird.
        if (kijs.isEmpty(e.raiseElement)) {
            e.raiseElement = this;
        }
        return super.raiseEvent(name, e);
    }

    /**
     * rendert den DOM-Node
     * @param {Boolean} [superCall=false]
     * @returns {undefined}
     */
    render(superCall) {

        // DOM Rendern
        this._dom.render();

        // Sichtbarkeit
        if (kijs.isDefined(this._visible)) {
            this.visible = this._visible;
        }

        if (this._waitMaskEl) {
            kijs.defer(function() {
                if (this._waitMaskEl) {
                    this._waitMaskEl.show();
                }
            }, 300, this);
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * rendert das Element und fügt den DOM-Node einem Parent-DOM-Node hinzu
     * @param {HTMLElement} targetNode           Eltern-Node
     * @param {HTMLElement} [referenceNode=null] Referenzknoten, Falls der Node
     *                                           statt angehängt eingefügt werden soll
     * @param {String} [insertPosition='before'] 'before': Einfügen vor dem referenceNode
     *                                           'after': Einfügen nach dem referenceNode
     * @returns {undefined}
     */
    renderTo(targetNode, referenceNode=null, insertPosition='before') {
        const firstRender = !this.isRendered;

        this.render();

        this._dom.renderTo(targetNode, referenceNode, insertPosition);

        // Event afterFirstRenderTo auslösen
        if (firstRender) {
            this.raiseEvent('afterFirstRenderTo');
        }
    }

    /**
     * Node aus DOM entfernen, falls vorhanden
     * @param {Boolean} superCall
     * @returns {undefined}
     */
    unrender(superCall) {
        // timer abbrechen
        if (this._afterResizeDeferId) {
            window.clearTimeout(this._afterResizeDeferId);
            this._afterResizeDeferId = null;
        }

        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._dom) {
            this._dom.unrender();
        }
    }

    /**
     * Durchläuft den Element-Baum nach oben und gibt das erste Element zurück,
     * dass mit dem Namen (Eigenschaft 'name') übereinstimmt.
     * @param {String} name
     * @returns {kijs_gui_Element|null}
     */
    up(name) {
        if (!kijs.isEmpty(name) && this.parent) {
            if (this.parent.name === name) {
                return this.parent;
            } else if (this.parent.up) {
                return this.parent.up(name);
            }
        }
        return null;
    }

    /**
     * Durchläuft den Element-Baum nach oben und gibt das erste Element zurück,
     * dass mit dem Klassennamen (Eigenschaft 'xtype') übereinstimmt.
     * @param {String} xtype
     * @returns {kijs_gui_Element|null}
     */
    upX(xtype) {
        if (!kijs.isEmpty(xtype) && this.parent) {
            if (this.parent.xtype === xtype) {
                return this.parent;
            } else if (this.parent.upX) {
                return this.parent.upX(xtype);
            }
        }
        return null;
    }

    /**
     * Zeigt die Lademaske an
     * Falls sie schon angezeigt wird, so wird nur der Zähler hochgezählt
     * @returns {kijs.gui.Mask}
     */
    waitMaskAdd() {
        this._waitMaskCount++;

        if (!this._waitMaskEl) {
            this.displayWaitMask = true;
        } else {
            this._waitMaskEl.show();
        }

        return this._waitMaskEl;
    }

    /**
     * Entfernt die Lademaske
     * Falls der Zähler > 1 ist, wird sie nicht geschlossen, sondern nur der Zähler dekrementiert.
     * @returns {undefined}
     */
    waitMaskRemove() {
        if (this._waitMaskEl && this._waitMaskCount) {
            this._waitMaskCount--;

            if (this._waitMaskCount <= 0) {
                this.displayWaitMask = false;
            }
        }
    }


    // PROTECTED
    /**
     * Leitet einen Event-Listener, der mit on oder once erstellt wurde an ein untergeordnetes kijs.gui.Dom Objekt weiter
     * @param {String} eventName            kijs-Event Name
     * @param {kijs.gui.Dom|kijs.gui.Element} target  Untergeordnetes Objekt, an dieses der Listener weitergeleitet wird
     * @param {String} [targetEventName]    kijs-Event Name im untergeordneten Objekt oder leer bei gleichem Event-Namen
     * @returns {undefined}
     */
    _eventForwardsAdd(eventName, target, targetEventName) {
        if (!targetEventName) {
            targetEventName = eventName;
        }

        if (!this._eventForwardsHas(eventName, target, targetEventName)) {
            if (!this._eventForwards[eventName]) {
                this._eventForwards[eventName] = [];
            }
            const forward = {
                target: target,
                targetEventName: targetEventName
            };

            this._eventForwards[eventName].push(forward);

            /*// Bei kijs.gui.Element-Targets, wird der Forward-Listener sofort erstellt,
            // weil sonst, wenn der Listener vor dem _eventForwardsAdd gemacht wird, nicht funktioniert.
            // Da dieser Vorfall bei kijs.gui.Dom nicht auftreten kann, können wir dort den Listener erst bei einer
            // Verwendung erstellen.
            //console.log(forward.target);
            if (forward.target instanceof kijs.gui.Element) {
                forward.target.on(forward.targetEventName, this.#onForwardEvent, this);
            }*/
        }
    }

    /**
     * Überprüft, ob eine Eventweiterleitung existiert
     * @param {String} eventName            kijs-Event Name
     * @param {kijs.gui.Dom|kijs.gui.Element} target Untergeordnetes Objekt, an dieses der Listener weitergeleitet wird
     * @param {String} [targetEventName]    kijs-Event Name im untergeordneten Objekt oder leer bei gleichem Event-Namen
     * @returns {Boolean}
     */
    _eventForwardsHas(eventName, target, targetEventName) {
        if (!targetEventName) {
            targetEventName = eventName;
        }

        let ret = false;

        if (!kijs.isEmpty(this._eventForwards[eventName])) {
            kijs.Array.each(this._eventForwards[eventName], function(forward) {
                if (forward.target === target && forward.targetEventName === targetEventName) {
                    ret = true;
                    return;
                }
            }, this);
        }
        return ret;
    }

    /**
     * Entfernt eine Event-Weiterleitung
     * @param {String} eventName            Name des Events, dessen Weiterleitung entfernt werden soll
     * @param {kijs.gui.Dom|kijs.gui.Element} target  Ziel, dessen Weiterleitung entfernt werden soll
     * @param {String} [targetEventName]    kijs-Event Name im untergeordneten Objekt oder leer bei gleichem Event-Namen
     * @returns {undefined}
     */
    _eventForwardsRemove(eventName, target, targetEventName) {
        if (!targetEventName) {
            targetEventName = eventName;
        }

        let forwardToDelete = null;

        if (!kijs.isEmpty(this._eventForwards[eventName])) {
            kijs.Array.each(this._eventForwards[eventName], function(forward) {
                if (forward.target === target && forward.targetEventName === targetEventName) {
                    forwardToDelete = forward;
                    return;
                }
            }, this);
        }

        if (forwardToDelete) {
            kijs.Array.remove(this._eventForwards[eventName], forwardToDelete);
        }
    }

    /**
     * Hat die Grösse seit dem letzten Aufruf von _raiseAfterResizeEvent geändert?
     * @param {Number|null} [height=null]   null=aktuelle Höhe
     * @param {Number|null} [width=null]    null=aktuelle Breite
     * @returns {Boolean}
     */
    _hasSizeChanged(height=null, width=null) {
        if (!kijs.isObject(this._lastSize)) {
            return true;
        }

        if (height === null) {
            height = this.height;
        }
        if (width === null) {
            width = this.width;
        }

        if (height !== this._lastSize.h || width !== this._lastSize.w) {
            return true;
        }

        return false;
    }

    /**
     * Falls sich seit dem letzten Aufruf dieser Funktion die Grösse geändert hat: das afterResize-Event auslösen
     * @param {Boolean} [useDelay=false]
     * @param {Object} [e={}]   Falls das Event nur weitergereicht wird, kann hier das
     *                          e-Arg des vorherigen Events übergeben werden
     * @returns {undefined}
     */
    _raiseAfterResizeEvent(useDelay=false, e={}) {
        if (this._preventAfterResize) {
            return;
        }

        // Aufruf mit Verzögerung
        if (useDelay) {
            if (this._afterResizeDeferId) {
                window.clearTimeout(this._afterResizeDeferId);
                this._afterResizeDeferId = null;
            }

            this._afterResizeDeferId = kijs.defer(function(){
                if (this._hasSizeChanged()) {
                    this._lastSize = { h: this.height, w: this.width };
                    this.raiseEvent('afterResize', e);
                }
            }, this._afterResizeDelay, this);

        // Aufruf ohne Verzögerung
        } else {
            if (this._hasSizeChanged()) {
                this._lastSize = { h: this.height, w: this.width };
                this.raiseEvent('afterResize', e);
            }

        }
    }
    

    // PRIVATE
    // LISTENERS
    #onAfterFirstRenderTo(e) {
        this.load();
    }

    /**
     * Listener für die weitergeleiteten Events der untergeordneten kijs.gui.Dom oder kijs.gui.Element Objekte.
     * Hier werden die Events, die in (this._eventForwards) zum Weiterleiten gekennzeichnet sind weitergeleitet.
     * @param {Object} e
     * @returns {Boolean}
     */
    #onForwardEvent(e) {
        let ret = true;

        // Vorhandene Weiterleitungen durchgehen und bei Übereinstimmung das Event weiterleiten
        kijs.Object.each(this._eventForwards, function(eventName, forwards) {

            kijs.Array.each(forwards, function(forward) {
                const eventContextProperty = (forward.target instanceof kijs.gui.Dom) ? 'context' : 'element';
                if (forward.target === e[eventContextProperty] && forward.targetEventName === e.eventName) {
                    e.element = this;
                    if (this.raiseEvent(eventName, e) === false) {
                        ret = false;
                    }
                }
            }, this);
        }, this);

        return ret;
    }

    /**
     * Listener der Aufgerufen wird, wenn die Grösse des Parents geändert hat
     * @param {Object} e
     * @returns {undefined}
     */
    #onParentAfterResize(e) {
        // Falls die eigene Grösse geändert hat: das eigene afterResize-Event auslösen
        this._raiseAfterResizeEvent(false, e);
    }

    /**
     * Listener der aufgerufen wird, wenn die Grösse des Parents geändert hat
     * @param {Object} e
     * @returns {undefined}
     */
    #onParentChildElementAfterResize(e) {
        // Falls die eigene Grösse geändert hat: das eigene afterResize-Event auslösen
        this._raiseAfterResizeEvent(false, e);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        // afterResize-Events verhindern
        this._preventAfterResize = true;
            
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Listeners entfernen
        if (this._parentEl) {
            this._parentEl.off(null, null, this);
        }

        // Elemente/DOM-Objekte entladen
        if (this._dom) {
            this._dom.destruct();
        }
        if (this._waitMaskEl) {
            this._waitMaskEl.destruct();
        }
        if (this._ddSource) {
            this._ddSource.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._afterResizeDeferId = null;
        this._defaultConfig = null;
        this._ddSource = null;
        this._eventForwards = null;
        this._dom = null;
        this._parentEl = null;
        this._rpc = null;
        this._rpcLoadArgs = null;
        this._lastSize = null;
        this._userData = null;
        this._waitMaskEl = null;
        this._waitMaskTarget = null;

        // Basisklasse entladen
        super.destruct();
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Container
// --------------------------------------------------------------
/**
 * Container Element, welches untergeordnete Elemente beinhalten kann.
 * Das Element besteht aus zwei ineinanderliegenden dom-Nodes.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *
 * CONFIG-Parameter (es gelten auch die Config-Parameter der Basisklassen)
 * ----------------
 * defaults     Object [optional]       Objekt mit Config-Parameter, die bei allen untergeordneten elements
 *                                      angewendet werden.
 *
 * clsInner     Array|String [optional] CSS-Klassennamen für den inneren dom-Node
 *                                      Beispiel: clsInner:['cls-a','cls-b'] oder cls:'cls-a cls-b'
 *
 * styleInner   Object [optional]       Objekt mit CSS-Style Anweisungen als Javascript für das innere dom-Element
 *                                      Beispiel: styleInner:{background-color:'#ff8800'}
 *
 * elements     Array|Object            Array mit den untergeordneten elements.
 *                                      Es können sowohl Config-Objekte, als auch Instanzen der Klasse im Array sein.
 *                                      Beispiel: elements:[
 *                                          {
 *                                              xtype: 'kijs.gui.Element',
 *                                              html: 'Hello World'
 *                                          }, new kijs.gui.Element({
 *                                              html: 'Hallo Welt'
 *                                          })
 *                                      ]
 *
 * scrollableX  Boolean|String [optional] default=false     Soll auf der X-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 *
 * scrollableY  Boolean|String [optional] default=false     Soll auf der Y-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 *
 *
 * FUNKTIONEN (es gelten auch die Funktionen der Basisklassen)
 * ----------
 * addClsInner                          Fügt eine oder mehrere CSS-Klassen zum inneren dom-Node hinzu
 *  Args: cls   String|Array
 *
 * hasClsInner                          Überprüft, ob der innere dom-Node eine CSS-Klasse hat
 *  Args:
 *   cls        String
 *  Return: Boolean
 *
 * removeClsInner                       Entfernt eine oder mehrere CSS-Klassen vom inneren dom-Node
 *  Args:
 *   cls        String|Array
 *
 *
 * add                                  Fügt ein oder mehrere Elemente hinzu
 *  Args:
 *   elements   Array|Object            Es können sowohl Config-Objekte, als auch Instanzen der Klasse im Array sein.
 *   before     Number|Function [optional]  Index der Position oder Verweis auf das Element, vor dem eingefügt werden soll.
 *   options
 *
 * getElementsByName                    Gibt untergeordnete Elemente aufgrund ihres 'name' zurück
 *  Args:
 *   name       String
 *   deep       Number [optional] default=-1 Gewünschte Suchtiefe
 *                                            0=nur im aktuellen Container
 *                                            1=im aktuellen Container und in deren untergeordneten
 *                                            2=im aktuellen Container, deren untergeordneten und deren untergeordneten
 *                                            n=...
 *                                            -1=unendlich
 *   breakOnFirst {Boolean} [optional] default=false Soll nur das Erste Element zurückgegeben werden?
 *  Return: Array
 *
 * getElementsByXtype                   Gibt untergeordnete Elemente aufgrund ihres 'xtype' zurück
 *  Args:
 *   xtype      String
 *   deep       Number [optional] default=-1 Gewünschte Suchtiefe
 *                                            0=nur im aktuellen Container
 *                                            1=im aktuellen Container und in deren untergeordneten
 *                                            2=im aktuellen Container, deren untergeordneten und deren untergeordneten
 *                                            n=...
 *                                            -1=unendlich
 *   breakOnFirst {Boolean} [optional] default=false Soll nur das Erste Element zurückgegeben werden?
 *  Return: Array
 *
 * hasChild                             Überprüft, ob ein untergeordnetes Element existiert
 *  Args:
 *   element    kijs.gui.Element
 *  Return: Boolean
 *
 * remove                               Löscht ein oder mehrere untergeordenete Elemente
 *  Args:
 *   elements    Object|Array
 *   options
 *
 * removeAll                            Löscht alle untergeordeneten Elemente
 *  Args:
 *   options
 *   
 * down                                 Durchläuft den Element-Baum nach unten und gibt das erste Element zurück,
 *  Args:                               dass mit dem Namen (Eigenschaft 'name') übereinstimmt.
 *   name       String
 *  Return: kijs.gui.Element|null
 *
 * downX                                Durchläuft den Element-Baum nach unten und gibt das erste Element zurück,
 *  Args:                               dass mit dem Klassennamen (Eigenschaft 'xtype') übereinstimmt.
 *   xtype      String
 *  Return: kijs.gui.Element|null
 *
 *
 * EIGENSCHAFTEN (es gelten auch die Eigenschaften der Basisklassen)
 * -------------
 * innerDom     HTML-Element            Verweis auf den inneren dom-Node
 *
 * elements     Array                   Array mit den untergeordeten elements
 *
 * isEmpty      Boolean (readonly)
 *
 * scrollableX  Boolean|String [optional] default=false     Soll auf der X-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 *
 * scrollableY  Boolean|String [optional] default=false     Soll auf der Y-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 *
 *
 * EVENTS
 * ----------
 * add
 * beforeAdd
 * beforeRemove
 * childElementAfterResize
 * remove
 *
 * // Geerbte Events
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * changeVisibility
 * click
 * dblClick
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseEnter
 * mouseLeave
 * mouseMove
 * mouseUp
 * singleClick
 * touchStart
 * touchEnd
 * touchMove
 * touchCancel
 * unrender
 * wheel
 *
 * // key events
 * keyDown
 * keyUp
 * keyPress
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.Container = class kijs_gui_Container extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._innerDom = new kijs.gui.Dom();

        this._defaults = {};
        this._elements = [];

        this._dom.clsAdd('kijs-container');
        this._innerDom.clsAdd('kijs-container-inner');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            scrollableX: { target: 'scrollableX' },
            scrollableY: { target: 'scrollableY' },
            defaults: true,
            html: { target: 'html', context: this._innerDom },
            htmlDisplayType: { target: 'htmlDisplayType', context: this._innerDom },
            innerCls: { fn: 'function', target: this._innerDom.clsAdd, context: this._innerDom },
            innerStyle : { fn: 'assign', target: 'style', context: this._innerDom },

            elements: { prio: 1000, fn: 'function', target: this._replaceElements, context: this }
        });

        // Event-Weiterleitungen von this._innerDom
        this._eventForwardsAdd('scroll', this._innerDom);
        this._eventForwardsAdd('scrollEnd', this._innerDom);
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get defaults() { return this._defaults; }
    set defaults(val) { this._defaults = val; }
    
    get elements() { return this._elements; }

    get firstChild() {
        if (this._elements.length > 0) {
            return this._elements[0];
        }
        return null;
    }

    // overwrite
    get html() { return this._innerDom.html; }
    set html(val) { this._innerDom.html = val; }

    // overwrite
    get htmlDisplayType() { return this._innerDom.htmlDisplayType; }
    set htmlDisplayType(val) { this._innerDom.htmlDisplayType = val; }

    get innerDom() { return this._innerDom; }

    get lastChild() {
        if (this._elements.length > 0) {
            return this._elements[this._elements.length-1];
        }
        return null;
    }

    // overwrite
    get isEmpty() { return this._innerDom.isEmpty && kijs.isEmpty(this._elements); }


    get scrollableX() {
        if (this._innerDom.clsHas('kijs-scrollable-x-enable')) {
            return true;
        } else if (this._innerDom.clsHas('kijs-scrollable-x-auto')) {
            return 'auto';
        } else {
            return false;
        }
    }
    set scrollableX(val) {
        this._innerDom.clsRemove('kijs-scrollable-x-enable');
        this._innerDom.clsRemove('kijs-scrollable-x-auto');
        
        if (val === 'auto') {
            this._innerDom.clsAdd('kijs-scrollable-x-auto');
        } else if(val) {
            this._innerDom.clsAdd('kijs-scrollable-x-enable');
        }
    }
    
    get scrollableY() {
        if (this._innerDom.clsHas('kijs-scrollable-y-enable')) {
            return true;
        } else if (this._innerDom.clsHas('kijs-scrollable-y-auto')) {
            return 'auto';
        } else {
            return false;
        }
    }
    set scrollableY(val) {
        this._innerDom.clsRemove('kijs-scrollable-y-enable');
        this._innerDom.clsRemove('kijs-scrollable-y-auto');
            
        if (val === 'auto') {
            this._innerDom.clsAdd('kijs-scrollable-y-auto');
        } else if(val) {
            this._innerDom.clsAdd('kijs-scrollable-y-enable');
        }
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt ein oder mehrere Elemente hinzu.
     * @param {Object|Array} elements
     * @param {Number} [index=null] Position an der Eingefügt werden soll null=am Schluss
     * @param {Object} [options={}]
     *  options Eigenschaften:
     *    {Boolean} [preventRender=false]   render verhindern?
     *    {Boolean} [preventEvents=false]   Das Auslösen des beforeAdd und add-Events verhindern?
     * @returns {undefined}
     */
    add(elements, index=null, options={}) {
        if (!kijs.isArray(elements)) {
            elements = [elements];
        }

        const newElements = [];
        for (let i=0,len=elements.length; i<len; i++) {
            let el = this._getInstanceForAdd(elements[i]);
            if (el && !kijs.Array.contains(this._elements, el)) {
                el.on('afterResize', this.#onChildElementAfterResize, this);
                newElements.push(el);
            }
        }
        elements = null;

        if (!options.preventEvents) {
            // event ausführen
            if (this.raiseEvent('beforeAdd', {elements: newElements}) === false) {
                return;
            }
        }

        // zu elements hinzufügen.
        kijs.Array.each(newElements, function(el) {
            if (kijs.isInteger(index)) {
                this._elements.splice(index, 0, el);
            } else {
                this._elements.push(el);
            }
        }, this);

        // Falls der DOM gemacht ist, wird neu gerendert.
        if (this._innerDom.node && !options.preventRender) {
            this.render();
        }
        
        // Hinzugefügt, Event auslösen.
        if (!options.preventEvents) {
            this.raiseEvent('add', {elements: newElements});
        }
        
        this.raiseEvent('afterResize');
    }

    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        kijs.Array.each(this._elements, function(el) {
            el.changeDisabled(!!val, true);
        }, this);
    }
    
    /**
     * Durchläuft den Element-Baum nach unten und gibt das erste Element zurück,
     * dass mit dem Namen (Eigenschaft 'name') übereinstimmt.
     * @param {String} name
     * @returns {kijs_gui_Element|null}
     */
    down(name) {
        const ret = this.getElementsByName(name, -1, true);
        if (!kijs.isEmpty(ret)) {
            return ret[0];
        } else {
            return null;
        }
    }

    /**
     * Durchläuft den Element-Baum nach unten und gibt das erste Element zurück,
     * dass mit dem Klassennamen (Eigenschaft 'xtype') übereinstimmt.
     * @param {String} xtype
     * @returns {kijs_gui_Element|null}
     */
    downX(xtype) {
        const ret = this.getElementsByXtype(xtype, -1, true);
        if (!kijs.isEmpty(ret)) {
            return ret[0];
        } else {
            return null;
        }
    }

    /**
     * Gibt untergeordnete Elemente aufgrund ihres 'name' zurück
     * @param {String} name
     * @param {Number} deep [optional] default=-1    Gewünschte Suchtiefe
     *                                               0=nur im aktuellen Container
     *                                               1=im aktuellen Container und in deren untergeordneten
     *                                               2=im aktuellen Container, deren untergeordneten und deren untergeordneten
     *                                               n=...
     *                                               -1=unendlich
     * @param {Boolean} breakOnFirst [optional] default=false Soll nur das erste Element zurückgegeben werden?
     * @returns {Array}
     */
    getElementsByName(name, deep=-1, breakOnFirst=false) {
        let ret=[];

        if (kijs.isEmpty(name)) {
            return [];
        }

        // elements im aktuellen Container werden zuerst zurückgegeben
        kijs.Array.each(this._elements, function(el) {
            if (el.name === name) {
                ret.push(el);
                if (breakOnFirst) {
                    return false;
                }
            }
        }, this);

        // Evtl. untergeordnete Container rekursiv duchsuchen
        if (!breakOnFirst || kijs.isEmpty(ret)) {
            if (deep && deep!==0) {
                if (deep>0) {
                    deep--;
                }
                kijs.Array.each(this._elements, function(el) {
                    if (kijs.isFunction(el.getElementsByName)) {
                        let retSub = el.getElementsByName(name, deep, breakOnFirst);
                        if (!kijs.isEmpty(retSub)) {
                            ret = ret.concat(retSub);
                            if (breakOnFirst) {
                                return false;
                            }
                        }
                    }
                }, this);
            }
        }

        // Rückgabe
        return ret;
    }

    /**
     * Gibt untergeordnete Elemente aufgrund ihres 'xtype' zurück
     * @param {String} xtype
     * @param {Number} deep [optional] default=-1    Gewünschte Suchtiefe
     *                                               0=nur im aktuellen Container
     *                                               1=im aktuellen Container und in deren untergeordneten
     *                                               2=im aktuellen Container, deren untergeordneten und deren untergeordneten
     *                                               n=...
     *                                               -1=unendlich
     * @param {Boolean} breakOnFirst [optional] default=false Soll nur das erste Element zurückgegeben werden?
     * @returns {Array}
     */
    getElementsByXtype(xtype, deep=-1, breakOnFirst=false) {
        let ret=[];

        if (kijs.isEmpty(xtype)) {
            return [];
        }

        // elements im aktuellen Container werden zuerst zurückgegeben
        kijs.Array.each(this._elements, function(el) {
            if (el.xtype === xtype) {
                ret.push(el);
                if (breakOnFirst) {
                    return false;
                }
            }
        }, this);

        // Evtl. untergeordnete Container rekursiv durchsuchen
        if (!breakOnFirst || kijs.isEmpty(ret)) {
            if (deep && deep!==0) {
                if (deep>0) {
                    deep--;
                }
                kijs.Array.each(this._elements, function(el) {
                    if (kijs.isFunction(el.getElementsByXtype)) {
                        let retSub = el.getElementsByXtype(xtype, deep, breakOnFirst);
                        if (!kijs.isEmpty(retSub)) {
                            ret = ret.concat(retSub);
                            if (breakOnFirst) {
                                return false;
                            }
                        }
                    }
                }, this);
            }
        }

        // Rückgabe
        return ret;
    }
    
    /**
     * Gibt alle Unterelemente als flaches Array zurück
     * @param {Number} [deep]         default=-1    Gewünschte Suchtiefe
     *                                              0=nur im aktuellen Container
     *                                              1=im aktuellen Container und in deren untergeordneten
     *                                              2=im aktuellen Container, deren untergeordneten und deren untergeordneten
     *                                              n=...
     *                                              -1=unendlich
     * @returns {Array}
     */
    getElementsRec(deep=-1) {
        let ret = [];

        // elements im aktuellen Container werden zuerst zurückgegeben
        kijs.Array.each(this._elements, function(el) {
            ret.push(el);
        }, this);

        // Evtl. untergeordnete Container rekursiv duchsuchen
        if (deep !== 0) {
            if (deep>0) {
                deep--;
            }
            kijs.Array.each(this._elements, function(el) {
                if (kijs.isFunction(el.getElementsRec)) {
                    let retSub = el.getElementsRec(deep);
                    if (!kijs.isEmpty(retSub)) {
                        ret = ret.concat(retSub);
                    }
                }
            }, this);
        }

        return ret;
    }

    /**
     * Überprüft ob ein untergeordnetes Element existiert
     * @param {kijs.gui.Element} element
     * @returns {Boolean}
     */
    hasChild(element) {
        return kijs.Array.contains(this._elements, element);
    }

    /**
     * Löscht ein oder mehrere untergeordnete Elemente
     * @param {Object|Array} elements
     * @param {Object} [options={}]
     *  options Eigenschaften:
     *    {Boolean} [preventDestruct=false] desctruct verhindern?
     *    {Boolean} [preventUnrender=false] unrender verhindern?
     *    {Boolean} [preventRender=false]   render verhindern?
     *    {Boolean} [preventEvents=false]   Das Auslösen des beforeRemove und remove-Events verhindern?
     * @param {Boolean} [superCall=false]
     * @returns {undefined}
     */
    remove(elements, options={}, superCall) {
        if (!superCall) {
            if (!kijs.isArray(elements)) {
                elements = [elements];
            }
            
            if (!options.preventEvents) {
                // beforeRemove Event. Bei Rückgabe=false -> abbrechen
                if (this.raiseEvent('beforeRemove', {removeElements: elements}) === false) {
                    return;
                }
            }
        }
        
        // löschen
        kijs.Array.each(kijs.Array.clone(elements), function(el) {
            if (!kijs.Array.contains(this._elements, el)) {
                throw new kijs.Error(`el does not exist in elements.`);
            }
            
            if (!options.preventDestruct && el.destruct) {
                el.destruct();

            } else if (el.isRendered && el.unrender && !options.preventUnrender) {
                el.unrender();
            }
            el.off(null, null, this);
            kijs.Array.remove(this._elements, el);
        }, this);

        // Falls der DOM gemacht ist, wird neu gerendert.
        if (this.dom.node && !options.preventRender) {
            this.render();
        }

        // Gelöscht, Event auslösen.
        if (!options.preventEvents) {
            this.raiseEvent('remove');
        }
    }

    /**
     * Löscht alle untergeordneten Elemente
     * @param {Object} [options={}]
     *  options Eigenschaften:
     *    {Boolean} [preventDestruct=false] desctruct verhindern?
     *    {Boolean} [preventUnrender=false] unrender verhindern?
     *    {Boolean} [preventRender=false]   render verhindern?
     *    {Boolean} [preventEvents=false]   Das Auslösen des beforeRemove und remove-Events verhindern?
     * @returns {undefined}
     */
    removeAll(options={}) {
        if (this._elements && this._elements.length > 0) {
            this.remove(this._elements, options);
        }
    }

    /**
     * Sortiert die Elemente mit einer Funktion. Der Funktion werden
     * zwei Elemente zum Vergleich übergeben, die Funktion
     * muss 1, 0 oder -1 zurückgeben, wenn a grösser, gleich oder kleiner b ist.
     * @param {Function} compareFn
     * @param {Object|null} context
     * @returns {undefined}
     */
    sort(compareFn, context=null) {
        if (kijs.isFunction(compareFn)) {
            this._elements.sort((a, b) => {
                return compareFn.call(context || this, a, b);
            });

            // elemente in der neuen Reihenfolge rendern.
            if (this.isRendered) {
                this._renderElements();
            }
        }
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // innerDOM rendern
        this._innerDom.renderTo(this._dom.node);

        // Render der Elements in Funktion, damit dies
        // in Vererbungen überschrieben werden könnte.
        this._renderElements();

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        if (this._elements) {
            kijs.Array.each(this._elements, function(el) {
                el.unrender();
            }, this);
        }
        
        if (this._innerDom) {
            this._innerDom.unrender();
        }
        
        super.unrender(true);
    }


    // PROTECTED
    /**
     * Gibt eine Instanz des Elements zurück, das hinzugefügt werden soll.
     * Falls ein xtype angegeben wird, wird eine neue instanz erstellt.
     * @param {kijs.gui.Element|Object} obj
     * @returns {kijs.gui.Element}
     */
    _getInstanceForAdd(obj) {
        // String (Kurzform für einen xtype)
        if (kijs.isString(obj)) {
            switch (obj) {
                // '-' -> kijs.gui.Separator
                case '-':
                    obj = new kijs.gui.Separator({});
                    break;
                    
                // '>' -> kijs.gui.Spacer
                case '>':
                    obj = new kijs.gui.Spacer({});
                    break;
            }
        }
        
        // Falls eine Instanz übergeben wird
        if (obj instanceof kijs.gui.Element) {
            // Da das Element bereits erstellt wurde, werden hier keine defaults übernommen

            // Parent zuweisen
            obj.parent = this;

        // Falls ein Config-Objekt übergeben wird
        } else  if (kijs.isObject(obj)) {
            
            // defaults
            if (!kijs.isEmpty(this._defaults)) {
                
                // Damit unbekannte defaults keinen Fehler auslösen, die Namen der
                // defaults in die skipUnknownConfigs schreiben
                this._defaults.skipUnknownConfigs = Object.getOwnPropertyNames(this._defaults);
                
                // defaults in die config übernehmen. 
                // Bereits vorhandene Eigenschaften werden nicht verändert.
                kijs.Object.assignDeep(obj, this._defaults, false);
                
                // Defaults wiederum als defaults weitergeben, damit evtl. vorhandene subElements diese auch übernehmen können
                /*if (kijs.isObject(obj.defaults)) {
                    kijs.Object.assignDeep(obj.defaults, this._defaults, false);
                } else {
                    obj.defaults = kijs.Object.clone(this._defaults);
                }*/
            }

            // xtype vorhanden?
            if (!kijs.isString(obj.xtype)) {
                throw new kijs.Error(`config missing "xtype".`);
            }

            // Konstruktor ermitteln
            const constr = kijs.getObjectFromString(obj.xtype);
            if (!kijs.isFunction(constr)) {
                throw new kijs.Error(`Unknown xtype "${obj.xtype}".`);
            }
            
            // Parent zuweisen
            obj.parent = this;

            // Element erstellen
            obj = new constr(obj);

        // Ungültige Übergabe
        } else {
            throw new kijs.Error(`kijs.gui.Container: invalid element: ` + typeof obj);
            
        }

        return obj;
    }

    /**
     * Rendert die elements in den innerDom.
     */
    _renderElements() {
        // elements im innerDOM rendern
        kijs.Array.each(this._elements, function(el) {
            el.renderTo(this._innerDom.node);
        }, this);
    }

    /**
     * Entfernt alle elements und fügt neue hinzu
     * Wird intern von der config elements verwendet
     * @param {Object|Array} elements
     * @returns {undefined}
     */
    _replaceElements(elements) {
        // Bestehende Elemente löschen
        this.removeAll({
            preventRender: true
        });

        // Neue Elemente hinzufügen
        this.add(elements, null);
    }



    // PRVATE
    // LISTENERS
    /**
     * Listener der aufgerufen wird, wenn sich die Grösse eines untergeordneten Elements ändert
     * PRIVATE! Bitte diese Funktion nicht vererben, sondern Listener verwenden!
     * @param {Object} e
     * @returns {undefined}
     */
    #onChildElementAfterResize(e) {
        // Endlosschlaufe verhindern: wenn der Event von dieser Klasse ausgelöst wurde,
        // den Event nicht erneut auslösen
        if (e.raiseElement === this) {
            return;
        }

        this.raiseEvent('childElementAfterResize', {childElement: e.element});
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._elements) {
            kijs.Array.each(this._elements, function(el) {
                if (el && el.destruct) {
                    el.destruct();
                }
            }, this);
        }
        if (this._innerDom) {
            this._innerDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._defaults = null;
        this._elements = null;
        this._innerDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Separator (Trennlinie für Menüs und Toolbars)
// --------------------------------------------------------------
kijs.gui.Separator = class kijs_gui_Separator extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dom.clsAdd('kijs-separator');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }

    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Spacer (Abstandshalter für Toolbars)
// --------------------------------------------------------------
kijs.gui.Spacer = class kijs_gui_Spacer extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dom.clsAdd('kijs-spacer');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }

    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.container (namespace)
// --------------------------------------------------------------
kijs.gui.container = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.Fieldset
// --------------------------------------------------------------
kijs.gui.container.Fieldset = class kijs_gui_container_Fieldset extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._headerDom = new kijs.gui.Dom({
            cls: 'kijs-header'
        });
        
        this._iconEl = new kijs.gui.Icon({ 
            parent: this,
            on: {
                click: this.#onIconElClick,
                context: this
            }
        });
        
        this._captionDom = new kijs.gui.Dom({
            cls: 'kijs-caption',
            on: {
                click: this.#onCaptionDomClick,
                context: this
            }
        });
        
        this._collapseButtonEl = null;
        
        // Höhe, die bei collapse hier zwischengespeichert wird, damit sie dann bei 
        // expand wieder wie zugewiesen werden kann.
        this._expandedHeight = null;
        
        this._innerDisabled = false;

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-container-fieldset');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // caption
            caption: { target: 'html', context: this._captionDom },
            
            iconChar: { target: 'iconChar', context: this._iconEl },
            iconCls: { target: 'iconCls', context: this._iconEl },
            iconColor: { target: 'iconColor', context: this._iconEl },
            iconMap: { target: 'iconMap', context: this._iconEl },
            
            // inner
            innerDisabled: { target: 'innerDisabled' },
            
            collapsible: { prio: 1002, target: 'collapsible' },
            collapseButton: { prio: 1003, target: 'collapseButton' },
            collapsed: { prio: 1004, target: 'collapsed' }

        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._captionDom.html; }
    set caption(val) { this._captionDom.html = val; }

    get captionDom() { return this._captionDom; }

    get collapseButton() { return this._collapseButtonEl; }
    set collapseButton(val) {
        // Button entfernen
        if (kijs.isEmpty(val)) {
            if (this._collapseButtonEl) {
                this._collapseButtonEl.destruct();
            }
            this._collapseButtonEl = null;

        // Instanz von kijs.gui.Button
        } else if (val instanceof kijs.gui.Button) {
            if (this._collapseButtonEl) {
                this._collapseButtonEl.destruct();
            }
            this._collapseButtonEl = val;
            this._collapseButtonEl.on('click', this.#onCollapseButtonClick, this);

        // Config-Objekt
        } else if (kijs.isObject(val)) {
            if (this._collapseButtonEl) {
                this._collapseButtonEl.applyConfig(val);
            } else {
                this._collapseButtonEl = new kijs.gui.Button(val);
                this._collapseButtonEl.on('click', this.#onCollapseButtonClick, this);
            }

        } else {
            throw new kijs.Error(`Unknown format on config "collapseButton"`);
        }

        if (this.isRendered) {
            this.render();
        }
    }

    get collapsed() {
        return this._dom.clsHas('kijs-collapse-top');
    }
    set collapsed(val) {
        if (val) {
            if (val === 'toggle') {
                if (this.collapsed) {
                    this.expand();
                } else {
                    this.collapse();
                }
            } else {
                this.collapse();
            }
        } else {
            this.expand();
        }
    }

    get collapsible() { return !!this._collapseButtonEl; }
    set collapsible(val) {
        if (val) {
            if (!this._collapseButtonEl) {
                this.collapseButton = {
                    iconMap: this._getCollapseIconMap()
                };
            }
        } else {
            if (this._collapseButtonEl) {
                this.collapseButton = null;
            }
        }
    }
    

    get headerDom() { return this._headerDom; }

    // overwrite
    get height() { return super.height; }
    set height(val) {
        let doFn = false;

        if (this.collapsible && kijs.isNumber(this._collapseHeight)) {
            if (val <= this._collapseHeight) {
                doFn = 'collapse';
            } else if (this.collapsed) {
                doFn = 'expand';
            }
        }
        
        // Höhe merken, damit beim aufklappen, wieder die gleiche Höhe wiederhergestellt werden kann
        if (kijs.isNumber(this._collapseHeight) && val > kijs.isNumber(this._collapseHeight)) {
            this._expandedHeight = val;
        }
        
        if (doFn === 'collapse') {
            if (!this.collapsed) {
                this.collapse();
            }
        } else if (doFn === 'expand') {
            this.expand(val);
        } else {
            super.height = val;
        }
    }

    get innerDisabled() { return this._innerDisabled; }
    set innerDisabled(val) {
        this._innerDisabled = !!val;
        kijs.Array.each(this._elements, function(el) {
            el.changeDisabled(!!val, true);
        }, this);
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._iconEl.changeDisabled(!!val, true);
        this._captionDom.changeDisabled(!!val, true);
        if (this._collapseButtonEl) {
            this._collapseButtonEl.changeDisabled(!!val, true);
        }
    }
    
    /**
     * Minimiert den Container
     * @returns {undefined}
     */
    collapse() {
        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        this._dom.clsAdd('kijs-collapse-top');
        this._dom.height = null;
        
        // das richtige Icon in den Button
        if (this._collapseButtonEl) {
            this._collapseButtonEl.iconMap = this._getCollapseIconMap();
        }
        
        // Event werfen
        this.raiseEvent('collapse');

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;
        
        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    /**
     * Expandiert den Container
     * @param {Number} size [optional] Höhe in die der Container wiederhergestellt werden soll
     * @returns {undefined}
     */
    expand(size) {
        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        this._dom.clsRemove('kijs-collapse-top');

        // das richtige Icon in den Button
        if (this._collapseButtonEl) {
            this._collapseButtonEl.iconMap = this._getCollapseIconMap();
        }
        
        // falls kein size übergeben wurde, die letzte höhe nehmen
        if (kijs.isEmpty(size)) {
            if (!kijs.isEmpty(this._expandedHeight)) {
                size = this._expandedHeight;
            }
        }
        
        // Übergebene Grösse wiederherstellen
        if (!kijs.isEmpty(size)) {
            if (size > this._collapseHeight) {
                this.height = size;
            }
        }

        // Event werfen
        this.raiseEvent('expand');

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    // overwrite
    focus(alsoSetIfNoTabIndex) {
        if (alsoSetIfNoTabIndex) {
            return super.focus(alsoSetIfNoTabIndex);

        } else {
            // Zuerst versuchen den Fokus auf ein Element im innerDom zu setzen
            let nde = this._innerDom.focus(false);
            // falls nicht erfolgreich. Den Fokus direkt auf das Fenster setzen
            if (!nde) {
                nde = super.focus(alsoSetIfNoTabIndex);
            }
            return nde;
        }

        // Darf der Node den Fokus erhalten?
        if (alsoSetIfNoTabIndex) {
            this._dom.node.focus();

        // sonst den Fokus auf den ersten möglichen untegeordneten Node settzen
        } else {
            const nde = kijs.Dom.getFirstFocusableNode(this._node);
            if (nde) {
                nde.focus();
                return nde;
            }
        }
        
        return false;
    }

    // Overwrite
    render(superCall) {
        // dom mit elements rendern (innerDom)
        super.render(true);

        // Header rendern (kijs.gui.Dom)
        this._headerDom.renderTo(this._dom.node, this._innerDom.node);

        // Icon rendern (kijs.gui.Icon)
        if (this._iconEl) {
            if (!this._iconEl.isEmpty) {
                this._iconEl.renderTo(this._headerDom.node);
            } else if (this._iconEl.isRendered) {
                this._iconEl.unrender();
            }
        }

        // Caption rendern (kijs.gui.Dom)
        if (this._captionDom) {
            if (!this._captionDom.isEmpty) {
                this._captionDom.renderTo(this._headerDom.node);
            } else if (this._captionDom.isRendered) {
                this._captionDom.unrender();
            }
        }
        
        // CollapseButton rendern (kijs.gui.Button)
        if (this._collapseButtonEl) {
            if (!this._collapseButtonEl.isEmpty) {
                this._collapseButtonEl.renderTo(this._headerDom.node);
            } else if (this._collapseButtonEl.isRendered) {
                this._collapseButtonEl.unrender();
            }
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        if (this._iconEl) {
            this._iconEl.unrender();
        }
        if (this._captionDom) {
            this._captionDom.unrender();
        }
        if (this._collapseButtonEl) {
            this._collapseButtonEl.unrender();
        }
        if (this._headerDom) {
            this._headerDom.unrender();
        }
        super.unrender(true);
    }


    // PROTECTED
    /**
     * Gibt das Icon für den Collapse-Knopf zurück
     * @returns {undefined}
     */
    _getCollapseIconMap() {
        if (this.collapsed) {
            return 'kijs.iconMap.Fa.chevron-down';
        } else {
            return 'kijs.iconMap.Fa.chevron-up';
        }
    }
    
    // PRIVATE
    // LISTENERS
    #onCollapseButtonClick(e) {
        if (this.collapsed && !this._dom.disabled) {
            this.expand();
        } else {
            this.collapse();
        }
    }

    #onCaptionDomClick(e) {
        if (this.collapsible && !this._dom.disabled) {
            if (this.collapsed) {
                this.expand();
            } else {
                this.collapse();
            }
        }
    }
    
    #onIconElClick(e) {
        if (this.collapsible && !this._dom.disabled) {
            if (this.collapsed) {
                this.expand();
            } else {
                this.collapse();
            }
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._captionDom) {
            this._captionDom.destruct();
        }
        if (this._iconEl) {
            this._iconEl.destruct();
        }
        if (this._collapseButtonEl) {
            this._collapseButtonEl.destruct();
        }
        if (this._headerDom) {
            this._headerDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._captionDom = null;
        this._collapseButtonEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.Form
// --------------------------------------------------------------
kijs.gui.container.Form = class kijs_gui_container_Form extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._data = {};
        this._rpcSaveFn = null;     // Name der remoteFn. Bsp: 'address.save'
        this._rpcSaveArgs = {};     // Standard RPC-Argumente
        this._fields = [];          // Array mit kijs.gui.field.Fields-Elementen
        this._defaultSaveErrorMsg = kijs.getText(`Es wurden noch nicht alle Felder richtig ausgefüllt`) + '.';
        this._defaultSaveErrorTitle = kijs.getText(`Fehler`) + '.';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            data: { target: 'data', prio: 2000}, // Recordset-Row-Objekt {id:1, caption:'Wert 1'}
            defaultSaveErrorMsg: true,          // Meldung, wenn nicht ausgefüllte Felder vorhanden sind. null wenn keine Meldung.
            rpcSaveFn: true,
            rpcSaveArgs: true
        });

        // Beim Hinzufügen oder Löschen von Kindelementen Felder neu suchen
        this.on('add', () => { this.searchFields(); }, this);
        this.on('remove', () => { this.searchFields(); }, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get data() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        // Evtl. Daten aus Formular holen
        kijs.Array.each(this._fields, function(field) {
            if (field.submitValueEnable) {
                // Bestehendes Recordset mit Daten aus dem Feld ergänzen
                Object.assign(this._data, field.values);
            } else {
                // Wert soll nicht übermittelt werden.
                delete this._data[field.name];
            }
        }, this);

        return this._data;
    }
    set data(val) {
        this._data = val;

        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        // Daten in Formular einfüllen
        kijs.Array.each(this._fields, function(field) {
            field.values = this._data;
            // Feld validieren, wenn nicht leer
            field.validate(true);
            // nicht 'dirty'
            field.isDirty = false;
        }, this);
    }

    get defaultSaveErrorMsg() { return this._defaultSaveErrorMsg; }
    set defaultSaveErrorMsg(val) { this._defaultSaveErrorMsg = val; }

    get fields() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }
        return this._fields;
    }

    // gibt es ein Feld, dass verändert wurde?
    get isDirty() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            if (this._fields[i].isDirty) {
                return true;
            }
        }

        return false;
    }
    // setzt bei allen Felder isDirty auf true oder false
    set isDirty(val) {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            this._fields[i].isDirty = !!val;
        }
    }

    // sind alle Felder leer?
    get isEmpty() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            if (this._fields[i].xtype !== 'kijs.gui.field.Display') {
                if (!this._fields[i].isEmpty) {
                    return false;
                }
            }
        }

        return true;
    }

    // sind alle Felder readOnly?
    get readOnly(){
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            if (this._fields[i].xtype !== 'kijs.gui.field.Display') {
                if (!this._fields[i].readOnly) {
                    return false;
                }
            }
        }

        return true;
    }
    // setzt bei allen Felder readOnly auf true oder false
    set readOnly(val){
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            if (this._fields[i].xtype !== 'kijs.gui.field.Display') {
                this._fields[i].readOnly = !!val;
            }
        }
    }

    get rpcSaveArgs() { return this._rpcSaveArgs; }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }
    
    get rpcSaveFn() { return this._rpcSaveFn; }
    set rpcSaveFn(val) { this._rpcSaveFn = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Löscht allen Werte aus dem Formular
     * @returns {undefined}
     */
    clear() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            if (this._fields[i].xtype !== 'kijs.gui.field.Display') {
                this._fields[i].clear();
                this._fields[i].errorsClear();
            }
        }

        this._data = {};

        // Validierungsfehler auch zurücksetzen
        this.errorsClear();
    }

    /**
     * Setzt die Validierungsfehler zurück.
     * @returns {undefined}
     */
    errorsClear() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            this._fields[i].errorsClear();
        }
    }

    /**
     * Lädt das Formular mit Daten vom Server
     * @param {Object}  [args] Objekt mit Argumenten, die an die remoteFn übergeben werden
     * @param {Boolean} [searchFields=false] Sollen die Formularfelder neu gesucht werden?
     * @param {Boolean} [resetValidation=false] Sollen die Formularfelder als invalid markiert werden?
     * @param {Boolean} [superCall=false]
     * @returns {Promise}
     */
    // overwrite
    load(args=null, searchFields=false, resetValidation=false, superCall=false) {
        return new Promise((resolve) => {
            super.load(args, true).then((e) => {
                let config = e.responseData.config ?? {};

                // Falls des Formular destructed wurde: abbrechen
                if (!this._dom) {
                    resolve(e);
                    return;
                }
                
                if (e.responseData.config && e.responseData.config.elements) {
                    searchFields = true;
                }

                if (searchFields || kijs.isEmpty(this._fields)) {
                    this.searchFields();
                }

                // Formulardaten in Formular einfüllen
                if (config.data) {
                    this.data = config.data;
                }

                // Validierung zurücksetzen?
                if (resetValidation) {
                    this.errorsClear();
                }
                
                // rendern
                this.render();

                // 'afterLoad' auslösen
                if (!superCall) {
                    this.raiseEvent('afterLoad', e);
                }
                
                // promise ausführen
                resolve(e);
            });
        });
    }
    
    /**
     * Sendet die Formulardaten an den Server
     * @param {Boolean} searchFields
     * @param {Boolean} args
     * @param {type} waitMaskTarget
     * @returns {Promise}
     */
    save(searchFields=false, args=null, waitMaskTarget=null) {
        return new Promise((resolve, reject) => {
            if (!kijs.isObject(args)) {
                args = {};
            }
            
            args = Object.assign({}, args, this._rpcSaveArgs);
            
            if (!waitMaskTarget) {
                waitMaskTarget = this;
            }

            if (searchFields || kijs.isEmpty(this._fields)) {
                this.searchFields();
            }

            // Zuerst lokal validieren
            if (!this.validate()) {
                kijs.gui.MsgBox.error(this._defaultSaveErrorTitle, this._defaultSaveErrorMsg);
                return;
            }

            // formData ermitteln
            args.formData = this.data;

            // an den Server senden
            this.rpc.do({
                remoteFn: this.rpcSaveFn,
                owner: this,
                data: args,
                cancelRunningRpcs: false,
                waitMaskTarget: waitMaskTarget,
                waitMaskTargetDomProperty: 'dom',
                context: this
                
            }).then((e) => {
                // Falls des Formular destructed wurde: abbrechen
                if (!this._dom) {
                    resolve(e);
                    return;
                }
                
                // config Properties anwenden, falls vorhanden
                if (e.responseData.config) {
                    // config Properties übernehmen
                    this.applyConfig(e.responseData.config);
                }
                
                // Evtl. Fehler bei den entsprechenden Feldern anzeigen
                if (e.responseData && !kijs.isEmpty(e.responseData.fieldErrors)) {
                    if (!kijs.isEmpty(this._fields)) {
                        kijs.Array.each(this._fields, function(field) {
                            if (e.responseData.fieldErrors[field.name]) {
                                field.errorsAdd(e.responseData.fieldErrors[field.name]);
                            }
                        }, this);
                    }

                    // Falls keine errorMsg übergeben wurde, die Standardmeldung nehmen
                    if (kijs.isEmpty(e.errorTitle) && !kijs.isEmpty(this._defaultSaveErrorTitle)) {
                        e.errorTitle = this._defaultSaveErrorTitle;
                    }
                    if (kijs.isEmpty(e.errorMsg)) {
                        e.errorMsg = this._defaultSaveErrorMsg;
                    }
                }

                // Falls alles OK: 'dirty' zurücksetzen
                if (kijs.isEmpty(e.errorType)) {
                    this.isDirty = false;
                }

                // 'afterSave' auslösen
                this.raiseEvent('afterSave', e);
                
                // Promise auslösen
                resolve(e);
                
            }).catch((ex) => {
                reject(ex);
                
            });
        });
    }

    /**
     * Sucht alle Felder im Formular und schreibt einen Verweis darauf in this._fields
     * (rekursiv)
     * @param {kijs.gui.Container} [parent=this]
     * @returns {Array}
     */
    searchFields(parent=this) {
        let ret = [];

        for (let i=0; i<parent.elements.length; i++) {
            let el = parent.elements[i];

            // field
            if (el instanceof kijs.gui.field.Field && !kijs.isEmpty(el.name)) {
                ret.push(el);

                // blur listener
                if (!el.hasListener('blur', this.#onFieldBlur, this)) {
                    el.on('blur', this.#onFieldBlur, this);
                }

                // change listener
                if (!el.hasListener('change', this.#onFieldChange, this)) {
                    el.on('change', this.#onFieldChange, this);
                }

            // container
            } else if (el instanceof kijs.gui.Container) {
                ret = ret.concat(this.searchFields(el));

            }
        }
        
        if (parent === this) {
            // Felder, die nicht mehr gefunden wurden, werden nicht mehr überwacht.
            if (!kijs.isEmpty(this._fields)) {
                this._fields.forEach((oldField) => {
                    if (ret.indexOf(oldField) === -1) {
                        oldField.off('change', this.#onFieldChange, this);
                    }
                });
            }

            this._fields = ret;
        }

        return ret;
    }

    /**
     * Validiert das Formular (Validierung nur im JavaScript)
     * @returns {Boolean}
     */
    validate() {
        let ret = true;

        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }

        for (let i=0; i<this._fields.length; i++) {
            if (!this._fields[i].validate()) {
                ret = false;
            }
        }

        return ret;
    }

    /**
     * Setzt die Werte der Felder auf den Originalwert zurück
     * @returns {undefined}
     */
    valuesReset() {
        if (kijs.isEmpty(this._fields)) {
            this.searchFields();
        }
        
        for (let i=0; i<this._fields.length; i++) {
            this._fields[i].valuesReset();
        }
    }
    

    // PRIVATE
    // LISTENERS
    #onFieldBlur(e) {
        this.raiseEvent('blur', e);
    }

    #onFieldChange(e) {
        this.raiseEvent('change', e);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Variablen (Objekte/Arrays) leeren
        this._data = null;
        this._fields = null;
        this._rpcSaveArgs = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.Scrollable
// --------------------------------------------------------------
/**
 * Wie kijs.gui.Container, jedoch werden anstelle von Scrollbars Scroll-Buttons angezeigt.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.container.Scrollable
 *
 * CONFIG-Parameter (es gelten auch die Config-Parameter der Basisklassen)
 * ----------------
 * disableSmoothScrolling Boolean [optional] default=false  Sanftes Scrollen ausschalten
 * 
 * scrollableX  Boolean|String [optional] default=false     Soll auf der X-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 * 
 * scrollableY  Boolean|String [optional] default=false     Soll auf der Y-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 *
 * scrollDelay  Number [optional] default=150               Wert in ms. Wenn eine Scroll-Taste 
 *                                                          gehalten wird, wird in diesem Abstand gescrollt
 * 
 * scrollStep   Number [optional] default=20                Anzahl Pixel, die bei einem Klick auf einen
 *                                                          Scroll-Button gescrollt wird
 * 
 * EIGENSCHAFTEN (es gelten auch die Eigenschaften der Basisklassen)
 * -------------
 * scrollableX  Boolean|String [optional] default=false     Soll auf der X-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 * 
 * scrollableY  Boolean|String [optional] default=false     Soll auf der Y-Achse gescrollt werden können?
 *                                                          true=Ja, false=Nein, 'auto'=wenn erforderlich
 *
 *
 * EVENTS
 * ----------
 * 
 */
kijs.gui.container.Scrollable = class kijs_gui_container_Scrollable extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._scrollableX = false;
        this._scrollableY = false;
        this._scrollDeferId = null;
        this._scrollStep = 20;
        this._scrollDelay = 150;
        this._disableSmoothScrolling = false;
        this._touchXStart = null;
        this._touchYStart = null;

        this._btnUpDom = new kijs.gui.Dom({
            cls: 'kijs-btn-scrollup',
            on: {
                mouseDown: this.#onBtnScrollUpMouseDown,
                touchStart: this.#onBtnScrollUpMouseDown,
                dragOver: this.#onBtnScrollUpMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                touchEnd: this.#onBtnScrollMouseUp,
                dragLeave: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        this._btnLeftDom = new kijs.gui.Dom({
            cls: 'kijs-btn-scrollleft',
            on: {
                mouseDown: this.#onBtnScrollLeftMouseDown,
                touchStart: this.#onBtnScrollLeftMouseDown,
                dragOver: this.#onBtnScrollLeftMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                touchEnd: this.#onBtnScrollMouseUp,
                dragLeave: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        this._btnRightDom = new kijs.gui.Dom({
            cls: 'kijs-btn-scrollright',
            on: {
                mouseDown: this.#onBtnScrollRightMouseDown,
                touchStart: this.#onBtnScrollRightMouseDown,
                dragOver: this.#onBtnScrollRightMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                touchEnd: this.#onBtnScrollMouseUp,
                dragLeave: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        this._btnDownDom = new kijs.gui.Dom({
            cls: 'kijs-btn-scrolldown',
            on: {
                mouseDown: this.#onBtnScrollDownMouseDown,
                touchStart: this.#onBtnScrollDownMouseDown,
                dragOver: this.#onBtnScrollDownMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                touchEnd: this.#onBtnScrollMouseUp,
                dragLeave: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        
        this._iconUpEl = new kijs.gui.Icon({
            parent: this,
            name: 'up',
            cls: 'kijs-icon-scrollup'
        });
        
        this._iconLeftEl = new kijs.gui.Icon({
            parent: this,
            name: 'left',
            cls: 'kijs-icon-scrollleft',
            on: {
                mouseDown: this.#onBtnScrollLeftMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        this._iconRightEl = new kijs.gui.Icon({
            parent: this,
            name: 'right',
            cls: 'kijs-icon-scrollright',
            on: {
                mouseDown: this.#onBtnScrollRightMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        this._iconDownEl = new kijs.gui.Icon({
            parent: this,
            name: 'down',
            cls: 'kijs-icon-scrolldown',
            on: {
                mouseDown: this.#onBtnScrollDownMouseDown,
                mouseUp: this.#onBtnScrollMouseUp,
                context: this
            }
        });
        
        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-container-scrollable');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            iconDownMap: 'kijs.iconMap.Fa.chevron-down',
            iconLeftMap: 'kijs.iconMap.Fa.chevron-left',
            iconRightMap: 'kijs.iconMap.Fa.chevron-right',
            iconUpMap: 'kijs.iconMap.Fa.chevron-up'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            disableSmoothScrolling: true,
            scrollableX: { target: 'scrollableX' },
            scrollableY: { target: 'scrollableY' },
            scrollDelay: true,
            scrollStep: true,
            
            iconDown: { target: 'iconDown' },
            iconDownMap: { target: 'iconMap', context: this._iconDownEl },
            iconDownChar: { target: 'iconChar', context: this._iconDownEl },
            iconDownCls: { target: 'iconCls', context: this._iconDownEl },
            iconDownColor: { target: 'iconColor', context: this._iconDownEl },
            
            iconLeft: { target: 'iconLeft' },
            iconLeftMap: { target: 'iconMap', context: this._iconLeftEl },
            iconLeftChar: { target: 'iconChar', context: this._iconLeftEl },
            iconLeftCls: { target: 'iconCls', context: this._iconLeftEl },
            iconLeftColor: { target: 'iconColor', context: this._iconLeftEl },
            
            iconRight: { target: 'iconRight' },
            iconRightMap: { target: 'iconMap', context: this._iconRightEl },
            iconRightChar: { target: 'iconChar', context: this._iconRightEl },
            iconRightCls: { target: 'iconCls', context: this._iconRightEl },
            iconRightColor: { target: 'iconColor', context: this._iconRightEl },

            iconUp: { target: 'iconUp' },
            iconUpMap: { target: 'iconMap', context: this._iconUpEl },
            iconUpChar: { target: 'iconChar', context: this._iconUpEl },
            iconUpCls: { target: 'iconCls', context: this._iconUpEl },
            iconUpColor: { target: 'iconColor', context: this._iconUpEl }
        });
        
        // Listeners
        this.on('afterResize', this.#onAfterResize, this);
        this.on('childElementAfterResize', this.#onChildElementAfterResize, this);
        this.on('scrollEnd', this.#onScrollEnd, this);
        this.on('touchEnd', this.#onTouchEnd, this);
        this.on('touchMove', this.#onTouchMove, this);
        this.on('touchStart', this.#onTouchStart, this);
        this.on('wheel', this.#onWheel, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get disableSmoothScrolling() { return this._disableSmoothScrolling; }
    set disableSmoothScrolling(val) { this._disableSmoothScrolling = val; }
    
    
    get iconDown() { return this._iconDownEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set iconDown(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconDownEl.iconChar = null;
            this._iconDownEl.iconCls = null;
            this._iconDownEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconDownEl.destruct();
            this._iconDownEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconDownEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "iconDown" is not valid.`);

        }
    }

    get iconDownChar() { return this._iconDownEl.iconChar; }
    set iconDownChar(val) { this._iconDownEl.iconChar = val; }

    get iconDownCls() { return this._iconDownEl.iconCls; }
    set iconDownCls(val) { this._iconDownEl.iconCls = val; }

    get iconDownColor() { return this._iconDownEl.iconColor; }
    set iconDownColor(val) { this._iconDownEl.iconColor = val; }

    set iconDownMap(val) { this._iconDownEl.iconMap = val; }
    
    
    get iconLeft() { return this._iconLeftEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set iconLeft(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconLeftEl.iconChar = null;
            this._iconLeftEl.iconCls = null;
            this._iconLeftEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconLeftEl.destruct();
            this._iconLeftEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconLeftEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "iconLeft" is not valid.`);

        }
    }

    get iconLeftChar() { return this._iconLeftEl.iconChar; }
    set iconLeftChar(val) { this._iconLeftEl.iconChar = val; }

    get iconLeftCls() { return this._iconLeftEl.iconCls; }
    set iconLeftCls(val) { this._iconLeftEl.iconCls = val; }

    get iconLeftColor() { return this._iconLeftEl.iconColor; }
    set iconLeftColor(val) { this._iconLeftEl.iconColor = val; }

    set iconLeftMap(val) { this._iconLeftEl.iconMap = val; }
    
    
    get iconRight() { return this._iconRightEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set iconRight(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconRightEl.iconChar = null;
            this._iconRightEl.iconCls = null;
            this._iconRightEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconRightEl.destruct();
            this._iconRightEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconRightEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "iconRight" is not valid.`);

        }
    }

    get iconRightChar() { return this._iconRightEl.iconChar; }
    set iconRightChar(val) { this._iconRightEl.iconChar = val; }

    get iconRightCls() { return this._iconRightEl.iconCls; }
    set iconRightCls(val) { this._iconRightEl.iconCls = val; }

    get iconRightColor() { return this._iconRightEl.iconColor; }
    set iconRightColor(val) { this._iconRightEl.iconColor = val; }

    set iconRightMap(val) { this._iconRightEl.iconMap = val; }
    
    
    get iconUp() { return this._iconUpEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set iconUp(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconUpEl.iconChar = null;
            this._iconUpEl.iconCls = null;
            this._iconUpEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconUpEl.destruct();
            this._iconUpEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconUpEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "iconUp" is not valid.`);

        }
    }

    get iconUpChar() { return this._iconUpEl.iconChar; }
    set iconUpChar(val) { this._iconUpEl.iconChar = val; }

    get iconUpCls() { return this._iconUpEl.iconCls; }
    set iconUpCls(val) { this._iconUpEl.iconCls = val; }

    get iconUpColor() { return this._iconUpEl.iconColor; }
    set iconUpColor(val) { this._iconUpEl.iconColor = val; }

    set iconUpMap(val) { this._iconUpEl.iconMap = val; }
    
    
    // overwrite
    get scrollableX() { return this._scrollableX; };
    // overwrite
    set scrollableX(val) {
        this._scrollableX = val;
        if (this.isRendered) {
            this._renderScrollButtons();
        }
    }
    
    // overwrite
    get scrollableY() { return this._scrollableY; }
    // overwrite
    set scrollableY(val) {
        this._scrollableY = val;
        if (this.isRendered) {
            this._renderScrollButtons();
        }
    }
    
    get scrollDelay() { return this._scrollDelay; }
    set scrollDelay(val) { this._scrollDelay = val; }

    get scrollStep() { return this._scrollStep; }
    set scrollStep(val) { this._scrollStep = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._btnUpDom.changeDisabled(!!val, true);
        this._btnLeftDom.changeDisabled(!!val, true);
        this._btnRightDom.changeDisabled(!!val, true);
        this._btnDownDom.changeDisabled(!!val, true);
    }
    
    // overwrite
    render(superCall) {
        super.render(true);
        
        // Scroll-Buttons rendern/entfernen
        this._renderScrollButtons();
        
        // Zeitverzögert kontrollieren, ob der Inhalt Platz hat oder ob Scrollbuttons nötig sind,
        // wenn Ja: diese noch rendern. Wenn nein: unrendern
        if (this._scrollableX === 'auto' || this._scrollableY === 'auto') {
            kijs.defer(this._renderScrollButtons, 20, this);
            
        // Wenn Scrollbar sichtbar Schaltflächen aktivieren/deaktivieren
        } else if (this._scrollableX || this._scrollableY) {
            kijs.defer(this._updateButtons, 20, this);
        }
        
        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        this._scrollStop();
        
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        this._iconUpEl.unrender();
        this._iconLeftEl.unrender();
        this._iconRightEl.unrender();
        this._iconDownEl.unrender();
        
        this._btnUpDom.unrender();
        this._btnLeftDom.unrender();
        this._btnRightDom.unrender();
        this._btnDownDom.unrender();
        
        super.unrender(true);
    }


    // PROTECTED
    // Scroll-Buttons rendern/entfernen
    _renderScrollButtons() {
        let hasScrollX = false;
        let hasScrollY = false;
        
        if (!this._innerDom || !this._innerDom.node) {
            return;
        }
        
        // Buttons auf X-Achse nötig?
        if (this._scrollableX === 'auto') {
            if (this._innerDom.node.scrollWidth > this._dom.node.clientWidth) {
                hasScrollX = true;
            }
        } else if (this._scrollableX) {
            hasScrollX = true;
        }
        
        // Buttons auf Y-Achse nötig?
        if (this._scrollableY === 'auto') {
            if (this._innerDom.node.scrollHeight > this._dom.node.clientHeight) {
                hasScrollY = true;
            }
        } else if (this._scrollableY) {
            hasScrollY = true;
        }
        
        
        // CSS hinzufügen/entfernen
        if (hasScrollX) {
            this._dom.clsAdd('kijs-scrollable-x-enable');
        } else {
            this._dom.clsRemove('kijs-scrollable-x-enable');
        }
        
        if (hasScrollY) {
            this._dom.clsAdd('kijs-scrollable-y-enable');
        } else {
            this._dom.clsRemove('kijs-scrollable-y-enable');
        }
        
        
        // Rendern oder Unrendern
        // Up (kijs.guiDom)
        if (hasScrollY) {
            this._btnUpDom.renderTo(this._dom.node, this._innerDom.node);
            this._iconUpEl.renderTo(this._btnUpDom.node);
        } else if (this._iconUpEl.isRendered) {
            this._iconUpEl.unrender();
            this._btnUpDom.unrender();
        }

        // Left (kijs.guiDom)
        if (hasScrollX) {
            this._btnLeftDom.renderTo(this._dom.node, this._innerDom.node);
            this._iconLeftEl.renderTo(this._btnLeftDom.node);
        } else if (this._iconLeftEl.isRendered) {
            this._iconLeftEl.unrender();
            this._btnLeftDom.unrender();
        }

        // Right (kijs.guiDom)
        if (hasScrollX) {
            this._btnRightDom.renderTo(this._dom.node);
            this._iconRightEl.renderTo(this._btnRightDom.node);
        } else if (this._iconRightEl.isRendered) {
            this._iconRightEl.unrender();
            this._btnRightDom.unrender();
        }

        // Down (kijs.guiDom)
        if (hasScrollY) {
            this._btnDownDom.renderTo(this._dom.node);
            this._iconDownEl.renderTo(this._btnDownDom.node);
        } else if (this._iconDownEl.isRendered) {
            this._iconDownEl.unrender();
            this._btnDownDom.unrender();
        }
        
        // Schaltflächen aktivieren/deaktivieren
        this._updateButtons();
    }
    
    // starten das Scrollen in eine Richtung
    _scrollStart(dir) {
        // falls bereits gescrollt wird: abbrechen
        this._scrollStop();
        
        let opt = {};
        
        switch (dir) {
            case 'up':    opt.top  = this._innerDom.node.scrollTop + this._scrollStep*-1; break;
            case 'left':  opt.left = this._innerDom.node.scrollLeft + this._scrollStep*-1; break;
            case 'right': opt.left = this._innerDom.node.scrollLeft + this._scrollStep; break;
            case 'down':  opt.top  = this._innerDom.node.scrollTop + this._scrollStep; break;
        }
        
        if (!this._disableSmoothScrolling) {
            opt.behavior = 'smooth';
        }
        
        this._innerDom.node.scrollTo(opt);
        
        this._scrollDeferId = kijs.defer(this._scrollStart, this._scrollDelay, this, dir);
    }
    
    // stoppt das Scrollen
    _scrollStop() {
        if (this._scrollDeferId) {
            clearTimeout(this._scrollDeferId);
            this._scrollDeferId = null;
        }
    }
    
    // Schaltflächen aktivieren/deaktivieren
    _updateButtons() {
        if (!this._innerDom) {
            return;
        }
        
        if (this.disabled) {
            return;
        }
        
        this._btnUpDom.disabled = this._innerDom.node.scrollTop <= 0;
        this._btnLeftDom.disabled = this._innerDom.node.scrollLeft <= 0;
        this._btnRightDom.disabled = Math.abs(this._innerDom.node.scrollWidth - 
                this._innerDom.node.clientWidth - 
                this._innerDom.node.scrollLeft) <= 1;
        this._btnDownDom.disabled = Math.abs(this._innerDom.node.scrollHeight - 
                this._innerDom.node.clientHeight - 
                this._innerDom.node.scrollTop) <= 1;
    }
    
    
    // PRIVATE
    // LISTENERS
    #onBtnScrollDownMouseDown(e) {
        if (!this._btnDownDom.disabled) {
            this._scrollStart('down');
        }
    }
    
    #onBtnScrollLeftMouseDown(e) {
        if (!this._btnLeftDom.disabled) {
            this._scrollStart('left');
        }
    }
    
    #onBtnScrollMouseUp(e) {
        this._scrollStop();
    }
    
    #onBtnScrollRightMouseDown(e) {
        if (!this._btnRightDom.disabled) {
            this._scrollStart('right');
        }
    }
    
    #onBtnScrollUpMouseDown(e) {
        if (!this._btnUpDom.disabled) {
            this._scrollStart('up');
        }
    }
    
    // Wenn die Grösse des Containers verändert wird, müssen evtl. 
    // die Buttons ein-/ausgeblendet werden
    #onAfterResize(e) {
        if (this._scrollableX === 'auto' || this._scrollableY === 'auto') {
            kijs.defer(this._renderScrollButtons, 20, this);
        } else if (this._scrollableX || this._scrollableY) {
            kijs.defer(this._updateButtons, 20, this);
        }
    }
    
    // Wenn die Grösse eines Kind-Elements verändert wird, müssen evtl. 
    // die Buttons ein-/ausgeblendet werden
    #onChildElementAfterResize(e) {
        if (this._scrollableX === 'auto' || this._scrollableY === 'auto') {
            kijs.defer(this._renderScrollButtons, 20, this);
        } else if (this._scrollableX || this._scrollableY) {
            kijs.defer(this._updateButtons, 20, this);
        }
    }
    
    #onScrollEnd(e) {
        // Schaltflächen aktivieren/deaktivieren
        this._updateButtons();
    }
    
    #onTouchEnd(e) {
        // Buttons rendern
        this._renderScrollButtons();
    }

    #onTouchMove(e) {
        const hasScrollbarX = this._dom.clsHas('kijs-scrollable-x-enable');
        const hasScrollbarY = this._dom.clsHas('kijs-scrollable-y-enable');

        const deltaX = this._touchXStart - e.nodeEvent.touches[0].clientX;
        const deltaY = this._touchYStart - e.nodeEvent.touches[0].clientY;

        // Scrollbar auf Y + X Achse
        if (hasScrollbarY && hasScrollbarX) {
            this._innerDom.node.scrollTop += deltaY;
            this._innerDom.node.scrollLeft += deltaX;

            // Scrollbar nur auf Y Achse
        } else if (hasScrollbarY) {
            this._innerDom.node.scrollTop += deltaY;

            // Scrollbar nur auf X Achse
        } else if (hasScrollbarX) {
            this._innerDom.node.scrollLeft += deltaX;
        }

        // Aktuelle Startpunkte setzen
        this._touchXStart = e.nodeEvent.touches[0].clientX;
        this._touchYStart = e.nodeEvent.touches[0].clientY;

        if (hasScrollbarX || hasScrollbarY) {
            // Bubbeling und native Listeners verhindern
            e.nodeEvent.stopPropagation();
            e.nodeEvent.preventDefault();
        }
    }

    #onTouchStart(e) {
        // Startpunkte setzen
        this._touchXStart = e.nodeEvent.touches[0].clientX;
        this._touchYStart = e.nodeEvent.touches[0].clientY;
    }
       
    #onWheel(e) {
        const hasScrollbarX = this._dom.clsHas('kijs-scrollable-x-enable');
        const hasScrollbarY = this._dom.clsHas('kijs-scrollable-y-enable');
        
        // Scrollbar auf Y + X Achse
        if (hasScrollbarY && hasScrollbarX) {
            this._innerDom.node.scrollTop += e.nodeEvent.deltaY;
            this._innerDom.node.scrollLeft += e.nodeEvent.deltaX;
            
        // Scrollbar nur auf Y Achse
        } else if (hasScrollbarY) {
            this._innerDom.node.scrollTop += e.nodeEvent.deltaY;
            
        // Scrollbar nur auf X Achse
        } else if (hasScrollbarX) {
            // Mit dem Mausrad kann auf der X-Achse gescrollt werden
            if (e.nodeEvent.deltaX) {
                this._innerDom.node.scrollLeft += e.nodeEvent.deltaX;
            } else {
                this._innerDom.node.scrollLeft += e.nodeEvent.deltaY;
            }
        }
        
        if (hasScrollbarX || hasScrollbarY) {
            // Bubbeling und native Listeners verhindern
            e.nodeEvent.stopPropagation();
            e.nodeEvent.preventDefault();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._iconUpEl) {
            this._iconUpEl.destruct();
        }
        if (this._iconLeftEl) {
            this._iconLeftEl.destruct();
        }
        if (this._iconRightEl) {
            this._iconRightEl.destruct();
        }
        if (this._iconDownEl) {
            this._iconDownEl.destruct();
        }
        
        if (this._btnUpDom) {
            this._btnUpDom.destruct();
        }
        if (this._btnLeftDom) {
            this._btnLeftDom.destruct();
        }
        if (this._btnRightDom) {
            this._btnRightDom.destruct();
        }
        if (this._btnDownDom) {
            this._btnDownDom.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._iconUpEl = null;
        this._iconLeftEl = null;
        this._iconRightEl = null;
        this._iconDownEl = null;
        
        this._btnUpDom = null;
        this._btnLeftDom = null;
        this._btnRightDom = null;
        this._btnDownDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.Stack
// --------------------------------------------------------------
/**
 * Container Element, dass untergeordnete Elemente beinhalten kann.
 * Es wird jeweils nur ein Element angezeigt. 
 * Die Elemente können mit den currentEl, currentIndex und currentName
 * gewechselt werden.
 * Mit der Funktion setCurrentAnimated() können sie auch animiert gewechselt werden.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.container.Stack
 *
 * CONFIG-Parameter (es gelten auch die Config-Parameter der Basisklassen)
 * ----------------
 * animation           String [optional]     Standard Animation. Gültige Werte:
 *                                              none:           Keine Animation
 *                                              fade:           Überblenden (default)
 *                                              slideLeft:      Ausfahren nach Links
 *                                              slideRight:     Ausfahren nach Rechts
 *                                              slideTop:       Ausfahren nach oben
 *                                              slideBottom:    Ausfahren nach unten
 *
 * animationDuration   Integer [optional]   Dauer der Animation in Milisekunden (default: 1000).
 * 
 * currentEl           kijs.gui.Element [optional] Element, das als erstes angezeigt wird
 * currentIndex        Integer [optional]          Element, das als erstes angezeigt wird (default: 0)
 * currentName         String [optional]           Element, das als erstes angezeigt wird
 * 
 *
 * FUNKTIONEN (es gelten auch die Funktionen der Basisklassen)
 * ----------
 * setCurrentAnimated                       Wechselt das Element mit einer Animation
 *  Args: element   Mixed                   Element, das angezeigt werden soll.
 *                                              String = Name des Elements
 *                                              Int = Index des Elements
 *                                              Object = Verweis auf das Element
 *        animation String [optional]       Art der Animation
 *        duration  Integer [optional]      Dauer der Animation in Milisekunden
 *
 *
 * EIGENSCHAFTEN (es gelten auch die Eigenschaften der Basisklassen)
 * -------------
 *  currentEl           kijs.gui.Element    Gibt das zurzeit aktive Element zurück oder setzt es
 *  currentIndex        Integer [optional]  Gibt das zurzeit aktive Element zurück oder setzt es
 *  currentName         String [optional]   Gibt das zurzeit aktive Element zurück oder setzt es
 *  animation           String              Gibt die Standardanimation zurück oder setzt sie
 *  animationDuration   Integer             Gibt die Standarddauer zurück oder setzt sie
 *
 *
 * EVENTS
 * ----------
 *
 */
kijs.gui.container.Stack = class kijs_gui_container_Stack extends kijs.gui.Container {
    
    
    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._afterAnimationDeferId = null;
        this._animation = 'fade';
        this._animationDuration = 500;

        this._currentEl = null;     // Aktuelles (sichtbaren) Element
        this._elHistory = [];       // Auflistung der Elemente, die als letztes
                                    // angeklickt wurden.
                                    // Mit Hilfe dieser Auflistung kann beim 
                                    // Löschen eines Elements das vorher 
                                    // selektierte wieder ausgewählt werden.
        
        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-container-stack');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            currentIndex: 0
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            currentEl:    { prio: 1001, target: 'currentEl' },
            currentIndex: { prio: 1001, target: 'currentIndex' },
            currentName:  { prio: 1001, target: 'currentName' },
            animation:    { target: 'animation' },
            animationDuration: true
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    
    
    
    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get animation() { return this._animation; }
    set animation(val) {
        if (this._validateAnimation(val)) {
            this._animation = val;
        } else {
            throw new kijs.Error(`unknown animation.`);
        }
    }
    
    get animationDuration() { return this._animationDuration; }
    set animationDuration(val) {
        this._animationDuration = val;
    }
    
    // Aktueller Container ermitteln/setzen
    get currentEl() { return this._currentEl; }
    set currentEl(val) {
        if (!this.hasChild(val)) {
            throw new kijs.Error(`currentEl does not exist in elements.`);
        }
        
        this._setCurrent(val);
        
        this._updateElementsVisibility();
        
        // und neu rendern
        if (val.isRendered) {
           val.render();
        }
    }
    
    // Aktueller Container ermitteln/setzen via Index
    get currentIndex() { return this._getElIndex(this._currentEl); }
    set currentIndex(val) {
        if (this._elements[val]) {
            this.currentEl = this._elements[val];
        }
    }
    
    // Aktueller Container ermitteln/setzen via Name
    get currentName() { 
        if (this._currentEl) {
            return this._currentEl.name;
        } else {
            return null;
        }
    }
    set currentName(val) {
        let elements = this.getElementsByName(val, 0, true);
        if (elements.length === 0) {
            throw new kijs.Error(`currentName does not exist in elements.`);
        } else {
            this.currentEl = elements[0];
        }
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    add(elements, index=null, options={}) {
        super.add(elements, index, options);
    }
    
    // overwrite
    remove(elements, options={}, superCall) {
        if (!superCall) {
            if (!kijs.isArray(elements)) {
                elements = [elements];
            }
            
            if (!options.preventEvents) {
                // beforeRemove Event. Bei Rückgabe=false -> abbrechen
                if (this.raiseEvent('beforeRemove', {removeElements: elements}) === false) {
                    return;
                }
            }
        }
        
        super.remove(elements, options, true);
        
        // Elemente auch aus elHistory entfernen
        kijs.Array.each(elements, function(el) {
            this._elHistoryRemove(el);
        }, this);
        
        // Falls das aktuelle Element gelöscht wurde, das vorherige aktivieren
        if (kijs.Array.contains(elements, this._currentEl)) {
            if (this._elements.length) {
                // Wenn noch eines in der History ist: dieses nehmen
                if (this._elHistory.length) {
                    this.currentEl = this._elHistory[this._elHistory.length-1];
                    
                // sonst das Element mit Index 0 nehmen
                } else {
                    this.currentIndex = 0;
                }
            } else {
                // es gibt keine Elemente
                this._currentEl = null;
            }
        }
    }
    
    // overwrite
    render(superCall) {
        this._updateElementsVisibility();
        super.render(true);
    }
    
    /**
     * Aktuelles Element wechseln und dabei eine Animation abspielen
     * @param {Integer|String|kijs.gui.Element} el
     * @param {String} animation
     * @param {Integer} duration
     * @returns {Promise}
     */
    setCurrentAnimated(el, animation=null, duration=null) {
        return new Promise((resolve, reject) => {
            let oldEl = this._currentEl;
            
            // Event ausführen
            if (this._currentEl.raiseEvent('beforeChange', {element: this._currentEl}) === false) {
                return;
            }
            
            // Argumente
            if (!animation) {
                animation = this._animation;
            }
            if (!duration) {
                duration = this._animationDuration;
            }
            if (animation === 'none') {
                duration = 0;
            }

            if (!this._validateAnimation(animation)) {
                throw new kijs.Error(`unknown animation.`);
            }

            // Element aus Index, Name oder Element ermitteln
            el = this._getElFromIndexNameEl(el);

            // Wenn das Element bereits aktuell ist, ist keine Animation nötig
            if (oldEl === el) {
                return;
            }
            
            // Wenn noch kein Element aktiv ist oder bei Dauer = 0 ist keine 
            // Animation nötig
            if (!oldEl || duration === 0) {
                this.currentEl = el;
                return;
            }

            // Falls bereits eine Animation läuft: Abbrechen
            this._cleanUp();
            if (this._afterAnimationDeferId) {
                window.clearTimeout(this._afterAnimationDeferId);
                this._afterAnimationDeferId = null;
            }
            
            // Altes Element für Animation vorbereiten
            oldEl.dom.clsAdd(this._getAnimationCls(animation, 'out'));
            oldEl.style.animationDuration = duration+ 'ms';

            // Neues Element für Animation vorbereiten
            el.dom.clsAdd(this._getAnimationCls(animation, 'in'));
            el.style.animationDuration = duration + 'ms';
            el.style.zIndex = 1;
            el.visible = true;

            // Das Change Event kommt sofort. Das Promise dann erst nach der Animation
            this._setCurrent(el);

            // Animation abwarten
            this._afterAnimationDeferId = kijs.defer(function() {
                this._afterAnimationDeferId = null;

                // Aufräumen und Sichtbarkeit aktualisieren
                this._updateElementsVisibility();
                this._cleanUp();

                // und neu rendern
                if (el.isRendered) {
                    el.render();
                }
                
                // promise ausführen
                resolve({
                    currentEl: el,
                    oldEl: oldEl
                });
                
            }, duration, this);
        });
    }

    /**
     * Aktiviert das vorherige Element
     * @param {String} animation
     * @param {Integer} duration
     * @returns {Promise}
     */
    setPreviousAnimated(animation=null, duration=null) {
        if (this._elHistory.length > 1) {
            const el = this._elHistory[this._elHistory.length - 2];
            this._elHistory.pop();
            this.setCurrentAnimated(el, animation, duration);
        }
    }
    
    // overwrite
    unrender(superCall) {
        // timer abbrechen
        if (this._afterAnimationDeferId) {
            window.clearTimeout(this._afterAnimationDeferId);
            this._afterAnimationDeferId = null;
        }
        
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        super.unrender(true);
    }
    
    
    // PROTECTED
    // Entfernt CSS-Klassen, zIndex und animationDuration der Animation
    _cleanUp() {
        const animationClasses = [
            'kijs-fade-in',
            'kijs-slide-in-top',
            'kijs-slide-in-right',
            'kijs-slide-in-bottom',
            'kijs-slide-in-left',
            'kijs-fade-out',
            'kijs-slide-out-top',
            'kijs-slide-out-right',
            'kijs-slide-out-bottom',
            'kijs-slide-out-left'
        ];
        
        for (let i=0; i<this._elements.length; i++) {
            // Animations-Klassen entfernen
            this._elements[i].dom.clsRemove(animationClasses);
            
            // zIndex zurücketzen
            this._elements[i].style.zIndex = 0;
            this._elements[i].style.animationDuration = '0s';
        }
    }
    
    // Fügt einen neues Element zur Element History hinzu
    _elHistoryAdd(el) {
        // Falls das element bereits im Array ist: entfernen
        this._elHistory = kijs.Array.remove(this._elHistory, el);
        
        // Neues Element am Ende anfügen
        this._elHistory.push(el);
    }
    
    // Entfernt ein Element aus der Element History.
    _elHistoryRemove(el) {
        this._elHistory = kijs.Array.remove(this._elHistory, el);
    }
    
    _getAnimationCls(animation, dir) {
        let ret = null;
        
        switch (animation) {
            case 'none':        ret = '';                           break;
            case 'fade':        ret = `kijs-fade-${dir}`;            break;
            case 'slideTop':    ret = `kijs-slide-${dir}-top`;       break;
            case 'slideRight':  ret = `kijs-slide-${dir}-right`;     break;
            case 'slideBottom': ret = `kijs-slide-${dir}-bottom`;    break;
            case 'slideLeft':   ret = `kijs-slide-${dir}-left`;      break;
        }
        
        return ret;
    }
    
    // Gibt ein Element anhand eines Index, eines Namens oder einem Element zurück
    _getElFromIndexNameEl(el) {
        // by index
        if (kijs.isInteger(el)) {
            el = this._elements[el];

        // by name
        } else if (kijs.isString(el)) {
            el = this.getElementsByName(el, 0, true).shift();

        }

        if (!el || !kijs.Array.contains(this._elements, el)) {
            throw new kijs.Error(`el does not exist in elements.`);
        }
        
        return el;
    }
    
    // Ermittelt den Index eines Elements
    _getElIndex(el) {
        let index = null;
        
        for (let i=0; i<this._elements.length; i++) {
            if (this._elements[i] === el) {
                index = i;
                break;
            }
        }
        
        return index;
    }
    
    // Setzt das aktuelle Element und wirft das change-Event
    _setCurrent(element) {
        if (element !== this._currentEl) {
            let oldEl = this._currentEl;
            
            this._elHistoryAdd(element);
            this._currentEl = element;
            if (this.isRendered) {
                this.raiseEvent('change', {currentEl: element, oldEl: oldEl});
            }
        }
    }
    
    // nur das currentEl ist sichtbar, alle anderen werden ausgeblendet
    _updateElementsVisibility() {
        // Falls es noch kein aktuelles Element gibt
        if (!this._currentEl) {
            if (this._elements.length) {
                // Wenn noch eines in der History ist: dieses nehmen
                if (this._elHistory.length) {
                    this.currentEl = this._elHistory[this._elHistory.length-1];
                // sonst das Element mit Index 0 nehmen
                } else {
                    this.currentIndex = 0;
                }
            } else {
                // es gibt keine Elemente
                this._currentEl = null;
            }
        }
        
        for (let i=0; i<this._elements.length; i++) {
            this._elements[i].visible = this._elements[i] === this._currentEl;
        }
    }
    
    // Überprüft, ob eine animation gültig ist
    _validateAnimation(animation) {
        return this._getAnimationCls(animation, 'in') !== null;
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._currentEl = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.DropZone
// --------------------------------------------------------------
/**
 * DropZone für Dateitransfer. Dem Container wird beim Dragover eine CSS-Klasse zugewiesen, um die Zone zu markieren.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.DropZone
 *
 * CONFIG-Parameter (es gelten auch die Config-Parameter der Basisklassen)
 * ----------------
 * contentTypes    Array|String Ein (oder ein Array von) Content-Types. z.B. "image/jpeg" für JPG's oder nur "image" alle Bildtypen.
 *
 * FUNKTIONEN (es gelten auch die Funktionen der Basisklassen)
 * ----------
 *
 *
 * EIGENSCHAFTEN (es gelten auch die Eigenschaften der Basisklassen)
 * -------------
 * contentTypes
 *
 *
 * EVENTS
 * ----------
 *
 *
 */
kijs.gui.DropZone = class kijs_gui_DropZone extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dragOverCls = 'kijs-dragover';
        this._dragOverForbiddenCls = 'kijs-dragover-forbidden';
        this._contentTypes = [];
        this._multiple = true;
        this._validMediaTypes = [
            'application',
            'audio',
            'example',
            'image',
            'message',
            'model',
            'multipart',
            'text',
            'video'
        ];

        // CSS
        this._dom.clsAdd('kijs-dropzone');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            dragOverCls: true,
            dragOverForbiddenCls: true,
            contentTypes: { target: 'contentTypes' }
        });

        // Drag-Events kommen nicht vom Element, sondern von dieser Klasse
        this._eventForwardsRemove('dragEnter', this._dom);
        this._eventForwardsRemove('dragOver', this._dom);
        this._eventForwardsRemove('dragLeave', this._dom);
        this._eventForwardsRemove('drop', this._dom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events für DOM mappen
        this._dom.on('dragEnter', this.#onDragEnter, this);
        this._dom.on('dragOver', this.#onDragOver, this);
        this._dom.on('dragLeave', this.#onDragLeave, this);
        this._dom.on('drop', this.#onDrop, this);

    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get contentTypes() { return this._contentTypes; }
    set contentTypes(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        
        this._contentTypes = [];
        
        kijs.Array.each(val, function(contentType) {
            let parts = contentType.toLowerCase().split('/', 2);
            if (!kijs.Array.contains(this._validMediaTypes, parts[0])) {
                throw new kijs.Error('invalid content type "' + contentType + '"');
            }
            this._contentTypes.push(parts.join('/'));
        }, this);
    }

    get multiple() { return this._multiple; }

    set multiple(val) { this._multiple = val; }

    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    _checkMime(dataTransferItems) {
        for (let i=0; i<dataTransferItems.length; i++) {
            if (dataTransferItems[i].type) {
                let mime = dataTransferItems[i].type.toLowerCase();
                let mimeParts = dataTransferItems[i].type.split('/', 2);
                if (!kijs.Array.contains(this._contentTypes, mime) && !kijs.Array.contains(this._contentTypes, mimeParts[0] + '/*')) {
                    return false;
                }
            }
        }
        return true;
    }


    // PRIVATE
    // LISTENERS
    #onDragEnter(e) {
        if (!this.disabled) {
            this._dom.clsAdd(this._dragOverCls);
            this.raiseEvent('dragEnter', e);
        }
    }

    #onDragLeave(e) {
        if (!this.disabled) {
            this._dom.clsRemove(this._dragOverCls);
            this._dom.clsRemove(this._dragOverForbiddenCls);
            this.raiseEvent('dragLeave', e);
        }
    }

    #onDragOver(e) {
        e.nodeEvent.preventDefault();

        if (!this.disabled) {
            // 'forbidden' Klasse, falls ungültiger Dateityp
            let valid = true;
            if (e.nodeEvent.dataTransfer && e.nodeEvent.dataTransfer.items && this._contentTypes.length > 0) {
                if (!this._checkMime(e.nodeEvent.dataTransfer.items)) {
                    valid = false;
                    this._dom.clsAdd(this._dragOverForbiddenCls);
                }
            }
            e.validMime = valid;

            // 'forbidden' Klasse, falls nicht mehrere Dateien hinzugefügt werden dürfen
            let allowed = true;
            if (e.nodeEvent.dataTransfer && e.nodeEvent.dataTransfer.items) {
                if (!this._multiple && e.nodeEvent.dataTransfer.items.length > 1) {
                    allowed = false;
                    this._dom.clsAdd(this._dragOverForbiddenCls);
                }
            }
            e.allowed = allowed;

            this._dom.clsAdd(this._dragOverCls);
            this.raiseEvent('dragOver', e);
        }
    }

    #onDrop(e) {
        e.nodeEvent.preventDefault();

        if (!this.disabled) {
            this._dom.clsRemove(this._dragOverCls);
            this._dom.clsRemove(this._dragOverForbiddenCls);

            // Dateityp überprüfen
            let valid = true;
            if (e.nodeEvent.dataTransfer && e.nodeEvent.dataTransfer.items && this._contentTypes.length > 0) {
                if (!this._checkMime(e.nodeEvent.dataTransfer.items)) {
                    valid = false;
                }
            }

            e.validMime = valid;

            // Mehrfachauswahl prüfen
            let allowed = true;
            if (!this._multiple && e.nodeEvent.dataTransfer && e.nodeEvent.dataTransfer.items && e.nodeEvent.dataTransfer.items.length > 1) {
                allowed = false;
            }
            e.allowed = allowed;

            this.raiseEvent('drop', e);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Variablen (Objekte/Arrays) leeren
        this._dragOverCls = null;
        this._dragOverForbiddenCls = null;
        this._contentTypes = null;
        this._multiple = null;
        this._validMediaTypes = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.SpinBox
// --------------------------------------------------------------
kijs.gui.SpinBox = class kijs_gui_SpinBox extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._ownPos = 'tl';        // Ankerpunkt bei der Spin Box
        this._targetPos = 'bl';     // Ankerpunkt beim Zielelement
                                    //       tl --- t --- tr
                                    //       |             |
                                    //       l      c      r
                                    //       |             |
                                    //       bl --- b --- br

        this._allowSwapX = true;    // Swappen möglich auf X-Achse?
        this._allowSwapY = true;    // Swappen möglich auf Y-Achse?

        this._autoSize = 'min';     // Grösse (je nach Pos die Breite oder Höhe) an das targetEl anpassen.
                                    // Werte: 'min' Grösse ist mind. wie beim targetEl
                                    //        'max' Grösse ist höchstens wie beim targetEl
                                    //        'fit' Grösse ist gleich wie beim targetEl
                                    //        'none' Grösse wird nicht angepasst

        this._offsetX = 0;           // Verschiebung aus dem Ankerpunkt auf der X-Achse
        this._offsetY = 0;           // Verschiebung aus dem Ankerpunkt auf der Y-Achse

        this._ownerNodes = [this._dom]; // Events auf diesen kijs.gui.Dom oder HTMLNodes werden ignoriert, die SpinBox wird nicht geschlossen

        this._preventHide = false;  // das Ausblenden der SpinBox verhindern

        this._targetEl = null;              // Zielelement (kijs.gui.Element)
        this._targetDomProperty = 'dom';    // Dom-Eigenschaft im Zielelement (String)
        this._autoWidth = true;

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-spinbox');
        this._dom.nodeAttributeSet('popover', 'manual');


        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            allowSwapX: true,
            allowSwapY: true,
            autoSize: { target: 'autoSize' },
            offsetX: true,
            offsetY: true,
            ownPos: true,
            targetPos: true,
            target: { target: 'target' },
            targetDomProperty: true,
            ownerNodes: { fn: 'appendUnique', target: '_ownerNodes' }
        });

        // Listener
        this.on('keyDown', this.#onKeyDown, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get allowSwapX() { return this._allowSwapX; }
    set allowSwapX(val) { this._allowSwapX = !!val; }

    get allowSwapY() { return this._allowSwapY; }
    set allowSwapY(val) { this._allowSwapY = !!val; }

    get autoSize() { return this._autoSize; }
    set autoSize(val) {
        if (kijs.Array.contains(['min', 'max', 'fit', 'none'], val)) {
            this._autoSize = val;
        } else {
            throw new kijs.Error(`Unknown format on config "autoSize"`);
        }
    }

    get offsetX() { return this._offsetX; }
    set offsetX(val) { this._offsetX = val; }

    get offsetY() { return this._offsetY; }
    set offsetY(val) { this._offsetY = val; }

    get ownPos() { this._ownPos; }
    set ownPos(val) {
        if (kijs.Array.contains(['tl', 't', 'tr', 'l', 'c', 'r', 'bl', 'b', 'br'], val)) {
            this._ownPos = val;
        } else {
            throw new kijs.Error(`Unknown format on config "pos"`);
        }
    }
    
    // overwrite, damit overflow beim dom statt innerDom zugewiesen wird
    get scrollableX() {
        if (this._dom.clsHas('kijs-scrollable-x-enable')) {
            return true;
        } else if (this._dom.clsHas('kijs-scrollable-x-auto')) {
            return 'auto';
        } else {
            return false;
        }
    }
    set scrollableX(val) {
        this._dom.clsRemove('kijs-scrollable-x-enable');
        this._dom.clsRemove('kijs-scrollable-x-auto');
        
        if (val === 'auto') {
            this._dom.clsAdd('kijs-scrollable-x-auto');
        } else if(val) {
            this._dom.clsAdd('kijs-scrollable-x-enable');
        }
    }
    
    // overwrite, damit overflow beim dom statt innerDom zugewiesen wird
    get scrollableY() {
        if (this._dom.clsHas('kijs-scrollable-y-enable')) {
            return true;
        } else if (this._dom.clsHas('kijs-scrollable-y-auto')) {
            return 'auto';
        } else {
            return false;
        }
    }
    set scrollableY(val) {
        this._dom.clsRemove('kijs-scrollable-y-enable');
        this._dom.clsRemove('kijs-scrollable-y-auto');
            
        if (val === 'auto') {
            this._dom.clsAdd('kijs-scrollable-y-auto');
        } else if(val) {
            this._dom.clsAdd('kijs-scrollable-y-enable');
        }
    }

    get target() {
        return this._targetEl;
    }
    set target(val) {
        // Evtl. Listeners vom alten _targetEl entfernen
        if (!kijs.isEmpty(this._targetEl)) {
            this._targetEl.off('keyDown', this.#onTargetElKeyDown, this);
        }

        if (val instanceof kijs.gui.Element) {
            this._targetEl = val;
            this._targetEl.on('keyDown', this.#onTargetElKeyDown, this);

        } else if (val === null) {
            this._targetEl = null;

        } else {
            throw new kijs.Error(`Unknown format on config "target"`);

        }
    }

    get targetDomProperty() { return this._targetDomProperty; };
    set targetDomProperty(val) { this._targetDomProperty = val; };

    /**
     * Gibt den Ziel-Node zurück, über den die Maske gelegt wird
     * @returns {HTMLElement}
     */
    get targetNode() {
        return this._targetEl ? this._targetEl[this._targetDomProperty].node : null;
    }


    get targetPos() { this._targetPos; }
    set targetPos(val) {
        if (kijs.Array.contains(['tl', 't', 'tr', 'l', 'c', 'r', 'bl', 'b', 'br'], val)) {
            this._targetPos = val;
        } else {
            throw new kijs.Error(`Unknown format on config "targetPos"`);
        }
    }

    // overwrite
    get width() { return super.width; }
    set width(val) {
        this._autoWidth = kijs.isNumeric(val) ? false : true;
        super.width = val;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Schliesst die SpinBox
     * @returns {undefined}
     */
    close() {
        // bei allen übergeordneten Spinboxes die aktuelle Spinbox wieder rausnehmen.
        // Siehe dazu auch den Kommentar in der Funktion show()
        let p = this.parent;
        while (p) {
            if (p instanceof kijs.gui.SpinBox) {
                p.ownerNodeRemove(this);
            }
            p = p.parent;
        }

        this.unrender();
        this.raiseEvent('close');
    }

    /**
     * Fügt eine Node hinzu, bei Klick auf diese wird das Fenster nicht geschlossen.
     * @param {kijs.gui.Element|kijs.gui.Dom|DOMElement} ownerNode
     * @returns {undefined}
     */
    ownerNodeAdd(ownerNode) {
        if (!kijs.Array.contains(this._ownerNodes, ownerNode)) {
            this._ownerNodes.push(ownerNode);
        }

        if (ownerNode instanceof kijs.gui.Element) {
            ownerNode = ownerNode.dom;
        }
        if (ownerNode instanceof kijs.gui.Dom) {
            ownerNode = ownerNode.node;
        }
        if (ownerNode) {
            kijs.Dom.addEventListener('mousedown', ownerNode, this.#onNodeMouseDown, this);
            kijs.Dom.addEventListener('resize', ownerNode, this.#onNodeResize, this);
            kijs.Dom.addEventListener('wheel', ownerNode, this.#onNodeWheel, this);
        }
    }

    /**
     * Entfernt eine Node aus den überwachten elementen
     * @param {kijs.gui.Element|kijs.gui.Dom|DOMElement} ownerNode
     * @param {Bool} removeFromObservedNodes soll die Node von der Überwachung entfernt werden?
     * @returns {undefined}
     */
    ownerNodeRemove(ownerNode, removeFromObservedNodes=true) {
        if (removeFromObservedNodes) {
            kijs.Array.remove(this._ownerNodes, ownerNode);
        }

        if (ownerNode instanceof kijs.gui.Element) {
            ownerNode = ownerNode.dom;
        }
        if (ownerNode instanceof kijs.gui.Dom) {
            ownerNode = ownerNode.node;
        }
        if (ownerNode) {
            kijs.Dom.removeEventListener('mousedown', ownerNode, this);
            kijs.Dom.removeEventListener('resize', ownerNode, this);
            kijs.Dom.removeEventListener('wheel', ownerNode, this);
        }
    }

    /**
     * Zeigt die SpinBox an
     * @param {Number|null} x X-Koordinate (null, falls an target ausgerichtet werden soll)
     * @param {Number|null} y Y-Koordinate (null, falls an target ausgerichtet werden soll)
     * @returns {undefined}
     */
    show(x=null, y=null) {
        if (this.isRendered) {
            return;
        }

        // SpinBox anzeigen
        this.renderTo(this.targetNode ?? document.body);

        // popover mode
        this._dom.node.showPopover();

        // Workaround um die Breite zu rechnen.
        // Ist z.T. nötig, damit sich die Breite richtig an die Breite des Inhalts anpasst,
        // auch wenn der Inhalt keine definierte Breite hat (z.B. bei einem Menu).
        this._widthWorkaround();

        // Ausrichten
        if ((kijs.isNumber(x) && kijs.isNumber(y)) || this._targetEl) {
            this._adjustPositionToTarget(x, y, true);
        }

        // allen übergeordneten Spinboxes mitteilen, dass beim Klick auf dieses Element
        // die Spnbox nicht geschlossen werden soll.
        let p = this.parent;
        while (p) {
            if (p instanceof kijs.gui.SpinBox) {
                p.ownerNodeAdd(this);
            }
            p = p.parent;
        }

        // afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);

        if (this._targetEl) {
            this._targetEl.focus();
        }

        // Listeners auf body/window zum ausblenden
        kijs.Dom.addEventListener('mousedown', document.body, this.#onBodyMouseDown, this);
        kijs.Dom.addEventListener('resize', window, this.#onWindowResize, this);
        kijs.Dom.addEventListener('wheel', window, this.#onWindowWheel, this);

        // Listeners auf die _ownerNodes die das Ausblenden verhindern
        kijs.Array.each(this._ownerNodes, function(ownerNode) {
            this.ownerNodeAdd(ownerNode);
        }, this);

        this.raiseEvent('show');
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // hide popover
        if (this._dom.node) {
            this._dom.node.hidePopover();
        }

        kijs.Dom.removeEventListener('mousedown', document.body, this);
        kijs.Dom.removeEventListener('resize', window, this);
        kijs.Dom.removeEventListener('wheel', window, this);

        kijs.Array.each(this._ownerNodes, function(ownerNode) {
            this.ownerNodeRemove(ownerNode, false);
        }, this);

        super.unrender(true);
    }


    // PROTECTED
    /**
     * Richtet die SpinBox am Target aus
     * @param {Number|null} [x=null]            // X-Koordinate
     * @param {Number|null} [y=null]            // Y-Koordinate
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    _adjustPositionToTarget(x=null, y=null, preventEvents=false) {
        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        // Evtl. Grösse automatisch anpassen
        if (this._autoSize !== 'none') {
            // Breite anpassen
            if ( (this._targetPos.indexOf('t') !== -1 || this._targetPos.indexOf('b') !== -1) &&
                    (this._ownPos.indexOf('t') !== -1 || this._ownPos.indexOf('b') !== -1) ) {
                
                let width = 0;
                if (this._targetEl) {
                    if (this._targetEl.hasOwnProperty('spinBoxWidth')) {
                        width = this._targetEl.spinBoxWidth;
                    } else {
                        width = this._targetEl[this.targetDomProperty].width;
                    }
                }
                
                switch (this._autoSize) {
                    case 'min': this.style.minWidth = width + 'px'; break;
                    case 'max': this.style.maxWidth = width + 'px'; break;
                    case 'fit': this.style.width = width + 'px'; break;
                }

            // Höhe anpassen
            } else if ( (this._targetPos.indexOf('l') !== -1 || this._targetPos.indexOf('r') !== -1) &&
                    (this._ownPos.indexOf('l') !== -1 || this._ownPos.indexOf('r') !== -1) ) {
                
                let height = 0;
                if (this._targetEl) {
                    if (this._targetEl.hasOwnProperty('spinBoxHeight')) {
                        height = this._targetEl.spinBoxHeight;
                    } else {
                        height = this._targetEl.height;
                    }
                }
                
                switch (this._autoSize) {
                    case 'min': this.style.minHeight = height + 'px'; break;
                    case 'max': this.style.maxHeight = height + 'px'; break;
                    case 'fit': this.style.height = height + 'px'; break;
                }
            }
        }

        // Aurichten an X, Y
        let positions = null;
        if (kijs.isNumber(x) && kijs.isNumber(y)) {
            positions = this._dom.alignToRect(
                {x: x, y: y, w: 0, h: 0},
                this._targetPos,
                this._ownPos,
                this._allowSwapX,
                this._allowSwapY,
                this._offsetX,
                this._offsetY
            );

        // Ausrichten an Node
        } else {
            positions = this._dom.alignToTarget(
                this.targetNode,
                this._targetPos,
                this._ownPos,
                this._allowSwapX,
                this._allowSwapY,
                this._offsetX,
                this._offsetY
            );
        }

        // Je nach Position eine CSS-Klasse zuweisen
        let cls = '';
        if (positions.targetPos.indexOf('t') !== -1 && positions.pos.indexOf('b') !== -1) {
            cls = 'kijs-pos-top';
        } else if (positions.targetPos.indexOf('b') !== -1 && positions.pos.indexOf('t') !== -1) {
            cls = 'kijs-pos-bottom';
        } else if (positions.targetPos.indexOf('l') !== -1 && positions.pos.indexOf('r') !== -1) {
            cls = 'kijs-pos-left';
        } else if (positions.targetPos.indexOf('r') !== -1 && positions.pos.indexOf('l') !== -1) {
            cls = 'kijs-pos-right';
        }
        this._dom.clsRemove(['kijs-pos-top', 'kijs-pos-bottom', 'kijs-pos-left', 'kijs-pos-right']);
        if (cls) {
            this._dom.clsAdd(cls);
        }

        // afterResize-Event wieder zulassen
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        if (!preventEvents && this._hasSizeChanged()) {
            this._raiseAfterResizeEvent(true);
        }
    }


    /**
     * Workaround um die Breite zu rechnen.
     * Ist z.T. nötig, damit sich die Breite richtig an die Breite des Inhalts anpasst,
     * auch wenn der Inhalt keine definierte Breite hat (z.B. bei einem Menu).
     * Schaut, wie breit das Element ohne Scrollbar ist, und stellt diese Fix ein.
     * @returns {undefined}
     */
    _widthWorkaround() {
        if (this._autoWidth && this.scrollableY) {
            let currentScrollableY = this.scrollableY;
            this.scrollableY = false;
            this._dom.width = null;
            let pos = kijs.Dom.getAbsolutePos(this._dom.node);
            let sbw = kijs.Dom.getScrollbarWidth();
            let w = pos.w + sbw + 10;

            this._dom.width = w;
            this.scrollableY = currentScrollableY;
        }
    }


    // PRIVATE
    // LISTENERS
    #onBodyMouseDown(e) {
        if (!this._preventHide) {
            this.close();
        }
        this._preventHide = false;
    }

    #onKeyDown(e) {
        switch (e.nodeEvent.code) {
            case 'Escape':
            case 'F4':
            case 'Tab':
                this.close();
                break;
        }
    }

    // Wir nutzen das Bubbeling der Events um auszuschliessen, dass die Events vom Node kommen.
    // Das Event kommt zuerst beim Node und wir setzen _preventHide=true
    // Dann kommt das Event beim Body und wenn die Variable _preventHide!==true ist, kann ausgeblendet werden
    #onNodeMouseDown(e) {
        this._preventHide = true;
    }

    #onNodeResize(e) {
        this._preventHide = true;
    }

    #onNodeWheel(e) {
        this._preventHide = true;
    }

    #onTargetElKeyDown(e) {
        switch (e.nodeEvent.code) {
            case 'Escape':
            case 'Tab':
                this.close();
                break;

            case 'F4':
                if (this.isRendered) {
                    this.close();
                } else {
                    this.show();
                }
                break;

            case 'ArrowDown':
                this.show();
                break;
        }
    }
    
    #onWindowResize(e) {
        if (!this._preventHide) {
            this.close();
        }
        this._preventHide = false;
    }

    #onWindowWheel(e) {
        if (!this._preventHide) {
            this.close();
        }
        this._preventHide = false;
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Event-Listeners entfernen
        if (this._targetEl) {
            this._targetEl.off(null, null, this);
        }


        // Variablen (Objekte/Arrays) leeren
        this._targetEl = null;
        this._ownerNodes = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.ViewPort
// --------------------------------------------------------------
kijs.gui.ViewPort = class kijs_gui_ViewPort extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._autoTheme = false;
        this._dom.node = document.body;

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-viewport');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableDrop: true,
            disableContextMenu: false,
            theme: null
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            disableDrop: { target: 'disableDrop' },
            disableContextMenu: { target: 'disableContextMenu' },
            theme: { target: 'theme'}         // 'dark', 'light' oder null=auto oder einen benutzerdefiniertes Farbschema
        });

        // onResize überwachen
        kijs.Dom.addEventListener('resize', window, this.#onWindowResize, this);

        // dark mode change überwachen
        kijs.Dom.addEventListener('change', window.matchMedia('(prefers-color-scheme: dark)'), this.#onDarkModeChange, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get disableContextMenu() {
        return kijs.Dom.hasEventListener('contextmenu', document.body, this);
    }
    set disableContextMenu(val) {
        if (val === true) {
            // Standardmässig öffnet der Browser das Kontextmenu
            kijs.Dom.addEventListener('contextmenu', document.body, function(e) {
                e.nodeEvent.preventDefault();
            }, this);

        } else if (val === false) {
            kijs.Dom.removeEventListener('contextmenu', document.body, this);

        } else {
           throw new kijs.Error('invalid value for property "disableContextMenu" in kijs.gui.ViewPort');
        }
    }

    get disableDrop() {
        return kijs.Dom.hasEventListener('dragover', window, this) && kijs.Dom.hasEventListener('drop', window, this);
    }
    set disableDrop(val) {
        if (val === true) {
            // Standardmässig öffnet der Browser das Dokument, wenn
            // es über einer Webseite verschoben wird. Mittels preventDefault
            // wird sichergestellt, dass in diesem Fall nichts passiert.
            kijs.Dom.addEventListener('dragover', window, function(e) {
                e.nodeEvent.preventDefault();
            }, this);
            kijs.Dom.addEventListener('drop', window, function(e) {
                e.nodeEvent.preventDefault();
            }, this);

        } else if (val === false) {
            kijs.Dom.removeEventListener('dragover', window, this);
            kijs.Dom.removeEventListener('drop', window, this);

        } else {
           throw new kijs.Error('invalid value for property "disableDrop" in kijs.gui.ViewPort');
        }
    }

    get theme() {
        return kijs.Dom.themeGet();
    }
    // Farbschema aktivieren. 'light', 'dark' oder null=auto oder einen benutzerdefiniertes Farbschema
    set theme(val) {
        kijs.Dom.themeSet(val);
        this._autoTheme = val === null;
        if (this.isRendered) {
            this.render();
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    render(superCall) {
        super.render(true);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }

        // afterResize-Event auslösen
        this._raiseAfterResizeEvent(true);
    }


    // PRIVATE
    // LISTENERS
    #onWindowResize(e) {
        this._raiseAfterResizeEvent(true, e);
    }

    #onDarkModeChange(e) {
        if (this._autoTheme) {
            this.theme = null; // set to null to get the current browser theme
        }
    }


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Listener entfernen
        kijs.Dom.removeAllEventListenersFromContext(this);

        // Basisklasse auch entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Icon
// --------------------------------------------------------------
kijs.gui.Icon = class kijs_gui_Icon extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._iconCls = null;
        this._iconSize = null;
        this._iconMapName = null;

        this._dom.nodeTagName = 'span';
        this._dom.clsAdd('kijs-icon');
        this._dom.htmlDisplayType = 'code';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            iconMap: { target: 'iconMap', prio: 1 },
            iconChar: { target: 'iconChar', prio: 2 },
            iconCls: { target: 'iconCls', prio: 2 },
            iconColor: { target: 'iconColor', prio: 2 },
            iconSize: { target: 'iconSize', prio: 2 }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get iconChar() {
        let chr = kijs.toString(this._dom.html);
        if (chr.length > 0) {
            return chr.codePointAt(0);
        }
        return '';
    }
    set iconChar(val) {
        if (kijs.isString(val) && val.substr(0,2) === '&#') {
            console.warn('DEPRECATED: set iconChar with HTML entity instead of Number');
            val = kijs.String.htmlentities_decode(val).codePointAt(0);

        } else if (!kijs.isInteger(val)) {
            val = parseInt(val);
        }

        this._dom.html = kijs.isInteger(val) ? String.fromCodePoint(val) : '';
    }

    get iconCls() { return this._iconCls; }
    set iconCls(val) {
        if (kijs.isEmpty(val)) {
            val = null;
        }
        if (!kijs.isString && !val) {
            throw new kijs.Error(`config "iconCls" is not a string`);
        }
        if (this._iconCls) {
            this._dom.clsRemove(this._iconCls);
        }
        this._iconCls = val;
        if (this._iconCls) {
            this._dom.clsAdd(this._iconCls);
        }
    }

    get iconColor() { return this._dom.style.color; }
    set iconColor(val) { this._dom.style.color = val; }

    get iconMap() {
        let ret = {};
        if (this.iconChar) {
            ret.char = this.iconChar;
        }
        if (this.iconCls) {
            ret.cls = this.iconCls;
        }
        if (this.iconColor) {
            ret.color = this.iconColor;
        }
        if (this.iconStyle) {
            ret.style = this.iconStyle;
        }
        return ret;
    }
    set iconMap(val) {
        if (kijs.isString(val) && val) {
            const obj = kijs.getObjectFromString(val);
            if (kijs.isEmpty(obj)) {
                throw new kijs.Error(`Unknown iconMap "${val}".`);
            }
            this._iconMapName = val;
            val = obj;
        } else {
            this._iconMapName = null;
        }

        if (kijs.isEmpty(val)) {
            this.iconChar = '';
            
        } else {
            if (kijs.isDefined(val.char)) {
                this.iconChar = val.char;
            }
            if (kijs.isDefined(val.cls)) {
                this.iconCls = val.cls;
            }
            if (kijs.isDefined(val.color)) {
                this.iconColor = val.color;
            }
            if (kijs.isDefined(val.style)) {
                Object.assign(this.style, val.style);
            }
        }
    }
    
    get iconMapName() { return this._iconMapName; }
    set iconMapName(val) { this.iconMap = val; }

    get iconSize() { return this._iconSize; }
    set iconSize(val) {
        if (val && !kijs.isInteger(val)) {
            throw new kijs.Error(`invalid value for kijs.gui.Icon attribute: iconSize=` + val);
        }
        this._iconSize = val;

        // Buchstaben-Grösse mittels fontSize festlegen
        if (this.iconChar) {
            if (val === 16 || !val) { // 16: default css size
                this.style.fontSize = null;
            } else {
                this.style.fontSize = val + 'px';
            }

        // icon-Grösse mittels w&h festlegen
        } else if (this.iconCls) {
            if (!val) {
                this.style.width = null;
                this.style.height = null;
                this.style.backgroundSize = null;
            } else {
                this.style.width = val + 'px';
                this.style.height = val + 'px';
                this.style.backgroundSize = val + 'px ' + val + 'px';
            }
        }
    }

    get isEmpty() {
        return kijs.isEmpty(this._dom.html) && kijs.isEmpty(this._iconCls);
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._dom.changeDisabled(!!val, true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Button
// --------------------------------------------------------------
kijs.gui.Button = class kijs_gui_Button extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._smallPaddings = 'auto';
        
        this._captionDom = new kijs.gui.Dom({
            cls: 'kijs-caption',
            nodeTagName: 'span'
        });

        this._iconEl = new kijs.gui.Icon({ parent: this });
        this._icon2El = new kijs.gui.Icon({ parent: this, cls:'kijs-icon2' });

        this._menuEl = null;

        this._badgeDom = new kijs.gui.Dom({
            cls: 'kijs-badge',
            nodeTagName: 'span'
        });

        this._dom.nodeTagName = 'button';
        this._dom.nodeAttributeSet('type', 'button');

        this._dom.clsAdd('kijs-button');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableFlex: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            badgeText: { target: 'html', context: this._badgeDom },
            badgeCls: { fn: 'function', target: this._badgeDom.clsAdd, context: this._badgeDom },
            badgeTextHtmlDisplayType: { target: 'htmlDisplayType', context: this._badgeDom },
            badgeStyle: { fn: 'assign', target: 'style', context: this._badgeDom },
            caption: { target: 'html', context: this._captionDom },
            captionCls: { fn: 'function', target: this._captionDom.clsAdd, context: this._captionDom },
            captionHtmlDisplayType: { target: 'htmlDisplayType', context: this._captionDom },
            captionStyle: { fn: 'assign', target: 'style', context: this._captionDom },
            disableFlex: { target: 'disableFlex' }, // false=ganze Breite wird genutzt, true=nur die benötigte Breite wird genutzt
            smallPaddings: true,                    // false=breite Abstände, true=schmale Abstände, 'auto'=automatisch (default)
            icon: { target: 'icon' },
            iconMap: { target: 'iconMap', context: this._iconEl },
            iconChar: { target: 'iconChar', context: this._iconEl },
            iconCls: { target: 'iconCls', context: this._iconEl },
            iconColor: { target: 'iconColor', context: this._iconEl },
            icon2: { target: 'icon2' },
            icon2Map: { target: 'iconMap', context: this._icon2El },
            icon2Char: { target: 'iconChar', context: this._icon2El },
            icon2Cls: { target: 'iconCls', context: this._icon2El },
            icon2Color: { target: 'iconColor', context: this._icon2El },
            isDefault: { target: 'isDefault' },
            menu: { target: 'menu' },
            menuElements: { target: 'menuElements', prio: 200 },
            menuCloseOnClick: { target: 'menuCloseOnClick', prio: 201 },
            menuDirection: { target: 'menuDirection', prio: 200 },
            menuExpandOnHover: { target: 'menuExpandOnHover', prio: 200 }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get badgeDom() { return this._badgeDom; }

    get badgeText() { return this._badgeDom.html; }
    set badgeText(val) {
        this._badgeDom.html = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get badgeTextHtmlDisplayType() { return this._badgeDom.htmlDisplayType; }
    set badgeTextHtmlDisplayType(val) { this._badgeDom.htmlDisplayType = val; }

    get caption() { return this._captionDom.html; }
    set caption(val) {
        this._captionDom.html = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get captionDom() { return this._captionDom; }

    get captionHtmlDisplayType() { return this._captionDom.htmlDisplayType; }
    set captionHtmlDisplayType(val) { this._captionDom.htmlDisplayType = val; }

    get disableFlex() { return this._dom.clsHas('kijs-disableFlex'); }
    set disableFlex(val) {
        if (val) {
            this._dom.clsAdd('kijs-disableFlex');
        } else {
            this._dom.clsRemove('kijs-disableFlex');
        }
        if (this.isRendered) {
            this.render();
        }
    }
    
    // overwrite
    get html() { return this.caption; }
    set html(val) { this.caption = val; }

    get icon() { return this._iconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set icon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconEl.iconChar = null;
            this._iconEl.iconCls = null;
            this._iconEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconEl.destruct();
            this._iconEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "icon" is not valid.`);
        }
    }

    get iconChar() { return this._iconEl.iconChar; }
    set iconChar(val) { 
        this._iconEl.iconChar = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get iconCls() { return this._iconEl.iconCls; }
    set iconCls(val) { 
        this._iconEl.iconCls = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get iconColor() { return this._iconEl.iconColor; }
    set iconColor(val) { 
        this._iconEl.iconColor = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get iconMap() { return this._iconEl.iconMap; }
    set iconMap(val) { 
        this._iconEl.iconMap = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get icon2() { return this._icon2El; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon2-Config oder kijs.gui.Icon Element
     */
    set icon2(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._icon2El.iconChar = null;
            this._icon2El.iconCls = null;
            this._icon2El.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._icon2El.destruct();
            this._icon2El = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._icon2El.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "icon2" is not valid.`);

        }
    }

    get icon2Char() { return this._icon2El.iconChar; }
    set icon2Char(val) {
        this._icon2El.iconChar = val; 
        if (this.isRendered) {
            this.render();
        }
    }

    get icon2Cls() { return this._icon2El.iconCls; }
    set icon2Cls(val) { 
        this._icon2El.iconCls = val; 
        if (this.isRendered) {
            this.render();
        }
    }

    get icon2Color() { return this._icon2El.iconColor; }
    set icon2Color(val) { 
        this._icon2El.iconColor = val; 
        if (this.isRendered) {
            this.render();
        }
    }

    get icon2Map() { return this._icon2El.iconMap; }
    set icon2Map(val) { 
        this._icon2El.iconMap = val; 
        if (this.isRendered) {
            this.render();
        }
    }

    get isDefault() {
        return this._dom.clsHas('kijs-default');
    }
    set isDefault(val) {
        if (val) {
            this._dom.clsAdd('kijs-default');
        } else {
            this._dom.clsRemove('kijs-default');
        }
    }

    // overwrite
    get isEmpty() { return this._captionDom.isEmpty && this._iconEl.isEmpty && this._icon2El.isEmpty && this._badgeDom.isEmpty; }

    get menu() { return this._menuEl; }
    set menu(val) {
        // Menu zurücksetzen?
        if (kijs.isEmpty(val)) {
            if (this._menuEl) {
                this._menuEl.destruct();
                this._menuEl = null;
            }

        // kijs.gui.Menu Instanz
        } else if (val instanceof kijs.gui.Menu) {
            if (this._menuEl) {
                this._menuEl.destruct();
            }
            this._menuEl = val;
            this._createMenu();

        // Config Objekt
        } else if (kijs.isObject(val)) {
            if (!this._menuEl) {
                this._createMenu();
            }
            this._menuEl.applyConfig(val);

        } else {
            throw new kijs.Error(`config "menu" is not valid.`);
        }
    }
    
    set menuElements(val) { this._createMenu().add(val); }
    set menuCloseOnClick(val) { this._createMenu().closeOnClick = val; }
    set menuDirection(val) { this._createMenu().direction = val; }
    set menuExpandOnHover(val) { this._createMenu().expandOnHover = val; }

    get smallPaddings() { return this._smallPaddings; }
    set smallPaddings(val) {
        let changed = this._smallPaddings !== val;
        this._smallPaddings = val;
        if (changed && this.isRendered) {
            this.render();
        }
    }
    
    

    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._iconEl.changeDisabled(!!val, true);
        this._icon2El.changeDisabled(!!val, true);
        this._iconEl.changeDisabled(!!val, true);
    }
    
    // Overwrite
    render(superCall) {
        // Evtl. schmale Ränder anzeigen?
        if (this._hasSmallPaddings()) {
            this._dom.clsAdd('kijs-smallpaddings');
        } else {
            this._dom.clsRemove('kijs-smallpaddings');
        }
        
        super.render(true);
        
        // Span icon rendern (kijs.gui.Icon)
        if (!this._iconEl.isEmpty) {
            this._iconEl.renderTo(this._dom.node);
        } else if (this._iconEl.isRendered) {
            this._iconEl.unrender();
        }

        // Span caption rendern (kijs.guiDom)
        if (!this._captionDom.isEmpty) {
            this._captionDom.renderTo(this._dom.node);
        } else if (this._captionDom.isRendered) {
            this._captionDom.unrender();
        }

        // Div badge rendern (kijs.guiDom)
        if (!this._badgeDom.isEmpty) {
            this._badgeDom.renderTo(this._dom.node);
        } else if (this._badgeDom.isRendered) {
            this._badgeDom.unrender();
        }

        // Span icon2 rendern (kijs.gui.Icon)
        if (!this._icon2El.isEmpty) {
            this._icon2El.renderTo(this._dom.node);
        } else if (this._icon2El.isRendered) {
            this._icon2El.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        if (this._iconEl) {
            this._iconEl.unrender();
        }
        if (this._icon2El) {
            this._icon2El.unrender();
        }
        if (this._captionDom) {
            this._captionDom.unrender();
        }
        if (this._badgeDom) {
            this._badgeDom.unrender();
        }
        if (this._menuEl) {
            this._menuEl.unrender();
        }

        super.unrender(true);
    }


    // PROTECTED
    /**
     * Erstellt die Instanz vom Menu.
     * @returns {kijs.gui.Menu}
     */
    _createMenu() {
        if (this._menuEl) {
            this._menuEl.parent = this;
            this._menuEl.button = this;
        } else {
            this._menuEl = new kijs.gui.Menu({
                parent: this,
                button: this
            });
        }

        if (!this.icon2Char) {
            this.icon2Map = this._menuEl.getIconMap();
        }

        return this._menuEl;
    }
    
    // Sollen links/rechts nur schmale Paddings angezeigt werden?
    _hasSmallPaddings() {
        // 'auto' = falls der Button keine caption hat und nicht disableFlex hat, 
        // wird er mit kleineren Paddings angezeigt.
        if (this._smallPaddings === 'auto') {
            return this._captionDom.isEmpty && this._dom.clsHas('kijs-disableFlex');
        } else {
            return !!this._smallPaddings;
        }
    }
    
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._badgeDom) {
            this._badgeDom.destruct();
        }
        if (this._captionDom) {
            this._captionDom.destruct();
        }
        if (this._iconEl) {
            this._iconEl.destruct();
        }
        if (this._icon2El) {
            this._icon2El.destruct();
        }
        if (this._menuEl) {
            this._menuEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._badgeDom = null;
        this._captionDom = null;
        this._iconEl = null;
        this._menuEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.ButtonGroup
// --------------------------------------------------------------
kijs.gui.ButtonGroup = class kijs_gui_ButtonGroup extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._columns = 1;
        this._rowSizes = [];
        this._colSizes = [];
        
        this._captionDom = new kijs.gui.Dom({
            cls: 'kijs-caption',
            nodeTagName: 'span'
        });

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-buttongroup');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columns: true,
            rowSizes: { target: 'rowSizes' },
            colSizes: { target: 'colSizes' },

            caption: { target: 'html', context: this._captionDom },
            captionCls: { fn: 'function', target: this._captionDom.clsAdd, context: this._captionDom },
            captionHtmlDisplayType: { target: 'htmlDisplayType', context: this._captionDom },
            captionStyle: { fn: 'assign', target: 'style', context: this._captionDom }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._captionDom.html; }
    set caption(val) {
        this._captionDom.html = val;
        if (this.isRendered) {
            this.render();
        }
    }

    get captionDom() { return this._captionDom; }

    get captionHtmlDisplayType() { return this._captionDom.htmlDisplayType; }
    set captionHtmlDisplayType(val) { this._captionDom.htmlDisplayType = val; }

    get columns() { return this._columns; }
    set columns(val) { this._columns = kijs.isNumeric(val) ? window.parseInt(val) : 1; }

    get colSizes() {
        let rs = [];
        for (let i=0; i<this.elements.length; i++) {
            rs[i] = kijs.isDefined(this._colSizes[i]) ? this._colSizes[i] : 1;
        }
        return rs;
    }
    set colSizes(val) {
        this._colSizes = kijs.isArray(val) ? val : [];
    }

    // overwrite
    get isEmpty() { return this._captionDom.isEmpty && kijs.isEmpty(this._elements); }

    get rowSizes() {
        let rs = [];
        for (let i=0; i<this.elements.length; i++) {
            rs[i] = kijs.isDefined(this._rowSizes[i]) ? this._rowSizes[i] : 1;
        }
        return rs;
    }
    set rowSizes(val) {
        this._rowSizes = kijs.isArray(val) ? val : [];
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // Overwrite
    render(superCall) {
        super.render(true);

        // Span caption rendern (kijs.guiDom)
        if (!this._captionDom.isEmpty) {
            this._captionDom.renderTo(this._dom.node, this._innerDom.node);
        } else if (this._captionDom.isRendered) {
            this._captionDom.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._captionDom.unrender();
        super.unrender(true);
    }


    // PROTECTED
    _getTableMatrix() {
        let colSizes = this.colSizes, rowSizes = this.rowSizes, matrix = [];

        // Anzahl Felder
        let numberOfCells = 0;
        for (let i=0; i<this.elements.length; i++) {
            numberOfCells += Math.max(1, colSizes[i] * rowSizes[i]);
        }

        // Anzahl rows
        let rows = Math.ceil(numberOfCells / this._columns);

        // rows in matrix
        for (let i=0; i<rows; i++) {
            matrix[i] = [];
        }

        // cells
        let rowPointer = 0;
        let colPointer = 0;
        for (let i=0; i<this.elements.length; i++) {
            let colSize = colSizes[i], rowSize = rowSizes[i];

            // weitere benötigte felder markieren
            for (let ri=0; ri<rowSize; ri++) {
                for (let ci=0; ci<colSize; ci++) {
                    if (!matrix[rowPointer + ri]) {
                        matrix[rowPointer + ri] = [];
                    }
                    matrix[rowPointer + ri][colPointer + ci] = (ri === 0 && ci === 0) ? i : 'R';
                }
            }

            // pointer erhöhen
            if (this.elements[i+1]) {
                let nextFound = false;
                while (!nextFound) {
                    rowPointer++;

                    if (rowPointer >= rows && (colPointer+1) < this._columns) {
                        colPointer++;
                        rowPointer = 0;
                    }

                    if (!matrix[rowPointer] || !matrix[rowPointer][colPointer]) {
                        nextFound = true;
                    }
                }
            }
        }

        return matrix;
    }

    // overwrite
    _renderElements() {
        let matrix = this._getTableMatrix();

        kijs.Dom.removeAllChildNodes(this._innerDom.node);

        // Grid-Grösse berechnen (Anzahl Rows und Columns)
        let maxR=0, maxC=0;

        // durchgehen und zählen
        for (let iR=0; iR<matrix.length; iR++) {
            for (let iC=0; iC<matrix[iR].length; iC++) {
                if (kijs.isInteger(matrix[iR][iC])) {
                    let elId = matrix[iR][iC];
                    let cS = this.colSizes[elId];
                    let rS = this.rowSizes[elId];

                    maxR = Math.max(maxR, (iR+rS));
                    maxC = Math.max(maxC, (iC+cS));
                }
            }
        }

        let gtr='', gtc=''; // CSS: grid-template-rows, grid-template-columns

        // Spalten
        for (let iR=0; iR<maxR; iR++) {
            gtr += '[kijs-row' + iR + '] auto ';
        }
        gtr += '[kijs-row' + maxR + ']';

        // Zeilen
        for (let iC=0; iC<maxC; iC++) {
            gtc += '[kijs-col' + iC + '] auto ';
        }
        gtc += '[kijs-col' + maxC + ']';

        this._innerDom.style.gridTemplateRows = gtr;
        this._innerDom.style.gridTemplateColumns = gtc;

        // Spalten durchgehen
        for (let iR=0; iR<matrix.length; iR++) {

            // Zeilen
            for (let iC=0; iC<matrix[iR].length; iC++) {

                if (kijs.isInteger(matrix[iR][iC])) {
                    let elId = matrix[iR][iC];
                    let cS = this.colSizes[elId];
                    let rS = this.rowSizes[elId];

                    let cellContainer = document.createElement('div');
                    cellContainer.style.gridRow = 'kijs-row' + iR + ' / kijs-row' + (iR+rS);
                    cellContainer.style.gridColumn = 'kijs-col' + iC + ' / kijs-col' + (iC+cS);

                    this.elements[elId].renderTo(cellContainer);
                    this._innerDom.node.appendChild(cellContainer);
                }
            }
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._captionDom) {
            this._captionDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._captionDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Menu
// --------------------------------------------------------------

kijs.gui.Menu = class kijs_gui_Menu extends kijs.gui.SpinBox {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._direction = '';
        this._expandOnHover = false;
        this._closeOnClick = false;
        this._expandDeferId = null;

        // Button, von dem aus dieses Menu geöffnet wird
        this._button = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            scrollableY: 'auto',
            direction: 'auto',
            expandOnHover: 'auto',
            cls: ['kijs-flexcolumn', 'kijs-menu-spinbox']
        });

        // default xtype der Unterelemente soll der Button sein.
        // kann nicht ins defaultConfig, weils ein unterobjekt ist.
        if (kijs.isObject(config)) {
            if (kijs.isObject(config.defaults) && !kijs.isDefined(config.defaults.xtype)) {
                config.defaults.xtype = 'kijs.gui.Button';
                config.defaults.disableFlex = false;
                config.defaults.smallPaddings = false;
            } else if (!kijs.isDefined(config.defaults)) {
                config.defaults = {
                    xtype: 'kijs.gui.Button',
                    disableFlex: false,
                    smallPaddings: false
                };
            }
        }

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            button: { target: 'button', prio: 1},
            direction: { target: 'direction', prio: 2},
            expandOnHover: { target: 'expandOnHover', prio: 3},
            closeOnClick: { target: 'closeOnClick', prio: 1001} // prio: nach den elements (1000)
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get button() { return this._button; }
    set button(val) {
        if (!(val instanceof kijs.gui.Button)) {
            throw new kijs.Error(`invalid value for kijs.gui.Menu::button`);
        }

        // change button?
        if (this._button !== null) {
            this._button.off('click', this.#onBtnClick, this);
            this._button = null;
        }

        this._button = val;
        this._button.on('click', this.#onBtnClick, this);
        this.target = this._button;
        this.ownerNodeAdd(this._button);
    }

    get closeOnClick() { return this._closeOnClick; }
    set closeOnClick(val) {
        val = !!val;

        if (val !== this._closeOnClick) {
            kijs.Array.each(this.elements, function(element) {
                if (element instanceof kijs.gui.Button) {

                    // sub-buttons überwachen
                    if (val && !element.hasListener('click', this.#onSubButtonClick, this)) {
                        element.on('click', this.#onSubButtonClick, this);
                    } else if (!val) {
                        element.off('click', this.#onSubButtonClick, this);
                    }

                    // closeOnClick den Untermenus weitergeben
                    if (element.menu) {
                        element.menu.closeOnClick = val;
                    }
                }
            }, this);
        }

        this._closeOnClick = val;
    }

    get direction() { return this._direction; }
    set direction(val) {
        // auto: Falls der Button nicht im Menu ist ist, nach unten, sonst nach rechts
        if (val === 'auto') {
            if (this._button && !this.upX('kijs.gui.Menu')) {
                val = 'down';
            } else {
                val = 'right';
            }
        }

        switch (val) {
            case 'left':
                this.ownPos = 'tr';
                this.targetPos = 'tl';
                this.offsetX = -5;
                break;
            case 'right':
                this.ownPos = 'tl';
                this.targetPos = 'tr';
                this.offsetX = -5;
                break;
            case 'up':
                this.ownPos = 'bl';
                this.targetPos = 'tl';
                this.offsetX = 0;
                break;
            case 'down':
                this.ownPos = 'tl';
                this.targetPos = 'bl';
                this.offsetX = 0;
                break;
            default:
                throw new kijs.Error(`invalid value for kijs.gui.Menu::direction`);
        }
        this._direction = val;
    }

    get expandOnHover() { return this._expandOnHover; }
    set expandOnHover(val) {
        if (this._button) {
            // auto: falls in einem Untermenu ja, sonst nein.
            if (val === 'auto') {
                val = this.upX('kijs.gui.Menu') !== null;
            }

            // listeners setzen
            if (val) {
                this._button.on('mouseEnter', this.#onBtnMouseEnter, this);
                this._button.on('mouseLeave', this.#onBtnMouseLeave, this);

            // listeners entfernen
            } else {
                this._button.off('mouseEnter', this.#onBtnMouseEnter, this);
                this._button.off('mouseLeave', this.#onBtnMouseLeave, this);
            }

            this._expandOnHover = !!val;
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Schliesst das Dropdownmenu und alle Untermenus
     * @returns {undefined}
     */
    close() {
        // Untermenu Schliessen
        this.closeSubMenus();

        // selber schliessen
        super.close();
    }

    /**
     * Schliesst das Dropdownmenu und alle unter- und übergeordneten Menus
     * @returns {undefined}
     */
    closeAll() {
        // alle Parents durchsuchen, beim höchsten vom Typ Menu 'Schliessen'
        let topMostMenu=this, p=this;
        while (p.parent) {
            if (p.parent instanceof kijs.gui.Menu) {
                topMostMenu = p.parent;
            }
            p=p.parent;
        }

        topMostMenu.close();
    }

    /**
     * Schliesst alle Untermenus
     * @param {kijs.gui.Menu|kijs.gui.Button|null} exeption Instanz, welche nicht geschlossen werden soll.
     * @returns {undefined}
     */
    closeSubMenus(exeption=null) {
        // Untermenu Schliessen
        kijs.Array.each(this.elements, function(element) {
            if ((element instanceof kijs.gui.Button) && element.menu && element.menu !== exeption && element !== exeption) {
                element.menu.close();
            }
        }, this);
    }
    
    /**
     * Gibt das Icon fürs öffen für die entsprechende Richtung zurück
     * @returns {String}
     */
    getIconMap() {
        switch (this._direction) {
            case 'left': return 'kijs.iconMap.Fa.angle-left';
            case 'right': return 'kijs.iconMap.Fa.angle-right';
            case 'up': return 'kijs.iconMap.Fa.angle-up';
            case 'down': return 'kijs.iconMap.Fa.angle-down';
        }
        return '';
    }

    /**
     * Zeigt das Menu an
     * @param {Number|null} x X-Koordinate (null, falls an target ausgerichtet werden soll)
     * @param {Number|null} y Y-Koordinate (null, falls an target ausgerichtet werden soll)
     * @returns {undefined}
     */
    show(x=null, y=null) {
        super.show(x, y);

        // Falls dieses Menu ein Untermenu ist: beim Öffnen
        // alle andere Untermenus ausser dieses schliessen
        if (this._button && (this._button.parent instanceof kijs.gui.Menu)) {
            this._button.parent.closeSubMenus(this);
        }
    }
    
    // overwerite
    unrender(superCall) {
        // timer abbrechen
        if (this._expandDeferId) {
            window.clearTimeout(this._expandDeferId);
            this._expandDeferId = null;
        }
        
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        super.unrender(true);
    }


    // PRIVATE
    // LISTENERS
    #onBtnClick() {
        if (this.dom.node) {
            this.close();
        } else {
            this.show();
        }
    }

    #onBtnMouseEnter() {
        if (!this._expandDeferId) {
            this._expandDeferId = kijs.defer(function() {
                if (!this.isRendered) {
                    this.show();
                }
            }, 500, this);
        }
    }

    #onBtnMouseLeave() {
        if (this._expandDeferId) {
            window.clearTimeout(this._expandDeferId);
            this._expandDeferId = null;
        }
    }

    #onSubButtonClick(e) {
        // Falls auf ein Button ohne Untermenu geklickt wird, schliessen
        if (this._closeOnClick && (e.element instanceof kijs.gui.Button) && e.element.menu === null) {
            this.closeAll();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwerite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Variablen (Objekte/Arrays) leeren
        this._button = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};/* global kijs */

// --------------------------------------------------------------
// kijs.gui.container.tab (namespace)
// --------------------------------------------------------------
kijs.gui.container.tab = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.tab.Button
// --------------------------------------------------------------
/**
 * Tab-Button Element, das in kijs.gui.container.Tab.Elementen verwendet wird.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Button
 *   kijs.gui.container.tab.Button
 *
 */
kijs.gui.container.tab.Button = class kijs_gui_container_tab_Button extends kijs.gui.Button {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._closeButtonHide = false;
        this._closeButtonIconMap = 'kijs.iconMap.Fa.xmark';
        this._tabContainerEl = null;
        
        this._menuHide = false;
        
        this._menuEl = new kijs.gui.Menu({
            closeOnClick: true,
            elements: [
                {
                    name: 'close',
                    caption: kijs.getText('Schliessen'),
                    on: {
                        click: this.#onMenuCloseButtonClick,
                        context: this
                    }
                },{
                    name: 'closeAll',
                    caption: kijs.getText('Alle schliessen'),
                    on: {
                        click: this.#onMenuCloseButtonClick,
                        context: this
                    }
                },{
                    name: 'closeOther',
                    caption: kijs.getText('Andere schliessen'),
                    on: {
                        click: this.#onMenuCloseButtonClick,
                        context: this
                    }
                }
            ]
        });
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            closeButtonIconMap: { target: 'closeButtonIconMap' },
            closeButtonHide: { prio: 1000, target: 'closeButtonHide' },
            menuHide: true,
            tabContainerEl: true
        });
        
        // Listeners
        this.on('contextMenu', this.#onContextMenu, this);
        this._icon2El.on('click', this.#onCloseClick, this);
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get closeButtonHide() { return this._closeButtonHide; }
    set closeButtonHide(val) {
        this._closeButtonHide = val;
        if (val) {
            this.icon2Map = null;
        } else {
            this.icon2Map = this._closeButtonIconMap;
        }
    }
    
    get closeButtonIconMap() { return this._closeButtonIconMap; }
    set closeButtonIconMap(val) {
        this._closeButtonIconMap = val;
        if (!this._closeButtonHide) {
            this.icon2Map = val;
        }
    }

    get menuEl() { return this._menuEl; }

    get menuHide() { return !!this._menuHide; }
    set menuHide(val) { this._menuHide = !!val; }
    
    get tabContainerEl() { return this._tabContainerEl; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._menuEl) {
            this._menuEl.unrender();
        }

        super.unrender(true);
    }
    
    
    // PRIVATE
    // LISTENERS
    // es wurde auf den Schliessen-Button geklickt
    #onCloseClick(e) {
        this.raiseEvent('closeClick', e);
        
        // bubbeling verhindern, damit nicht das click-Event des Buttons
        // auch noch ausgelöst wird
        e.nodeEvent.stopPropagation();
    }
    
    // Menü anzeigen, falls es Elemente enthält
    #onContextMenu(e) {
        e.nodeEvent.preventDefault();
        
        if (!this._menuHide) {
            // aktiviert/deaktiviert den Schliessen-Button
            this._menuEl.down('close').disabled = this.closeButtonHide;
            this._menuEl.down('closeAll').disabled = this.closeButtonHide;

            // Menü anzeigen
            this._menuEl.show(e.nodeEvent.pageX, e.nodeEvent.pageY);
        }
    }
    
    // es wurde auf einen Schliessen-Button im Menü geklickt
    #onMenuCloseButtonClick(e) {
        switch (e.element.name) {
            case 'close':
                this._menuEl.close();
                this.raiseEvent('closeClick', e);
                break;
                
            case 'closeAll':
                this._menuEl.close();
                this.raiseEvent('closeAllClick', e);
                break;
                
            case 'closeOther':
                this._menuEl.close();
                this.raiseEvent('closeOtherClick', e);
                break;
                
        }
    }
    
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._menuEl = null;
        this._closeButtonIconMap = null;
        this._tabContainerEl = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.tab.Bar
// --------------------------------------------------------------
/**
 * Funktionsweise, wie kijs.gui.container.Scrollable.
 * Das Element wird für die Tab-Leiste in kijs.gui.container.Tab verwendet.
 * Es sollte sonst nicht verwendet werden. sonst bitte kijs.gui.container.Scrollable
 * nehmen.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.container.Scrollable
 *    kijs.gui.container.tab.Bar
 *
 * 
 */
kijs.gui.container.tab.Bar = class kijs_gui_container_tab_Bar extends kijs.gui.container.Scrollable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._ddName = kijs.uniqId('tab');
        this._ddPosBeforeAfterFactor = 0.666;  // Position, ab der nachher statt vorher eingefügt wird
        this._sortable = false; // Tabs sind per Drag&Drop verschiebbar
        this._ddMapping = {};
        
        this._ddTarget = null;
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            scrollableX: 'auto',
            scrollableY: 'auto'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            ddPosBeforeAfterFactor: true,
            ddTarget: { target: 'ddTarget' },
            ddName: { target: 'ddName' },
            
            sortable: { prio: 90, target: 'sortable' }
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get ddMapping() { return this._ddMapping; }
    set ddMappping(val) {
        if (!kijs.isObject(val)) {
            throw new kijs.Error(`"ddMapping" is not valid.`);
        }
        
        kijs.Object.assignDeep(this._ddMapping, val, true);
    }
    
    get ddPosBeforeAfterFactor() { return this._ddPosBeforeAfterFactor; }
    set ddPosBeforeAfterFactor(val) { this._ddPosBeforeAfterFactor = val; }

    get ddName() {
        return this._ddName;
    }
    set ddName(val) {
        this._ddName = val;
    }
    
    get ddTarget() { 
        return this._ddTarget; 
    }
    set ddTarget(val) {
        // config-object
        if (kijs.isObject(val)) {
            if (kijs.isEmpty(this._ddTarget)) {
                val.ownerEl = this;
                if (kijs.isEmpty(val.ownerDomProperty)) {
                    val.ownerDomProperty = 'innerDom';
                }
                this._ddTarget = new kijs.gui.dragDrop.Target(val);
                this._eventForwardsAdd('ddTargetDrop', this.ddTarget, 'drop');
            } else {
                this._ddTarget.applyConfig(val);
            }

        // null
        } else if (val === null) {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;

        } else {
            throw new kijs.Error(`ddTarget must be a object or null`);

        }
    }
    
    get sortable() { return this._sortable; }
    set sortable(val) {
        this._sortable = !!val;
        
        // source
        this._initTabs();
        
        // target
        if (val) {
            this._ddMapping[this._ddName] = {
                allowMove: true,
                allowCopy: false,
                allowLink: false
            };
        } else {
            delete this._ddMapping[this._ddName];
        }
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // aktiviert/deaktiviert Drag&Drop bei den Tabs
    _initTabs(elements) {
        if (kijs.isEmpty(elements)) {
            elements = [];
            kijs.Array.each(this._elements, (el) => {
                if (el.xtype === 'kijs.gui.Button') {
                    elements = kijs.Array.concat(elements, el.elements);
                }
            }, this);
        }
        
        // source
        kijs.Array.each(elements, function(el) {
            if (this._sortable) {
                el.ddSource = {
                    name: this._ddName,
                    allowMove: true,
                    allowCopy: false,
                    allowLink: false
                };
                el.ddSource.on('drop', this.#onSourceDrop, this);
            } else {
                if (el.ddSource) {
                    el.ddSource.destruct();
                }
                el.ddSource = null;
            }
        }, this);
        
        // target
        if (this._sortable) {
            this.ddTarget = {
                posBeforeFactor: this._ddPosBeforeAfterFactor,
                posAfterFactor: this._ddPosBeforeAfterFactor,
                mapping: this._ddMapping
            };
            this.ddTarget.on('drop', this.#onTargetDrop, this);
            this.on('add', this.#onAddTabs, this);
        } else {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;
        }
    }
    
    
    // PRIVATE
    // LISTENERS
    #onAddTabs(e) {
        this._initTabs(e.elements);
    }
    
    #onSourceDrop(e) {
        this.raiseEvent('sourceDrop', e);
    }
    
    #onTargetDrop(e) {
        this.raiseEvent('targetDrop', e);
    }

    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._ddTarget) {
            this._ddTarget.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._ddTarget = null;
        this._ddMapping = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.tab.Container
// --------------------------------------------------------------
/**
 * Container Element, zur Verwendung in kijs.gui.container.Tab.Elementen.
 * Es hat zusätzlich zum normalen Container noch ein paar Eigenschaften, für den
 * Tab-Button in der Tab-Bar.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.container.tab.Container
 *
 */
kijs.gui.container.tab.Container = class kijs_gui_container_tab_Container extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._tabButtonEl = new kijs.gui.container.tab.Button({
            parent: this,
            tabContainerEl: this
        });
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            tabClosable: { target: 'tabClosable' },
            tabClosableIconMap: { target: 'closableIconMap', context: this._tabButtonEl },
            tabBadgeText: { target: 'badgeText', context: this._tabButtonEl },
            tabBadgeCls: { target: 'badgeCls', context: this._tabButtonEl },
            tabBadgeTextHtmlDisplayType: { target: 'badgeTextHtmlDisplayType', context: this._tabButtonEl },
            tabBadgeStyle: { target: 'badgeStyle', context: this._tabButtonEl },
            tabCaption: { target: 'caption', context: this._tabButtonEl },
            tabCaptionCls: { target: 'captionCls', context: this._tabButtonEl },
            tabCaptionHtmlDisplayType: { target: 'captionHtmlDisplayType', context: this._tabButtonEl },
            tabCaptionStyle: { target: 'captionStyle', context: this._tabButtonEl },
            
            tabIcon: { target: 'icon', context: this._tabButtonEl },
            tabIconMap: { target: 'iconMap', context: this._tabButtonEl },
            tabIconChar: { target: 'iconChar', context: this._tabButtonEl },
            tabIconCls: { target: 'iconCls', context: this._tabButtonEl },
            tabIconColor: { target: 'iconColor', context: this._tabButtonEl },
            tabStyle: { fn: 'assign', target: 'style', context: this._tabButtonEl },
            tabTooltip: { target: 'tooltip', context: this._tabButtonEl },
            tabWidth: { target: 'width', context: this._tabButtonEl },
            
            tabMenuHide: { target: 'menuHide', context: this._tabButtonEl }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // gibt Grund-Daten zum Container zurück, wie caption und Position.
    get posData() {
        let ret = {
            tabCaption: this._tabButtonEl.caption,
            tabIconMap: this._tabButtonEl.icon.iconMapName ?? null,
            tabClosable: this.tabClosable
        };
        if (!kijs.isEmpty(this.name)) {
            ret.name = this.name;
        }
        if (this.disabled) {
            ret.disabled = this.disabled;
        }
        if (this.userData) {
            ret.userData = this.userData;
        }
        return ret;
    }
    
    get tabButtonEl() { return this._tabButtonEl; }

    get tabClosable() { return !this._tabButtonEl.closeButtonHide; }
    set tabClosable(val) { this._tabButtonEl.closeButtonHide = !val; }

    get tabClosableIconMap() { return this._tabButtonEl.closeButtonIconMap; }
    set tabClosableIconMap(val) { this._tabButtonEl.closeButtonIconMap = val; }

    get tabMenuHide() { return this._tabButtonEl.menuHide; }
    set tabMenuHide(val) { this._tabButtonEl.menuHide = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._tabButtonEl.changeDisabled(!!val, true);
    }
    
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._tabButtonEl) {
            this._tabButtonEl.unrender();
        }

        super.unrender(true);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._tabButtonEl) {
            this._tabButtonEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._tabButtonEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.container.Tab
// --------------------------------------------------------------
/**
 * Tab Container.
 * Es können nur kijs.gui.container.tab.Container hinzugefügt werden (xtype kann
 * auch weggelassen werden).
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.container.Stack
 *    kijs.gui.container.Tab
 *
 *
 */
kijs.gui.container.Tab = class kijs_gui_container_Tab extends kijs.gui.container.Stack {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._tabBarEl = new kijs.gui.container.tab.Bar({
            parent: this,
            on: {
                sourceDrop: this.#onTabBarSourceDrop,
                targetDrop: this.#onTabBarTargetDrop,
                context: this
            }
        });

        this._tabBarPos = 'top';
        this._tabBarAlign = 'start';

        this._rpcSaveFn = null;     // Name der remoteFn. Bsp: 'myTabs.save'
        this._rpcSaveArgs = {};     // Standard RPC-Argumente fürs Speichern
        this._autoSave = false;     // Automatisches Speichern bei Änderungen

        this._dom.clsRemove('kijs-container-stack');
        this._dom.clsAdd('kijs-container-tab');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            animation: 'fade',
            animationDuration: 300,
            tabBarPos: 'top',
            tabBarAlign: 'start',
            tabBarScrollableX: 'auto',
            tabBarScrollableY: 'auto'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            tabBarPos: { target: 'tabBarPos' }, // Position der TabBar 'top', 'left',
                                                // 'bottom' oder 'right' (default: 'top')
            tabBarAlign: { target: 'tabBarAlign'},// Ausrichtung der Tabs 'start',
                                                  // center oder 'end' (default: 'start')
            tabBarScrollableX: { target: 'scrollableX', context: this._tabBarEl },
            tabBarScrollableY: { target: 'scrollableY', context: this._tabBarEl },

            ddName: { target: 'ddName', context: this._tabBarEl },
            ddPosBeforeAfterFactor: { target: 'ddPosBeforeAfterFactor', context: this._tabBarEl },
            ddMapping: { target: 'ddMapping', context: this._tabBarEl },

            rpcSaveFn: true,    // Name der remoteFn. Bsp: 'myTabs.save'
            rpcSaveArgs: true,  // Standard RPC-Argumente fürs Speichern
            autoSave: true,     // Automatisches Speichern bei Änderungen

            sortable: { prio: 90, target: 'sortable', context: this._tabBarEl }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autoSave() { return this._autoSave; }
    set autoSave(val) { this._autoSave = !!val; }

    get rpcSaveArgs() { return this._rpcSaveArgs; }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }

    get rpcSaveFn() { return this._rpcSaveFn; }
    set rpcSaveFn(val) { this._rpcSaveFn = val; }

    get tabBarAlign() { return this._tabBarAlign; }
    set tabBarAlign(val) {
        if (!kijs.Array.contains(['start','center','end'], val)) {
            throw new kijs.Error(`unknown tabBarAlign.`);
        }

        let oldTabParAlign = this._tabBarAlign;
        this._tabBarAlign = val;

        // bestehende CSS-Klassen entfernen
        this._dom.clsRemove(['kijs-align-start','kijs-align-center','kijs-align-end']);

        // neue hinzufügen
        this._dom.clsAdd('kijs-align-' + val.toLowerCase());

        if (val !== oldTabParAlign) {
            this._tabBarEl.render();
        }
    }

    get tabBarPos() { return this._tabBarPos; }
    set tabBarPos(val) {

        if (!kijs.Array.contains(['top','right','bottom','left'], val)) {
            throw new kijs.Error(`unknown tabBarPos.`);
        }

        let oldTabParPos = this._tabBarPos;
        this._tabBarPos = val;

        // bestehende CSS-Klassen entfernen
        this._dom.clsRemove(['kijs-pos-top','kijs-pos-right','kijs-pos-bottom','kijs-pos-left']);

        // neue hinzufügen
        this._dom.clsAdd('kijs-pos-' + val.toLowerCase());

        if (val !== oldTabParPos) {
            this._tabBarEl.render();
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    add(elements, index=null, options={}) {
        if (!kijs.isArray(elements)) {
            elements = [elements];
        }

        const newElements = [];
        const newTabBarButtons = [];
        kijs.Array.each(elements, function(el) {

            // Es dürfen nur kijs.gui.container.tab.Container hinzugefügt werden
            if ((el instanceof kijs.gui.Element)) {
                if (!(el instanceof kijs.gui.container.tab.Container)) {
                    throw new kijs.Error(`Element must be an instance of kijs.gui.container.tab.Container.`);
                }

            // Falls eine Config übergeben wurde, den xtype checken.
            // Falls kein xtype angegeben wurde, kijs.gui.container.tab.Container
            // als Standard nehmen.
            } else {
                if (el.xtype) {
                    if (el.xtype !== 'kijs.gui.container.tab.Container') {
                        throw new kijs.Error(`Element must be an instance of kijs.gui.container.tab.Container.`);
                    }
                } else {
                    el.xtype = 'kijs.gui.container.tab.Container';
                }

                // element erstellen
                el = this._getInstanceForAdd(el);
            }

            newElements.push(el);

            // Button für tabBar erstellen
            el.tabButtonEl.on('click', this.#onTabButtonElClick, this);
            el.tabButtonEl.on('closeClick', this.#onTabButtonElCloseClick, this);
            el.tabButtonEl.on('closeAllClick', this.#onTabButtonElCloseAllClick, this);
            el.tabButtonEl.on('closeOtherClick', this.#onTabButtonElCloseOtherClick, this);
            newTabBarButtons.push(el.tabButtonEl);
        }, this);

        // Buttons zu tabBar hinzufügen
        this._tabBarEl.add(newTabBarButtons, index, { preventRender: true });

        // Elemente hinzufügen
        super.add(newElements, index, options);
    }

    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._tabBarEl.changeDisabled(!!val, true);
    }

    // overwrite
    remove(elements, options={}, superCall) {
        if (!superCall) {
            if (!kijs.isArray(elements)) {
                elements = [elements];
            }

            if (!options.preventEvents) {
                // beforeRemove Event. Bei Rückgabe=false -> abbrechen
                if (this.raiseEvent('beforeRemove', {removeElements: elements}) === false) {
                    return;
                }
            }
        }

        // tabBarButton entfernen
        kijs.Array.each(elements, function(el) {
            this._tabBarEl.remove(el.tabButtonEl, options);
        }, this);

        super.remove(elements, options, true);

        // speichern
        if (this._autoSave && this._rpcSaveFn && !options.preventEvents) {
            this.save();
        }
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // TabBar rendern (kijs.gui.container.tab.Bar)
        this._tabBarEl.renderTo(this._dom.node, this._innerDom.node);
    }

    save() {
        return new Promise((resolve, reject) => {
            let args = {};

            args = Object.assign({}, args, this._rpcSaveArgs);

            // Positionsdaten der Tabs ermitteln
            args.elements = [];
            kijs.Array.each(this._elements, function(el) {
                args.elements.push(el.posData);
            }, this);

            // an den Server senden
            this.rpc.do({
                remoteFn: this.rpcSaveFn,
                owner: this,
                data: args,
                cancelRunningRpcs: false,
                waitMaskTarget: this,
                waitMaskTargetDomProperty: 'dom',
                context: this

            }).then((e) => {
                // config Properties anwenden, falls vorhanden
                if (e.responseData.config) {
                    // config Properties übernehmen
                    this.applyConfig(e.responseData.config);
                }

                // 'afterSave' auslösen
                this.raiseEvent('afterSave', e);

                // Promise auslösen
                resolve(e);

            }).catch((ex) => {
                reject(ex);

            });
        });
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._tabBarEl) {
            this._tabBarEl.unrender();
        }

        super.unrender(true);
    }


    // PROTECTED
    // Ermittelt den Index eines TabButtons
    _getTabButtonElIndex(el) {
        let index = null;

        for (let i=0; i<this._tabBarEl.elements.length; i++) {
            if (this._tabBarEl.elements[i] === el) {
                index = i;
                break;
            }
        }

        return index;
    }

    // overwrite
    _setCurrent(element) {
        super._setCurrent(element);

        // Aktueller TabButton hervorheben
        kijs.Array.each(this._tabBarEl.elements, function(el) {
            if (element && el === element.tabButtonEl) {
                el.dom.clsAdd('kijs-current');
            } else {
                el.dom.clsRemove('kijs-current');
            }
        }, this);

        // In den sichtbaren bereich scrollen, wenn nötig
        if (element && element.tabButtonEl && element.tabButtonEl.isRendered) {
            element.tabButtonEl.dom.scrollIntoView();
        }
    }


    // PRIVATE
    // LISTENERS
    #onTabBarSourceDrop(e) {
        if (e.source.name === this._tabBarEl.ddName && e.operation === 'move') {
            // Source Button+Container
            let sourceButton = e.source.ownerEl;
            let sourceContainer = sourceButton.parent.parent.elements[sourceButton.index];

            // Source Container merken, damit er beim Ziel wieder eingefügt werden kann
            kijs.gui.DragDrop.data.sourceContainer = sourceContainer;

            // Events vom sourceButton entfernen
            sourceButton.off('click', this.#onTabButtonElClick, this);
            sourceButton.icon2.off('click', this.#onTabButtonElCloseClick, this);
            sourceButton.ddSource.off('drop');

            // Container vom alten Ort entfernen
            sourceContainer.parent.remove(sourceContainer, {
                preventDestruct: true,
                preventUnrender: true,
                preventEvents: true
            });

            // speichern
            if (this._autoSave && this._rpcSaveFn) {
                // nur speichern, wenn das Target ein anderes Element ist
                // (sonst wird ja beim target bereits gespeichert)
                if (e.target.ownerEl !== this._tabBarEl) {
                    this.save();
                }
            }
        }
    }

    #onTabBarTargetDrop(e) {
        if (e.source.name === this._tabBarEl.ddName) {
            // target index ermitteln
            let targetIndex = kijs.gui.DragDrop.dropFnGetTargetIndex(e);

            // Container, des gezogenen Tab-Buttons ermitteln
            let sourceContainer = kijs.gui.DragDrop.data.sourceContainer;

            // Ist das geogene Tab das aktuell selektierte?
            const isCurrent = e.source.ownerEl.dom.clsHas('kijs-current');

            let newTabContainer = null;

            // Falls der Drag von einem anderen kijs.gui.container.Tab kommt, können
            // wir das vorhandene Tab gleich nehmen
            if (sourceContainer instanceof kijs.gui.container.tab.Container) {
                newTabContainer = sourceContainer;

            } else {
                throw new Error('Drag&Drop of elements other than kijs.gui.container.Tab.container is not yet implemented.');

            }

            // Container am neuen Ort einfügen
            this.add(newTabContainer, targetIndex);

            // Fall der aktuelle Container gezogen wurde: wieder auswählen
            if (isCurrent) {
                this.currentEl = newTabContainer;
            } else {
                // sonst nur in sichtbaren Bereich scrollen
                newTabContainer.tabButtonEl.dom.scrollIntoView();
            }

            // speichern
            if (this._autoSave && this._rpcSaveFn) {
                this.save();
            }
        }
    }

    #onTabButtonElClick(e) {
        // Element wechseln
        this.setCurrentAnimated(e.element.tabContainerEl);
    }

    // Alle Tabs schliessen
    #onTabButtonElCloseAllClick(e) {
        let elements = [];
        
        // alle Tabs durchgehen und schliessen, wenn closable
        kijs.Array.each(this._tabBarEl.elements, function(el) {
            if (!el.closeButtonHide) {
                elements.push(el.tabContainerEl);
            }
        }, this);
        
        if (!kijs.isEmpty(elements)) {
            this.remove(elements);
        }
    }
    
    // ein Tab schliessen
    #onTabButtonElCloseClick(e) {
        // Tab schliessen
        this.remove(e.element.tabContainerEl);
    }
    
    // Alle anderen Tabs schliessen, die closable sind
    #onTabButtonElCloseOtherClick(e) {
        let elements = [];
        let elCur = e.element;
        
        // alle Tabs durchgehen und schliessen, wenn closable und nicht das aktuelle tab
        kijs.Array.each(this._tabBarEl.elements, function(el) {
            if (!el.closeButtonHide && el !== elCur) {
                elements.push(el.tabContainerEl);
            }
        }, this);
        
        if (!kijs.isEmpty(elements)) {
            this.remove(elements);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._tabBarEl) {
            this._tabBarEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._rpcSaveArgs = null;
        this._tabBarEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// TODO: Grundsätzlich überarbeiten
// TODO: load() ist nicht kompatibel mit Basisklasse
// --------------------------------------------------------------
// kijs.gui.Tree
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * afterLoad
 * beforeSelectionChange
 * selectionChange
 * rowClick
 * rowDblClick
 *
 */
kijs.gui.Tree = class kijs_gui_Tree extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        this._rpc = null;   // Instanz von kijs.gui.Rpc
        this._rpcLoadFn = null;
        this._rpcLoadArgs = null;
        this._rpcSaveFn = null;
        this._rpcSaveArgs = null;
        this._autoLoad = true;
        this._loaded = false;
        this._nodeId = null;
        this._leaf = true;
        this._rootVisible = false;

        this._nodeDom = new kijs.gui.Dom({cls: 'kijs-node'});
        this._elementsDom = new kijs.gui.Dom({cls: 'kijs-expandcontainer'});
        this._treeCaptionDom = new kijs.gui.Dom({cls: 'kijs-treecaption', htmlDisplayType: 'code'});

        this._iconEl = new kijs.gui.Icon({cls: 'fa-regular'});
        this._expandIconEl = new kijs.gui.Icon({cls: 'kijs-expandicon', iconMap: 'kijs.iconMap.Fa.angle-right'});
        this._expandedIconEl = new kijs.gui.Icon({cls: 'kijs-expandedicon fa-regular'});
        this._spinnerIconEl = new kijs.gui.Icon({cls: 'kijs-spinnericon kijs-pulse fa-solid', iconMap: 'kijs.iconMap.Fa.spinner'});

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-tree');

        // Events
        this._expandIconEl.on('click', this.#onExpandClick, this);

        this._iconEl.on('dblClick', this.#onNodeDblClick, this);
        this._expandedIconEl.on('dblClick', this.#onNodeDblClick, this);
        this._treeCaptionDom.on('dblClick', this.#onNodeDblClick, this);

        this._iconEl.on('singleClick', this.#onNodeSingleClick, this);
        this._expandedIconEl.on('singleClick', this.#onNodeSingleClick, this);
        this._treeCaptionDom.on('singleClick', this.#onNodeSingleClick, this);

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            scrollableY: 'auto',
          //  waitMaskTarget           : this,
          //  waitMaskTargetDomProperty: 'dom',
            folderIcon               : 'auto'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autoLoad                  : true,
            rootVisible               : true,

            rpc                       : { target: 'rpc' },  // Instanz von kijs.gui.Rpc oder Name einer RPC
            rpcLoadFn                 : true,
            rpcLoadArgs               : true,
            rpcSaveFn                 : true,
            rpcSaveArgs               : true,
            nodeId                    : true,

            // leaf = true = keine Kindknoten
            leaf                      : true,

            // Bezeichnung des node
            caption                   : { target: 'html', context: this._treeCaptionDom },

            // Pfeil-Icon im Baum
            expandIconMap             : { target: 'iconMap', context: this._expandIconEl },
            expandIconChar            : { target: 'iconChar', context: this._expandIconEl },
            expandIconCls             : { target: 'iconCls', context: this._expandIconEl },
            expandIconColor           : { target: 'iconColor', context: this._expandIconEl },

            // icon bei geschlossenem Baum
            iconMap                   : { target: 'iconMap', context: this._iconEl },
            iconChar                  : { target: 'iconChar', context: this._iconEl },
            iconCls                   : { target: 'iconCls', context: this._iconEl },
            iconColor                 : { target: 'iconColor', context: this._iconEl },

            // icon bei offenem Baum
            expandedIconMap           : { target: 'iconMap', context: this._expandedIconEl },
            expandedIconChar          : { target: 'iconChar', context: this._expandedIconEl },
            expandedIconCls           : { target: 'iconCls', context: this._expandedIconEl },
            expandedIconColor         : { target: 'iconColor', context: this._expandedIconEl },

            // setzt das 'iconChar' und das 'expandedIconChar' auf ein Ordner-Symbol.
            folderIcon                : { target: 'folderIcon', prio: 10 },

            iconSize                  : { target: 'iconSize' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (this.isRoot) {
            this._dom.clsAdd('kijs-tree-root');
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._treeCaptionDom.html; }

    get expanded() { return !!this._innerDom.clsHas('kijs-expanded'); }
    set expanded(val) {
        if (val) {
            this._innerDom.clsAdd('kijs-expanded');
        } else {
            this._innerDom.clsRemove('kijs-expanded');
        }
    }

    set folderIcon(val) {
        if (val === 'auto') {
            val = (!this._iconEl.iconChar && !this._iconEl.iconCls);
        }

        if (val) {
            this._iconEl.iconMap = 'kijs.iconMap.Fa.folder';
            this._expandedIconEl.iconMap = 'kijs.iconMap.Fa.folder-open';
        }
    }
    get folderIcon() {
        return (this._iconEl.iconChar === kijs.iconMap.Fa.folder.char && this._expandedIconEl.iconChar === kijs.iconMap.Fa['folder-open'].char);
    }

    get leaf() { return this.elements.length === 0 && this._leaf; }
    set leaf(val) { this._leaf = !!val; }

    get loadSpinner() { return !!this._innerDom.clsHas('kijs-loading'); }
    set loadSpinner(val) {
        if (val) {
            this._innerDom.clsAdd('kijs-loading');
        } else {
            this._innerDom.clsRemove('kijs-loading');
        }
    }

    get iconChar() { return this._iconEl.iconChar; }
    set iconChar(val) { this._iconEl.iconChar = val; }

    get iconCls() { return this._iconEl.iconCls; }
    set iconCls(val) { this._iconEl.iconCls = val; }

    get iconColor() { return this._iconEl.iconColor; }
    set iconColor(val) { this._iconEl.iconColor = val; }

    get iconMap() { return this._iconEl.iconMap; }
    set iconMap(val) { this._iconEl.iconMap = val; }

    get expandedIconChar() { return this._expandedIconEl.iconChar; }
    set expandedIconChar(val) { this._expandedIconEl.iconChar = val; }

    get expandedIconCls() { return this._expandedIconEl.iconCls; }
    set expandedIconCls(val) { this._expandedIconEl.iconCls = val; }

    get expandedIconColor() { return this._expandedIconEl.iconColor; }
    set expandedIconColor(val) { this._expandedIconEl.iconColor = val; }

    get expandedIconMap() { return this._expandedIconEl.iconMap; }
    set expandedIconMap(val) { this._expandedIconEl.iconMap = val; }

    get iconSize() { return this._iconEl.iconSize; }
    set iconSize(val) {
        this._iconEl.iconSize = val;
        this._expandedIconEl.iconSize = val;
        this._spinnerIconEl.iconSize = val;
    }

    get isRemote() { return !!(this._rpcLoadFn || (this.parent &&
                (this.parent instanceof kijs.gui.Tree) && this.parent.isRemote)); }

    get isRoot() { return !this.parent || !(this.parent instanceof kijs.gui.Tree); }

    get nodeId() { return this._nodeId; }
    set nodeId(val) { this._nodeId = val; }


    get rpc() {
        if (this._rpc) {
            return this._rpc;
        } else if (this.parent && (this.parent instanceof kijs.gui.Tree)) {
            return this.parent.rpc;
        } else {
            return kijs.getRpc('default');
        }
    }
    set rpc(val) {
        if (kijs.isString(val)) {
            val = kijs.getRpc(val);
        }

        if (val instanceof kijs.gui.Rpc) {
            this._rpc = val;
        } else {
            throw new kijs.Error(`Unknown format on config "rpc"`);
        }
    }

    get rpcLoadArgs() {
        if (this._rpcLoadArgs) {
            return this._rpcLoadArgs;
        }
        if (this.parent && (this.parent instanceof kijs.gui.Tree)) {
            return this.parent.rpcLoadArgs;
        }
        return null;
    }
    set rpcLoadArgs(val) { this._rpcLoadArgs = val; }

    get rpcLoadFn() {
        if (this._rpcLoadFn) {
            return this._rpcLoadFn;
        }
        if (this.parent && (this.parent instanceof kijs.gui.Tree)) {
            return this.parent.rpcLoadFn;
        }
        return null;
    }

    get rpcSaveArgs() {
        if (this._rpcSaveArgs) {
            return this._rpcSaveArgs;
        }
        if (this.parent && (this.parent instanceof kijs.gui.Tree)) {
            return this.parent.rpcLoadArgs;
        }
        return null;
    }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }

    get rpcSaveFn() {
        if (this._rpcSaveFn) {
            return this._rpcSaveFn;
        }
        if (this.parent && (this.parent instanceof kijs.gui.Tree)) {
            return this.parent.rpcSaveFn;
        }
        return null;
    }


    get selected() { return !!this._innerDom.clsHas('kijs-selected'); }
    set selected(val) {
        if (val) {
            this._innerDom.clsAdd('kijs-selected');
        } else {
            this._innerDom.clsRemove('kijs-selected');
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    add(elements, index=null, options={}) {
        elements = this._recursiveSetProperties(elements);
        super.add(elements, index, options);
    }

    /**
     * Klappt die Node zu.
     * @returns {undefined}
     */
    collapse() {
        if (this.expanded) {
            this.expanded = false;
            this._raiseRootEvent('collapse');
        }
    }

    /**
     * Klappt die Node auf.
     * @returns {undefined}
     */
    expand() {
        if (!this.leaf) {
            if (this.isRemote && !this.expanded) {
                this.load().then(() => {
                    this.expanded = true;
                    this._raiseRootEvent('expand');
                });
            } else if (!this.expanded) {
                this.expanded = true;
                this._raiseRootEvent('expand');
            }
        }
    }

    /**
     * Gibt den Pfad im Baum zur aktuellen Node zurück.
     * @param {String} separator
     * @returns {String}
     */
    getPath(separator='/') {
        let path = '';
        if (this.isRoot) {
            path += separator;
        } else {
            path += this.parent.getPath(separator) + separator;
        }

        if (this._nodeId !== null) {
            path += kijs.toString(this._nodeId);

        } else if (this.isRoot) {
            path += 'root';

        } else {
            path += '<no-id>';
        }

        return path;
    }

    /**
     * Gibt die Root-Node des aktuellen Baums zurück.
     * @returns {kijs_gui_Tree}
     */
    getRootNode() {
        if (this.parent && (this.parent instanceof kijs.gui.Tree)) {
            return this.parent.getRootNode();
        }

        return this;
    }

    /**
     * Gibt den aktuell Selektierten Node zurück (Sollte vom Root-Node aus aufgerufen werden!)
     * @returns {kijs_gui_Tree|null}
     */
    getSelected() {
        if (this.selected) {
            return this;

        } else {
            let selectedNode = null;

            kijs.Array.each(this.elements, function(el) {
                if (el.selected) {
                    selectedNode = el;
                    return false;
                } else {
                    selectedNode = el.getSelected();
                    if (selectedNode) {
                        return false;
                    }
                }
            }, this);

            return selectedNode;
        }
    }


    /**
     * Lädt die Daten vom RPC
     * @param {Object|null} args
     * @param {bool} force
     * @returns {Promise}
     */
    load(args=null, force=false) {
        return new Promise((resolve, reject) => {
            if (!this.isRemote) {
                reject(new kijs.Error('tree not remotable'));

            } else  if ((!this._loaded && this.elements.length === 0) || force) {
                this._loaded = true;

                if (!kijs.isObject(args)) {
                    args = {};
                }

                let defaultRpcArgs = this.rpcLoadArgs;
                if (kijs.isObject(defaultRpcArgs)) {
                    args = Object.assign(args, defaultRpcArgs);
                }

                args.nodeId = this._nodeId;

                // spinner icon aktivieren
                this.loadSpinner = true;

                this.rpc.do({
                    remoteFn: this.rpcLoadFn,
                    owner: this,
                    data: args,
                    waitMaskTarget: (!this._rootVisible && this.isRoot) ? this : 'none'

                }).then((e) => {
                    this.loadSpinner = false;

                    // alle unterelemente entfernen und destructen
                    this.removeAll();

                    if (e.responseData.tree) {
                        this.add(e.responseData.tree);
                    }
                    resolve(e.responseData);

                }).catch((ex) => {
                    this.loadSpinner = false;
                    this.removeAll();
                    reject(ex);
                });

            } else {
                resolve(null);
            }
        });
    }

    // overwrite
    remove(elements, options={}, superCall) {
        super.remove(elements, options, superCall);

        if (this._elements.length === 0) {
            this.collapse();
        }
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // leerer ordner
        if (this.leaf) {
            this._expandIconEl.dom.clsAdd('kijs-leaf');
        } else {
            this._expandIconEl.dom.clsRemove('kijs-leaf');
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }

        if (this._autoLoad && this.isRemote && this.isRoot) {
            this.load();
        }
    }

    // Setzt den 'selected' Status rekursiv
    setSelected(selected, recursive=false) {
        this.selected = !!selected;
        if (recursive) {
            kijs.Array.each(this.elements, function(element) {
                if (element instanceof kijs.gui.Tree) {
                    element.setSelected(!!selected, true);
                }
            }, this);
        }

    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._nodeDom.unrender();
        this._elementsDom.unrender();
        this._expandIconEl.unrender();
        this._iconEl.unrender();
        this._expandedIconEl.unrender();
        this._spinnerIconEl.unrender();
        this._treeCaptionDom.unrender();

        super.unrender(true);
    }


    // PROTECTED
    /**
     * Führt einen Event nicht nur beim aktuellen, sondern auch beim root-Element aus.
     * @param {Mixed} args
     * @returns {unresolved}
     */
    _raiseRootEvent(...args) {
        let ret = this.raiseEvent.apply(this, args);

        if (!this.isRoot) {
            this.getRootNode().raiseEvent.apply(this.getRootNode(), args);
        }
        return ret;
    }

    /**
     * Setzt den xtype von Unterelementen
     * @param elements
     * @returns {mixed}
     * @private
     */
    _recursiveSetProperties(elements) {
        if (kijs.isObject(elements)) {
            elements = [elements];
        }
        if (kijs.isArray(elements)) {
            for (let i = 0; i < elements.length; i++) {
                let element = elements[i];
                if (kijs.isStandardObject(element)) {
                    if (element.elements) {
                        element.elements = this._recursiveSetProperties(element.elements);
                    }

                    element.xtype = element.xtype ? element.xtype : 'kijs.gui.Tree';
                    element.scrollableY = false;

                    //element.iconChar = element.iconChar ? element.iconChar : this.getRootNode().iconChar;
                    //element.iconCls = element.iconCls ? element.iconCls : this.getRootNode().iconCls;
                    //element.iconColor = element.iconColor ? element.iconColor : this.getRootNode().iconColor;
                    element.iconMap = element.iconMap ? element.iconMap : this.getRootNode().iconMap;

                    //element.expandedIconChar = element.expandedIconChar ? element.expandedIconChar : this.getRootNode().expandedIconChar;
                    //element.expandedIconCls = element.expandedIconCls ? element.expandedIconCls : this.getRootNode().expandedIconCls;
                    //element.expandedIconColor = element.expandedIconColor ? element.expandedIconColor : this.getRootNode().expandedIconColor;
                    element.expandedIconMap = element.expandedIconMap ? element.expandedIconMap : this.getRootNode().expandedIconMap;

                    if (!element.iconSize && this.getRootNode().iconSize) {
                        element.iconSize = this.getRootNode().iconSize;
                    }
                }
            }
        }
        return elements;
    }

    // overwrite
    _renderElements() {
        // Beim Root-Element werden die Nodes
        // direkt in den innerDom gerendert.
        // Es gibt kein Icon, etc.
        if (!this._rootVisible && this.isRoot) {
            // elements im innerDom rendern
            kijs.Array.each(this._elements, function(el) {
                el.renderTo(this._innerDom.node);
            }, this);

        } else {
            // node in den innerDom
            this._nodeDom.renderTo(this._innerDom.node);

            // elementDom in den innerDom
            this._elementsDom.renderTo(this._innerDom.node);

            // elements im elementDom rendern
            kijs.Array.each(this._elements, function(el) {
                el.renderTo(this._elementsDom.node);
            }, this);

            this._expandIconEl.renderTo(this._nodeDom.node);
            this._iconEl.renderTo(this._nodeDom.node);
            this._expandedIconEl.renderTo(this._nodeDom.node);
            this._spinnerIconEl.renderTo(this._nodeDom.node);
            this._treeCaptionDom.renderTo(this._nodeDom.node);
        }
    }


    // PRIVATE
    // LISTENERS
    /**
     * Klick auf den 'expand' button
     * Öffnet die Node, selektion wird nicht verändert
     * @private
     */
    #onExpandClick() {
        if (this.loadSpinner || this.disabled) {
            return;
        }

        if (this.expanded) {
            this.collapse();
        } else {
            this.expand();
        }

        // Event beim Root auslösen
        this._raiseRootEvent('nodeClick');
    }

    /**
     * Öffnet die Node
     * @returns {undefined}
     */
    #onNodeDblClick() {
        if (this.loadSpinner || this.disabled) {
            return;
        }
        if (this.expanded) {
            this.collapse();
        } else {
            this.expand();
        }

        // Event beim Root auslösen
        this._raiseRootEvent('nodeDblClick');
    }

    // Selektiert die Node
    #onNodeSingleClick() {
        if (this.loadSpinner || this.disabled) {
            return;
        }
        // alles deselektieren, nur aktuelle selektiert
        this.getRootNode().setSelected(false, true);
        this.selected = true;
        this._raiseRootEvent('select');
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        this._nodeDom.destruct();
        this._elementsDom.destruct();
        this._expandIconEl.destruct();
        this._iconEl.destruct();
        this._expandedIconEl.destruct();
        this._spinnerIconEl.destruct();
        this._treeCaptionDom.destruct();

        // Variablen (Objekte/Arrays) leeren
        this._rpc = null;
        this._rpcLoadArgs = null;
        this._rpcSaveArgs = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.PanelBar
// --------------------------------------------------------------
kijs.gui.PanelBar = class kijs_gui_PanelBar extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._iconEl = new kijs.gui.Icon({ parent: this });
        this._containerLeftEl = new kijs.gui.Container({
            cls: 'kijs-container-left',
            parent: this
        });
        this._containerLeftEl.dom.clsRemove('kijs-container');

        this._containerRightEl = new kijs.gui.Container({
            cls: 'kijs-container-right',
            parent: this
        });
        this._containerRightEl.dom.clsRemove('kijs-container');

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-panelbar');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            icon: { target: 'icon' },
            iconChar: { target: 'iconChar', context: this._iconEl },
            iconCls: { target: 'iconCls', context: this._iconEl },
            iconColor: { target: 'iconColor', context: this._iconEl },
            iconMap: { target: 'iconMap', context: this._iconEl },

            elementsLeft: { fn: 'function', target: this._containerLeftEl.add, context: this._containerLeftEl },
            elementsRight: { fn: 'function', target: this._containerRightEl.add, context: this._containerRightEl }
        });

        // click- und mouseDown-Event soll nur auf dem label und icon kommen. Bei den elements nicht.
        this._eventForwardsRemove('click', this._dom);
        this._eventForwardsAdd('click', this._innerDom);
        this._eventForwardsAdd('click', this._iconEl.dom);

        this._eventForwardsRemove('dblClick', this._dom);
        this._eventForwardsAdd('dblClick', this._innerDom);
        this._eventForwardsAdd('dblClick', this._iconEl.dom);

        this._eventForwardsRemove('mouseDown', this._dom);
        this._eventForwardsAdd('mouseDown', this._innerDom);
        this._eventForwardsAdd('mouseDown', this._iconEl.dom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get icon() { return this._iconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set icon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconEl.iconChar = null;
            this._iconEl.iconCls = null;
            this._iconEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconEl.destruct();
            this._iconEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "icon" is not valid.`);

        }
    }

    get iconChar() { return this._iconEl.iconChar; }
    set iconChar(val) { this._iconEl.iconChar = val; }

    get iconCls() { return this._iconEl.iconCls; }
    set iconCls(val) { this._iconEl.iconCls = val; }

    get iconColor() { return this._iconEl.iconColor; }
    set iconColor(val) { this._iconEl.iconColor = val; }

    get iconMap() { return this._iconEl.iconMap; }
    set iconMap(val) { this._iconEl.iconMap = val; }

    // overwrite
    get isEmpty() { return super.isEmpty && this._iconEl.isEmpty && this._containerLeftEl.isEmpty && this._containerRightEl.isEmpty; }

    get containerLeftEl() { return this._containerLeftEl; }

    get containerRightEl() { return this._containerRightEl; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // Overwrite
    render(superCall) {
        // Schematischer Aufbau des DOMs:
        // + panelBar
        //   + icon
        //   + containerLeft
        //   + innerDom
        //   + containerRight

        // dom rendern. Im innerDom ist die Bezeichnung (html). Links und rechts davon sind die Tools
        super.render(true);

        // Span icon rendern (icon kijs.gui.Icon)
        if (!this._iconEl.isEmpty) {
            this._iconEl.renderTo(this._dom.node, this._innerDom.node);
        } else if (this._iconEl.isRendered) {
            this._iconEl.unrender();
        }

        // ToolsLeft rendern (kijs.gui.Container)
        if (!this._containerLeftEl.isEmpty) {
            this._containerLeftEl.renderTo(this._dom.node, this._innerDom.node);
        } else if (this._containerLeftEl.isRendered) {
            this._containerLeftEl.unrender();
        }

        // ToolsRight rendern (kijs.gui.Container)
        if (!this._containerRightEl.isEmpty) {
            this._containerRightEl.renderTo(this._dom.node);
        } else if (this._containerRightEl.isRendered) {
            this._containerRightEl.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._iconEl.unrender();
        this._containerLeftEl.unrender();
        this._containerRightEl.unrender();
        super.unrender(true);
    }


    // PROTECTED
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._iconEl.changeDisabled(!!val, true);
        this._containerLeftEl.changeDisabled(!!val, true);
        this._containerRightEl.changeDisabled(!!val, true);
    }
    
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._iconEl) {
            this._iconEl.destruct();
        }
        if (this._containerLeftEl) {
            this._containerLeftEl.destruct();
        }
        if (this._containerRightEl) {
            this._containerRightEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._iconEl = null;
        this._containerLeftEl = null;
        this._containerRightEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Resizer
// --------------------------------------------------------------
kijs.gui.Resizer = class kijs_gui_Resizer extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._initialPos = null;
        this._targetEl = null;

        this._targetMaxHeight = null;
        this._targetMaxWidth = null;
        this._targetMinHeight = null;
        this._targetMinWidth = null;

        this._overlayDom = new kijs.gui.Dom({
            cls: 'kijs-resizer-overlay'
        });

        this._dom.clsAdd('kijs-resizer');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            allowResizeWidth: true,
            allowResizeHeight: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            target: { target: '_targetEl' },
            targetMaxHeight: true,
            targetMaxWidth: true,
            targetMinHeight: true,
            targetMinWidth: true,
            allowResizeWidth: { target: 'allowResizeWidth' },
            allowResizeHeight: { target: 'allowResizeHeight' }
        });

        // Listeners
        this.on('mouseDown', this.#onMouseDown, this);
        this.on('touchStart', this.#onTouchStart, this);
        this.on('touchMove', this.#onTouchMove, this);
        this.on('touchEnd', this.#onTouchEnd, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get allowResizeHeight() {
        return this._dom.clsHas('kijs-resizer-height');
    }
    set allowResizeHeight(val) {
        if (val) {
            this._dom.clsAdd('kijs-resizer-height');
        } else {
            this._dom.clsRemove('kijs-resizer-height');
        }
    }
    
    get allowResizeWidth() {
        return this._dom.clsHas('kijs-resizer-width');
    }
    set allowResizeWidth(val) {
        if (val) {
            this._dom.clsAdd('kijs-resizer-width');
        } else {
            this._dom.clsRemove('kijs-resizer-width');
        }
    }
    
    get target() { return this._targetEl; }

    get targetMaxHeight() { return this._targetMaxHeight; }
    set targetMaxHeight(val) { this._targetMaxHeight = val; }

    get targetMaxWidth() { return this._targetMaxWidth; }
    set targetMaxWidth(val) { this._targetMaxWidth = val; }

    get targetMinHeight() { return this._targetMinHeight; }
    set targetMinHeight(val) { this._targetMinHeight = val; }

    get targetMinWidth() { return this._targetMinWidth; }
    set targetMinWidth(val) { this._targetMinWidth = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    /**
     * Ermittelt die maximale Grösse, die das Element haben darf
     * @returns {Object}
     */
    _getMinMaxSize() {
        const ret = {
            wMin: null,
            wMax: null,
            hMin: null,
            hMax: null
        };

        let parentNode;

        // kijs.gui.Window haben die Eigenschaft targetNode
        const isWindow = !!this._targetEl.targetNode;
        if (isWindow) {
            parentNode = this._targetEl.targetNode;

        // Bei allen anderen Elementen ermitteln wir selber
        } else {
            parentNode = this._targetEl.dom.node.parentNode;
        }


        // Maximale Grösse aufgrund des übergeordneten Elements
        // -------------
        // Window
        if (isWindow) {
            ret.wMax = parentNode.clientWidth + parentNode.offsetLeft - this._targetEl.left;
            ret.hMax = parentNode.clientHeight + parentNode.offsetTop - this._targetEl.top;

        // Panel und andere Elemente
        } else {
            // Breite
            switch (parentNode.style.overflowX) {
                case 'visible':
                case 'scroll':
                case 'auto':
                    ret.wMax = null;
                    break;

                case 'hidden':
                default:
                    ret.wMax = parentNode.clientWidth - this._targetEl.left;
            }

            // Höhe
            switch (parentNode.style.overflowY) {
                case 'visible':
                case 'scroll':
                case 'auto':
                    ret.hMax = null;
                    break;

                case 'hidden':
                default:
                    ret.hMax = parentNode.clientHeight - this._targetEl.top;
            }

        }

        // Max/min Grösse aufgrund der config des resizers
        // -------------
        if (!kijs.isEmpty(this._targetMaxWidth)) {
            if (ret.wMax === null || this._targetMaxWidth < ret.wMax) {
                ret.wMax = this._targetMaxWidth;
            }
        }
        if (!kijs.isEmpty(this._targetMaxHeight)) {
            if (ret.hMax === null || this._targetMaxHeight < ret.hMax) {
                ret.hMax = this._targetMaxHeight;
            }
        }

        if (!kijs.isEmpty(this._targetMinWidth)) {
            if (ret.wMin === null || this._targetMinWidth < ret.wMin) {
                ret.wMin = this._targetMinWidth;
            }
        }
        if (!kijs.isEmpty(this._targetMinHeight)) {
            if (ret.hMin === null || this._targetMinHeight < ret.hMin) {
                ret.hMin = this._targetMinHeight;
            }
        }

        return ret;
    }


    // PRIVATE
    // LISTENERS
    #onMouseDown(e) {
        if (this.disabled) {
            return;
        }

        this._initialPos = {
            x: e.nodeEvent.clientX,
            y: e.nodeEvent.clientY,
            w: this._targetEl.width,
            h: this._targetEl.height
        };
        
        let targetElPos = kijs.Dom.getAbsolutePos(this._targetEl.dom.node);
        
        // Overlay positionieren
        this._overlayDom.top = targetElPos.y;
        this._overlayDom.left = targetElPos.x;
        this._overlayDom.width = targetElPos.w;
        this._overlayDom.height = targetElPos.h;

        // Overlay rendern
        this._overlayDom.render();
        document.body.appendChild(this._overlayDom.node);

        // mousemove und mouseup Listeners auf das document setzen
        kijs.Dom.addEventListener('mousemove', document, this.#onMouseMove, this);
        kijs.Dom.addEventListener('mouseup', document, this.#onMouseUp, this);
    }

    #onMouseMove(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        // Neue Grösse ermitteln
        let w = this._initialPos.w + (e.nodeEvent.clientX - this._initialPos.x);
        let h = this._initialPos.h + (e.nodeEvent.clientY - this._initialPos.y);

        // Max/min-Grösse begrenzen
        const minMaxSize = this._getMinMaxSize();
        if (minMaxSize.wMin !== null && w < minMaxSize.wMin) {
            w = minMaxSize.wMin;
        }
        if (minMaxSize.hMin !== null && h < minMaxSize.hMin) {
            h = minMaxSize.hMin;
        }

        if (minMaxSize.wMax !== null && w > minMaxSize.wMax) {
            w = minMaxSize.wMax;
        }
        if (minMaxSize.hMax !== null && h > minMaxSize.hMax) {
            h = minMaxSize.hMax;
        }
        
        // Wenn Breite nicht veränderbar
        if (!this._dom.clsHas('kijs-resizer-width')) {
            w = this._initialPos.w;
        }
        if (!this._dom.clsHas('kijs-resizer-height')) {
            h = this._initialPos.h;
        }
        
        // Grösse zuweisen
        this._overlayDom.width = w;
        this._overlayDom.height = h;
    }

    #onMouseUp(e) {
        // Beim ersten Auslösen Listeners gleich wieder entfernen
        kijs.Dom.removeEventListener('mousemove', document, this);
        kijs.Dom.removeEventListener('mouseup', document, this);

        // Neue Grösse ermitteln
        let w = this._initialPos.w + (e.nodeEvent.clientX - this._initialPos.x);
        let h = this._initialPos.h + (e.nodeEvent.clientY - this._initialPos.y);

        // Max/min-Grösse begrenzen
        const minMaxSize = this._getMinMaxSize();
        if (minMaxSize.wMin !== null && w < minMaxSize.wMin) {
            w = minMaxSize.wMin;
        }
        if (minMaxSize.hMin !== null && h < minMaxSize.hMin) {
            h = minMaxSize.hMin;
        }

        if (minMaxSize.wMax !== null && w > minMaxSize.wMax) {
            w = minMaxSize.wMax;
        }
        if (minMaxSize.hMax !== null && h > minMaxSize.hMax) {
            h = minMaxSize.hMax;
        }

        // Grösse zuweisen
        if (this._dom.clsHas('kijs-resizer-width')) {
            this._targetEl.width = w;
        }
        if (this._dom.clsHas('kijs-resizer-height')) {
            this._targetEl.height = h;
        }

        // Overlay wieder ausblenden
        this._overlayDom.unrender();
    }

    #onTouchEnd(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        // Neue Grösse ermitteln
        let w = this._overlayDom.width;
        let h = this._overlayDom.height;

        // Max/min-Grösse begrenzen
        const minMaxSize = this._getMinMaxSize();
        if (minMaxSize.wMin !== null && w < minMaxSize.wMin) {
            w = minMaxSize.wMin;
        }
        if (minMaxSize.hMin !== null && h < minMaxSize.hMin) {
            h = minMaxSize.hMin;
        }

        if (minMaxSize.wMax !== null && w > minMaxSize.wMax) {
            w = minMaxSize.wMax;
        }
        if (minMaxSize.hMax !== null && h > minMaxSize.hMax) {
            h = minMaxSize.hMax;
        }

        // Grösse zuweisen
        if (this._dom.clsHas('kijs-resizer-width')) {
            this._targetEl.width = w;
        }
        if (this._dom.clsHas('kijs-resizer-height')) {
            this._targetEl.height = h;
        }

        // Overlay wieder ausblenden
        this._overlayDom.unrender();

        this._initialPos = null;
    }


    #onTouchMove(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        // Neue Grösse ermitteln
        let w = this._initialPos.w + (e.nodeEvent.touches[0].clientX - this._initialPos.x);
        let h = this._initialPos.h + (e.nodeEvent.touches[0].clientY - this._initialPos.y);

        // Max/min-Grösse begrenzen
        const minMaxSize = this._getMinMaxSize();
        if (minMaxSize.wMin !== null && w < minMaxSize.wMin) {
            w = minMaxSize.wMin;
        }
        if (minMaxSize.hMin !== null && h < minMaxSize.hMin) {
            h = minMaxSize.hMin;
        }

        if (minMaxSize.wMax !== null && w > minMaxSize.wMax) {
            w = minMaxSize.wMax;
        }
        if (minMaxSize.hMax !== null && h > minMaxSize.hMax) {
            h = minMaxSize.hMax;
        }

        // Wenn Breite nicht veränderbar
        if (!this._dom.clsHas('kijs-resizer-width')) {
            w = this._initialPos.w;
        }
        if (!this._dom.clsHas('kijs-resizer-height')) {
            h = this._initialPos.h;
        }

        // Grösse zuweisen
        this._overlayDom.width = w;
        this._overlayDom.height = h;

        // Bubbeling und native Listeners verhindern
        e.nodeEvent.stopPropagation();
        e.nodeEvent.preventDefault();
    }

    #onTouchStart(e) {
        if (this.disabled || e.nodeEvent.touches.length > 1) {
            return;
        }

        this._initialPos = {
            x: e.nodeEvent.touches[0].clientX,
            y: e.nodeEvent.touches[0].clientY,
            w: this._targetEl.width,
            h: this._targetEl.height
        };

        let targetElPos = kijs.Dom.getAbsolutePos(this._targetEl.dom.node);

        // Overlay positionieren
        this._overlayDom.top = targetElPos.y;
        this._overlayDom.left = targetElPos.x;
        this._overlayDom.width = targetElPos.w;
        this._overlayDom.height = targetElPos.h;

        // Overlay rendern
        this._overlayDom.render();
        document.body.appendChild(this._overlayDom.node);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._overlayDom) {
            this._overlayDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._initialPos = null;
        this._overlayDom = null;
        this._targetEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Splitter
// --------------------------------------------------------------
kijs.gui.Splitter = class kijs_gui_Splitter extends kijs.gui.Element {

    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._overlayDom = new kijs.gui.Dom();

        this._initialPos = null;
        this._targetPos = null;
        this._targetEl = null;      // Zielelement (kijs.gui.Element)

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            targetPos: 'left'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            target: { target: 'target' },   // Optional. Wenn leer wird das Target aufgrund der targetPos ermittelt
            targetPos: { target: 'targetPos' }
        });

        // Listeners
        this.on('mouseDown', this.#onMouseDown, this);
        this.on('touchStart', this.#onTouchStart, this);
        this.on('touchMove', this.#onTouchMove, this);
        this.on('touchEnd', this.#onTouchEnd, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get direction() {
        if (this._targetPos === 'left' || this._targetPos === 'right') {
            return 'horizontal';
        } else if (this._targetPos === 'top' || this._targetPos === 'bottom') {
            return 'vertical';
        } else {
            throw new kijs.Error(`unknown targetPos`);
        }
    }

    get target() {
        // Falls das Target nicht bekannt ist: automatisch aufgrund der targetPos ermitteln
        if (!this._targetEl) {
            this.target = this._detectTarget();
            if (!this._targetEl) {
                throw new kijs.Error(`config missing "target"`);
            }
        }
        return this._targetEl;
    }
    set target(val) {
        if (!val instanceof kijs.gui.Element) {
            throw new kijs.Error(`Unknown format on config "target"`);
        }
        this._targetEl = val;
    }

    get targetPos() { return this._targetPos; }
    set targetPos(val) {
        if (!kijs.Array.contains(['top', 'right', 'left', 'bottom'], val)) {
            throw new kijs.Error(`unknown targetPos`);
        }

        this._targetPos = val;

        this._dom.clsRemove(['kijs-splitter-horizontal', 'kijs-splitter-vertical']);
        this._dom.clsAdd('kijs-splitter-' + this.direction);

        this._overlayDom.clsRemove(['kijs-splitter-overlay-horizontal', 'kijs-splitter-overlay-vertical']);
        this._overlayDom.clsAdd('kijs-splitter-overlay-' + this.direction);
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    /**
     * Ermittelt den Ziel-Node (target), dessen Grösse angepasst werden soll aufgrund der targetPos
     * @returns {HTMLELement}
     */
    _detectTarget() {
        let targetEl = null;
        if (this._targetPos === 'left' || this._targetPos === 'top') {
            targetEl = this.previous;

        } else if (this._targetPos === 'right' || this._targetPos === 'bottom') {
            targetEl = this.next;

        }
        return targetEl;
    }

    _updateSpliterPosition() {
        // Differenz zur vorherigen Position ermitteln
        let offset;
        if (this.direction === 'horizontal') {
            offset = this._overlayDom.left - this._initialPos;
        } else {
            offset = this._overlayDom.top - this._initialPos;
        }
        
        // Overlay wieder ausblenden
        this._overlayDom.unrender();

        // Neue Breite des Zielelements berechnen und zuweisen
        switch (this._targetPos) {
            case 'top': this.target.height = this.target.height + offset; break;
            case 'right': this.target.width = this.target.width - offset; break;
            case 'bottom': this.target.height = this.target.height - offset; break;
            case 'left': this.target.width = this.target.width + offset; break;
        }
    }

    /**
     * Aktualisiert die Overlay-Position aufgrund der Mauszeigerposition
     * @param {Number} xAbs     Mausposition clientX
     * @param {Number} yAbs     Mausposition clientY
     * @returns {undefined}
     */
    _updateOverlayPosition(xAbs, yAbs) {
        // Berechnet aus der absoluten Position bezogen zum Browserrand,
        // die relative Position bezogen zum übergeordneten DOM-Node
        const parentPos = kijs.Dom.getAbsolutePos(this._dom.node.parentNode);
        const newPos = {
            x: xAbs - parentPos.x,
            y: yAbs - parentPos.y
        };

        if (this.direction === 'horizontal') {
            this._overlayDom.left = newPos.x;
        } else {
            this._overlayDom.top = newPos.y;
        }
    }


    // PRIVATE
    // LISTENERS
    #onMouseDown(e) {
        if (this.disabled) {
            return;
        }

        if (this.direction === 'horizontal') {
            this._initialPos = e.nodeEvent.clientX;
        } else {
            this._initialPos = e.nodeEvent.clientY;
        }

        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.clientX, e.nodeEvent.clientY);

        // Overlay rendern
        this._overlayDom.render();
        this._dom.node.parentNode.appendChild(this._overlayDom.node);

        // mousemove und mouseup Listeners auf das document setzen
        kijs.Dom.addEventListener('mousemove', document, this.#onMouseMove, this);
        kijs.Dom.addEventListener('mouseup', document, this.#onMouseUp, this);
    }

    #onMouseMove(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.clientX, e.nodeEvent.clientY);
    }

    #onMouseUp(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        // Beim ersten auslösen Listeners gleich wieder entfernen
        kijs.Dom.removeEventListener('mousemove', document, this);
        kijs.Dom.removeEventListener('mouseup', document, this);

        this._updateSpliterPosition();

        this._initialPos = null;
    }

    #onTouchEnd(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        this._updateSpliterPosition();

        this._initialPos = null;
    }


    #onTouchMove(e) {
        if (this.disabled || this._initialPos === null) {
            return;
        }

        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.touches[0].clientX, e.nodeEvent.touches[0].clientY);

        // Bubbeling und native Listeners verhindern
        e.nodeEvent.stopPropagation();
        e.nodeEvent.preventDefault();
    }

    #onTouchStart(e) {
        if (this.disabled || e.nodeEvent.touches.length > 1) {
            return;
        }

        if (this.direction === 'horizontal') {
            this._initialPos = e.nodeEvent.touches[0].clientX;
        } else {
            this._initialPos = e.nodeEvent.touches[0].clientY;
        }

        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.touches[0].clientX, e.nodeEvent.touches[0].clientY);

        // Overlay rendern
        this._overlayDom.render();
        this._dom.node.parentNode.appendChild(this._overlayDom.node);
    }


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._overlayDom) {
            this._overlayDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._overlayDom = null;
        this._targetEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Panel
// --------------------------------------------------------------
kijs.gui.Panel = class kijs_gui_Panel extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._headerBarEl = new kijs.gui.PanelBar({
            cls: 'kijs-headerbar',
            parent: this,
            on: {
                click: this.#onHeaderBarClick,
                dblClick: this.#onHeaderBarDblClick,
                context: this
            }
        });

        this._headerEl = new kijs.gui.container.Scrollable({
            cls: 'kijs-header',
            parent: this
        });

        this._footerEl = new kijs.gui.container.Scrollable({
            cls: 'kijs-footer',
            parent: this
        });

        this._footerBarEl = new kijs.gui.PanelBar({
            cls: 'kijs-footerbar',
            parent: this
        });

        this._collapseHeight = null;    // Schwellwert, wenn die Höhe kleiner ist, wird zugeklappt
        this._collapseWidth = null;     // Schwellwert, wenn die Breite kleiner ist, wird zugeklappt
        
        // Masse, die bei collapse oder Maximize hier zwischengespeichert werden, damit sie dann bei 
        // expand/restore wieder wie vorher sind.
        this._expandedSize = { 
            left:null, top:null,
            width:null, height:null, 
            marginLeft:null, marginRight:null, marginTop:null, marginBottom:null
        };
        
        this._domPos = null;
        
        this._closeButtonEl = null;
        this._collapseButtonEl = null;
        this._innerDisabled = false;
        this._maximizeButtonEl = null;
        this._collapsible = false;
        this._resizerEl = null;

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-panel');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            collapseHeight: 50,
            collapseWidth: 50,
            headerScrollableX: 'auto',
            headerScrollableY: false,
            footerScrollableX: 'auto',
            footerScrollableY: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // headerBar
            caption: { target: 'html', context: this._headerBarEl },
            
            collapseHeight: true,
            collapseWidth: true,

            iconChar: { target: 'iconChar', context: this._headerBarEl },
            iconCls: { target: 'iconCls', context: this._headerBarEl },
            iconColor: { target: 'iconColor', context: this._headerBarEl },
            iconMap: { target: 'iconMap', context: this._headerBarEl },
            
            headerBarCls: { fn: 'function', target: this._headerBarEl.dom.clsAdd, context: this._headerBarEl.dom },
            headerBarDefaults: { target: 'defaults', context: this._headerBarEl },
            headerBarDisabled: { target: 'disabled', context: this._headerBarEl },
            headerBarElements: { fn: 'function', target: this._headerBarEl.containerRightEl.add, context: this._headerBarEl.containerRightEl },
            headerBarStyle: { fn: 'assign', target: 'style', context: this._headerBarEl.dom },

            // header
            headerCls: { fn: 'function', target: this._headerEl.dom.clsAdd, context: this._headerEl.dom },
            headerDefaults: { target: 'defaults', context: this._headerEl },
            headerDisabled: { target: 'disabled', context: this._headerEl },
            headerElements: { fn: 'function', target: this._headerEl.add, context: this._headerEl },
            headerInnerCls: { fn: 'function', target: this._headerEl.innerDom.clsAdd, context: this._headerEl.innerDom },
            headerInnerStyle: { fn: 'assign', target: 'style', context: this._headerEl.innerDom },
            headerScrollableX: { target: 'scrollableX', context: this._headerEl },
            headerScrollableY: { target: 'scrollableY', context: this._headerEl },
            headerStyle: { fn: 'assign', target: 'style', context: this._headerEl.dom },
            
            // inner
            innerDisabled: { target: 'innerDisabled' },
            
            // footer
            footerCls: { fn: 'function', target: this._footerEl.dom.clsAdd, context: this._footerEl.dom },
            footerDefaults: { target: 'defaults', context: this._footerEl },
            footerDisabled: { target: 'disabled', context: this._footerEl },
            footerElements: { fn: 'function', target: this._footerEl.add, context: this._footerEl },
            footerInnerCls: { fn: 'function', target: this._footerEl.innerDom.clsAdd, context: this._footerEl.innerDom },
            footerInnerStyle: { fn: 'assign', target: 'style', context: this._footerEl.innerDom },
            footerScrollableX: { target: 'scrollableX', context: this._footerEl },
            footerScrollableY: { target: 'scrollableY', context: this._footerEl },
            footerStyle: { fn: 'assign', target: 'style', context: this._footerEl.dom },

            // footerBar
            footerBarCaption: { target: 'html', context: this._footerBarEl },
            footerBarDefaults: { target: 'defaults', context: this._footerBarEl },
            footerBarDisabled: { target: 'disabled', context: this._footerBarEl },
            footerBarElements: { fn: 'function', target: this._footerBarEl.containerLeftEl.add, context: this._footerBarEl.containerLeftEl },
            footerBarStyle: { fn: 'assign', target: 'style', context: this._footerBarEl.dom },

            resizable: { target: 'resizable' }, // Soll in der rechten unteren Ecke das resize-Sybmol zum ändern der Grösse angezeigt werden.
            resizableWidth: { target: 'resizableWidth' }, // Soll in der rechten unteren Ecke das resize-Sybmol zum ändern der Breite angezeigt werden.
            resizableHeight: { target: 'resizableHeight' }, // Soll in der rechten unteren Ecke das resize-Sybmol zum ändern der Höhe angezeigt werden.
            
            collapsible: { prio: 1002, target: 'collapsible' },
            collapseButton: { prio: 1003, target: 'collapseButton' },
            collapsed: { prio: 1004, target: 'collapsed' },

            maximizable: { prio: 1010, target: 'maximizable' },
            maximizeButton: { prio: 1011, target: 'maximizeButton' },
            maximized: { prio: 1012, target: 'maximized' },

            closable: { prio: 1013, target: 'closable' },
            closeButton: { prio: 1014, target: 'closeButton' }

        });

        // Listeners
        this.on('enterPress', this.#onEnterPress, this);
        this.on('escPress', this.#onEscPress, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._headerBarEl.html; }
    set caption(val) { this._headerBarEl.html = val; }

    get closable() { return !!this._closeButtonEl;}
    set closable(val) {
        if (val) {
            if (!this._closeButtonEl) {
                this.closeButton = {
                    iconMap: 'kijs.iconMap.Fa.xmark'
                };
            }
        } else {
            if (this._closeButtonEl) {
                this.closeButton = null;
            }
        }
    }

    get closeButton() { return this._closeButtonEl; }
    set closeButton(val) {
        // Button entfernen
        if (kijs.isEmpty(val)) {
            this._headerBarEl.containerRightEl.remove(this._closeButtonEl);
            this._closeButtonEl = null;

        // Instanz von kijs.gui.Button
        } else if (val instanceof kijs.gui.Button) {
            if (this._closeButtonEl) {
                this._headerBarEl.containerRightEl.remove(this._closeButtonEl);
            }
            this._closeButtonEl = val;
            this._closeButtonEl.on('click', this.#onCloseClick, this);
            this._headerBarEl.containerRightEl.add(this._closeButtonEl);

        // Config-Objekt
        } else if (kijs.isObject(val)) {
            if (this._closeButtonEl) {
                this._closeButtonEl.applyConfig(val);
            } else {
                this._closeButtonEl = new kijs.gui.Button(val);
                this._closeButtonEl.on('click', this.#onCloseClick, this);
                this._headerBarEl.containerRightEl.add(this._closeButtonEl);
            }

        } else {
            throw new kijs.Error(`Unknown format on config "closeButton"`);
        }

        if (this.isRendered) {
            this.render();
        }
    }

    get collapseButton() { return this._collapseButtonEl; }
    set collapseButton(val) {
        // Button entfernen
        if (kijs.isEmpty(val)) {
            if (this._collapseButtonEl) {
                this._headerBarEl.containerRightEl.remove(this._collapseButtonEl);
            }
            this._collapseButtonEl = null;

        // Instanz von kijs.gui.Button
        } else if (val instanceof kijs.gui.Button) {
            if (this._collapseButtonEl) {
                this._headerBarEl.containerRightEl.remove(this._collapseButtonEl);
            }
            this._collapseButtonEl = val;
            this._collapseButtonEl.on('click', this.#onCollapseClick, this);
            this._headerBarEl.containerRightEl.add(this._collapseButtonEl);

        // Config-Objekt
        } else if (kijs.isObject(val)) {
            if (this._collapseButtonEl) {
                this._collapseButtonEl.applyConfig(val);
            } else {
                this._collapseButtonEl = new kijs.gui.Button(val);
                this._collapseButtonEl.on('click', this.#onCollapseClick, this);
                this._headerBarEl.containerRightEl.add(this._collapseButtonEl);
            }

        } else {
            throw new kijs.Error(`Unknown format on config "collapseButton"`);
        }

        if (this.isRendered) {
            this.render();
        }
    }

    get collapsed() {
        return this._dom.clsHas('kijs-collapse-top') ||
                this._dom.clsHas('kijs-collapse-right') ||
                this._dom.clsHas('kijs-collapse-bottom') ||
                this._dom.clsHas('kijs-collapse-left');
    }
    set collapsed(val) {
        if (val) {
            if (val === 'toggle') {
                if (this.collapsed) {
                    this.expand();
                } else {
                    this.collapse();
                }
            } else {
                this.collapse();
            }
        } else {
            this.expand();
        }
    }

    get collapseHeight() { return this._collapseHeight; }
    set collapseHeight(val) { this._collapseHeight = val; }

    get collapseWidth() { return this._collapseWidth; }
    set collapseWidth(val) { this._collapseWidth = val; }

    get collapsible() {
        if (this._collapseButtonEl) {
            return this._collapsible;
        } else {
            return false;
        }
    }
    set collapsible(val) {
        const validePos = ['top', 'right', 'bottom', 'left'];

        if (kijs.isEmpty(val) || val === false) {
            val = false;
            this._collapsible = false;
        } else {
            if (kijs.Array.contains(validePos, val)) {
                this._collapsible = val;
            } else {
                throw new kijs.Error(`Unknown pos on config "collapsible"`);
            }
        }

        if (val) {
            if (!this._collapseButtonEl) {
                this.collapseButton = {
                    iconMap: this._getCollapseIconMap()
                };
            }
        } else {
            if (this._collapseButtonEl) {
                this.collapseButton = null;
            }
        }
    }
    
    get draggable() { return false; }

    get footer() { return this._footerEl; }

    get footerBar() { return this._footerBarEl; }

    get header() { return this._headerEl; }

    get headerBar() { return this._headerBarEl; }

    // overwrite
    get height() { return super.height; }
    set height(val) {
        let doFn = false;

        if (kijs.Array.contains(['top', 'bottom'], this.collapsible) && kijs.isNumber(this._collapseHeight)) {
            if (val <= this._collapseHeight) {
                doFn = 'collapse';
            } else if (this.collapsed) {
                doFn = 'expand';
            }
        }
        
        // Höhe merken, damit beim aufklappen, wieder die gleiche Höhe wiederhergestellt werden kann
        if (kijs.isNumber(this._collapseHeight) && val > kijs.isNumber(this._collapseHeight)) {
            this._expandedSize.height = val;
        }
        
        if (doFn === 'collapse') {
            if (!this.collapsed) {
                this.collapse();
            }
        } else if (doFn === 'expand') {
            this.expand(val);
        } else {
            super.height = val;
        }
    }

    get innerDisabled() { return this._innerDisabled; }
    set innerDisabled(val) {
        this._innerDisabled = !!val;
        kijs.Array.each(this._elements, function(el) {
            el.changeDisabled(!!val, true);
        }, this);
    }

    get maximizable() { return !!this._maximizeButtonEl; }
    set maximizable(val) {
        if (val) {
            if (!this._maximizeButtonEl) {
                this.maximizeButton = new kijs.gui.Button({
                    iconMap: this._getMaximizeIconMap()
                });
            }
        } else {
            if (this._maximizeButtonEl) {
                this.maximizeButton = null;
            }
        }
    }

    get maximizeButton() { return this._maximizeButtonEl; }
    set maximizeButton(val) {
        // Button entfernen
        if (kijs.isEmpty(val)) {
            this._headerBarEl.containerRightEl.remove(this._maximizeButtonEl);
            this._maximizeButtonEl = null;

        // Instanz von kijs.gui.Button
        } else if (val instanceof kijs.gui.Button) {
            if (this._maximizeButtonEl) {
                this._headerBarEl.containerRightEl.remove(this._maximizeButtonEl);
            }
            this._maximizeButtonEl = val;
            this._maximizeButtonEl.on('click', this.#onMaximizeClick, this);
            this._headerBarEl.containerRightEl.add(this._maximizeButtonEl);

        // Config-Objekt
        } else if (kijs.isObject(val)) {
            if (this._maximizeButtonEl) {
                this._maximizeButtonEl.applyConfig(val);
            } else {
                this._maximizeButtonEl = new kijs.gui.Button(val);
                this._maximizeButtonEl.on('click', this.#onMaximizeClick, this);
                this._headerBarEl.containerRightEl.add(this._maximizeButtonEl);
            }

        } else {
            throw new kijs.Error(`Unknown format on config "maximizeButton"`);
        }

        if (this.isRendered) {
            this.render();
        }
    }

    get maximized() {
        return this._dom.clsHas('kijs-maximize');
    }
    set maximized(val) {
        if (val) {
            this.maximize();
        } else {
            this.restore();
        }
    }

    get resizable() { return !!this._resizerEl; }
    set resizable(val) {
        if (val) {
            this._setResizable(true, true);
        } else {
            this._setResizable(false, false);
        }
    }
    
    get resizableHeight() {
        return this._resizerEl && this._resizerEl.allowResizeHeight;
    }
    set resizableHeight(val) {
        this._setResizable(null, !!val);
    }
    
    get resizableWidth() {
        return this._resizerEl && this._resizerEl.allowResizeWidth;
    }
    set resizableWidth(val) {
        this._setResizable(!!val, null);
    }
    
    // overwrite
    get width() { return super.width; }
    set width(val) {
        let doFn = false;

        if (kijs.Array.contains(['left', 'right'], this.collapsible) && kijs.isNumber(this._collapseWidth)) {
            if (val <= this._collapseWidth) {
                doFn = 'collapse';
            } else if (this.collapsed) {
                doFn = 'expand';
            }
        }
        
        // Breite merken, damit beim aufklappen, wieder die gleiche Breite wiederhergestellt werden kann
        if (kijs.isNumber(this._collapseWidth) && val > kijs.isNumber(this._collapseWidth)) {
            this._expandedSize.width = val;
        }
        
        if (doFn === 'collapse') {
            if (!this.collapsed) {
                this.collapse();
            }
        } else if (doFn === 'expand') {
            this.expand(val);
        } else {
            super.width = val;
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._headerBarEl.changeDisabled(!!val, true);
        this._headerEl.changeDisabled(!!val, true);
        this._footerEl.changeDisabled(!!val, true);
        this._footerBarEl.changeDisabled(!!val, true);
        if (this._resizerEl) {
            this._resizerEl.changeDisabled(!!val, true);
        }
    }
    
    /**
     * Schliesst das Panel
     * @param {Boolean} [preventDestruct=false]  Kein 'close' Event auslösen
     * @param {Boolean} [preventEvents=false]    Das Auslösen des beforeClose und close-Events verhindern?
     * @param {Boolean} [superCall=false]
     * @returns {undefined}
     */
    close(preventDestruct, preventEvents, superCall) {
        if (!superCall) {
            if (!preventEvents) {
                // beforeClose Event. Bei Rückgabe=false -> abbrechen
                if (this.raiseEvent('beforeClose') === false) {
                    return;
                }
            }
        }
        
        if (this._parentEl && (this._parentEl instanceof kijs.gui.Container) && this._parentEl.hasChild(this)) {
            this._parentEl.remove([this], {
                preventRender: false,
                preventDestruct: true,
                preventEvents: preventEvents
            });
        } else {
            this.unrender();
        }
        
        if (!preventEvents) {
            this.raiseEvent('close');
        }

        if (!preventDestruct) {
            this.destruct();
        }
    }

    /**
     * Minimiert das Panel in eine gewünschte Richtung
     * @param {String} direction [optional]
     * @returns {undefined}
     */
    collapse(direction) {
        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        if (this.maximized) {
            this.restore();
        }

        if (direction) {
            this._collapsible = direction;
        }

        if (!this._collapsible) {
            this._collapsible = 'top';
        }

        this._dom.clsRemove(['kijs-collapse-top', 'kijs-collapse-right', 'kijs-collapse-bottom', 'kijs-collapse-left']);

        switch (this._collapsible) {
            case 'top':
                this._dom.clsAdd('kijs-collapse-top');
                this._dom.height = null;
                break;
                
            case 'right':
                this._dom.clsAdd('kijs-collapse-right');
                this._dom.width = null;
                break;
                
            case 'bottom':
                this._dom.clsAdd('kijs-collapse-bottom');
                this._dom.height = null;
                break;
                
            case 'left':
                this._dom.clsAdd('kijs-collapse-left');
                this._dom.width = null;
                break;
                
        }

        // das richtige Icon in den Button
        if (this._collapseButtonEl) {
            this._collapseButtonEl.iconMap = this._getCollapseIconMap();
        }

        // Event werfen
        this.raiseEvent('collapse');

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    /**
     * Expandiert das Panel
     * @param {Number} size [optional] Breite oder Höhe in die das Panel wiederhergestellt werden soll
     * @returns {undefined}
     */
    expand(size) {
        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        this._dom.clsRemove(['kijs-collapse-top', 'kijs-collapse-right', 'kijs-collapse-bottom', 'kijs-collapse-left']);

        // das richtige Icon in den Button
        if (this._collapseButtonEl) {
            this._collapseButtonEl.iconMap = this._getCollapseIconMap();
        }
        
        // falls kein size übergeben wurde, die letzte breite/höhe nehmen
        if (kijs.isEmpty(size)) {
            switch (this._collapsible) {
                case 'top':
                case 'bottom':
                    if (!kijs.isEmpty(this._expandedSize.height)) {
                        size = this._expandedSize.height;
                    }
                    break;

                case 'right':
                case 'left':
                    if (!kijs.isEmpty(this._expandedSize.width)) {
                        size = this._expandedSize.width;
                    }
                    break;
            }
        }
        
        // Übergebene Grösse wiederherstellen
        if (!kijs.isEmpty(size)) {
            switch (this._collapsible) {
                case 'top':
                case 'bottom':
                    if (size > this._collapseHeight) {
                        this.height = size;
                    }
                    break;

                case 'right':
                case 'left':
                    if (size > this._collapseWidth) {
                        this.width = size;
                    }
                    break;
            }
        }

        // Event werfen
        this.raiseEvent('expand');

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    // overwrite
    focus(alsoSetIfNoTabIndex) {
        if (alsoSetIfNoTabIndex) {
            return super.focus(alsoSetIfNoTabIndex);

        } else {
            // Zuerst versuchen den Fokus auf ein Element im innerDom zu setzen
            let nde = this._innerDom.focus(false);
            // dann auf eine Schaltfläche im footer
            if (!nde && !this._footerEl.isEmpty && this._footerEl.isRendered) {
                nde = this._footerEl.focus(alsoSetIfNoTabIndex);
            }
            // falls nicht erfolgreich. Den Fokus direkt auf das Fenster setzen
            if (!nde) {
                nde = super.focus(alsoSetIfNoTabIndex);
            }
            return nde;
        }

        // Darf der Node den Fokus erhalten?
        if (alsoSetIfNoTabIndex) {
            this._dom.node.focus();

        // sonst den Fokus auf den ersten möglichen untegeordneten Node settzen
        } else {
            const nde = kijs.Dom.getFirstFocusableNode(this._node);
            if (nde) {
                nde.focus();
                return nde;
            }
        }
        
        return false;
    }

    /**
     * Maximiert das Panel
     * @returns {undefined}
     */
    maximize() {
        if (this.maximized) {
            return;
        }

        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        if (this.collapsed) {
            this.expand();
        }

        if (this.isRendered) {
            this._domPos = {
                parent: this._dom.node.parentNode,
                nextSibling: this._dom.node.nextSibling
            };
            document.body.appendChild(this._dom.node);
        }
        
        this._expandedSize.left = this._dom.style.left;
        this._expandedSize.top = this._dom.style.top;
        this._expandedSize.marginLeft = this._dom.style.marginLeft;
        this._expandedSize.marginRight = this._dom.style.marginRight;
        this._expandedSize.marginTop = this._dom.style.marginTop;
        this._expandedSize.marginBottom = this._dom.style.marginBottom;
        
        this._dom.clsAdd('kijs-maximize');
        this.left = 0;
        this.top = 0;
        this._dom.width = null;
        this._dom.height = null;
        this._dom.style.marginLeft = 0;
        this._dom.style.marginRight = 0;
        this._dom.style.marginTop = 0;
        this._dom.style.marginBottom = 0;
        
        // das richtige Icon in den Button
        if (this._maximizeButtonEl) {
            this._maximizeButtonEl.iconMap = this._getMaximizeIconMap();
        }

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    // Overwrite
    render(superCall) {
        // dom mit elements rendern (innerDom)
        super.render(true);

        // HeaderBar rendern (kijs.gui.Bar)
        if (!this._headerBarEl.isEmpty) {
            this._headerBarEl.renderTo(this._dom.node, this._innerDom.node);
        } else if (this._headerBarEl.isRendered) {
            this._headerBarEl.unrender();
        }

        // Header rendern (kijs.gui.Container)
        if (!this._headerEl.isEmpty) {
            this._headerEl.renderTo(this._dom.node, this._innerDom.node);
        } else if (this._headerEl.isRendered) {
            this._headerEl.unrender();
        }

        // Footer rendern (kijs.gui.Container)
        if (!this._footerEl.isEmpty) {
            this._footerEl.renderTo(this._dom.node);
        } else if (this._footerEl.isRendered) {
            this._footerEl.unrender();
        }

        // FooterBar rendern (kijs.gui.Bar)
        if (!this._footerBarEl.isEmpty) {
            this._footerBarEl.renderTo(this._dom.node);
        } else if (this._footerBarEl.isRendered) {
            this._footerBarEl.unrender();
        }

        // resizer
        if (this._resizerEl) {
            this._resizerEl.renderTo(this._dom.node);
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // Overwrite
    renderTo(targetNode, insertBefore) {
        // Falls das Panel schon maximiert geöffnet werden soll, muss der Node zum body verschoben werden
        if (this.maximized && kijs.isEmpty(this._domPos)) {
            this._domPos = {
                parent: targetNode,
                nextSibling: insertBefore
            };
            targetNode = document.body;
            insertBefore = null;
        }

        super.renderTo(targetNode, insertBefore);
    }

    /**
     * Verlässt die maximierte Ansicht
     * @returns {undefined}
     */
    restore() {
        if (!this.maximized) {
            return;
        }

        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        if (this._domPos.nextSibling) {
            this._domPos.parent.insertBefore(this._dom.node, this._domPos.nextSibling);
        } else {
            this._domPos.parent.appendChild(this._dom.node);
        }

        this._dom.clsRemove('kijs-maximize');

        if (!kijs.isEmpty(this._expandedSize.left)) {
            this._dom.style.left = this._expandedSize.left;
        }
        if (!kijs.isEmpty(this._expandedSize.top)) {
            this._dom.style.top = this._expandedSize.top;
        }
        if (!kijs.isEmpty(this._expandedSize.width)) {
            this._dom.width = this._expandedSize.width;
        }
        if (!kijs.isEmpty(this._expandedSize.height)) {
            this._dom.height = this._expandedSize.height;
        }
        if (!kijs.isEmpty(this._expandedSize.marginLeft)) {
            this._dom.style.marginLeft = this._expandedSize.marginLeft;
        }
        if (!kijs.isEmpty(this._expandedSize.marginRight)) {
            this._dom.style.marginRight = this._expandedSize.marginRight;
        }
        if (!kijs.isEmpty(this._expandedSize.marginTop)) {
            this._dom.style.marginTop = this._expandedSize.marginTop;
        }
        if (!kijs.isEmpty(this._expandedSize.marginBottom)) {
            this._dom.style.marginBottom = this._expandedSize.marginBottom;
        }

        // das richtige Icon in den Button
        if (this._maximizeButtonEl) {
            this._maximizeButtonEl.iconMap = this._getMaximizeIconMap();
        }

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        if (this._headerBarEl) {
            this._headerBarEl.unrender();
        }
        if (this._headerEl) {
            this._headerEl.unrender();
        }
        if (this._footerEl) {
            this._footerEl.unrender();
        }
        if (this._footerBarEl) {
            this._footerBarEl.unrender();
        }
        if (this._resizerEl) {
            this._resizerEl.unrender();
        }
        super.unrender(true);
    }


    // PROTECTED
    /**
     * Gibt das Icon für den Maximieren-Knopf zurück
     * @returns {String}
     */
    _getMaximizeIconMap() {
        if (this.maximized) {
            return 'kijs.iconMap.Fa.window-restore';
        } else {
            return 'kijs.iconMap.Fa.window-maximize';
        }
    }

    /**
     * Gibt das Icon für den Collapse-Knopf zurück
     * @returns {undefined}
     */
    _getCollapseIconMap() {
        if (this.collapsed) {
            switch (this._collapsible) {
                case 'top': return 'kijs.iconMap.Fa.caret-down';
                case 'right': return 'kijs.iconMap.Fa.caret-left';
                case 'bottom': return 'kijs.iconMap.Fa.caret-up';
                case 'left': return 'kijs.iconMap.Fa.caret-right';
            }
        } else {
            switch (this._collapsible) {
                case 'top': return 'kijs.iconMap.Fa.caret-up';
                case 'right': return 'kijs.iconMap.Fa.caret-right';
                case 'bottom': return 'kijs.iconMap.Fa.caret-down';
                case 'left': return 'kijs.iconMap.Fa.caret-left';
            }
        }
        return '';
    }
    
    /**
     * Zeigt das Resize-Icon in der unteren rechten Ecke an oder blendet es aus.
     * @param {Boolean|null} resizeWidth Breite änderbar
     * @param {Boolean|null} resizeHeight Höhe änderbar
     * @returns {undefined}
     */
    _setResizable(resizeWidth, resizeHeight) {
        if (resizeWidth === null) {
            resizeWidth = this._resizerEl && this._resizerEl.allowResizeWidth;
        }
        if (resizeHeight === null) {
            resizeHeight = this._resizerEl && this._resizerEl.allowResizeHeight;
        }
        
        const hasResizer = resizeWidth || resizeHeight;
        
        if (hasResizer !== !!this._resizerEl) {
            if (this._resizerEl) {
                this._resizerEl.destruct();
                this._resizerEl = null;
            } else {
                this._resizerEl = new kijs.gui.Resizer({
                    target: this
                });
                if (this._dom.node) {
                    this._resizerEl.renderTo(this._dom.node);
                }
            }
        }
        
        if (hasResizer) {
            this._resizerEl.allowResizeWidth = resizeWidth;
            this._resizerEl.allowResizeHeight = resizeHeight;
        }
    }


    // PRIVATE
    // LISTENERS
    #onCloseClick(e) {
        this.close();
    }

    #onCollapseClick(e) {
        if (this.collapsed) {
            this.expand();
        } else {
            this.collapse();
        }
    }

    #onEnterPress(e) {
        // Gibt es einen Button mit Eigenschaft isDefault?
        if (this._footerEl) {
            kijs.Array.each(this._footerEl.elements, function(el) {
                if ((el instanceof kijs.gui.Button) && el.dom && el.isDefault) {

                    // Wenn der Fokus nicht auf dem Element, Click-Event werfen
                    if (document.activeElement !== el.dom.node) {
                        el.raiseEvent('click');
                    }
                    return;
                }
            }, this);
        }
    }
    
    #onEscPress(e) {
        if (this.closable) {
            this.close();
        }
    }

    #onHeaderBarClick(e) {
        // Ein Panel (draggable=false) kann per click auf die HeaderBar auf/zugeklappt werden.
        if (this.collapsible && !this.maximized && !this.draggable) {
            if (this.collapsed) {
                this.expand();
            } else {
                this.collapse();
            }
        }
    }

    #onHeaderBarDblClick(e) {
        // Ein Fenster (draggable=true) kann per dblClick auf die HeaderBar maximiert werden.
        if (this.maximizable && this.draggable) {
            if (this.maximized) {
                this.restore();
            } else {
                this.maximize();
            }

        // Falls das Fenster maximiert ist, kann es jederzeit durch einen Doppelklick wiederhergestellt werden
        } else if (this.maximizable && this.maximized) {
            this.restore();
        }
    }

    #onMaximizeClick(e) {
        if (this.maximized) {
            this.restore();
        } else {
            this.maximize();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._headerBarEl) {
            this._headerBarEl.destruct();
        }
        if (this._headerEl) {
            this._headerEl.destruct();
        }
        if (this._footerEl) {
            this._footerEl.destruct();
        }
        if (this._footerBarEl) {
            this._footerBarEl.destruct();
        }
        if (this._resizerEl) {
            this._resizerEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._domPos = null;
        this._headerBarEl = null;
        this._headerEl = null;
        this._footerEl = null;
        this._footerBarEl = null;
        this._closeButtonEl = null;
        this._collapseButtonEl = null;
        this._maximizeButtonEl = null;
        this._resizerEl = null;
        this._expandedSize = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.dashboard (namespace)
// --------------------------------------------------------------
kijs.gui.dashboard = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.dashboard.Panel
// --------------------------------------------------------------
/**
 * Panel Element, zur Verwendung in kijs.gui.Dasboard Elementen.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.Panel
 *    kijs.gui.dashboard.Panel
 *
 */
kijs.gui.dashboard.Panel = class kijs_gui_dashboard_Panel extends kijs.gui.Panel {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-dashboard-panel');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // nix
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // nix
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // gibt Grund-Daten zum Panel zurück, wie caption und Position.
    // der Inhalt des Panels hingegen, wird vom Panel selbst verwaltet.
    get posData() {
        let ret = {
            xtype: this.xtype
        };
        if (!kijs.isEmpty(this.name)) {
            ret.name = this.name;
        }
        if (this.collapsed) {
            ret.collapsed = this.collapsed;
        } else {
            if (this.resizableHeight) {
                ret.height = this.height;
            }
        }
        if (this.userData) {
            ret.userData = this.userData;
        }
        return ret;
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        super.unrender(true);
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.dashboard.Column
// --------------------------------------------------------------
/**
 * Panel Element, zur Verwendung in kijs.gui.Dasboard Elementen.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.Container
 *   kijs.gui.dashboard.Column
 *
 */
kijs.gui.dashboard.Column = class kijs_gui_dashboard_Column extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._ddTarget = null;
        
        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-dashboard-column');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // nix
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            ddTarget: { target: 'ddTarget' }
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get ddTarget() { 
        return this._ddTarget; 
    }
    set ddTarget(val) {
        // config-object
        if (kijs.isObject(val)) {
            if (kijs.isEmpty(this._ddTarget)) {
                val.ownerEl = this;
                if (kijs.isEmpty(val.ownerDomProperty)) {
                    val.ownerDomProperty = 'innerDom';
                }
                this._ddTarget = new kijs.gui.dragDrop.Target(val);
            } else {
                this._ddTarget.applyConfig(val);
            }

        // null
        } else if (val === null) {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;
            
        } else {
            throw new kijs.Error(`ddTarget must be a object or null`);
            
        }
    }
    
    // gibt Grund-Daten zur Spalte zurück.
    // der Inhalt der Panels hingegen, wird von den Panels selbst verwaltet.
    get posData() {
        let ret = {
            xtype: this.xtype,
            elements: []
        };
        
        kijs.Array.each(this._elements, function(el) {
            ret.elements.push(el.posData);
        }, this);
        
        return ret;
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        super.unrender(true);
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        if (this._ddTarget) {
            this._ddTarget.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._ddTarget = null;
                
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Dashboard
// --------------------------------------------------------------
kijs.gui.Dashboard = class kijs_gui_Dashboard extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._sortable = false;      // Panels sind per Drag&Drop verschiebbar
        this._ddPosBeforeAfterFactor = 0.66;  // Position, ab der nachher statt vorher eingefügt wird
        this._ddPanelName = 'kijs.gui.dashboard.Panel';
        this._ddMapping = {};
        
        this._rpcSaveFn = null;     // Name der remoteFn. Bsp: 'dashboard.save'
        this._rpcSaveArgs = {};     // Standard RPC-Argumente fürs Speichern
        this._autoSave = false;     // Automatisches Speichern bei Änderungen
        
        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-dashboard');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            sortable: true,
            scrollableY: 'auto'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            ddPanelName: true,
            ddPosBeforeAfterFactor: true,
            
            rpcSaveFn: true,    // Name der remoteFn. Bsp: 'dashboard.save'
            rpcSaveArgs: true,  // Standard RPC-Argumente fürs Speichern
            autoSave: true,     // Automatisches Speichern bei Änderungen
            
            sortable: { prio: 90, target: 'sortable' },
            ddMapping: { prio: 100, target: 'ddMapping' }
        });
        
        // Listeners
        this.on('add', this.#onAddColumns, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autoSave() { return this._autoSave; }
    set autoSave(val) { this._autoSave = !!val; }

    get ddMapping() { return this._ddMapping; }
    set ddMappping(val) {
        if (!kijs.isObject(val)) {
            throw new kijs.Error(`"ddMapping" is not valid.`);
        }
        
        kijs.Object.assignDeep(this._ddMapping, val, true);
    }
    
    get ddPanelName() { return this._ddPanelName; }
    set ddPanelName(val) { this._ddPanelName = val; }
    
    get ddPosBeforeAfterFactor() { return this._ddPosBeforeAfterFactor; }
    set ddPosBeforeAfterFactor(val) { this._ddPosBeforeAfterFactor = val; }
    
    get rpcSaveArgs() { return this._rpcSaveArgs; }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }
    
    get rpcSaveFn() { return this._rpcSaveFn; }
    set rpcSaveFn(val) { this._rpcSaveFn = val; }

    get sortable() { return this._sortable; }
    set sortable(val) { 
        this._sortable = !!val;
        
        if (val) {
            this._ddMapping[this._ddPanelName] = {
                allowMove: true,
                allowCopy: false,
                allowLink: false
            };
        } else {
            delete this._ddMapping[this._ddPanelName];
        }
        
        this._initColumns();
    }

    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    save() {
        return new Promise((resolve, reject) => {
            let args = {};
            
            args = Object.assign({}, args, this._rpcSaveArgs);
            
            // Positionsdaten der Spalten + Panels ermitteln
            args.elements = [];
            kijs.Array.each(this._elements, function(el) {
                args.elements.push(el.posData);
            }, this);
            
            // an den Server senden
            this.rpc.do({
                remoteFn: this.rpcSaveFn,
                owner: this,
                data: args,
                cancelRunningRpcs: false,
                waitMaskTarget: this,
                waitMaskTargetDomProperty: 'dom',
                context: this
                
            }).then((e) => {
                // config Properties anwenden, falls vorhanden
                if (e.responseData.config) {
                    // config Properties übernehmen
                    this.applyConfig(e.responseData.config);
                }
                
                // 'afterSave' auslösen
                this.raiseEvent('afterSave', e);
                
                // Promise auslösen
                resolve(e);
                
            }).catch((ex) => {
                reject(ex);
                
            });
        });
    }
    
    // PROTECTED
    _initColumns(elements) {
        let panels = [];
        
        if (kijs.isEmpty(elements)) {
            elements = this._elements;
        }
        
        kijs.Array.each(elements, (el) => {
            if (el instanceof kijs.gui.dashboard.Column) {
                if (this._sortable) {
                    el.ddTarget = {
                        posBeforeFactor: this._ddPosBeforeAfterFactor,
                        posAfterFactor: this._ddPosBeforeAfterFactor,
                        mapping: this._ddMapping
                    };
                    el.ddTarget.on('drop', this.#onDdTargetDrop, this);
                    el.on('add', this.#onAddPanels, this);
                } else {
                    if (el.ddTarget) {
                        el.ddTarget.destruct();
                    }
                    el.ddTarget = null;
                }
                panels = kijs.Array.concat(panels, el.elements);
            }
        }, this);
        
        this._initPanels(panels);
    }
    
    _initPanels(elements) {
        if (kijs.isEmpty(elements)) {
            elements = [];
            kijs.Array.each(this._elements, (el) => {
                if (el.xtype === 'kijs.gui.dashboard.Column') {
                    elements = kijs.Array.concat(elements, el.elements);
                }
            }, this);
        }
        
        kijs.Array.each(elements, (el) => {
            if (el instanceof kijs.gui.dashboard.Panel) {
                el.on('close', this.#onPanelClose, this);
                if (this._sortable) {
                    el.ddSource = { 
                        name: this._ddPanelName,
                        ownerDomProperty: 'headerBar.dom',
                        allowMove: true,
                        allowCopy: false,
                        allowLink: false
                    };
                } else {
                    if (el.ddSource) {
                        el.ddSource.destruct();
                    }
                    el.ddSource = null;
                }
                
            } else {
                throw new Error('The elements of a dashboard-Column must be an instance of kijs.gui.dashboard.Panel');
            }
        }, this);
    }
    
    
    // PRIVATE
    // LISTENERS
    // Beim hinzufügen einer Spalte: Spalte konfigurieren
    #onAddColumns(e) {
        this._initColumns(e.elements);
    }
    #onAddPanels(e) {
        this._initPanels(e.elements);
    }
    #onDdTargetDrop(e) {
        if (e.source.name === this._ddPanelName) {
            kijs.gui.DragDrop.dropFnMoveEl(e);
            if (this._autoSave && this._rpcSaveFn) {
                this.save();
            }
        }
    }
    
    #onPanelClose(e) {
        if (this._autoSave && this._rpcSaveFn) {
            this.save();
        }
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        this._rpcSaveArgs = null;
        this._ddMapping = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.Mask
// --------------------------------------------------------------
// Halbtransparente Maske, die über den Body oder ein kijs.gui.Element gelegt wird
// und so die Bedienung der dahinterliegenden Oberfläche verhindert.
//
// Mit der Eigenschaft displayWaitIcon=true kann ein Ladesymbol mitangezeigt werden.
//
// Mit text kann ein Ladetext unterhalb des Icons angezeigt werden.
//
// Das Element, dass überdeckt wird, wird mit der Eigenschaft target festgelegt.
// Dies kann der document.body sein oder ein kijs.gui.Element.
//
// Beim Body als target wird die Maske mit dem nativen dialog-Tag dem body angefügt.
// Dies verhindert auch die Navigation via Tastatur unterhalb der Maske.
//
// Bei allen anderen targets, wird in den target zuerst ein Anchor-Div (0x0px div)
// als erster Node eingefügt und darin befindet sich das div der Maske.
// Eine Navigation via Tastatur wird damit nicht verhindert.
//
// Mit der targetDomProperty kann noch festgelegt werden, welcher node eines Elements
// als target dient. Wird nichts angegeben, so dient das ganze Element als target.
// Es kann z.B. bei einem kijs.gui.Panel nur der innere Teil als target angegeben werden.
// Dazu kann die Eigenschaft targetDomProperty="innerDom" definiert werden.
// --------------------------------------------------------------
kijs.gui.Mask = class kijs_gui_Mask extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // Anker-Node von 0x0px mit position:relative in dem sich die Maske befindet.
        // Nur nötig, wenn der Target nicht der Body ist
        this._maskAnchorDom = new kijs.gui.Dom({
            cls:'kijs-mask-anchor'
        });

        // Zetriertes div, in dem sich das Ladeicon und der Ladetext befindet
        this._maskCenterDom = new kijs.gui.Dom({
            cls:'kijs-mask-center'
        });

        // Ladeicon
        this._iconEl = new kijs.gui.Icon({
            parent: this,
            cls:'kijs-mask-icon'
        });

        // Ladetext
        this._textDom = new kijs.gui.Dom({
            cls:'kijs-mask-text'
        });

        this._targetElement = null;      // Zielelement (kijs.gui.Element) oder NULL=document.body (HTMLElement)
        this._targetDomProperty = 'dom'; // Dom-Eigenschaft im Zielelement (String) (Spielt bei Body als target keine Rolle)

        this._dom.clsAdd('kijs-mask');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            target: document.body
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            displayWaitIcon: { target: 'displayWaitIcon' },
            icon: { target: 'icon' },
            text: { target: 'html', context: this._textDom },
            iconChar: { target: 'iconChar', context: this._iconEl },
            iconCls: { target: 'iconCls', context: this._iconEl },
            iconColor: { target: 'iconColor', context: this._iconEl },
            iconMap: { target: 'iconMap', context: this._iconEl },
            target: { target: 'target' }, // kijs.gui.Element oder body
            targetDomProperty: true
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get displayWaitIcon() {
        return this._iconEl.iconChar === kijs.iconMap.Fa.spinner.char;
    }
    set displayWaitIcon(val) {
        if (val) {
            this.iconMap = 'kijs.iconMap.Fa.spinner';
            this._iconEl.dom.clsAdd('kijs-pulse');
        } else {
            this.iconChar = null;
            this._iconEl.dom.clsRemove('kijs-pulse');
        }
    }
    get icon() { return this._iconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set icon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconEl.iconChar = null;
            this._iconEl.iconCls = null;
            this._iconEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconEl.destruct();
            this._iconEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "icon" is not valid.`);

        }
    }

    get iconChar() { return this._iconEl.iconChar; }
    set iconChar(val) { this._iconEl.iconChar = val; }

    get iconCls() { return this._iconEl.iconCls; }
    set iconCls(val) { this._iconEl.iconCls = val; }

    get iconColor() { return this._iconEl.iconColor; }
    set iconColor(val) { this._iconEl.iconColor = val; }

    get iconMap() { return this._iconEl.iconMap; }
    set iconMap(val) { this._iconEl.iconMap = val; }

    // overwrite
    get isEmpty() { return this._iconEl.isEmpty; }

    get target() {
        return this._targetElement;
    }
    set target(val) {
        // Evtl. Listeners vom alten _targetElement entfernen
        if (!kijs.isEmpty(this._targetElement)) {
            if (this._targetElement instanceof kijs.gui.Element) {
                this._targetElement.off(null, null, this);
            }
        }

        // Target ist der Viewport
        if (val instanceof kijs.gui.ViewPort) {
            this._targetElement = null;
            
        // Target ist ein kijs.gui.Element
        } else if ((val instanceof kijs.gui.Element) && !(val instanceof kijs.gui.ViewPort)) {
            this._targetElement = val;

            this._targetElement.on('afterResize', this.#onTargetElAfterResize, this);
            this._targetElement.on('changeVisibility', this.#onTargetElChangeVisibility, this);
            this._targetElement.on('destruct', this.#onTargetElDestruct, this);

        // Target ist der Body
        } else if (val === document.body || kijs.isEmpty(val)) {
            this._targetElement = null;

        } else {
            throw new kijs.Error(`kijs.gui.Mask: Unknown format on config "target"`);
        }
    }

    get targetDomProperty() { return this._targetDomProperty; };
    set targetDomProperty(val) { this._targetDomProperty = val; };

    get text() { return this._textDom.html; }
    set text(val) { this._textDom.html = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // Overwrite
    render(superCall) {
        const isBody = !(this._targetElement instanceof kijs.gui.Element);

        // Bei body, wird ein dialog-Tag verwendet, sonst ein div-Tag
        this._dom.nodeTagName = isBody ? 'dialog' : 'div';

        // Falls target != Body: Muss die Maske in ein Anchor-Element.
        if (!isBody) {
            this._maskAnchorDom.render();
        }

        // DOM Rendern
        if (isBody) {
            this._dom.render();
        } else {
            this._dom.renderTo(this._maskAnchorDom.node);
        }

        // Sichtbarkeit
        if (kijs.isDefined(this._visible)) {
            this.visible = this._visible;
        }

        if (this._waitMaskEl) {
            kijs.defer(function() {
                if (this._waitMaskEl) {
                    this._waitMaskEl.show();
                }
            }, 300, this);
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }

        // Grösse der Maske an target anpassen
        this._updateMaskSize();

        // centerDom rendern
        this._maskCenterDom.renderTo(this._dom.node);
        
        // Span icon rendern (kijs.gui.Icon)
        if (!this._iconEl.isEmpty) {
            this._iconEl.renderTo(this._maskCenterDom.node);
        } else if (this._iconEl.isRendered) {
            this._iconEl.unrender();
        }

        // Text rendern (kijs.gui.Dom)
        if (!this._textDom.isEmpty) {
            this._textDom.renderTo(this._maskCenterDom.node);
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    renderTo(targetNode, referenceNode=null, insertPosition='before') {
        // Wenn nicht im Viewport, wird die Maske in ein 0x0px Anker-Div gerendert
        if (this._targetElement instanceof kijs.gui.Element) {
            const firstRender = !this.isRendered;

            this.render();

            this._maskAnchorDom.renderTo(targetNode, referenceNode, insertPosition);

            // Event afterFirstRenderTo auslösen
            if (firstRender) {
                this.raiseEvent('afterFirstRenderTo');
            }

        } else {
            super.renderTo(targetNode, referenceNode, insertPosition);
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._maskCenterDom) {
            this._maskCenterDom.unrender();
        }

        if (this._maskAnchorDom) {
            this._maskAnchorDom.unrender();
        }
        
        super.unrender(true);
    }

    /**
     * Zeigt die Maskierung an
     * @returns {undefined}
     */
    show() {
        if (this._targetElement instanceof kijs.gui.Element) {
            let nde = this._targetElement[this._targetDomProperty].node;

            if (nde) {
                if (nde.hasChildNodes()) {
                    this.renderTo(nde, nde.firstChild);
                } else {
                    this.renderTo(nde);
                }
            }
            
        } else {
            this.renderTo(document.body);
            this._dom.node.showModal();
        }
    }


    // PROTECTED
    _updateMaskSize() {
        // nur nötig, wenn Target != Body
        if (this._targetElement instanceof kijs.gui.Element) {
            let style;

            let top = 0;
            let left = 0;
            let height = this._targetElement[this._targetDomProperty].height;
            let width = this._targetElement[this._targetDomProperty].width;

            // Weitere Eigenschaften
            // Bereits gerendert: direkt aus CSS nehmen
            if (this._targetElement[this._targetDomProperty] && this._targetElement[this._targetDomProperty].node) {
                style = window.getComputedStyle(this._targetElement[this._targetDomProperty].node);
            } else {
                style = this._targetElement.style;
            }

            // Border abziehen
            top -= style.borderTopWidth ? parseFloat(style.borderTopWidth) : 0;
            left -= style.borderLeftWidth ? parseFloat(style.borderLeftWidth) : 0;

            // Padding abziehen
            top -= style.paddingTop ? parseFloat(style.paddingTop) : 0;
            left -= style.paddingLeft ? parseFloat(style.paddingLeft) : 0;

            // Masse übernehmen
            this.top = top;
            this.left = left;
            this.height = height;
            this.width = width;

            // Border-Radius auch von target übernehmen
            this._dom.style.borderTopLeftRadius = style.borderTopLeftRadius;
            this._dom.style.borderTopRightRadius = style.borderTopRightRadius;
            this._dom.style.borderBottomLeftRadius = style.borderBottomLeftRadius;
            this._dom.style.borderBottomRightRadius = style.borderBottomRightRadius;
        }
    }


    // PRIVATE
    // LISTENERS
    #onTargetElAfterResize(e) {
        this._updateMaskSize();
    }

    #onTargetElChangeVisibility(e) {
        this._updateMaskSize();
        this.visible = e.visible;
    }

    #onTargetElDestruct(e) {
        this.destruct();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Event-Listeners entfernen
        if (this._targetElement instanceof kijs.gui.Element) {
            this._targetElement.off(null, null, this);
        }

        // Elemente/DOM-Objekte entladen
        if (this._iconEl) {
            this._iconEl.destruct();
        }
        if (this._textDom) {
            this._textDom.destruct();
        }
        if (this._maskCenterDom) {
            this._maskCenterDom.destruct();
        }

        if (this._maskAnchorDom) {
            this._maskAnchorDom.destruct();
        }

        // Basisklasse entladen
        super.destruct(true);

        // Variablen (Objekte/Arrays) leeren
        this._iconEl = null;
        this._textDom = null;
        this._maskCenterDom = null;
        this._targetElement = null;
        this._maskAnchorDom = null;
    }
    
};
/* global kijs, this, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.ApertureMask
// --------------------------------------------------------------
// Halbtransparente Maske mit einem Ausschnitt für ein Element,
// das unmaskiert bleibt.
// Das Element, dass nicht überdeckt wird, wird mit der Eigenschaft target festgelegt.
// Der Rest des Bildschirms wird von der Maske überdeckt und kann nicht mehr bedient werden.
// Fals der target ein kijs.gui.Element ist, werden Grössenänderungen am Element automatisch übernommen.
// Bei target = kijs.gui.Dom muss die Grösse manuell nachgeführt werden.
kijs.gui.ApertureMask = class kijs_gui_ApertureMask extends kijs.Observable {
    
    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._defaultConfig = {};
        
        this._target = null;

        this._topDom = new kijs.gui.Dom({cls:['kijs-aperturemask', 'top']});
        this._rightDom = new kijs.gui.Dom({cls:['kijs-aperturemask', 'right']});
        this._bottomDom = new kijs.gui.Dom({cls:['kijs-aperturemask', 'bottom']});
        this._leftDom = new kijs.gui.Dom({cls:['kijs-aperturemask', 'left']});
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            animated: true
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            animated: { target: 'animated' },
            cls: { fn: 'function', target: this.clsAdd },
            target: { target: 'target' }
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // window onResize überwachen
        kijs.Dom.addEventListener('resize', window, this.#onWindowResize, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get animated() { return this._topDom.clsHas('animated'); }
    set animated(val) {
        if (val) {
            this._topDom.clsAdd('animated');
            this._rightDom.clsAdd('animated');
            this._bottomDom.clsAdd('animated');
            this._leftDom.clsAdd('animated');
            
        } else {
            this._topDom.clsRemove('animated');
            this._rightDom.clsRemove('animated');
            this._bottomDom.clsRemove('animated');
            this._leftDom.clsRemove('animated');

        }
    }
    
    get isRendered() { return !!this._topDom.isRendered; }

    get target() { return this._target; }
    set target(val) {

        // resize-Listener vom target entfernen
        if (this._target && (this._target instanceof kijs.gui.Element)) {
            this._target.off('afterResize', null, this);
        }

        // target ist kijs.gui.Element
        if (val instanceof kijs.gui.Element) {
            this._target = val;
            
            // resize-Listener zum target hinzufügen
            this._target.on('afterResize', this.#onTargetElAfterResize, this);
            
        // target ist kijs.gui.Dom
        } else if (val instanceof kijs.gui.Dom) {
            this._target = val;

        } else {
            throw new kijs.Error('kijs.gui.ApertureMask target must be an instance of kijs.gui.Element or kijs.gui.Dom');
            
        }
    }

    get visible() { return this.isRendered; }
    set visible(val) {
        if (val && !this.visible) {
            this.show();

        } else if (!val && this.visible) {
            this.hide();
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @returns {undefined}
     */
    applyConfig(config={}) {
        // Config zuweisen
        kijs.Object.assignConfig(this, config, this._configMap);
    }

    /**
     * Fügt den DOM-Elementen eine CSS-Klasse hinzu.
     * @param {Array|String} cls
     * @returns {undefined}
     */
    clsAdd(cls) {
        this._topDom.clsAdd(cls);
        this._rightDom.clsAdd(cls);
        this._bottomDom.clsAdd(cls);
        this._leftDom.clsAdd(cls);
    }


    /**
     * Blendet die Maske aus (mit Animation)
     * @returns {undefined}
     */
    hide() {
        this._topDom.style.opacity = 0;
        this._rightDom.style.opacity = 0;
        this._bottomDom.style.opacity = 0;
        this._leftDom.style.opacity = 0;

        if (this.animated) {
            // animation läuft 0.2s, danach aus DOM entfernen
            kijs.defer(function() {
                this.unrender();
            }, 200, this);

        } else {
            this.unrender();
        }
    }
    
    render() {
        this._updatePosition();
        
        if (!this.isRendered) {
            this._topDom.renderTo(document.body);
            this._rightDom.renderTo(document.body);
            this._bottomDom.renderTo(document.body);
            this._leftDom.renderTo(document.body);
        }
        
        this.raiseEvent('afterRender');
    }
    
    // Zeigt die Maske an.
    show() {
        this.render();
        
        // einblenden
        if (this.animated) {
            // einblenden nach 10ms
            kijs.defer(function() {
                this._topDom.style.opacity = 1;
                this._rightDom.style.opacity = 1;
                this._bottomDom.style.opacity = 1;
                this._leftDom.style.opacity = 1;
            }, 10, this);

        } else {
            this._topDom.style.opacity = 1;
            this._rightDom.style.opacity = 1;
            this._bottomDom.style.opacity = 1;
            this._leftDom.style.opacity = 1;
            
        }
    }
    
    unrender(superCall=false) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._topDom.unrender();
        this._rightDom.unrender();
        this._leftDom.unrender();
        this._bottomDom.unrender();
    }

    
    // PROTECTED
    // Aktualisiert die Position der Masken
    _updatePosition() {
        let dom = null;
        
        if (this._target instanceof kijs.gui.Element) {
            dom = this._target.dom;
            
        } else if (this._target instanceof kijs.gui.Dom) {
            dom = this._target;
            
        }
        
        if (dom && dom.node) {
            let pos = kijs.Dom.getAbsolutePos(dom.node);

            // top element
            this._topDom.style.left = pos.x + 'px';
            this._topDom.style.height = pos.y + 'px';
            this._topDom.style.width = pos.w + 'px';

            // right element
            this._rightDom.style.left = (pos.x + pos.w) + 'px';

            // bottom element
            this._bottomDom.style.left = pos.x + 'px';
            this._bottomDom.style.top = (pos.y + pos.h) + 'px';
            this._bottomDom.style.width = pos.w + 'px';

            // left element
            this._leftDom.style.width = pos.x + 'px';
            
        }
    }

    
    // PRIVATE
    // LISTENERS
    #onTargetElAfterResize() {
        if (this.isRendered) {
            this._updatePosition();
        }
    }

    #onWindowResize() {
        if (this.isRendered) {
            this._updatePosition();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall=false) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Node-Event Listener auf Window entfernen
        kijs.Dom.removeEventListener('resize', window, this);

        // Listeners entfernen
        if (this._target && (this._target instanceof kijs.gui.Element)) {
            this._target.off(null, null, this);
        }

        // Elemente/DOM-Objekte entladen
        if (this._topDom) {
            this._topDom.destruct();
        }
        if (this._rightDom) {
            this._rightDom.destruct();
        }
        if (this._leftDom) {
            this._leftDom.destruct();
        }
        if (this._bottomDom) {
            this._bottomDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._topDom = null;
        this._rightDom = null;
        this._leftDom = null;
        this._bottomDom = null;
        this._target = null;

        // Basisklasse entladen
        super.destruct();
    }

};/* global kijs, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.LayerManager (Singleton)
// --------------------------------------------------------------
// Der Layermanager wird verwendet um den z-index von Fenstern zu managen.
// Wird ein Fenster angeklickt, so wird der z-index aller Fenster mit dem gleichen
// parentNode neu berechnet und es erscheint zuvorderst.
// Neben kijs.gui.Window können auch Masken (kijs.gui.Mask) in den Layermanager
// aufgenommen werden. Dies ist bei modalen Fenster notwendig. Deren masken werden
// separat im Layermanager geführt.
// --------------------------------------------------------------
kijs.gui.LayerManager = class kijs_gui_LayerManager {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    constructor() {
        // Singleton (es wird immer die gleiche Instanz zurückgegeben)
        if (!kijs.gui.LayerManager.__singletonInstance) {
            kijs.gui.LayerManager.__singletonInstance = this;

            // Variablen
            this._parents = new Map();  // Map mit allen parents
                                        // key = parentNode (HTMLElement)
                                        // value = {
                                        //   activeEl: Verweis auf das aktive Fenster (kijs.gui.Window|kijs.gui.Mask)
                                        //   stack: [
                                        //       el: Verweis auf Fenster/Maske (kijs.gui.Window|kijs.gui.Mask)
                                        //   ]
                                        // }
                                        //
                                        // Die Elemente im Stack sind normalerweise kijs.gui.Window.
                                        // Es können aber auch kijs.gui.Mask sein, dies sind die Mask-Layers von
                                        // modalen Fenstern, die einen eigenen z-index erhalten.

            this._startZIndex = 10000;
        }
        return kijs.gui.LayerManager.__singletonInstance;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt eine Element an
     * @param {kijs.gui.Element} el
     * @returns {undefined}
     */
    addElement(el) {
        let parentProp =  this._parents.get(el.parentNode);
        if (!parentProp) {
            parentProp = {
                activeEl: null,
                stack: []
            };
            this._parents.set(el.parentNode, parentProp);
        }

        // Wenn das Element schon drin ist: Fehler
        if (kijs.Array.contains(parentProp.stack, el)) {
            throw new kijs.Error(`element is duplicated in layermanager`);
        }

        parentProp.stack.push(el);

        // Listeners erstellen, damit wenn, dass Element entladen wird alles neu geordnet wird
        el.on('destruct', this.#onElementDestruct, this);
        // Wenn die Sichtbarkeit ändert, wird ein anderes element aktiviert
        el.on('changeVisibility', this.#onElementChangeVisibility, this);
        el.on('unrender', this.#onElementChangeVisibility, this);
    }
    
    /**
     * Gibt das oberste Element zurück
     * @param {HTMLElement} parentNode
     * @returns {kijs.gui.Element|null}
     */
    getActive(parentNode) {
        const parentProp =  this._parents.get(parentNode);

        if (parentProp && parentProp.activeEl) {
            return parentProp.activeEl;
        } else {
            return null;
        }
    }
    
    /**
     * Entfernt ein Element aus dem LayerManager
     * @param {kijs.gui.Element} el
     * @param {Boolean} [preventReorder=false] z-Indexe nicht neu zuweisen?
     * @returns {Boolean} Wurden Änderungen gemacht?
     */
    removeElement(el, preventReorder) {
        let changed = false;
        let parentProp =  this._parents.get(el.parentNode);

        if (kijs.isEmpty(parentProp) || kijs.isEmpty(parentProp.stack)) {
            return changed;
        }

        const newElements = [];
        for (let i=0; i<parentProp.stack.length; i++) {
            if (parentProp.stack[i] === el) {
                changed = true;
            } else {
                newElements.push(parentProp.stack[i]);
            }
        }
        parentProp.stack = newElements;

        // Evtl. parentNode entfernen, wenn leer
        if (parentProp.stack.length === 0) {
            this._parents.delete(el.parentNode);
            parentProp = null;
        }

        // Listeners entfernen
        el.off('destruct', this.#onElementDestruct, this);
        el.off('changeVisibility', this.#onElementChangeVisibility, this);

        // falls was geändert hat
        if (parentProp && changed && !preventReorder) {
            // z-indexe der Fenster neu zuweisen
            this._assignZIndexes(el.parentNode);

            // Oberstes sichtbares Element aktualisieren und Fokus setzen
            parentProp.activeEl = this._getTopVisibleElement(el.parentNode);
            if (parentProp.activeEl) {
                parentProp.activeEl.focus();
            }
        }

        return changed;
    }

    /**
     * Bringt ein Element in den Vordergrund
     * @param el
     * @param setFocus // Setzt den Fokus auf das erste Element
     * @returns {Boolean}
     */
    setActive(el, setFocus=true) {
        // Ist das Element schon zuoberst?
        if (el === this.getActive(el.parentNode)) {
            return false;
        }

        // falls das Element schon drin ist: entfernen
        this.removeElement(el, true);

        // und am Ende wieder anfügen
        this.addElement(el);

        // z-indexe den Elementen neu zuweisen
        this._assignZIndexes(el.parentNode);

        // Oberstes sichtbares Element aktualisieren und Fokus setzen
        const parentProp =  this._parents.get(el.parentNode);
        parentProp.activeEl = this._getTopVisibleElement(el.parentNode);
        if (parentProp.activeEl && setFocus) {
            parentProp.activeEl.focus();
        }

        return true;
    }


    // PROTECTED
    /**
     * Nummeriert die z-Indexe der Elemente neu durch und entfernt gelöschte Fenster
     * @param {HTMLElement} parentNode
     * @returns {undefined}
     */
    _assignZIndexes(parentNode) {
        let zIndex = this._startZIndex;
        const parentProp =  this._parents.get(parentNode);

        if (kijs.isEmpty(parentProp) || kijs.isEmpty(parentProp.stack)) {
            return;
        }

        kijs.Array.each(parentProp.stack, function(el) {
            el.style.zIndex = zIndex;
            zIndex += 10;
        }, this);
    }

    /**
     * Gibt das oberste sichtbare Element zurück
     * @param {HTMLElement} parentNode
     * @returns {kijs.gui.Element}
     */
    _getTopVisibleElement(parentNode) {
        const parentProp =  this._parents.get(parentNode);

        if (kijs.isEmpty(parentProp) || kijs.isEmpty(parentProp.stack)) {
            return;
        }

        for (let i=parentProp.stack.length-1; i>=0; i--) {
            if (parentProp.stack[i].isRendered && parentProp.stack[i].visible) {
                return parentProp.stack[i];
            }
        }

        return null;
    }


    // PRIVATE
    // LISTENERS
    #onElementChangeVisibility(e) {
        const el = e.element;
        const parentProp =  this._parents.get(el.parentNode);

        if (kijs.isEmpty(parentProp) || kijs.isEmpty(parentProp.stack)) {
            return;
        }

        // Oberstes sichtbares Element aktualisieren und Fokus setzen
        parentProp.activeEl = this._getTopVisibleElement(el.parentNode);
        if (parentProp.activeEl) {
            parentProp.activeEl.focus();
        }
    }
    
    #onElementDestruct(e) {
        this.removeElement(e.element);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    destruct() {
        // Listeners entfernen
        for (var parentProp of this._parents.values()) {
            kijs.Array.each(parentProp.stack, function(el) {
                el.off(null, null, this);
            }, this);
        }

        this._parents.clear();
        this._parents = null;
    }

};/* global kijs, this, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.Window
// --------------------------------------------------------------
// Das Fenster kann mit der Methode .show() angezeigt werden.
// Es wird dann in das target gerendert.
// Als target kann der document.body oder ein kijs.gui.Element angegeben
// werden.
// Beim Body als target ist der Body auch gleich der übergeordnete Node (parentNode).
// Beim einem kijs.gui.Element als target ist das übergeordnete Element nicht der node
// des Elements, sondern dessen parentNode.
// Deshalb gibt es die Eigenschaften targetNode und parentNode, welche bei einem
// kijs.gui.Element als target nicht den gleichen node als Inhalt haben. Beim body
// als target, hingegen schon.
// Mit der targetDomProperty kann noch festgelegt werden, welcher node eines Elements
// als target dient, wird nichts angegeben, so dient das ganze Element als target.
// Es kann z.B. bei einem kijs.gui.Panel nur der innere Teil als target angegeben werden.
// Dazu kann die Eigenschaft targetDomProperty="innerDom" definiert werden.
// --------------------------------------------------------------
kijs.gui.Window = class kijs_gui_Window extends kijs.gui.Panel {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._resizeDeferHandle = null;   // intern
        this._dragInitialPos = null;      // intern

        this._moveWhenVirtualKeyboard = false; // Fenster neu zentrieren, falls das Virtual Keyboard eingeblendet wird.
        this._allowDragOutside = true; // Darf das Fenster ausserhalb des sichtbaren Bereichs gezogen werden?

        //this._modalMaskEl = null;
        this._modal = !!document.querySelector('dialog:modal[open]'); // wenn ein modales Fenster offen ist, sollten die Unterfenster auch modal sein;

        this._draggable = false;
        this._resizeDelay = 300;    // min. Delay zwischen zwei Resize-Events

        this._targetX = null;           // Zielelement (kijs.gui.Element) oder Body (HTMLElement)
        this._targetDomProperty = 'dom'; // Dom-Eigenschaft im Zielelement (String) (Spielt bei Body als target keine Rolle)

        this._dom.clsAdd('kijs-window');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            nodeTagName: 'dialog',
            draggable: true,
            target: document.body,

            // defaults overwrite kijs.gui.Panel
            closable: true,
            maximizable: true,
            resizable: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            draggable: { target: 'draggable' },
            allowDragOutside: true,         // Darf das Fenster ausserhalb des sichtbaren Bereichs gezogen werden?
            modal: { target: 'modal' },     // Soll das Fenster modal geöffnet werden (alles Andere wird mit einer halbtransparenten Maske verdeckt)?
            resizeDelay: true,
            target: { target: 'target' },
            targetDomProperty: true,

            moveWhenVirtualKeyboard: true
        });

        // Listeners
        this.on('mouseDown', this.#onMouseDown, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Virtual Keyboard API (Nur in Chrome mit SSL)
        if (this._moveWhenVirtualKeyboard && 'virtualKeyboard' in navigator) {
            navigator.virtualKeyboard.overlaysContent = true;
            kijs.Dom.addEventListener('geometrychange', navigator.virtualKeyboard, this.#onVirtualKeyboardGemoetryChange, this);
        }

    }
    


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get allowDragOutside() { return this._allowDragOutside; }
    set allowDragOutside(val) {
        this._allowDragOutside = val;
    }

    get draggable() { return this._draggable; }
    set draggable(val) {
        if (val && !this._draggable) {
            this._headerBarEl.on('mouseDown', this.#onHeaderBarMouseDown, this);
            this._headerBarEl.on('touchStart', this.#onHeaderBarTouchStart, this);
            this._headerBarEl.on('touchMove', this.#onHeaderBarTouchMove, this);
            this._headerBarEl.on('touchEnd', this.#onHeaderBarTouchEnd, this);
        } else if (!val && this._draggable) {
            this._headerBarEl.off('mouseDown', this.#onHeaderBarMouseDown, this);
            this._headerBarEl.off('touchStart', this.#onHeaderBarTouchStart, this);
            this._headerBarEl.off('touchMove', this.#onHeaderBarTouchMove, this);
            this._headerBarEl.off('touchEnd', this.#onHeaderBarTouchEnd, this);
            kijs.Dom.removeEventListener('mousemove', document, this);
            kijs.Dom.removeEventListener('mouseup', document, this);
        }
        this._draggable = !!val;
    }

    get modal() { return !!this._modal; }
    set modal(val) {
        this._modal = !!val;
        if (this.isRendered) {
            this.show();
        }
    }

    /**
     * Gibt den Node zurück in dem sich die Maske befindet (parentNode)
     * @returns {HTMLElement}
     */
    get parentNode() {
        if (this._targetX instanceof kijs.gui.Element) {
            return this._targetX[this._targetDomProperty].node.parentNode;
        } else {
            return this._targetX;
        }
    }

    get resizeDelay() { return this._resizeDelay; }
    set resizeDelay(val) { this._resizeDelay = val; }

    get target() {
        return this._targetX;
    }
    set target(val) {
        // Evtl. Listeners vom alten _targetX entfernen
        if (!kijs.isEmpty(this._targetX)) {
            if (this._targetX instanceof kijs.gui.Element) {
                this._targetX.off('afterResize', this.#onTargetElAfterResize, this);
                this._targetX.off('changeVisibility', this.#onTargetElChangeVisibility, this);
                this._targetX.off('destruct', this.#onTargetElDestruct, this);
            } else if (this._targetX === document.body) {
                kijs.Dom.removeEventListener('resize', window, this);
            }
        }

        // Target ist ein kijs.gui.Element
        if (val instanceof kijs.gui.Element) {
            this._targetX = val;

            this._targetX.on('afterResize', this.#onTargetElAfterResize, this);
            this._targetX.on('changeVisibility', this.#onTargetElChangeVisibility, this);
            this._targetX.on('destruct', this.#onTargetElDestruct, this);

        // Target ist der Body
        } else if (val === document.body || val === null) {
            this._targetX = document.body;

            // onResize überwachen
            // Wenn der Browser langsam grösser gezogen wird, wird der event dauernd
            // ausgelöst, darum wird er verzögert weitergegeben.
            kijs.Dom.addEventListener('resize', window, this.#onWindowResize, this);

        } else {
            throw new kijs.Error(`Unknown format on config "target"`);
        }
    }

    get targetDomProperty() { return this._targetDomProperty; };
    set targetDomProperty(val) { this._targetDomProperty = val; };

    /**
     * Gibt den Ziel-Node zurück, über den die Maske gelegt wird
     * @returns {HTMLElement}
     */
    get targetNode() {
        if (this._targetX instanceof kijs.gui.Element) {
            return this._targetX[this._targetDomProperty].node;
        } else {
            return this._targetX;
        }
    }

    // overwrite
    get visible() { return super.visible; }
    set visible(val) {
        super.visible = val;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Zentriert das Fenster auf dem Bildschirm
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @param {Number} [offsetX=0]              // X-Offset
     * @param {Number} [offsetY=0]              // Y-Offset
     * @returns {undefined}
     */
    center(preventEvents=false, offsetX=0, offsetY=0) {
        const targetNode = this.targetNode;

        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        // Zentrieren
        this.left = targetNode.offsetLeft + ((targetNode.offsetWidth - this.width) / 2) + offsetX;
        this.top = targetNode.offsetTop + ((targetNode.offsetHeight - this.height) / 2) + offsetY;

       // afterResize-Event wieder zulassen
       this._preventAfterResize = prevAfterRes;

       // Evtl. afterResize-Event zeitversetzt auslösen
        if (!preventEvents && this._hasSizeChanged()) {
            this._raiseAfterResizeEvent(true);
        }
    }
    
    // overwrite
    close(preventDestruct, preventEvents, superCall) {
        if (!superCall) {
            if (!preventEvents) {
                // beforeClose Event. Bei Rückgabe=false -> abbrechen
                if (this.raiseEvent('beforeClose') === false) {
                    return;
                }
            }
        }
        
        this.unrender();
        
        if (!preventEvents) {
            this.raiseEvent('close');
        }
        
        if (!preventDestruct) {
            this.destruct();
        }
    }
    
    // overwrite
    restore() {
        if (!this.maximized) {
            return;
        }

        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        super.restore();

        // evtl. Fester zentrieren
        if (!this._dom.hasLeft || !this._dom.hasTop) {
            this.center(true);
        }

        // Sicherstellen, dass es platz hat
        this._adjustPositionToTarget(true);

        // afterResize-Event wieder aktivieren
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);
    }

    /**
     * Zeigt das Fenster an
     * @returns {undefined}
     */
    show() {
        // Fenster rendern und anzeigen
        if (this.isRendered) {
            this._dom.node.close();
        } else {
            this.renderTo(this.parentNode);
        }



        if (this._modal) {
            this._dom.node.showModal();
        } else {
            this._dom.node.show();
        }
        
        this.visible = true;

        if (!this.maximized) {
            // evtl. Fenster zentrieren
            if (!this._dom.hasLeft || !this._dom.hasTop) {
                this.center(true);

            // sonst nur sicherstellen, dass es ins Target passt
            } else {
                this._adjustPositionToTarget(true);
            }
        }

        // afterResize-Event zeitversetzt auslösen
        this._raiseAfterResizeEvent(true);

        this.toFront();
    }

    toFront() {
        if (this._dom.node && this._dom.node.parentNode &&
                (!this.resizer || (this.resizer && !this.resizer.domOverlay))) {
            new kijs.gui.LayerManager().setActive(this);
        }
    }


    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        super.unrender(true);
    }
    // PROTECTED
    /**
     * Stellt sicher, dass das Fenster innerhalb des Targets angezeigt wird
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    _adjustPositionToTarget(preventEvents=false) {
        const targetNode = this.targetNode;

        // afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        this._preventAfterResize = true;

        let left = this.left;
        let top = this.top;
        let width = this.width;
        let height = this.height;

        // Höhe und Breite evtl. an target anpassen
        if (width > targetNode.offsetWidth) {
            width = targetNode.offsetWidth;
        }
        if (height > targetNode.offsetHeight) {
            height = targetNode.offsetHeight;
        }
        this.width = width;
        this.height = height;

        // Evtl. Position an Target anpassen
        if (left + width > targetNode.offsetLeft + targetNode.offsetWidth) {
            left = targetNode.offsetLeft + (targetNode.offsetWidth - width);
        }
        if (left < 0) {
            left = 0;
        }
        if (top + height > targetNode.offsetTop + targetNode.offsetHeight) {
            top = targetNode.offsetTop + (targetNode.offsetHeight - height);
        }
        if (top < 0) {
            top = 0;
        }
        this.left = left;
        this.top = top;

        // afterResize-Event wieder zulassen
        this._preventAfterResize = prevAfterRes;

        // Evtl. afterResize-Event zeitversetzt auslösen
        if (!preventEvents && this._hasSizeChanged()) {
            this._raiseAfterResizeEvent(true);
        }
    }

    
    // PRIVATE
    // LISTENERS
    #onHeaderBarMouseDown(e) {
        this.toFront();

        if (this.maximized) {
            return;
        }

        this._dragInitialPos = {
            mouseX: e.nodeEvent.clientX,
            mouseY: e.nodeEvent.clientY,
            windowX: this.left,
            windowY: this.top,
            windowTransition: this.style.transition ? this.style.transition : ''
        };

        // Allfällige Transitionen temporär abschalten
        this.style.transition = 'none';

        // mousemove und mouseup Listeners auf das document setzen
        // (Workaround, weil sonst manchmal der Resizer stehen bleibt)
        kijs.Dom.addEventListener('mousemove', document, this.#onDocumentMouseMove, this);
        kijs.Dom.addEventListener('mouseup', document, this.#onDocumentMouseUp, this);
    }

    #onHeaderBarTouchEnd(e) {
        if (kijs.isEmpty(this._dragInitialPos)) {
            return;
        }

        // Transitions-sperre wieder aufheben
        this.dom.style.transition = this._dragInitialPos.windowTransition;
        this._dragInitialPos = null;
    }

    #onHeaderBarTouchMove(e) {
        if (kijs.isEmpty(this._dragInitialPos)) {
            return;
        }

        // Neue Position ermitteln
        let x = this._dragInitialPos.windowX + (e.nodeEvent.touches[0].clientX - this._dragInitialPos.mouseX);
        let y = this._dragInitialPos.windowY + (e.nodeEvent.touches[0].clientY - this._dragInitialPos.mouseY);

        // Min-Position begrenzen
        if (x < 0) {
            x = 0;
        }
        if (y < 0) {
            y = 0;
        }

        // Evtl. max-Position begrenzen
        const targetNode = this.targetNode;

        // Das Fenster darf auch ausserhalb des Target sein
        if (this._allowDragOutside) {
            // Mindestens die Icons auf der HeaderBar müssen sichtbar sein
            if (x < targetNode.offsetLeft + this._headerBarEl.containerRightEl.width + 20) {
                x = targetNode.offsetLeft + this._headerBarEl.containerRightEl.width + 20;
            }
            // Min. eine Breite die der HeaderBar-Höhe entspricht muss sichtbar sein
            if ((x + this._headerBarEl.height) > (targetNode.offsetLeft + targetNode.offsetWidth)) {
                x = targetNode.offsetLeft + targetNode.offsetWidth - this._headerBarEl.height;
            }

            if (y < targetNode.offsetTop) {
                y = targetNode.offsetTop;
            }
            // Min. die HeaderBar muss sichtbr sein
            if ((y + this._headerBarEl.height) > (targetNode.offsetTop + targetNode.offsetHeight)) {
                y = targetNode.offsetTop + targetNode.offsetHeight - this._headerBarEl.height;
            }

        } else {
            if (x < targetNode.offsetLeft) {
                x = targetNode.offsetLeft;
            }
            if ((x + this._dom.width) > (targetNode.offsetLeft + targetNode.offsetWidth)) {
                x = targetNode.offsetLeft + targetNode.offsetWidth - this._dom.width;
            }

            if (y < targetNode.offsetTop) {
                y = targetNode.offsetTop;
            }
            if ((y + this._dom.height) > (targetNode.offsetTop + targetNode.offsetHeight)) {
                y = targetNode.offsetTop + targetNode.offsetHeight - this._dom.height;
            }

        }

        // Grösse zuweisen
        this.left = x;
        this.top = y;

        // Bubbeling und native Listeners verhindern
        e.nodeEvent.stopPropagation();
        e.nodeEvent.preventDefault();
    }

    #onHeaderBarTouchStart(e) {
        if (e.nodeEvent.touches.length > 1) {
            return;
        }

        this.toFront();

        if (this.maximized) {
            return;
        }

        this._dragInitialPos = {
            mouseX: e.nodeEvent.touches[0].clientX,
            mouseY: e.nodeEvent.touches[0].clientY,
            windowX: this.left,
            windowY: this.top,
            windowTransition: this.style.transition ? this.style.transition : ''
        };

        // Allfällige Transitionen temporär abschalten
        this.style.transition = 'none';
    }

    #onDocumentMouseMove(e) {
        if (kijs.isEmpty(this._dragInitialPos)) {
            return;
        }

        // Neue Position ermitteln
        let x = this._dragInitialPos.windowX + (e.nodeEvent.clientX - this._dragInitialPos.mouseX);
        let y = this._dragInitialPos.windowY + (e.nodeEvent.clientY - this._dragInitialPos.mouseY);

        // Evtl. max-Position begrenzen
        const targetNode = this.targetNode;

        // Das Fenster darf auch ausserhalb des Target sein
        if (this._allowDragOutside) {
            // Mindestens die Icons auf der HeaderBar müssen sichtbar sein
            if (x < targetNode.offsetLeft - this.width + this._headerBarEl.containerRightEl.width + 20) {
                x = targetNode.offsetLeft - this.width + this._headerBarEl.containerRightEl.width + 20;
            }
            // Min. eine Breite die der HeaderBar-Höhe entspricht muss sichtbar sein
            if ((x + this._headerBarEl.height) > (targetNode.offsetLeft + targetNode.offsetWidth)) {
                x = targetNode.offsetLeft + targetNode.offsetWidth - this._headerBarEl.height;
            }

            if (y < targetNode.offsetTop) {
                y = targetNode.offsetTop;
            }
            // Min. die HeaderBar muss sichtbr sein
            if ((y + this._headerBarEl.height) > (targetNode.offsetTop + targetNode.offsetHeight)) {
                y = targetNode.offsetTop + targetNode.offsetHeight - this._headerBarEl.height;
            }

        } else {
            if (x < targetNode.offsetLeft) {
                x = targetNode.offsetLeft;
            }
            if ((x + this._dom.width) > (targetNode.offsetLeft + targetNode.offsetWidth)) {
                x = targetNode.offsetLeft + targetNode.offsetWidth - this._dom.width;
            }

            if (y < targetNode.offsetTop) {
                y = targetNode.offsetTop;
            }
            if ((y + this._dom.height) > (targetNode.offsetTop + targetNode.offsetHeight)) {
                y = targetNode.offsetTop + targetNode.offsetHeight - this._dom.height;
            }

        }

        // Grösse zuweisen
        this.left = x;
        this.top = y;
    }

    #onDocumentMouseUp(e) {
        // Beim ersten auslösen Listeners gleich wieder entfernen
        kijs.Dom.removeEventListener('mousemove', document, this);
        kijs.Dom.removeEventListener('mouseup', document, this);

        if (kijs.isEmpty(this._dragInitialPos)) {
            return;
        }

        // Transitions-sperre wieder aufheben
        this.dom.style.transition = this._dragInitialPos.windowTransition;
        this._dragInitialPos = null;
    }

    #onMouseDown(e) {
        this.toFront();
    }

    /**
     * Listener der Aufgerufen wird, wenn die Grösse des Target-Elements geändert hat
     * @param {Object} e
     * @returns {undefined}
     */
    #onTargetElAfterResize(e) {
        // Sicherstellen, dass das Fenster im Target platz hat
        this._adjustPositionToTarget(true);

        // Falls die eigene Grösse geändert hat: das eigene afterResize-Event auslösen
        this._raiseAfterResizeEvent(false, e);
    }

    #onTargetElChangeVisibility(e) {
        // Sichbarkeit ändern
        this.visible = e.visible;
    }

    #onTargetElDestruct(e) {
        this.destruct();
    }

    // Fenster neu zentrieren wenn eine virtuelle Tastatur eingeblendet wird (Mobile)
    #onVirtualKeyboardGemoetryChange(e) {

        if (this.isRendered && this._moveWhenVirtualKeyboard && e.nodeEvent.target) {
            const { x, y, width, height } = e.nodeEvent.target.boundingRect;
            
            // Tastatur geschlossen: Fenster zentrieren
            if (width === 0 && height === 0) {
                this.center();

            // Falls möglich, Fenster so zentrieren, dass es nicht von der Tastatur verdeckt wird.
            } else {
                this.center(false, 0, height * -1);
            }

        }

    }

    #onWindowResize(e) {
         // Sicherstellen, dass das Fenster im Target platz hat
        this._adjustPositionToTarget(true);

        this._raiseAfterResizeEvent(true, e);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender();

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Node-Event Listeners entfernen
        if (this._targetX === document.body) {
            kijs.Dom.removeEventListener('resize', window, this);
        }
        kijs.Dom.removeEventListener('mouseMove', document, this);
        kijs.Dom.removeEventListener('mouseUp', document, this);

        if ('virtualKeyboard' in navigator) {
            kijs.Dom.removeEventListener('geometrychange', navigator.virtualKeyboard, this);
        }

        // Event-Listeners entfernen
        if (this._targetX instanceof kijs.gui.Element) {
            this._targetX.off(null, null, this);
        }

        if (this._resizeDeferHandle) {
            window.clearTimeout(this._resizeDeferHandle);
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren
        this._dragInitialPos = null;
        this._resizeDeferHandle = null;
        this._targetX = null;

        // Basisklasse auch entladen
        super.destruct(true);
    }
    
};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.MsgBox (static)
// --------------------------------------------------------------
kijs.gui.MsgBox = class kijs_gui_MsgBox {


    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Zeigt ein normales Meldungsfenster mit OK-Schaltfläche
     * @param {String} caption
     * @param {String} msg
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static alert(caption, msg, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,
            closable: true,
            fn: fn,
            context: context,
            buttons: [
                {
                    name: 'ok',
                    caption: kijs.getText('OK'),
                    isDefault: true
                }
            ]
        });
    }

    /**
     * Zeigt ein Meldungsfenster mit Ja/Nein-Schaltfläche und einem Fragezeichen-Symbol
     * @param {String} caption
     * @param {String} msg
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static confirm(caption, msg, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,
            closable: true,
            fn: fn,
            context: context,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-question',
                iconColor: '#4398dd'
            },
            buttons: [
                {
                    name: 'yes',
                    caption: kijs.getText('Ja')
                },{
                    name: 'no',
                    caption: kijs.getText('Nein')
                }
            ]
        });
    }

    /**
     * Zeigt ein Meldungsfenster mit OK-Schaltfläche und einem "unerwarteten Fehler"-Symbol
     * @param {String} caption
     * @param {String} msg
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static error(caption, msg, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,
            closable: true,
            fn: fn,
            context: context,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-exclamation',
                iconColor: '#be6280'
            },
            buttons: [
                {
                    name: 'ok',
                    caption: kijs.getText('OK'),
                    isDefault: true
                }
            ]
        });
    }
    
    /**
     * Zeigt ein Meldungsfenster mit OK-Schaltfläche und einem Fehler-Symbol
     * @param {String} caption
     * @param {String} msg
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static errorNotice(caption, msg, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,
            closable: true,
            fn: fn,
            context: context,
            icon: {
                iconMap: 'kijs.iconMap.Fa.triangle-exclamation',
                iconColor: '#be6280'
            },
            buttons: [
                {
                    name: 'ok',
                    caption: kijs.getText('OK'),
                    isDefault: true
                }
            ]
        });
    }

    /**
     * Zeigt ein Meldungsfenster mit OK-Schaltfläche und einem Info-Symbol
     * @param {String} caption
     * @param {String} msg
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static info(caption, msg, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,
            closable: true,
            fn: fn,
            context: context,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-info',
                iconColor: '#4398dd'
            },
            buttons: [
                {
                    name: 'ok',
                    caption: kijs.getText('OK'),
                    isDefault: true
                }
            ]
        });
    }

    /**
     * Zeigt ein Eingabefenster mit OK/Abbrechen-Schaltflächen und einem Achtung-Symbol
     * @param {String} caption
     * @param {String} msg
     * @param {String} label
     * @param {String} value
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static prompt(caption, msg, label, value, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,

            closable: true,
            fieldConfig: {
                xtype: 'kijs.gui.field.Text',
                label: label,
                value: value
            },

            fn: fn,
            context: context,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-question',
                iconColor: '#4398dd'
            },
            buttons: [
                {
                    name: 'ok',
                    caption: kijs.getText('OK'),
                    isDefault: true
                },{
                    name: 'cancel',
                    caption: kijs.getText('Abbrechen')
                }
            ]
        });
    }

    /**
     * Zeigt ein individuelles Meldungsfenster
     * Beispiel config:
     * config = {
     *     caption: 'Testmeldung',
     *     msg: 'Hallo Welt!',
     *
     *     closable: true, // Soll das Fenster ein X zum Schliessen haben?
     *
     *     //Falls ein Input-Field gewünscht wird, können in einem Objekt die 
     *     // Eigenschaften des Fields angegeben werden:
     *     fieldConfig: {
     *         xtype: 'kijs.gui.field.Text',
     *         label: 'Wert',
     *         value: 'Mein Testwert'
     *     }
     *
     *     fn: function(e, el) {
     *         alert('Es wurde geklickt auf: ' + e.btn);
     *     },
     *     context: this,
     *     iconMap: '',
     *     icon: {
     *         iconMap: 'kijs.iconMap.Fa.circle-question',
     *         style: {
     *             color: '#ff9900'
     *         }
     *     },
     *     buttons: [
     *         {
     *             name: 'ok',
     *             caption: 'OK'
     *         },{
     *             name: 'cancel',
     *             caption: 'Abbrechen'
     *         }
     *     ]
     * }
     * @param {Object} config
     * @returns {Promise}
     */
    static show(config) {
        return new Promise((resolve) => {
            let btn = 'none';
            let value = null;
            const elements = [];
            const footerElements = [];

            // Icon
            if (config.icon) {
                if (!(config.icon instanceof kijs.gui.Icon)) {
                    config.icon.xtype = 'kijs.gui.Icon';
                }
                elements.push(config.icon);
            }
            
            // Benutzerdefiniertes Feld aus fieldConfig
            if (config.fieldConfig && config.fieldConfig.xtype) {
                
                // Konstruktor ermitteln
                const constr = kijs.getObjectFromString(config.fieldConfig.xtype);
                if (!kijs.isFunction(constr)) {
                    throw new kijs.Error(`Unknown xtype "${config.fieldConfig.xtype}".`);
                }

                // fixe Properties
                config.fieldConfig.name = 'field';
                
                // Field erstellen
                const fld = new constr(config.fieldConfig);
                fld.on('enterPress', (e) => {
                    btn = 'ok';
                    value = fld.value;
                    fld.upX('kijs.gui.Window').destruct();
                });
                
                // Container mit Beschrieb und Field
                elements.push(new kijs.gui.Container(
                    {
                        htmlDisplayType: 'html',
                        cls: 'kijs-msgbox-inner',
                        elements:[
                            {
                                xtype: 'kijs.gui.Element',
                                html: config.msg,
                                htmlDisplayType: 'html',
                                style: {
                                    marginBottom: '4px'
                                }
                            },
                            fld
                        ]
                    }
                ));
                
            // nur ein Element mit Html
            } else {
                elements.push({
                    xtype: 'kijs.gui.Element',
                    html: config.msg,
                    htmlDisplayType: 'html',
                    cls: 'kijs-msgbox-inner'
                });
                
            }
            
            // Spacer
            footerElements.push({
                xtype: 'kijs.gui.Spacer'
            });
                        
            // Buttons
            kijs.Array.each(config.buttons, function(button) {
                if (!(button instanceof kijs.gui.Button)) {
                    button.xtype = 'kijs.gui.Button';
                    if (!button.on) {
                        button.on = {};
                    }
                    if (!button.on.click) {
                        button.on.click = function() {
                            btn = button.name;
                            if (config.fieldConfig && config.fieldConfig.xtype) {
                                const fld = this.upX('kijs.gui.Window').down('field');
                                value = fld.value;

                                if (!fld.validate()) {
                                    return;
                                }
                            }

                            this.upX('kijs.gui.Window').destruct();
                        };
                    }
                }

                footerElements.push(button);
            }, this);

            // Fenster erstellen
            const win = new kijs.gui.Window({
                caption: kijs.isEmpty(config.caption) ? ' ' :  config.caption,
                iconMap: config.iconMap ? config.iconMap : '',
                closable: config.hasOwnProperty('closable') ? !!config.closable : true,
                collapsible: false,
                resizable: false,
                maximizable: false,
                modal: true,
                cls: 'kijs-msgbox',
                elements: elements,
                footerElements: footerElements,
                moveWhenVirtualKeyboard: true
            });

            // Listener
            win.on('destruct', function(e){
                e.btn = btn;
                e.value = value;
                if (config.fn) {
                    config.fn.call(config.context, e);
                }

                // Promise auflösen
                resolve(e);
            });

            // Fenster anzeigen
            win.show();
        });
    }

    /**
     * Zeigt ein Meldungsfenster mit OK/Abbrechen-Schaltflächen und einem Achtung-Symbol
     * @param {String} caption
     * @param {String} msg
     * @param {Function} fn
     * @param {Object} context
     * @returns {Promise}
     */
    static warning(caption, msg, fn, context) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        return this.show({
            caption: caption,
            msg: msg,
            closable: true,
            fn: fn,
            context: context,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-exclamation',
                iconColor: '#ff9900'
            },
            buttons: [
                {
                    name: 'ok',
                    caption: kijs.getText('OK'),
                    isDefault: true
                },{
                    name: 'cancel',
                    caption: kijs.getText('Abbrechen')
                }
            ]
        });
    }


    // PROTECTED
    static _convertArrayToHtml(messages) {
        if (messages.length === 1) {
            return messages[0];
        }

        let ret = '<ul>';
        kijs.Array.each(messages, function(msg) {
            ret += '<li>' + msg + '</li>';
        }, this);
         ret += '</ul>';
        return ret;
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.ProgressBar
// --------------------------------------------------------------
/**
 * ProgressBar Element, welches einen Ladebalken anzeigt.
 *
 * KLASSENHIERARCHIE
 * kijs.gui.Element
 *  kijs.gui.ProgressBar
 *
 * EVENTS
 * ----------
 *

 */
kijs.gui.ProgressBar = class kijs_gui_ProgressBar extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._percent = 0;
        this._showPercent = true;
        this._uploadDialog = null;
        this._uploadDialogId = null;

        this._captionDom = new kijs.gui.Dom();
        this._bottomCaptionDom = new kijs.gui.Dom();

        this._fieldDom = new kijs.gui.Dom();
        this._barDom = new kijs.gui.Dom();
        this._textDom = new kijs.gui.Dom();

        this._dom.clsAdd('kijs-progressbar');
        this._captionDom.clsAdd('kijs-progressbar-caption');
        this._bottomCaptionDom.clsAdd('kijs-progressbar-caption-bottom');

        this._fieldDom.clsAdd('kijs-progressbar-field');
        this._barDom.clsAdd('kijs-progressbar-bar');
        this._textDom.clsAdd('kijs-progressbar-text');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            percent: 0,
            showPercent: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            showPercent: true,
            caption: { target: 'html', context: this._captionDom },
            bottomCaption: { target: 'html', context: this._bottomCaptionDom },
            percent: { target: 'percent' },
            uploadDialog: { target: 'uploadDialog' },
            uploadDialogId: { target: 'uploadDialogId' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get bottomCaption() { return this._bottomCaptionDom.html; }
    set bottomCaption(val) { this._bottomCaptionDom.html = val;  }

    get caption() { return this._captionDom.html; }
    set caption(val) { this._captionDom.html = val;  }

    get percent() { return this._percent; }
    set percent(val) { this.setProgress(val); }

    get uploadDialog() { return this._uploadDialog; }
    set uploadDialog(val) { this.bindUploadDialog(val); }

    get uploadDialogId() { return this._uploadDialogId; }
    set uploadDialogId(val) { this._uploadDialogId = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Binden einen kijs.Uploaddialog an die Progressbar, um den Upload-Fortschritt
     * anzuzeigen.
     * @param {kijs.UploadDialog} uploadDialog
     * @param {Int} [uploadId] ID vom Upload. Wenn null übergeben wird, wird der erste genommen.
     * @returns {undefined}
     */
    bindUploadDialog(uploadDialog, uploadId=null) {
        if (!(uploadDialog instanceof kijs.UploadDialog)) {
            throw new kijs.Error('Upload Dialog must be of type kijs.UploadDialog');
        }

        // Events entfernen, wenn bereits eine Klasse verknüpft war.
        if (this._uploadDialog instanceof kijs.UploadDialog) {
            this._uploadDialog.off(null, null, this);
        }

        this._uploadDialog = uploadDialog;
        if (uploadId !== null) {
            this._uploadDialogId = uploadId;
        }

        uploadDialog.on('progress', this.#onUploadDialogProgress, this);
        uploadDialog.on('upload', this.#onUploadDialogUpload, this);
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // innerDOM rendern
        this._captionDom.renderTo(this._dom.node);
        this._fieldDom.renderTo(this._dom.node);
        this._bottomCaptionDom.renderTo(this._dom.node);
        this._barDom.renderTo(this._fieldDom.node);
        if (this._showPercent) {
            this._textDom.renderTo(this._fieldDom.node);
        }

        this._barDom.node.style.width = this._percent + '%';

        if (this._showPercent && (this._barDom.width >= this._textDom.width+3 || this._percent === 100)) {
            this._textDom.node.style.opacity = 1;
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }
    
    /**
     * aktualisiert den Balken
     * @param {int} percent Prozent zwischen 0-100
     * @returns {undefined}
     */
    setProgress(percent) {
        percent = window.parseInt(percent);
        if (window.isNaN(percent) || percent < 0 || percent > 100) {
            throw new kijs.Error('percent must be numeric between 0 and 100');
        }

        this._percent = percent;
        this._textDom.html = this._showPercent ? this._percent + '%' : '';

        if (this._barDom.node) {
            this._barDom.node.style.width = this._percent + '%';
        }

        if (this._showPercent && this._textDom.node) {
            if (this._barDom.width >= this._textDom.width+3 || this._percent === 100) {
                this._textDom.node.style.opacity = 1;

            } else {
                this._textDom.node.style.opacity = 0;
            }
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._barDom.unrender();
        this._textDom.unrender();

        super.unrender(true);
    }


    // PRIVATE
    // LISTENERS
    #onUploadDialogProgress(ud, e, id, percent) {
        if (this._uploadDialogId === null) {
            this._uploadDialogId = id;
        }

        if (kijs.isInteger(percent) && this._uploadDialogId === id) {
            this.setProgress(percent);
        }
    }

    // Upload fertig
    #onUploadDialogUpload(ud, resp, error, id) {
        if (this._uploadDialogId === id) {
            this.setProgress(100);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Events entfernen
        if (this._uploadDialog instanceof kijs.UploadDialog) {
            this._uploadDialog.off(null, null, this);
        }

        this._captionDom.destruct();
        this._bottomCaptionDom.destruct();

        this._fieldDom.destruct();
        this._barDom.destruct();
        this._textDom.destruct();

        this._captionDom = null;
        this._bottomCaptionDom = null;

        this._fieldDom = null;
        this._barDom = null;
        this._textDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.UploadWindow
// --------------------------------------------------------------

// TODO: Umbenennen zu kijs.gui.FileUpload !!!!!
// TODO: Sollte von kijs.FileUpload erben !!!!!


// Das Fenster kann mit der Mehtode .show() angezeigt werden.
// Es wird dann in das target gerendert.
// Als target kann der document.body oder ein kijs.gui.Element angegeben
// werden.
// Beim Body als target ist der Body auch gleich der übergeordnete Node (parentNode).
// Beim einem kijs.gui.Element als target ist das übergeordnete Element nicht der node
// des Elements, sondern dessen parentNode.
// Deshalb gibt es die Eigenschaften targetNode und parentNode, welche bei einem
// kijs.gui.Element als target nicht den gleichen node als Inhalt haben. Beim body
// als target, hingegen schon.
// Mit der targetDomProperty kann noch festgelegt werden, welcher node eines Elements
// als target dient, wird nichts angegeben, so dient das ganze Element als target.
// Es kann z.B. bei einem kijs.gui.Panel nur der innere Teil als target angegeben werden.
// Dazu kann die Eigenschaft targetDomProperty="innerDom" definiert werden.
// --------------------------------------------------------------
kijs.gui.UploadWindow = class kijs_gui_UploadWindow extends kijs.gui.Window {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._uploadDialog = null;   // intern
        this._uploads = [];          // intern
        this._autoClose = true;      // intern
        this._uploadRunning = true;  // intern

        this._dom.clsAdd('kijs-uploadwindow');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            caption: kijs.getText('Upload'),
            iconMap: 'kijs.iconMap.Fa.upload',
            uploadDialog: null,
            closable: false,
            maximizable: false,
            resizable: false,
            modal: true,
            width: 250,
            autoClose: true,
            innerStyle: {
                padding: '10px'
            },
            footerStyle: {
                padding: '10px'
            },
            footerElements:[
                '>',
                {
                    xtype: 'kijs.gui.Button',
                    caption: 'OK',
                    isDefault: true,
                    on: {
                        click: function() {
                            if (this._uploadRunning !== true && this._dom.node) {
                                this.unrender();
                            }
                        },
                        context: this
                    }
                }
            ]
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            uploadDialog: { target: 'uploadDialog' },
            autoClose: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get uploadDialog() { return this._uploadDialog; }
    set uploadDialog(val) {
        // falls bereits verknüpft, events entfernen
        if (this._uploadDialog instanceof kijs.UploadDialog) {
            this._uploadDialog.off(null, null, this);
        }

        this._uploadDialog = val;
        if (kijs.isDefined(val)) {
            if (!(val instanceof kijs.UploadDialog)) {
                throw new kijs.Error('uploadDialog must be of type kijs.UploadDialog');
            }

            this._uploadDialog.on('startUpload', this.#onStartUpload, this);
            this._uploadDialog.on('failUpload', this.#onFailUpload, this);
            this._uploadDialog.on('upload', this.#onUpload, this);
            this._uploadDialog.on('endUpload', this.#onEndUpload, this);
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Zeigt das Fenster zur Dateiauswahl an.
     * @param {Boolean} multiple Dürfen mehrere Dateien ausgewählt werden?
     * @param {Boolean} directory Soll statt eine Datei ein Verzeichnis hochgeladen werden?
     * @returns {undefined}
     */
    // TODO: Umbenennen zu showFileOpenDialog !!!!!
    showFileSelectDialog(multiple=null, directory=null) {
        if (!(this._uploadDialog instanceof kijs.UploadDialog)) {
            this._uploadDialog = new kijs.UploadDialog();
        }

        this._uploadDialog.showFileSelectDialog(multiple, directory);
    }


    // PROTECTED
    _getUploadProgressBar(uploadId) {
        for (let i=0; i<this._uploads.length; i++) {
            if (this._uploads[i].uploadId === uploadId)  {
                return this._uploads[i].progressBar;
            }
        }
        return null;
    }


    // PRIVATE
    // LISTENERS
    #onEndUpload() {
        // uploads fertig
        this._uploadRunning = false;
        if (this._autoClose) {
            kijs.defer(function() {
                if (this._dom.node) {
                    this.unrender();
                }
            }, 1000, this);
        }
    }
    
    #onFailUpload(ud, filename, filetype) {
        this._autoClose = false;
    }

    #onStartUpload(ud, filename, filedir, filetype, uploadId) {
        let progressBar = new kijs.gui.ProgressBar({
            caption: kijs.String.htmlspecialchars(filename),
            uploadDialog: this._uploadDialog,
            uploadDialogId: uploadId,
            style: {
                marginBottom: '10px'
            }
        });

        this._uploads.push({
            progressBar: progressBar,
            uploadId: uploadId
        });

        this.add(progressBar);

        if (!this._dom.node) {
            this.show();
        }

        this.center();

        // uploads laufen
        this._uploadRunning = true;
    }

    #onUpload(ud, response, errorMsg, uploadId) {
        let pg = this._getUploadProgressBar(uploadId);
        if (errorMsg && pg) {
            this._autoClose = false;
            pg.bottomCaption = '<span class="error">' + kijs.String.htmlspecialchars(errorMsg) + '</span>';
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._uploadDialog = null;   // intern
        this._uploads = [];          // intern
        this._autoClose = true;      // intern
        this._uploadRunning = true;  // intern
        
        // Basisklasse auch entladen
        super.destruct(true);
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.CornerTipContainer
// --------------------------------------------------------------
kijs.gui.CornerTipContainer = class kijs_gui_CornerTipContainer extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dismissDelay = null;

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-cornertipcontainer');
        this._dom.nodeAttributeSet('popover', 'manual');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            dismissDelay: 5000,
            width: 240
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            dismissDelay: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // STATICS
    // --------------------------------------------------------------
    /**
     * Zeigt einen CornerTip an und erstellt dafür eine Singleton-Instanz
     * @param {String} caption
     * @param {String} html
     * @param {String} [icon='alert'] 'alert', 'info', 'errorNotice' oder 'error'
     * @returns {undefined}
     */
    static show(caption, html, icon='alert') {
        // Singleton-Instanz ermitteln oder erstellen
        let instance = kijs.gui.CornerTipContainer._singletonInstance;
        if (!instance) {
            instance = new kijs.gui.CornerTipContainer();
            instance.renderTo(document.body);
            kijs.gui.CornerTipContainer._singletonInstance = instance;

        } else {
            // als letzte node anhängen
            document.body.appendChild(instance.dom.node);
        }

        switch (icon) {
            case 'alert': instance.alert(caption, html); break;
            case 'info': instance.info(caption, html); break;
            case 'warning': instance.warning(caption, html); break;
            case 'error': instance.error(caption, html); break;
            case 'errorNotice': instance.errorNotice(caption, html); break;
            default:
                throw new kijs.Error(`Unknown value on argument "icon"`);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get dismissDelay() { return this._dismissDelay; }
    set dismissDelay(val) { this._dismissDelay = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
     /**
     * Zeigt ein normaler CornerTip
     * @param {String} caption
     * @param {String} msg
     * @returns {undefined}
     */
    alert(caption, msg) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        this.show({
            caption: caption,
            msg: msg
        });
    }

    /**
     * Zeigt ein CornerTip mit einem "unerwarteten Fehler"-Symbol
     * @param {String} caption
     * @param {String} msg
     * @returns {undefined}
     */
    error(caption, msg) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        this.show({
            caption: caption,
            msg: msg,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-exclamation',
                iconColor: '#be6280'
            }
        });
    }
    
    /**
     * Zeigt ein CornerTip mit einem Fehler-Symbol
     * @param {String} caption
     * @param {String} msg
     * @returns {undefined}
     */
    errorNotice(caption, msg) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        this.show({
            caption: caption,
            msg: msg,
            icon: {
                iconMap: 'kijs.iconMap.Fa.triangle-exclamation',
                iconColor: '#be6280'
            }
        });
    }

    /**
     * Zeigt ein CornerTip mit einem Info-Symbol
     * @param {String} caption
     * @param {String} msg
     * @returns {undefined}
     */
    info(caption, msg) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        this.show({
            caption: caption,
            msg: msg,
            icon: {
                iconMap: 'kijs.iconMap.Fa.circle-info',
                iconColor: '#4398dd'
            }
        });
    }

    /**
     * Zeigt ein individueller CornerTip
     * Beispiel config:
     * config = {
     *     caption = 'Testmeldung',
     *     msg = 'Hallo Welt!'
     *     iconChar: '',
     *     icon: {
     *         iconChar: 0xf071,
     *         style: {
     *             color: '#ff9900'
     *         }
     *     }
     * }
     * @param {Object} config
     * @returns {undefined}
     */
    show(config) {
        const elements = [];

        // Icon
        if (config.icon) {
            if (!(config.icon instanceof kijs.gui.Icon)) {
                config.icon.xtype = 'kijs.gui.Icon';
            }
            elements.push(config.icon);
        }

        // Text
        elements.push({
            xtype: 'kijs.gui.Element',
            html: config.msg,
            htmlDisplayType: 'html',
            cls: 'kijs-msgbox-inner'
        });

        // CornerTip erstellen
        const tip = new kijs.gui.Panel({
            caption: config.caption,
            iconMap: config.iconMap ? config.iconMap : '',
            closable: true,
            elements: elements
        });

        // CornerTip anzeigen
        this.add(tip);

        // Nach einer bestimmten Zeit wieder automatisch schliessen
        if (this._dismissDelay) {
            kijs.defer(function() {
                if (this.hasChild(tip)) {
                    this.remove(tip);
                }

                // Singleton löschen, wenn nicht mehr benötigt.
                if (this.elements.length === 0 && kijs.gui.CornerTipContainer._singletonInstance === this) {
                    this.unrender();
                    delete kijs.gui.CornerTipContainer._singletonInstance;
                }

            }, this._dismissDelay, this);
        }
    }

    /**
     * Zeigt ein CornerTip mit einem Warnungs-Symbol
     * @param {String} caption
     * @param {String} msg
     * @returns {undefined}
     */
    warning(caption, msg) {
        if (kijs.isArray(msg)) {
            msg = this._convertArrayToHtml(msg);
        }

        this.show({
            caption: caption,
            msg: msg,
            icon: {
                iconMap: 'kijs.iconMap.Fa.triangle-exclamation',
                iconColor: '#ff9900'
            }
        });
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // popover
        if (this._dom.node && this._dom.node.parentNode) {
            this._dom.node.showPopover();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }


    // PROTECTED
    _convertArrayToHtml(messages) {
        if (messages.length === 1) {
            return messages[0];
        }

        let ret = '<ul>';
        kijs.Array.each(messages, function(msg) {
            ret += '<li>' + msg + '</li>';
        }, this);
         ret += '</ul>';
        return ret;
    }


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.Rpc
// --------------------------------------------------------------
// Erweiterung von kijs.Rpc, der die Meldungsfenster anzeigt
kijs.gui.Rpc = class kijs_gui_Rpc extends kijs.Rpc {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._defaultCornerTipIcon = 'info';
        this._defaultCornerTipTitle = null; // null=Standardwert: 'Info'
        this._defaultErrorTitle = null;     // null=Standardwert: 'Fehler'
        this._defaultInfoTitle = null;      // null=Standardwert: 'Info'
        this._defaultWarningTitle = null;   // null=Standardwert: 'Warnung'
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            defaultCornerTipIcon: true,
            defaultCornerTipTitle: true,
            defaultErrorTitle: true,
            defaultInfoTitle: true,
            defaultWarningTitle: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config);
        }
    }


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get defaultCornerTipIcon() { return this._defaultCornerTipIcon; }
    set defaultCornerTipIcon(val) { this._defaultCornerTipIcon = val; }

    get defaultCornerTipTitle() { return this._defaultCornerTipTitle; }
    set defaultCornerTipTitle(val) { this._defaultCornerTipTitle = val; }

    get defaultErrorTitle() { return this._defaultErrorTitle; }
    set defaultErrorTitle(val) { this._defaultErrorTitle = val; }

    get defaultInfoTitle() { return this._defaultInfoTitle; }
    set defaultInfoTitle(val) { this._defaultInfoTitle = val; }

    get defaultWarningTitle() { return this._defaultWarningTitle; }
    set defaultWarningTitle(val) { this._defaultWarningTitle = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Führt einen RPC aus
     * - Wird eine fn übergeben, wird diese bei erhalt der Antwort ausgeführt (auch im Fehlerfall).
     *   Die Rückgabe der Funktion ist dann immer Null.
     * - Es wird ein Promise zurückgegeben. Bei diesem wird immer (auch im Fehlerfall) resolve ausgeführt.
     * - Um festzustellen, ob es einen Fehler gegeben hat können errorType und errorMsg abgefragen
     *   werden.
     * - Es gibt folgende errorTypes:
     *    - 'errorNotice'   Es wurde eine errorMsg vom Server zurückgegeben mit errorType='errorNotice' 
     *                      oder ohne errorType (dann wird der errorType automatisch auf 'errorNotice' 
     *                      gesetzt. 
     *    - 'error'         Es wurde eine errorMsg vom Server zurückgegeben mit errorType='error'.
     *    - 'warning'       Es wurde vom Server eine warningMsg zurückgegeben und der Benutzer 
     *                      hat auf Abbrechen geklickt.
     *    - 'cancel'        Der Request wurde bei cancelRunningRpcs=true durch einen 
     *                      neueren Request abgebrochen
     *   Es können auch eigene errorTypes verwendet werden.
     * 
     * @param {Object} config   onfig-Objekt mit folgenden Eingenschaften
     *     {String} remoteFn                    Modul/Facaden-name und Methodenname Bsp: 'address.save'
     *     {Mixed} data                         Argumente/Daten, die an die Server-RPC Funktion übergeben werden.
     *     {Object} [owner]                     Verweis auf das Aufzurufende Element oder eine ID, die das Element eindeutig identifiziert.
     *                                          Wird verwendet um bei cancelRunningRpcs den Eigentümmer zu identifizieren.
     *     {Function} fn                        Callback-Funktion
     *     {Object} context                     Kontext für die Callback-Funktion
     *     {Boolean} [cancelRunningRpcs=false]  Bei true, werden alle laufenden Requests
     *                                          vom selben owner an dieselbe remoteFn abgebrochen
     *     {Boolean} [exclusive=false]          Bei true, wird der RPC sofort gesendet
     *                                          und nicht mit anderen RPCs zusammengefasst.
     *     {kijs.gui.BoxElement|HTMLElement} [waitMaskTarget=document.body]  Ziel-BoxElement oder Ziel-Node
     *                                                                       für Lademaske, NULL=document.body, 'none' für keine Maske.
     *     {String} [waitMaskTargetDomProperty='dom']   Name der DOM-Eigenschaft in der die Lademaske
     *                                                  angezeigt werden soll.
     *     {Boolean} [ignoreWarnings=false]     Sollen Warnungen ignoriert werden?
     * @returns {Promise}
     */
    // overwrite (Vorsicht andere Argumente!)
    do(config) {
        // Validierung
        if (!kijs.isObject(config)) {
            throw new kijs.Error('RPC call without config object');
        }

        return new Promise((resolve) => {
            this._doRpc(config, resolve);
        });
    }
    
    
    // PROTECTED
    _doRpc(config, resolve) {
        // Lademaske anzeigen
        let waitMask;
        if (config.waitMaskTarget === 'none') {
            waitMask = null;
        } else if (config.waitMaskTarget instanceof kijs.gui.Element) {
            waitMask = config.waitMaskTarget.waitMaskAdd();
        } else {
            waitMask = new kijs.gui.Mask({
                displayWaitIcon: true,
                target: config.waitMaskTarget,
                targetDomProperty: config.waitMaskTargetDomProperty
            });
            waitMask.show();
        }
        
        // RPC
        return super.do({
            remoteFn: config.remoteFn,
            requestData: config.data,
            owner: config.owner,
            cancelRunningRpcs: config.cancelRunningRpcs,
            exclusive: config.exclusive,
            rpcParams: {ignoreWarnings: !!config.ignoreWarnings},
            responseArgs: {waitMask: waitMask},
            context: this,
            fn: function(rpcData) {
                // Lademaske entfernen
                if (rpcData.request.responseArgs && rpcData.request.responseArgs.waitMask) {
                    if (rpcData.request.responseArgs.waitMask.target instanceof kijs.gui.Element) {
                        rpcData.request.responseArgs.waitMask.target.waitMaskRemove();
                    } else {
                        rpcData.request.responseArgs.waitMask.destruct();
                    }
                }

                // Abbruch durch neueren RPC bei cancelRunningRpcs=true
                if (rpcData.response.errorType === 'cancel') {
                    // Argument vorbereiten
                    const e = {
                        responseData: rpcData.response.responseData,
                        requestData: rpcData.request.requestData,
                        errorType: rpcData.response.errorType,
                        errorMsg: rpcData.response.errorMsg
                    };

                    // callback-fn ausführen
                    if (kijs.isFunction(config.fn)) {
                        config.fn.call(config.context || this, e);
                    }

                    // Promise auslösen
                    resolve(e);
                    return;
                    
                // Fehler --> FehlerMsg + Abbruch
                // rpcData.response.errorMsg (String oder Array mit Strings, die mit Aufzählungszeichen angezeigt werden)
                } else if (!kijs.isEmpty(rpcData.response.errorType) || !kijs.isEmpty(rpcData.response.errorMsg)) {
                    // Standard errorType
                    if (kijs.isEmpty(rpcData.response.errorType)) {
                        rpcData.response.errorType = this._defaultErrorType;
                    }

                    // Standard errorTitle
                    if (kijs.isEmpty(rpcData.response.errorTitle)) {
                        rpcData.response.errorTitle = this._defaultErrorTitle;
                        if (rpcData.response.errorTitle === null) {
                             rpcData.response.errorTitle = kijs.getText('Fehler');
                        }
                    }

                    // Fehler anzeigen
                    if (rpcData.response.errorType === 'error') {
                        kijs.gui.MsgBox.error(rpcData.response.errorTitle, rpcData.response.errorMsg);
                    } else {
                        kijs.gui.MsgBox.errorNotice(rpcData.response.errorTitle, rpcData.response.errorMsg);
                    }

                // Warning --> WarnungMsg mit OK, Cancel. Bei Ok wird der gleiche request nochmal gesendet mit dem Flag ignoreWarnings
                // rpcData.response.warningMsg (String oder Array mit Strings, die mit Aufzählungszeichen angezeigt werden)
                } else if (!kijs.isEmpty(rpcData.response.warningMsg)) {
                    // Standard warningTitle
                    if (kijs.isEmpty(rpcData.response.warningTitle)) {
                        rpcData.response.warningTitle = this._defaultWarningTitle;
                        if (rpcData.response.warningTitle === null) {
                             rpcData.response.warningTitle = kijs.getText('Warnung');
                        }
                    }

                    // Warnung anzeigen
                    kijs.gui.MsgBox.warning(rpcData.response.warningTitle, rpcData.response.warningMsg, function(e) {
                        // click auf Ok
                        if (e.btn === 'ok') {
                            // Request nochmal senden mit Flag ignoreWarnings
                            this._doRpc({
                                remoteFn: config.remoteFn,
                                data: config.data,
                                owner: config.owner,
                                fn: config.fn,
                                context: config.context,
                                cancelRunningRpcs: config.cancelRunningRpcs,
                                waitMaskTarget: config.waitMaskTarget,
                                waitMaskTargetDomProperty: config.waitMaskTargetDomProperty,
                                ignoreWarnings: true
                            }, resolve);

                        // click auf Abbrechen
                        } else {
                            // errorType ist fix 'warning'
                            rpcData.response.errorType = 'warning';

                            // Argument vorbereiten
                            const e = {
                                responseData: rpcData.response.responseData,
                                requestData: rpcData.request.requestData,
                                errorType: rpcData.response.errorType,
                                errorMsg: rpcData.response.errorMsg
                            };

                            // callback-fn ausführen
                            if (kijs.isFunction(config.fn)) {
                                config.fn.call(config.context || this, e);
                            }

                            // Promise auslösen
                            resolve(e);
                        }
                    }, this);

                    return;
                }

                // Info --> Msg ohne Icon
                // rpcData.response.infoMsg (String oder Array mit Strings, die mit Aufzählungszeichen angezeigt werden)
                if (!kijs.isEmpty(rpcData.response.infoMsg)) {
                    // Standard infoTitle
                    if (kijs.isEmpty(rpcData.response.infoTitle)) {
                        rpcData.response.infoTitle = this._defaultInfoTitle;
                        if (rpcData.response.infoTitle === null) {
                             rpcData.response.infoTitle = kijs.getText('Info');
                        }
                    }
                    kijs.gui.MsgBox.info(rpcData.response.infoTitle, rpcData.response.infoMsg);
                }

                // CornerTip -> Msg, die automatisch wieder verschwindet kein Abbruch
                // rpcData.response.tipMsg (String oder Array mit Strings, die mit Aufzählungszeichen angezeigt werden)
                if (rpcData.response.cornerTipMsg) {
                    // Standard cornerTipIcon
                    if (kijs.isEmpty(rpcData.response.cornerTipIcon)) {
                        rpcData.response.cornerTipIcon = this._defaultCornerTipIcon;
                    }

                    // Standard cornerTipTitle
                    if (kijs.isEmpty(rpcData.response.cornerTipTitle)) {
                        rpcData.response.cornerTipTitle = this._defaultCornerTipTitle;
                        if (rpcData.response.cornerTipTitle === null) {
                             rpcData.response.cornerTipTitle = kijs.getText('Info');
                        }
                    }

                    kijs.gui.CornerTipContainer.show(rpcData.response.cornerTipTitle, 
                            rpcData.response.cornerTipMsg, rpcData.response.cornerTipIcon);
                }

                // Argument vorbereiten
                const e = {
                    responseData: rpcData.response.responseData,
                    requestData: rpcData.request.requestData,
                    errorType: rpcData.response.errorType,
                    errorMsg: rpcData.response.errorMsg
                };

                // callback-fn ausführen
                if (kijs.isFunction(config.fn)) {
                    config.fn.call(config.context || this, e);
                }

                // Promise auslösen
                resolve(e);
            }
        });
    }

};
/* global kijs, this */

// TODO: Es gibt zwei unterschiedliche Möglichkeiten um zu Filtern 
// - selectByFilters()
// - this.filters (Entfernen: Ist nicht dokumentiert)
// Es sollte nur eine Möglichkeit geben!


// --------------------------------------------------------------
// kijs.gui.DataView
// --------------------------------------------------------------
kijs.gui.DataView = class kijs_gui_DataView extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._sortable = false;          // Elements sind per Drag&Drop verschiebbar

        this._elementXType = 'kijs.gui.dataView.element.AutoHtml';

        this._ddPosAfterFactor = 0.666;  // Position, ab der nachher eingefügt wird
        this._ddPosBeforeFactor = 0.666; // Position, ab der vorher eingefügt wird
        this._ddName = kijs.uniqId('dataview.element');
        this._ddTarget = null;
        this._elementDdSourceConfig = null;

        this._rpcSaveFn = null;         // Name der remoteFn. Bsp: 'dataview.save'
        this._rpcSaveArgs = {};         // Standard RPC-Argumente fürs Speichern
        this._autoSave = false;         // Automatisches Speichern bei Änderungen

        this._currentEl = null;         // Aktuelles Element (Wenn der Fokus auf dem DataView ist,
                                        // hat dieses Element den Fokus)
        this._lastSelectedEl = null;    // Letztes Element das Selektiert wurde. Wird gebraucht,
                                        // wenn mit der Shift-Taste mehrere selektiert werden.
        this._data = [];
        this._filters = [];
        this._focusable = true;
        this._selectType = 'none';

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-dataview');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            scrollableY: 'auto',
            focusable: true,
            selectType: 'single'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            elementXType: true,         // xtype für DataView-Element. Muss von 'kijs.gui.dataView.element.Base' vererbt sein.
            autoLoad: { target: 'autoLoad' },   // Soll nach dem ersten Rendern automatisch die Load-Funktion aufgerufen werden?
            data: { target: 'data' },   // Recordset-Array [{id:1, caption:'Wert 1'}] oder Werte-Array ['Wert 1']
            filters: { target: 'filters' },
            focusable: { target: 'focusable'},  // Kann das Dataview den Fokus erhalten?
            selectFilters: { fn: 'function', target: this.selectByFilters, context: this }, // Filter, die definieren, welche Datensätze das per default Selektiert sind.
            selectType: true,           // 'none': Es kann nichts selektiert werden
                                        // 'single' (default): Es kann nur ein Datensatz selektiert werden. Abwählen ist nicht möglich.
                                        // 'singleAndEmpty': Wie Single. Der aktuelle Datensatz kann aber abgewählt werden.
                                        // 'multi': Mit den Shift- und Ctrl-Tasten können mehrere Datensätze selektiert werden.
                                        // 'simple': Es können mehrere Datensätze selektiert werden. Shift- und Ctrl-Tasten müssen dazu nicht gedrückt werden.
            rpcSaveFn: true,    // Name der remoteFn. Bsp: 'dashboard.save'
            rpcSaveArgs: true,  // Standard RPC-Argumente fürs Speichern
            autoSave: true,     // Automatisches Speichern bei Änderungen

            ddName: true,
            ddPosBeforeFactor: true,
            ddPosAfterFactor: true,
            elementDdSourceConfig: true,
            sortable: { prio: 90, target: 'sortable' },
            ddTarget: { prio: 100, target: 'ddTarget' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this.on('keyDown', this.#onKeyDown, this);
        this.on('elementMouseDown', this.#onElementMouseDown, this);
        //this.on('elementFocus', this.#onElementFocus, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autoLoad() {
        return this.hasListener('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
    }
    set autoLoad(val) {
        if (val) {
            this.on('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
        } else {
            this.off('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
        }
    }

    get autoSave() { return this._autoSave; }
    set autoSave(val) { this._autoSave = !!val; }

    get current() { return this._currentEl; }
    /**
     * Setzt das aktuelle Element, dass den Fokus erhalten wird.
     * Null = automatische Ermittlung
     * Um den Fokus zu setzen, bitte die Funktion .focus() vom Element verwenden.
     * @param {kijs.gui.dataView.element.Base|null} el
     * @returns {undefined}
     */
    set current(el) {
        // Falls kein el übergeben wurde:
        if (!el && !kijs.isEmpty(this._elements)) {
            // Falls es schon ein gültiges Current-Element gibt, dieses nehmen
            if (this._currentEl && kijs.Array.contains(this._elements, this._currentEl)) {
                el = this._currentEl;
            }
            // Sonst das erste selektierte Element
            if (!el) {
                let sel = this.getSelected();
                if (!kijs.isEmpty(sel)) {
                    if (kijs.isArray(sel)) {
                        sel = sel[0];
                    }
                    el = sel;
                }
            }
            // Sonst halt das erste Element
            if (!el) {
                el = this._elements[0];
            }
        }

        this._currentEl = el;
        kijs.Array.each(this._elements, function(elem) {
            if (elem === el) {
                elem.dom.clsAdd('kijs-current');
            } else {
                elem.dom.clsRemove('kijs-current');
            }
            // Nur das currentEl darf den Fokus erhalten können
            if (this._focusable && elem === el) {
                el.dom.nodeAttributeSet('tabIndex', 0);
            } else {
                elem.dom.nodeAttributeSet('tabIndex', undefined);
            }
        }, this);
    }

    get data() { return this._data; }
    set data(val) {
        this._data = kijs.isEmpty(val) ? [] : val;
        this._createElements(this._data);

        // Current Element ermitteln und setzen
        this.current = null;
    }

    get elementXType() { return this._elementXType; }
    set elementXType(val) { this._elementXType = val; }

    get ddName() { return this._ddName; }
    set ddName(val) {
        this._ddName = val;
        if (this._ddTarget && this._sortable) {
            // Elements neu laden
            if (!kijs.isEmpty(this._elements)) {
                this._createElements(this._data);
                // Current Element ermitteln und setzen
                this.current = null;
            }
        }
    }

    get ddPosAfterFactor() { return this._ddPosAfterFactor; }
    set ddPosAfterFactor(val) {
        this._ddPosAfterFactor = val;
        if (this._ddTarget) {
            this._ddTarget.posAfterFactor = val;
        }
    }

    get ddPosBeforeFactor() { return this._ddPosBeforeFactor; }
    set ddPosBeforeFactor(val) {
        this._ddPosBeforeFactor = val;
        if (this._ddTarget) {
            this._ddTarget.posBeforeFactor = val;
        }
    }

    get ddTarget() {
        return this._ddTarget;
    }
    set ddTarget(val) {
        // config-object
        if (kijs.isObject(val)) {
            if (kijs.isEmpty(this._ddTarget)) {
                val.ownerEl = this;
                if (kijs.isEmpty(val.ownerDomProperty)) {
                    val.ownerDomProperty = 'innerDom';
                }
                if (kijs.isEmpty(val.posBeforeFactor)) {
                    val.posBeforeFactor = this._ddPosBeforeFactor;
                }
                if (kijs.isEmpty(val.posAfterFactor)) {
                    val.posAfterFactor = this._ddPosAfterFactor;
                }
                this._ddTarget = new kijs.gui.dragDrop.Target(val);
                this._eventForwardsAdd('ddTargetDrop', this.ddTarget, 'drop');
            } else {
                this._ddTarget.applyConfig(val);
            }

        // null
        } else if (val === null) {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;

        } else {
            throw new kijs.Error(`ddTarget must be a object or null`);

        }
    }

    get elementDdSourceConfig() {
        return this._elementDdSourceConfig;
    }
    set elementDdSourceConfig(val) {
        this._elementDdSourceConfig = val;
    }

    get filters() { return this._filters; }
    set filters(val) {
        if (!val) {
            this._filters = [];
        } else {
            if (!kijs.isArray(val)) {
                val = [val];
            }

            // einzelne Filter validieren
            kijs.Array.each(val, function(filter) {
                if (!kijs.isObject(filter) || !('field' in filter) || !('value' in filter) || !kijs.isString(filter.field) || !kijs.isString(filter.value)) {
                    throw new kijs.Error(`invalid argument for filters in kijs.gui.DataView`);
                }
                if (!('compare' in filter) || !kijs.Array.contains(['begin', 'part', 'end', 'full'], filter.compare)) {
                    filter.compare = 'begin';
                }
            }, this);

            this._filters = val;
        }
    }

    get focusable() { return this._focusable; }
    set focusable(val) {
        this._focusable = val;
    }

    // overwrite
    get hasFocus() {
        return this._currentEl ? this._currentEl.hasFocus : false;
    }

    get rpcSaveArgs() { return this._rpcSaveArgs; }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }

    get rpcSaveFn() { return this._rpcSaveFn; }
    set rpcSaveFn(val) { this._rpcSaveFn = val; }

    get selectType() { return this._selectType; }
    set selectType(val) { this._selectType = val; }

    get sortable() { return this._sortable; }
    set sortable(val) {
        this._sortable = !!val;

        // Evtl. ddTarget erstellen
        if (val && !this._ddTarget) {
            this.ddTarget = {
                posBeforeFactor: this._ddPosBeforeAfterFactor,
                posAfterFactor: this._ddPosBeforeAfterFactor
            };
            this._ddTarget.on('drop', this.#onTargetDrop, this);
        }

        // Mapping
        if (val) {
            this._ddTarget.mapping[this._ddName] = {
                allowMove: true,
                allowCopy: false,
                allowLink: false
            };
        } else {
            delete this._ddTarget.mapping[this._ddName];
        }

        // evtl. ddTarget löschen
        if (this._ddTarget && kijs.isEmpty(this._ddTarget.mapping)) {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;
        }

        // Elements neu laden
        if (!kijs.isEmpty(this._elements)) {
            this._createElements(this._data);
            // Current Element ermitteln und setzen
            this.current = null;
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt Daten hinzu
     * @param {type} data
     * @returns {undefined}
     */
    addData(data){
        if (!kijs.isArray(data)) {
            data = [data];
        }

        this._data = kijs.Array.concat(this._data, data);

        this._createElements(data, false);
    }

    /**
     * Wendet Filter auf das DataView an.
     * @param {Array|Object} filters
     * @returns {undefined}
     */
    applyFilters(filters) {
        this.filters = filters;
        if (this.isRendered) {
            this._createElements(this._data);
            // Current Element ermitteln und setzen
            this.current = null;
        }
    }

    /**
     * Entfernt alle Selektionen
     * @param {Boolean} [preventSelectionChange=false]    Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    clearSelections(preventSelectionChange) {
        this.unSelect(this._elements, preventSelectionChange);
    }

    /**
     * Gibt die selektierten Elemente zurück
     * Bei selectType='single' oder 'singleAndEmpty' wird das Element direkt zurückgegeben sonst ein Array mit den Elementen
     * @returns {Array|kijs.gui.dataView.element.Base|null}
     */
    getSelected() {
        let ret = [];
        for (let i=0, len=this._elements.length; i<len; i++) {
            if (this._elements[i].selected) {
                ret.push(this._elements[i]);
            }
        }

        if (this._selectType === 'none') {
            return null;

        } else if (kijs.Array.contains(['single', 'singleAndEmpty'], this._selectType)) {
            return ret.length ? ret[0] : null ;

        } else {
            return ret;

        }
    }

    /**
     * Gibt die Data-rows der selektieten Elemente zurück
     * @returns {Array|null}
     */
    getSelectedRows() {
        let rows = [];

        for (let i=0, len=this._elements.length; i<len; i++) {
            if (this._elements[i].selected) {
                rows.push(this._elements[i].dataRow);
            }
        }

        if (this._selectType === 'none') {
            return null;

        } else if (kijs.Array.contains(['single', 'singleAndEmpty'], this._selectType)) {
            return rows.length ? [rows[0]] : null ;

        } else {
            return rows;

        }
    }

    // wird von kijs.gui.Combo verwendet
    handleKeyDown(nodeEvent) {
        let isShiftPress = !!nodeEvent.shiftKey;
        let isCtrlPress = !!nodeEvent.ctrlKey;

        if (kijs.Navigator.isMac) {
            isCtrlPress = !!nodeEvent.metaKey;
        }

        if (!this.disabled) {
            switch (nodeEvent.code) {
                case 'ArrowLeft':
                    if (this._currentEl) {
                        const prev = this._currentEl.previous;
                        if (prev) {
                            this.current = prev;
                            if (this._focusable) {
                                prev.focus();
                            }
                        }

                        if (isShiftPress || (!isCtrlPress && kijs.Array.contains(['single', 'singleAndEmpty', 'multi'], this._selectType))) {
                            this._selectEl(this._currentEl, isShiftPress, isCtrlPress);
                        }
                    }
                    nodeEvent.preventDefault();
                    break;

                case 'ArrowUp':
                    if (this._currentEl && this._elements) {
                        let found = false;

                        kijs.Array.each(this._elements, function(el) {
                            if (found) {
                                if (el.top < this._currentEl.top && el.left === this._currentEl.left) {
                                    this.current = el;
                                    if (this._focusable) {
                                        el.focus();
                                    }
                                    return false;
                                }
                            } else {
                                if (el === this._currentEl) {
                                    found = true;
                                }
                            }
                        }, this, true);

                        if (isShiftPress || (!isCtrlPress && kijs.Array.contains(['single', 'singleAndEmpty', 'multi'], this._selectType))) {
                            this._selectEl(this._currentEl, isShiftPress, isCtrlPress);
                        }
                    }
                    nodeEvent.preventDefault();
                    break;

                case 'ArrowRight':
                    if (this._currentEl) {
                        const next = this._currentEl.next;
                        if (next) {
                            this.current = next;
                            if (this._focusable) {
                                next.focus();
                            }
                        }

                        if (isShiftPress || (!isCtrlPress && kijs.Array.contains(['single', 'singleAndEmpty', 'multi'], this._selectType))) {
                            this._selectEl(this._currentEl, isShiftPress, isCtrlPress);
                        }
                    }
                    nodeEvent.preventDefault();
                    break;

                case 'ArrowDown':
                    if (this._currentEl && this._elements) {
                        let found = false;
                        kijs.Array.each(this._elements, function(el) {
                            if (found) {
                                if (el.top > this._currentEl.top && el.left === this._currentEl.left) {
                                    this.current = el;
                                    if (this._focusable) {
                                        el.focus();
                                    }
                                    return false;
                                }
                            } else {
                                if (el === this._currentEl) {
                                    found = true;
                                }
                            }
                        }, this);

                        if (isShiftPress || (!isCtrlPress && kijs.Array.contains(['single', 'singleAndEmpty', 'multi'], this._selectType))) {
                            this._selectEl(this._currentEl, isShiftPress, isCtrlPress);
                        }
                    }
                    nodeEvent.preventDefault();
                    break;

                case 'Space':
                    this._selectEl(this._currentEl, isShiftPress, isCtrlPress);
                    break;

            }
        }
    }

    save() {
        return new Promise((resolve, reject) => {
            let args = {};

            args = Object.assign({}, args, this._rpcSaveArgs);

            // an den Server senden
            this.rpc.do({
                remoteFn: this.rpcSaveFn,
                owner: this,
                data: this._data,
                cancelRunningRpcs: false,
                waitMaskTarget: this,
                waitMaskTargetDomProperty: 'dom',
                context: this

            }).then((e) => {
                // config Properties anwenden, falls vorhanden
                if (e.responseData.config) {
                    // config Properties übernehmen
                    this.applyConfig(e.responseData.config);
                }

                // 'afterSave' auslösen
                this.raiseEvent('afterSave', e);

                // Promise auslösen
                resolve(e);

            }).catch((ex) => {
                reject(ex);

            });
        });
    }

    /**
     * Selektiert ein oder mehrere Elemente
     * @param {kijs.gui.Element|Array} elements Element oder Array mit Elementen, die selektiert werden sollen
     * @param {Boolean} [keepExisting=false]            Soll die bestehende selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]  Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    select(elements, keepExisting=false, preventSelectionChange=false) {
        if (kijs.isEmpty(elements)) {
            elements = [];
        }

        if (!kijs.isArray(elements)) {
            elements = [elements];
        }

        if (!keepExisting){
            this.clearSelections(true);
        }

        var changed = false;
        kijs.Array.each(elements, function(el) {
            changed = changed || !el.selected;
            el.selected = true;
        }, this);

        // SelectionChange auslösen
        if (!preventSelectionChange && changed) {
            this.raiseEvent('selectionChange', { elements: elements, unSelect: false } );
        }
    }

    /**
     * Selektiert alle Elemente zwischen el1 und el2
     * @param {kijs.gui.Element} el1
     * @param {kijs.gui.Element} el2
     * @param {bool} [preventSelectionChange=false]     Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    selectBetween(el1, el2, preventSelectionChange=false) {
        let found = false;
        let elements = [];

        // Alle Elemente zwischen dem vorher selektierten Element und dem aktuellen Element selektieren
        kijs.Array.each(this._elements, function(el) {
            if (!found) {
                if (el === el1) {
                    found = 'el1';
                } else if (el === el2) {
                    found = 'el2';
                }
            }

            if (found) {
                elements.push(el);
            }

            if ((found==='el1' && el===el2) || (found==='el2' && el===el1)) {
                return false;
            }
        }, this);

        if (!kijs.isEmpty(elements)) {
            this.select(elements, true, preventSelectionChange);
        }
    }

    /**
     * Selektiert ein oder mehrere Elemente
     * @param {Array} rows Recordset mit rows der zu selektierenden Elementen
     * @param {Boolean} [keepExisting=false]            Soll die bestehende selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]  Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    selectByDataRows(rows, keepExisting=false, preventSelectionChange=false) {
        if (kijs.isEmpty(rows)) {
            return;
        }

        let selectedElements = [];

        if (!keepExisting){
            this.clearSelections(true);
        }

        var changed = false;
        kijs.Array.each(this._elements, function(el) {
            if (kijs.Array.contains(rows, el.dataRow)) {
                changed = changed || !el.selected;
                el.selected = true;
                selectedElements.push(el);
            }
        }, this);

        // current aktualisieren
        this._currentEl = null;
        this.current = null;

        // SelectionChange auslösen
        if (!preventSelectionChange && changed) {
            this.raiseEvent('selectionChange', { elements: selectedElements, unSelect: false } );
        }
    }

    /**
     * Selektiert ein oder mehrere Elemente
     * @param {Array|Object} filters                    Array mit Objektdefinitionen der Elemente, die selektiert werden sollen
     *                                                  Beispiel 1 (nur ein Datensatz wird selektiert bei nur einem Primary-Field):
     *                                                  { field: "Id", value: 123 }
     *
     *                                                  Beispiel 2 (mehrere werden selektiert bei nur einem Primary-Field):
     *                                                  [ { field: "Id", value: 123 }, { field: "Id", value: 124 } ]
     *
     *                                                  Beispiel 3 (nur ein Datensatz wird selektiert bei mehreren Primary-Fields):
     *                                                  [
     *                                                    { field: "Name", value: "Muster" },
     *                                                    { field: "Vorname", value: "Max" }
     *                                                  ]
     *
     *                                                  Beispiel 4 (mehrere Datensätze werden selektiert bei mehreren Primary-Fields):
     *                                                  [
     *                                                    [
     *                                                      { field: "Name", value: "Muster" },
     *                                                      { field: "Vorname", value: "Max" }
     *                                                    ],[
     *                                                      { field: "Name", value: "Muster" },
     *                                                      { field: "Vorname", value: "Max" }
     *                                                    ]
     *                                                  ]
     *
     * @param {Boolean} [keepExisting=false]            Soll die bestehende selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]  Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    selectByFilters(filters, keepExisting, preventSelectionChange) {
        if (kijs.isEmpty(filters)) {
            filters = [];
        }

        // Evtl. das Format ändern auf: [ [{...}, {...}], [{...}, {...}] ]
        if (kijs.isObject(filters)) {
            filters = [filters];
        }
        for (let i=0; i<filters.length; i++) {
            if (kijs.isObject(filters[i])) {
                filters[i] = [filters[i]];
            }
        }

        // Nun die Elemente durchgehen und wenn sie zum Filter passen: das Element vormerken
        const selElements = [];
        if (!kijs.isEmpty(filters)) {
            kijs.Array.each(this._elements, function(el) {
                if (el instanceof kijs.gui.dataView.element.Base) {
                    const row = el.dataRow;

                    kijs.Array.each(filters, function(filterFields) {
                        let ok = false;
                        kijs.Array.each(filterFields, function(filterField) {
                            if (kijs.isEmpty(filterField.value) || kijs.isEmpty(filterField.field)) {
                                throw new kijs.Error(`Unknown filter format.`);
                            }

                            if (filterField.value === row[filterField.field]) {
                                ok = true;
                            } else {
                                ok = false;
                                return false;
                            }
                        }, this);
                        if (ok) {
                            selElements.push(el);
                            return false;
                        }
                    }, this);
                }
            }, this);
        }

        // Elemente selektieren
        this.select(selElements, keepExisting, preventSelectionChange);

        // Element mit Fokus neu ermitteln
        this._currentEl = null;
        this.current = null;
    }

    /**
     * Selektiert ein oder mehrere Elemente
     * @param {Array|Int} indexes Index oder Array mit Indexes, die selektiert werden sollen
     * @param {Boolean} [keepExisting=false]            Soll die bestehende selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]  Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    selectByIndex(indexes, keepExisting=false, preventSelectionChange=false) {
        if (!kijs.isArray(indexes)) {
            indexes = [indexes];
        }
        let selectElements = [];
        kijs.Array.each(indexes, function(index) {
            kijs.Array.each(this.elements, function(element) {
                if (element.index === index) {
                    selectElements.push(element);
                    return false;
                }
            }, this);
        }, this);

        this.select(selectElements, keepExisting, preventSelectionChange);
    }

    /**
     * Element festlegen, welches über die Tabulator-Taste den Fokus erhält
     * Setzt den tabIndex des Elements auf 0
     * und bei allen anderen Elementen auf undefined
     * @param {Object} el
     * @returns {undefined}
     */
    /*setFocusableElement(el) {
        // Sicherstellen, dass alle anderen Elemente den Fokus nicht mehr über die Tabulator-Taste erhalten können
        kijs.Array.each(this._elements, function(elem) {
            elem.dom.nodeAttributeSet('tabIndex', undefined);
        }, this);
        
        //if (!el && !kijs.isEmpty(this._elements)) {
        //    el = this._elements[0];
        //}

        // Beim neuen Element: tabIndex einschalten
        // kann nun auch über die Tastatur und Maus fokussiert werden.
        if (this._focusable) {
            if (el) {
                el.dom.nodeAttributeSet('tabIndex', 0);
                //this._dom.nodeAttributeSet('tabIndex', undefined);
            } else {
                //this._dom.nodeAttributeSet('tabIndex', 0);
            }
        } else {
            //this._dom.nodeAttributeSet('tabIndex', undefined);
        }
    }*/

    /**
     * Deselektiert ein oder mehrere Elemente
     * @param {kijs.gui.Element|Array} elements Element oder Array mit Elementen, die deselektiert werden sollen
     * @param {bool} [preventSelectionChange=false]     Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    unSelect(elements, preventSelectionChange) {
        if (!kijs.isArray(elements)) {
            elements = [elements];
        }

        kijs.Array.each(elements, function(el) {
            if ('selected' in el) {
                el.selected = false;
            }
        }, this);

        if (!preventSelectionChange) {
            this.raiseEvent('selectionChange', { elements: elements, unSelect: true } );
        }
    }


    // PROTECTED
    /**
     * Erstellt aus einem Recordset ein kijs.gui.dataView.element....
     * @param {Array} dataRow   Datensatz, der gerendert werden soll
     * @param {Number} dataIndex  Index des Datensatzes im Recordset
     * @returns {kijs.gui.getDataViewElement}
     */
    _createElement(dataRow, dataIndex) {
        let el = this._getInstanceForAdd({
            xtype: this._elementXType,
            parent: this,
            dataRow: dataRow,
            dataIndex: dataIndex
        });

        if (!(el instanceof kijs.gui.dataView.element.Base)) {
            throw new kijs.Error(`Element must be an instance of kijs.gui.dataView.element.Base.`);
        }

        return el;
    }

    /**
     * Erstellt die Elemente
     * @param {array|string} data
     * @param {bool}  removeElements
     * @returns {undefined}
     */
    _createElements(data, removeElements = true) {

        // index des aktuellen Elements merken (Element mit Fokus)
        let currentIndex = null;
        if (this._currentEl && (this._currentEl instanceof kijs.gui.dataView.element.Base) && kijs.isDefined(this._currentEl.index)) {
            currentIndex = this._currentEl.index;
        }

        // Bestehende Elemente löschen
        if (this.elements && removeElements) {
            this.removeAll({
                preventRender: true
            });
            this._currentEl = null;
        }

        let indexOffset = this.elements.length;

        // Neue Elemente generieren
        let newElements = [];
        for (let i=0, len=data.length; i<len; i++) {

            // Zeile überspringen, falls sie im Filter hängen bleibt.
            if (this._filterMatch(data[i])) {
                continue;
            }

            const newEl = this._createElement(data[i], indexOffset+i);
            newEl.parent = this;

            // Drag&Drop
            if (this._elementDdSourceConfig) {
                newEl.ddSource = this._elementDdSourceConfig;
            } else if (this._sortable) {
                newEl.ddSource = {
                    allowMove: true,
                    allowCopy: true,
                    allowLink: false,
                    name: this._ddName
                };
                newEl.ddSource.on('drop', this.#onSourceDrop, this);
            }

            // click-Event
            newEl.on('click', function(e) {
                return this.raiseEvent('elementClick', e);
            }, this);

            // dblclick-Event
            newEl.on('dblClick', function(e) {
                return this.raiseEvent('elementDblClick', e);
            }, this);

            // mouseDown-Event
            newEl.on('mouseDown', function(e) {
                return this.raiseEvent('elementMouseDown', e);
            }, this);

            // mouseUp-Event
            newEl.on('mouseUp', function(e) {
                return this.raiseEvent('elementMouseUp', e);
            }, this);

            // contextMenu-Event
            newEl.on('contextMenu', function(e) {
                return this.raiseEvent('elementContextMenu', e);
            }, this);

            // focus-Event
            newEl.on('focus', function(e) {
                return this.raiseEvent('elementFocus', e);
            }, this);

            // Evtl. fokus setzen
            if (newEl.index === currentIndex) {
                this._currentEl = newEl;
            }

            newElements.push(newEl);
        }

        // neue Elemente einfügen
        this.add(newElements);
    }

    /**
     * Prüft, ob ein Filter auf einen Record matcht
     * @param {Object} record
     * @returns {Boolean}
     */
    _filterMatch(record) {
        let filterMatch = false;

        kijs.Array.each(this.filters, function(filter) {
            if (!kijs.isDefined(record[filter.field])) {
                filterMatch = true;
            }

            let rgx;
            if (filter.compare === 'begin') {
                rgx = new RegExp('^' + kijs.Char.getRegexPattern(kijs.String.regexpEscape(filter.value)), 'i');

            } else if (filter.compare === 'part') {
                rgx = new RegExp(kijs.Char.getRegexPattern(kijs.String.regexpEscape(filter.value)), 'i');

            } else if (filter.compare === 'end') {
                rgx = new RegExp(kijs.Char.getRegexPattern(kijs.String.regexpEscape(filter.value)) + '$', 'i');

            } else if (filter.compare === 'full') {
                rgx = new RegExp('^' + kijs.Char.getRegexPattern(kijs.String.regexpEscape(filter.value)) + '$', 'i');

            } else {
                throw new kijs.Error(`invalid value for filter.compare in kijs.gui.DataView`);
            }

            if (!kijs.toString(record[filter.field]).match(rgx)) {
                filterMatch = true;
            }
        }, this);

        return filterMatch;
    }

    /**
     * Selektiert ein Element und berücksichtigt dabei die selectType und die tasten shift und ctrl
     * @param {kijs.gui.Element} el
     * @param {Boolean} shift   // Shift gedrückt?
     * @param {Boolean} ctrl    // Ctrl gedrückt?
     * @returns {undefined}
     */
    _selectEl(el, shift, ctrl) {
        if (!el) {
            return;
        }

        // darf überhaupt selektiert werden?
        switch (this._selectType) {
            case 'single':
                shift = false;
                ctrl = false;
                break;

            case 'singleAndEmpty':
                shift = false;
                ctrl = false;

                // 1. Selektiertes Element ermitteln
                let sel = this.getSelected();
                if (!kijs.isEmpty(sel)) {
                    if (kijs.isArray(sel)) {
                        sel = sel[0];
                    }
                }

                // Falls auf das selektierte Element geklickt wurde: Selektierung entfernen
                if (sel && sel === el) {
                    ctrl = true;
                }
                break;


            case 'multi':
                // nix
                break;

            case 'simple':
                ctrl = true;
                break;

            case 'none':
            default:
                return;
        }

        if (shift && this._lastSelectedEl) {
            // bestehende Selektierung entfernen
            if (!ctrl) {
                this.clearSelections(true);
            }

            // selektieren
            this.selectBetween(this._lastSelectedEl, el);

        } else {
            // bestehende Selektierung entfernen
            if (!ctrl) {
                this.clearSelections(true);
            }

            if (el.selected) {
                this.unSelect(el);
                if (el === this._lastSelectedEl) {
                    this._lastSelectedEl = null;
                }
            } else {
                this.select(el, true);
                this._lastSelectedEl = el;
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onAfterFirstRenderTo(e) {
        this.load();
    }

    #onElementMouseDown(e) {
        if (!this.disabled) {
            this.current = e.raiseElement;
            if (this._focusable) {
                e.raiseElement.focus();
            }

            let isShiftPress = !!e.nodeEvent.shiftKey;
            let isCtrlPress = !!e.nodeEvent.ctrlKey;

            if (kijs.Navigator.isMac) {
                isCtrlPress = !!e.nodeEvent.metaKey;
            }

            this._selectEl(this._currentEl, isShiftPress, isCtrlPress);
        }
    }

    /*#onElementFocus(e) {
        if (!this.disabled) {
            // Element festlegen, welches über die Tabulator-Taste den Fokus erhält
            //this.setFocusableElement(e.raiseElement);
        }
    }*/

    #onKeyDown(e) {
        this.handleKeyDown(e.nodeEvent);
    }

    #onSourceDrop(e) {
        // Source Element
        let sourceEl = e.source.ownerEl;

        // Source dataRow merken, damit beim Ziel wieder eingefügt werden kann
        kijs.gui.DragDrop.data.sourceDataRow = sourceEl.dataRow;

        if (e.source.name === this._ddName && e.operation === 'move') {
            // Zeile aus Source entfernen
            kijs.Array.remove(this._data, sourceEl.dataRow);

            // speichern
            if (this._autoSave && this._rpcSaveFn) {
                // nur speichern, wenn das Target ein anderes Element ist
                // (sonst wird ja beim target bereits gespeichert)
                if (e.target.ownerEl !== this) {
                    this.save();
                }
            }

            // evtl. neu laden
            if (e.target.ownerEl !== this) {
                // rows der selektierten Zeilen ermitteln
                let selectedDataRows = this.getSelectedRows();

                // neu laden
                this._createElements(this._data);

                // und wieder selektieren
                this.selectByDataRows(selectedDataRows, false, true);

                // Current Element ermitteln und setzen
                this.current = null;
            }
        }
    }

    #onTargetDrop(e) {
        if (e.source.name === this._ddName) {
            let targetIndex = null;

            // before oder after
            if (e.target.targetPos === 'before' || e.target.targetPos === 'after') {
                // target index ermitteln
                targetIndex = this._data.indexOf(e.target.targetEl.dataRow);
                if (e.target.targetPos === 'after') {
                    targetIndex++;
                }

                // dataRow bei gewünschtem Index einfügen
                this._data.splice(targetIndex, 0, kijs.gui.DragDrop.data.sourceDataRow);

            // child
            } else if (e.target.targetPos === 'child') {
                this._data.push(kijs.gui.DragDrop.data.sourceDataRow);
                targetIndex = this._data.length -1;
            }

            // rows der selektierten Zeilen ermitteln
            let selectedDataRows = this.getSelectedRows();

            // neu laden
            this._createElements(this._data);

            // und wieder selektieren
            this.selectByDataRows(selectedDataRows, false, true);

            // Current Element ermitteln und setzen
            this.current = null;

            // in sichtbaren Bereich scrollen?
            this._elements[targetIndex].dom.scrollIntoView();

            // speichern
            if (this._autoSave && this._rpcSaveFn) {
                this.save();
            }
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._ddTarget) {
            this._ddTarget.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._currentEl = null;
        this._lastSelectedEl = null;
        this._ddTarget = null;
        this._elementDdSourceConfig = null;
        this._data = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.dataView (namespace)
// --------------------------------------------------------------
kijs.gui.dataView = {};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.dataView.element (namespace)
// --------------------------------------------------------------
kijs.gui.dataView.element = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.dataView.element.Base
// --------------------------------------------------------------
kijs.gui.dataView.element.Base = class kijs_gui_dataView_element_Base extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dataRow = {};     // Verweis auf den Data-Datensatz
        this._dataIndex = null; // Index des Datensatzes im Recordset

        this._selected = false;

        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-dataview-element');
        this._dom.htmlDisplayType = 'html';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            dataIndex: { target: 'dataIndex' },
            dataRow: { target: 'dataRow' },
            selected: { target: 'selected' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Inhalt erstellen
        this.update();
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get dataIndex() { return this._dataIndex; }
    set dataIndex(val) { this._dataIndex = val; }

    get dataRow() { return this._dataRow; }
    set dataRow(val) { this._dataRow = val; }

    get selected() { return this._dom.clsHas('kijs-selected'); }
    set selected(val) {
        if (val) {
            this._dom.clsAdd('kijs-selected');
        } else {
            this._dom.clsRemove('kijs-selected');
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Erstellt den Inhalt
     * Diese Funktion muss überschrieben werden.
     */
    update() {

    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Variablen (Objekte/Arrays) leeren
        this._dataRow = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.dataView.element.AutoHtml
// --------------------------------------------------------------
kijs.gui.dataView.element.AutoHtml = class kijs_gui_dataView_element_AutoHtml extends kijs.gui.dataView.element.Base {


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    update() {
        let html = '';

        html += '<div>';
        html += ' <span class="label">Nr. ' + this.dataIndex + '</span>';
        html += '</div>';

        kijs.Object.each(this._dataRow, function(key, val) {
            html += '<div>';
            html += ' <span class="label">' + key + ': </span>';
            html += ' <span class="value">' + val + '</span>';
            html += '</div>';
        }, this);

        this.html = html;
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.dataView.element.ListView
// --------------------------------------------------------------
kijs.gui.dataView.element.ListView = class kijs_gui_dataView_element_ListView extends kijs.gui.dataView.element.Base {


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    update() {
        let iconArgs = {parent: this};

        // Icon/Cls
        if (!kijs.isEmpty(this.parent.iconClsField) && !kijs.isEmpty(this.dataRow[this.parent.iconClsField])) {
            iconArgs.iconCls = this.dataRow[this.parent.iconClsField];
        }
        if (!kijs.isEmpty(this.parent.iconColorField) && !kijs.isEmpty(this.dataRow[this.parent.iconColorField])) {
            iconArgs.iconColor = this.dataRow[this.parent.iconColorField];
        }
        if (!kijs.isEmpty(this.parent.iconCharField) && !kijs.isEmpty(this.dataRow[this.parent.iconCharField])) {
            iconArgs.iconChar = this.dataRow[this.parent.iconCharField];
        }
        if (!kijs.isEmpty(this.parent.iconMapField) && !kijs.isEmpty(this.dataRow[this.parent.iconMapField])) {
            iconArgs.iconMap = this.dataRow[this.parent.iconMapField];
        }
        
        let iconEl = new kijs.gui.Icon(iconArgs);

        // Caption
        let caption = '';
        if (!kijs.isEmpty(this.parent.captionField) && !kijs.isEmpty(this.dataRow[this.parent.captionField])) {
            caption = this.dataRow[this.parent.captionField];
        }
        let captionEl = new kijs.gui.Element({
            htmlDisplayType: this.parent.captionHtmlDisplayType,
            nodeTagName: 'span',
            html: caption,
            cls: 'kijs-caption'
        });

        // Tooltip
        let tooltip = '';
        if (!kijs.isEmpty(this.parent.tooltipField) && !kijs.isEmpty(this.dataRow[this.parent.tooltipField])) {
            tooltip = this.dataRow[this.parent.tooltipField];
        }

        // Checkbox
        let cls = '';
        if (this.parent.showCheckBoxes) {
            switch (this.parent.selectType) {
                case 'single':
                case 'singleAndEmpty':
                    cls = 'kijs-display-options';
                    break;

                case 'simple':
                case 'multi':
                    cls = 'kijs-display-checkboxes';
                    break;

            }
        }

        this._dom.clsRemove(['kijs-display-options', 'kijs-display-checkboxes']);
        if (cls) {
            this._dom.clsAdd(cls);
        }

        this.tooltip = tooltip;

        this.removeAll();
        this.add([iconEl, captionEl]);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.ListView
// --------------------------------------------------------------
kijs.gui.ListView = class kijs_gui_ListView extends kijs.gui.DataView {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._captionField = null;
        this._captionHtmlDisplayType = 'code';
        this._valueField = null;
        this._iconCharField = null;
        this._iconClsField = null;
        this._iconColorField = null;
        this._iconMapField = null;
        this._tooltipField = null;
        this._showCheckBoxes = false;
        this._value = null;

        this._dom.clsRemove('kijs-dataview');
        this._dom.clsAdd('kijs-listview');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            elementXType: 'kijs.gui.dataView.element.ListView',
            selectType: 'single'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            captionField: true,
            captionHtmlDisplayType: true,
            iconCharField: true,
            iconClsField: true,
            iconColorField: true,
            iconMapField: true,
            showCheckBoxes: true,
            tooltipField: true,
            valueField: true,

            value: { target: 'value' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this.on('afterLoad', this.#onAfterLoad, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get captionHtmlDisplayType() { return this._captionHtmlDisplayType; }    
    set captionHtmlDisplayType(val) { this._captionHtmlDisplayType = val; }
    
    get captionField() { return this._captionField; }
    set captionField(val) { this._captionField = val; }

    get iconCharField() { return this._iconCharField; }
    set iconCharField(val) { this._iconCharField = val; }

    get iconClsField() { return this._iconClsField; }
    set iconClsField(val) { this._iconClsField = val; }

    get iconColorField() { return this._iconColorField; }
    set iconColorField(val) { this._iconColorField = val; }

    get iconMapField() { return this._iconMapField; }
    set iconMapField(val) { this._iconMapField = val; }

    get showCheckBoxes() { return this._showCheckBoxes; }
    set showCheckBoxes(val) { this._showCheckBoxes = val; }

    get tooltipField() { return this._tooltipField; }
    set tooltipField(val) { this._tooltipField = val; }

    get value() {
        let val = null;
        
        if (!kijs.isEmpty(this._data) && this._valueField) {
            let selElements = this.getSelected();
            if (kijs.isArray(selElements)) {
                val = [];
                kijs.Array.each(selElements, function(el) {
                    val.push(el.dataRow[this._valueField]);
                }, this);
            } else if (!kijs.isEmpty(selElements)) {
                val = selElements.dataRow[this._valueField];
            }
            
        } else {
            val = this._value;
            
        }

        return val;
    }
    set value(val) {
        if (kijs.isEmpty(this._valueField)) {
            throw new kijs.Error(`Es wurde kein "valueField" definiert.`);
        }

        this._value = val;

        let filters = [];

        if (kijs.isArray(val)) {
            kijs.Array.each(val, function(v) {
                if (!kijs.isEmpty(v)) {
                    filters.push({
                        field: this._valueField,
                        value: v
                    });
                }
            }, this);
        } else if (!kijs.isEmpty(val)) {
            filters = {
                field: this._valueField,
                value: val
            };
        }
        this.selectByFilters(filters, false, true);
    }

    get valueField() { return this._valueField; }
    set valueField(val) { this._valueField = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PRIVATE
    // LISTENERS
    #onAfterLoad(e) {
        if (!kijs.isEmpty(this._value)) {
            this.value = this._value;
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Variablen (Objekte/Arrays) leeren
        this._value = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.TimePicker
// --------------------------------------------------------------
kijs.gui.TimePicker = class kijs_gui_TimePicker extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._secondsHide = true;
        this._minutesHide = false;
        this._separator = ':';
        this._empty = true,
        this._hour = 0;
        this._minute = 0;
        this._second = 0;

        this._canvas = null;            // canvas context objekt
        this._canvasSize  = null;       // Grösse des Canvas
        this._clockRadius = null;       // Radius der Uhr
        this._clockMode = 1;            // 1=Stunde 2=Minute 3=Sekunde
        this._distance = {
            hourAm: 32,                 // Distanz vom Kreisrand für Stunden 1-12
            hourPm: 12,                 // Distanz vom Kreisrand für Stunden 13-24
            minute: 20,                 // Distanz vom Kreisrand für Minuten
            second: 20                  // Distanz vom Kreisrand für Sekunden
        };

        this._headerBarHide = false;
        this._inputHide = false;
        this._nowBtnHide = false;
        this._emptyBtnHide = false;
        this._closeBtnHide = true;

        this._headerBar = new kijs.gui.PanelBar({
            cls: 'kijs-headerbar-center'
        });

        // inputDiv
        this._inputDivDom = new kijs.gui.Dom({
            cls: 'kijs-timepicker-inputdiv'
        });
        this._inputHourDom = new kijs.gui.Dom({
            cls: 'kijs-timepicker-hour',
            nodeTagName: 'input',
            nodeAttribute: {
                maxLength: 2
            },
            on: {
                change: this.#onInputChange,
                click: this.#onInputClick,
                focus: this.#onInputFocus,
                keyUp: this.#onInputKeyUp,
                context: this
            }
        });
        this._inputSeparator1 = new kijs.gui.Dom({
            nodeTagName: 'span',
            html: this._separator
        });
        this._inputMinuteDom = new kijs.gui.Dom({
            cls: 'kijs-timepicker-minute',
            nodeTagName: 'input',
            nodeAttribute: {
                maxLength: 2
            },
            on: {
                change: this.#onInputChange,
                click: this.#onInputClick,
                focus: this.#onInputFocus,
                keyUp: this.#onInputKeyUp,
                context: this
            }
        });
        this._inputSeparator2 = new kijs.gui.Dom({
            nodeTagName: 'span',
            html: this._separator
        });
        this._inputSecondDom = new kijs.gui.Dom({
            cls: 'kijs-timepicker-second',
            nodeTagName: 'input',
            nodeAttribute: {
                maxLength: 2
            },
            on: {
                change: this.#onInputChange,
                click: this.#onInputClick,
                focus: this.#onInputFocus,
                keyUp: this.#onInputKeyUp,
                context: this
            }
        });

        // canvasDiv
        this._canvasDivDom = new kijs.gui.Dom({
            cls: 'kijs-timepicker-canvasdiv'
        });
        this._canvasDom = new kijs.gui.Dom({
            nodeTagName: 'canvas',
            on: {
                mouseMove: this.#onCanvasMouseMove,
                mouseLeave: this.#onCanvasMouseLeave,
                click: this.#onCanvasMouseClick,
                context: this
            }
        });

        // footerDiv
        this._footerDivDom = new kijs.gui.Dom({ cls: 'kijs-timepicker-footerdiv' });

        // Button Jetzt
        this._nowBtn = new kijs.gui.Button({
            caption: kijs.getText('Jetzt'),
            on: {
                click: this.#onNowBtnClick,
                context: this
            }
        });
        this._nowBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Button Leeren
        this._emptyBtn = new kijs.gui.Button({
            caption: kijs.getText('Leeren'),
            on: {
                click: this.#onEmptyBtnClick,
                context: this
            }
        });
        this._emptyBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Button Schliessen
        this._closeBtn = new kijs.gui.Button({
            caption: kijs.getText('Schliessen')
        });
        this._closeBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._dom.clsAdd('kijs-timepicker');


        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            headerText: kijs.getText('Uhrzeit')
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            headerBarHide: true,                // HeaderBar ausblenden
            inputHide: true,                    // Input-Felder ausblenden
            nowBtnHide: true,                   // Jetzt Button ausblenden
            emptyBtnHide: true,                 // Leer lassen Button ausblenden
            closeBtnHide: true,                 // Schliessen Button ausblenden
            headerText: { target: 'html', context: this._headerBar },
            value: { target: 'value' },
            secondsHide: true,                  // Sekunden auch erfassen?
            minutesHide: true,                  // Minuten auch erfassen?
            separator: true
        });

        // Events weiterleiten
        this._eventForwardsAdd('closeClick', this._closeBtn, 'click');

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Damit nach dem Rendern die Input-Felder auch den Wert enthalten
        this.on('afterRender', this._updateInputFields, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get closeBtnHide() { return this._closeBtnHide; }
    set closeBtnHide(val) { this._closeBtnHide = !!val; }

    get emptyBtnHide() { return this._emptyBtnHide; }
    set emptyBtnHide(val) { this._emptyBtnHide = !!val; }

    get headerBar() { return this._headerBar; }

    get headerBarHide() { return this._headerBarHide; }
    set headerBarHide(val) { this._headerBarHide = !!val; }

    get inputHide() { return this._inputHide; }
    set inputHide(val) { this._inputHide = !!val; }

    get minutesHide() { return this._minutesHide; }
    set minutesHide(val) { this._minutesHide = !!val; }

    get nowBtnHide() { return this._nowBtnHide; }
    set nowBtnHide(val) { this._nowBtnHide = !!val; }

    get secondsHide() { return this._secondsHide; }
    set secondsHide(val) { this._secondsHide = !!val; }

    get value() {
        let val = '';
        if (!this._empty) {
            val += this._zeroPad(this._hour);
            if (!this._minutesHide) {
                val += this._separator + this._zeroPad(this._minute);
            }
            if (!this._secondsHide) {
                val += this._separator + this._zeroPad(this._second);
            }
        }
        return val;
    }

    set value(val) {
        this._empty = kijs.isEmpty(val);
        val = kijs.toString(val);
        val = val.split(this._separator);

        this._hour = val[0] ? parseInt(val[0]) : 0;
        this._minute = val[1] && !this._minutesHide ? parseInt(val[1]) : 0;
        this._second = val[2] && !this._secondsHide ? parseInt(val[2]) : 0;
        this._clockMode = 1;

        if (this._hour === 24) {
            this._hour = 0;
        }
        if (this._minute === 60) {
            this._minute = 0;
        }
        if (this._second === 60) {
            this._second = 0;
        }

        if (this._hour > 23 || this._hour < 0) {
            throw new kijs.Error('invalid time: hour');
        }
        if (this._minute > 60 || this._minute < 0) {
            throw new kijs.Error('invalid time: minute');
        }
        if (this._second > 60 || this._second < 0) {
            throw new kijs.Error('invalid time: second');
        }

        // zeichnen falls gerendert
        if (this._dom.node) {
            this._calculate();
        }

        // Input Felder aktualisieren
        this._updateInputFields();

        return;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        
        this._headerBar.changeDisabled(!!val, true);
        
        this._inputHourDom.changeDisabled(!!val, true);
        this._inputMinuteDom.changeDisabled(!!val, true);
        this._inputSecondDom.changeDisabled(!!val, true);
        
        this._nowBtn.changeDisabled(!!val, true);
        this._emptyBtn.changeDisabled(!!val, true);
        this._closeBtn.changeDisabled(!!val, true);
        
        this._calculate();
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        // HeaderBar rendern
        if (!this._headerBarHide) {
            this._headerBar.renderTo(this._dom.node);
        } else if (this._headerBar.isRendered) {
            this._headerBar.unrender();
        }

        // inputDiv
        if (!this._inputHide) {
            this._inputDivDom.renderTo(this._dom.node);
            this._inputHourDom.renderTo(this._inputDivDom.node);
            if (this._minutesHide) {
                this._inputSeparator1.unrender();
                this._inputMinuteDom.unrender();
            } else {
                this._inputSeparator1.renderTo(this._inputDivDom.node);
                this._inputMinuteDom.renderTo(this._inputDivDom.node);
            }
            if (this._secondsHide) {
                this._inputSeparator2.unrender();
                this._inputSecondDom.unrender();
            } else {
                this._inputSeparator2.renderTo(this._inputDivDom.node);
                this._inputSecondDom.renderTo(this._inputDivDom.node);
            }
        } else {
            this._inputDivDom.unrender();
        }

        // Canvas für timepicker
        this._canvasDivDom.renderTo(this._dom.node);
        this._canvasDom.renderTo(this._canvasDivDom.node);

        // Context
        this._canvas =  this._canvasDom.node.getContext('2d');

        // Footer
        this._footerDivDom.renderTo(this._dom.node);

        // nowBtn, emptyBtn, closeBtn
        if (!this._nowBtnHide) {
            this._nowBtn.renderTo(this._footerDivDom.node);
        } else if (this._nowBtn.isRendered) {
            this._nowBtn.unrender();
        }
        if (!this._emptyBtnHide) {
            this._emptyBtn.renderTo(this._footerDivDom.node);
        } else if (this._emptyBtn.isRendered) {
            this._emptyBtn.unrender();
        }
        if (!this._closeBtnHide) {
            this._closeBtn.renderTo(this._footerDivDom.node);
        } else if (this._closeBtn.isRendered) {
            this._closeBtn.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }

        // canvas zeichnen
        kijs.defer(function() {
            this._calculate();
        }, 10, this);
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        if (this._headerBar) {
            this._headerBar.unrender();
        }
        if (this._inputHourDom) {
            this._inputHourDom.unrender();
        }
        if (this._inputMinuteDom) {
            this._inputMinuteDom.unrender();
        }
        if (this._inputSecondDom) {
            this._inputSecondDom.unrender();
        }
        if (this._inputDivDom) {
            this._inputDivDom.unrender();
        }
        if (this._canvasDom) {
            this._canvasDom.unrender();
        }
        if (this._canvasDivDom) {
            this._canvasDivDom.unrender();
        }
        if (this._footerDivDom) {
            this._footerDivDom.unrender();
        }
        
        super.unrender(true);
    }


    // PROTECTED
    _addTextToArc(text, fontSize, degree, distance) {
        let coords = this._degreeToCoordinates(degree, distance);
        this._canvas.font = fontSize+'px Arial,sans-serif';
        this._canvas.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--clock-fontColor');

        let measure = this._canvas.measureText(text);
        this._canvas.fillText(text, coords.x - (measure.width /2), coords.y + (fontSize / 2));
    }

    _calculate(pointerPos=null) {
        // Grösse einstellen.
        this._canvasSize = Math.min(this._canvasDivDom.width, this._canvasDivDom.height);
        if (this._canvasSize === 0 || !this._canvasDom.node) {
            return;
        }

        this._canvasDom.node.width = this._canvasSize;
        this._canvasDom.node.height = this._canvasSize;
        this._clockRadius = this._canvasSize / 2 - 1;

        // Löschen
        this._canvas.clearRect(0, 0, this._canvasSize, this._canvasSize);

        // Hintergrund
        this._drawBackground();

        // zeiger-pos von Uhrzeit
        if (pointerPos === null && this._clockMode === 1) {
            pointerPos = this._degreeByHour(this._hour);
        }
        if (pointerPos === null && this._clockMode === 2) {
            pointerPos = this._degreeByMinute(this._minute);
        }
        if (pointerPos === null && this._clockMode === 3) {
            pointerPos = this._degreeBySecond(this._second);
        }

        // Zeiger
        this._drawPointer(pointerPos.degree, pointerPos.distance);

        // Stunden
        if (this._clockMode === 1) {
            this._drawHours();
        }
        if (this._clockMode === 2) {
            this._drawMinutes();
        }
        if (this._clockMode === 3) {
            this._drawSeconds();
        }
    }

    _coordinatesToDegree(ox, oy) {
        let x = ox - (this._canvasSize / 2);
        let y = (this._canvasSize / 2) - oy;

        let c = Math.sqrt(Math.pow(y,2) + Math.pow(x,2));
        let distance = this._clockRadius - c;
        let alphaRad =  Math.asin(y/c);
        let degree = 90 - (alphaRad / (Math.PI/180));

        if (ox < (this._canvasSize /2)) {
            degree = (180 - degree) + 180;
        }

        return {degree: degree, distance: distance};
    }

    _degreeByHour(hour) {
        let ret = {degree: 0, distance: 0};
        ret.distance = hour < 13 && hour > 0 ? this._distance.hourAm : this._distance.hourPm;
        if (hour > 11) {
            hour -= 12;
        }
        ret.degree = hour * 30;
        return ret;
    }

    _degreeByMinute(minute) {
        return {degree: minute / 60 * 360, distance: this._distance.minute};
    }

    _degreeBySecond(second) {
        return {degree: second / 60 * 360, distance: this._distance.second};
    }

    _degreeToCoordinates(degree, distance) {
        degree = degree+90;
        // h = c * sinus(degree)
        let a = (this._clockRadius - distance) * Math.sin(degree * ((Math.PI)/180));
        let b = Math.sqrt(Math.pow((this._clockRadius - distance),2) - Math.pow(a,2));

        let x=0,y=0;
        if (degree <= 270) {
            x = (this._canvasSize / 2)+b, y = (this._canvasSize / 2) - a;
        } else {
            x = (this._canvasSize / 2)-b, y = (this._canvasSize / 2) - a;
        }

        return {x: x, y: y};
    }

    _drawBackground() {
        // Kreis für Uhr zeichnen
        this._canvas.beginPath();
        this._canvas.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--clock-bkgrndColor');
        this._canvas.arc(
                (this._canvasSize / 2),
                (this._canvasSize / 2),
                this._clockRadius,
                0,
                Math.PI*2
            );
        this._canvas.fill();
    }

    _drawHours() {
        for (let i=1; i<=24; i++) {
            let dist = i<=12 ? this._distance.hourAm : this._distance.hourPm;
            let deg = i<=12 ? i * 30 : (i*30)-360;
            let size = i<=12 ? 15 : 10;
            let text = i!==24 ? i : '00';
            this._addTextToArc(text, size, deg, dist);
        }
    }

    _drawMinutes() {
        for (let i=0;i<12;i++) {
            let text = i!==0 ? i*5 : '00';
            this._addTextToArc(text, 15, (i*30), this._distance.minute);
        }
    }

    _drawPointer(degree, distance) {
        const cStyle = getComputedStyle(document.documentElement);
        const bkgrndColor = this.disabled
                ? cStyle.getPropertyValue('--clock-disabled-pointer-bkgrndColor')
                : cStyle.getPropertyValue('--clock-pointer-bkgrndColor');
        let coords = this._degreeToCoordinates(degree, distance);
        this._canvas.beginPath();
        this._canvas.strokeStyle = bkgrndColor;
        this._canvas.lineWidth = 2.0;
        this._canvas.moveTo(this._clockRadius, this._clockRadius);
        this._canvas.lineTo(coords.x, coords.y);
        this._canvas.stroke();
        this._canvas.beginPath();
        this._canvas.fillStyle = bkgrndColor;
        this._canvas.arc(coords.x, coords.y, 12, 0, Math.PI*2); // Kreis
        this._canvas.fill();
    }

    _drawSeconds() {
        for (let i=0; i<12; i++) {
            let text = i!==0 ? i*5 : '00';
            this._addTextToArc(text, 15, (i*30), this._distance.second);
        }
    }

    _updateInputFields() {
        if (this._inputHourDom.isRendered) {
            this._inputHourDom.nodeAttributeSet('value', this._empty ? '' : this._zeroPad(this._hour));
        }
        if (this._inputMinuteDom.isRendered) {
            this._inputMinuteDom.nodeAttributeSet('value', this._empty ? '' : this._zeroPad(this._minute));
        }
        if (this._inputSecondDom.isRendered) {
            this._inputSecondDom.nodeAttributeSet('value', this._empty ? '' : this._zeroPad(this._second));
        }
    }

    /**
     * Ergänzt die 0 einer Zahl.
     * @param {Integer|String} number
     * @param {Integer} lenght
     * @returns {String}
     */
    _zeroPad(number, lenght=2) {
        number = kijs.toString(number);
        while (number.length < lenght) {
            number = '0' + number;
        }
        return number;
    }


    // PRIVATE
    // LISTENERS
    /**
     * Beim Klick wird die Uhrzeit übernommen.
     * @param {Object} e
     * @returns {undefined}
     */
    #onCanvasMouseClick(e) {
        if (!this.disabled) {
            const oldValue = this.value;
            let x = e.nodeEvent.layerX, y = e.nodeEvent.layerY;
            let dg = this._coordinatesToDegree(x, y);
            let inputFinished = false;

            // ausserhalb kreis
            if (dg.distance < 0) {
                return;
            }

            // auf 30 grad runden
            dg.degree = Math.round(dg.degree / 30) * 30;

            this._empty = false;

            // Stunde
            if (this._clockMode === 1) {
                let hour = 12 / 360 * dg.degree;
                if (dg.distance < ((this._distance.hourAm+this._distance.hourPm)/2)) {
                    if (hour !== 0) {
                        hour += 12;
                    }
                } else if (hour === 0) {
                    hour += 12;
                }

                this._hour = hour;
                if (this._inputHourDom.isRendered) {
                    if (this._minutesHide) {
                        inputFinished = true;
                        this._inputHourDom.focus();
                    } else {
                        this._inputMinuteDom.focus();
                    }

                } else {
                    if (this._minutesHide) {
                        this._clockMode = 1;
                        inputFinished = true;
                    } else {
                        this._clockMode = 2;
                    }
                }

            // Minute
            } else if (this._clockMode === 2) {
                let min = 60 / 360 * dg.degree;
                this._minute = min === 60 ? 0 : min;
                if (this._inputMinuteDom.isRendered) {
                    if (this._secondsHide) {
                        inputFinished = true;
                        this._inputMinuteDom.focus();
                    } else {
                        this._inputSecondDom.focus();
                    }

                } else {
                    if (this._secondsHide) {
                        inputFinished = true;
                        this._clockMode = 2;
                    } else {
                        this._clockMode = 3;
                    }
                }


            // Sekunde
            } else if (this._clockMode === 3) {
                let sec = 60 / 360 * dg.degree;
                this._second = sec === 60 ? 0 : sec;
                if (this._inputSecondDom.isRendered) {
                    this._inputSecondDom.focus();
                } else {
                    this._clockMode = 3;
                }
                inputFinished = true;
            }

            if (inputFinished) {
                if (this._inputHourDom.isRendered) {
                    this._inputHourDom.focus();
                } else {
                    this._clockMode = 1;
                }
            }

            // Input Felder aktualisieren
            this._updateInputFields();

            // Events
            if (oldValue !== this.value) {
                this.raiseEvent('change', { value: this.value, oldValue: oldValue });
            }
            if (inputFinished) {
                this.raiseEvent('inputFinished');
            }
        }
    }
    
    /**
     * Kelle zurücksetzen
     * @returns {undefined}
     */
    #onCanvasMouseLeave() {
        if (!this.disabled) {
            this._calculate();
        }
    }
    
    /**
     * Beim bewegen der Maus wird die Kelle darunter angezeigt.
     * @param {Object} e
     * @returns {undefined}
     */
    #onCanvasMouseMove(e) {
        if (!this.disabled) {
            let x = e.nodeEvent.layerX, y = e.nodeEvent.layerY, pointerPos = {};
            let dg = this._coordinatesToDegree(x, y);

            // auf 30 grad runden
            pointerPos.degree = Math.round(dg.degree / 30) * 30;

            if (this._clockMode === 1) {
                pointerPos.distance = dg.distance 
                        > ((this._distance.hourAm+this._distance.hourPm)/2) 
                        ? this._distance.hourAm : this._distance.hourPm;

            } else if (this._clockMode === 2) {
                pointerPos.distance = this._distance.minute;

            } else if (this._clockMode ===  3) {
                pointerPos.distance = this._distance.second;

            } else {
                throw new kijs.Error('invalid clock mode');
            }

            this._calculate(pointerPos);
        }
    }

    #onEmptyBtnClick(e) {
        const oldValue = this.value;

        this.value = '';

        // Event
        if (oldValue !== this.value) {
            this.raiseEvent('change', { value: this.value, oldValue: oldValue });
        }
        this.raiseEvent('emptyClick');
    }

    /**
     * Nach dem Ändern Zeit übernehmen
     * @param {Object} e
     * @returns {undefined}
     */
    #onInputChange(e) {
        const oldValue = this.value;
        const fld = e.context;
        let inputFinished = false;

        this._empty = kijs.isEmpty(fld.node.value);
        if (this._empty) {
            this._hour = 0;
            this._minute = 0;
            this._second = 0;
            this._clockMode = 1;
        } else {
            if (fld === this._inputHourDom) {
                this._hour = parseInt(fld.node.value);
                if (this._minutesHide) {
                    inputFinished = true;
                }
            }
            if (fld === this._inputMinuteDom) {
                this._minute = fld.node.value ? parseInt(fld.node.value) : 0;
                if (this._secondsHide) {
                    inputFinished = true;
                }
            }
            if (fld === this._inputSecondDom) {
                this._second = fld.node.value ? parseInt(fld.node.value) : 0;
                inputFinished = true;
            }
        }

        // zeichnen
        this._calculate();

        // Input Felder aktualisieren
        this._updateInputFields();

        // Events
        if (oldValue !== this.value) {
            this.raiseEvent('change', { value: this.value, oldValue: oldValue });
        }
        if (inputFinished) {
            this.raiseEvent('inputFinished');
        }
    }

    /**
     * Beim Klick ins Zeitfeld wird alles selektiert, dass überschrieben werden kann.
     * @param {Object} e
     * @returns {undefined}
     */
    #onInputClick(e) {
        e.context.node.select();
    }

    /**
     * Beim Fokussieren wird die passende Auswahl gezeigt.
     * @param {Object} e
     * @returns {undefined}
     */
    #onInputFocus(e) {
        let fld = e.context;
        if (fld === this._inputHourDom) {
            this._clockMode = 1;
        }
        if (fld === this._inputMinuteDom) {
            this._clockMode = 2;
        }
        if (fld === this._inputSecondDom) {
            this._clockMode = 3;
        }

        // zeichnen
        this._calculate();
    }

    /**
     * Wenn die Uhrzeit mit Tastatur eingegeben wird
     * @param {Object} e
     * @returns {undefined}
     */
    #onInputKeyUp(e) {
        const fld = e.context;
        let type;
        if (fld === this._inputHourDom) {
            type = 'hour';
        }
        if (fld === this._inputMinuteDom) {
            type = 'minute';
        }
        if (fld === this._inputSecondDom) {
            type = 'second';
        }

        // Falsche Zeichen ersetzen
        fld.node.value = fld.node.value.replace(/[^0-9]/, '');

        // Stunden 00 - 23
        if (type === 'hour') {
            // Wenn eine Zahl > 2 eingegeben wurde, 0 padden
            if (fld.node.value.match(/^[3-9]$/)) {
                fld.node.value = '0' + fld.node.value;
            }

            // Wenn zu Grosse zahl eingegeben
            if (fld.node.value.match(/^[0-9]+$/) && parseInt(fld.node.value) > 23) {
                fld.node.value = '00';
            }

        // Minuten/Sekunden 00-59
        } else {
            // Wenn zu Grosse zahl eingegeben
            if (fld.node.value.match(/^[0-9]+$/) && parseInt(fld.node.value) > 59) {
                fld.node.value = '00';
            }
        }

        // wenn eine zahl eingegeben wurde, fokus evtl auf nächstes Feld.
        if (kijs.isString(e.nodeEvent.key) && e.nodeEvent.key.match(/^[0-9]$/)) {
            if (fld.node.value.length === 2) {
                switch (type) {
                    case 'hour':
                        this._inputMinuteDom.focus();
                        this._inputMinuteDom.node.select();
                        break;
                    case 'minute':
                        if (this._inputSecondDom.node) {
                            this._inputSecondDom.focus();
                            this._inputSecondDom.node.select();
                        }
                        break;
                    case 'second':
                        break;
                }
            }

        // ins vordere Feld springen beim Löschen
        } else if (e.nodeEvent.key === 'Backspace' && fld.node.value === '' && (type === 'minute' || type === 'second')) {
            switch (type) {
                case 'minute': this._inputHourDom.focus(); break;
                case 'second': this._inputMinuteDom.focus(); break;
            }
        }
    }

    // Die aktuelle Zeit übernehmen
    #onNowBtnClick(e) {
        const oldValue = this.value;
        let time = new Date();
        this.value =  '' + time.getHours() + this._separator + time.getMinutes() + this._separator + time.getSeconds();

        // Event
        if (oldValue !== this.value) {
            this.raiseEvent('change', { value: this.value, oldValue: oldValue });
        }
        this.raiseEvent('nowClick');
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._headerBar) {
            this._headerBar.destruct();
        }
        if (this._inputHourDom) {
            this._inputHourDom.destruct();
        }
        if (this._inputSeparator1) {
            this._inputSeparator1.destruct();
        }
        if (this._inputMinuteDom) {
            this._inputMinuteDom.destruct();
        }
        if (this._inputSecondDom) {
            this._inputSecondDom.destruct();
        }
        if (this._inputSeparator2) {
            this._inputSeparator2.destruct();
        }
        if (this._inputDivDom) {
            this._inputDivDom.destruct();
        }
        if (this._canvasDom) {
            this._canvasDom.destruct();
        }
        if (this._canvasDivDom) {
            this._canvasDivDom.destruct();
        }
        if (this._footerDivDom) {
            this._footerDivDom.destruct();
        }
        if (this._nowBtn) {
            this._nowBtn.destruct();
        }

        if (this._emptyBtn) {
            this._emptyBtn.destruct();
        }

        if (this._closeBtn) {
            this._closeBtn.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._headerBar = null;
        this._inputHourDom = null;
        this._inputSeparator1 = null;
        this._inputMinuteDom = null;
        this._inputSeparator2 = null;
        this._inputSecondDom = null;
        this._inputDivDom = null;
        this._canvasDom = null;
        this._canvasDivDom = null;
        this._footerDivDom = null;
        this._nowBtn = null;
        this._emptyBtn = null;
        this._closeBtn = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.MonthPicker
// --------------------------------------------------------------
kijs.gui.MonthPicker = class kijs_gui_MonthPicker extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._minDate = null; // Min Value (Date Object mit Datum vom 1. Tag des Monats)
        this._maxDate = null; // Max Value (Date Object mit Datum vom letzten Tag des Monats)
        this._valueFormat = 'Y-m-d';    // Format, mit dem der value ausgeliefert wird
        this._lastDayOfMonthAsValue = false;   // Soll beim Abfragen des Value oder Date der letzte Tag des Monats zurückgegeben werden?

        this._date = null;
        this._startYear = (new Date()).getFullYear() - 1;
        this._yearsCount = 5;
        
        this._headerBarHide = false;
        this._currentBtnHide = false;
        this._emptyBtnHide = false;
        this._closeBtnHide = true;

        // HeaderBar mit Buttons Previous und Next
        this._previousBtn = new kijs.gui.Button({
            iconMap: 'kijs.iconMap.Fa.circle-chevron-left',
            on: {
                click: this.#onPreviousBtnClick,
                context: this
            }
        });
        this._previousBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._nextBtn = new kijs.gui.Button({
            iconMap: 'kijs.iconMap.Fa.circle-chevron-right',
            on: {
                click: this.#onNextBtnClick,
                context: this
            }
        });
        this._nextBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._headerBar = new kijs.gui.PanelBar({
            cls: 'kijs-headerbar-center',
            elementsLeft: [this._previousBtn],
            elementsRight: [this._nextBtn]
        });

        this._yearMonthDivDom = new kijs.gui.Dom({ cls: 'kijs-monthpicker-yearmonthdiv' });

        this._yearDivDom = new kijs.gui.Dom({
            cls: 'kijs-monthpicker-yeardiv',
            on: {
                wheel: this.#onYearDivDomWheel,
                context: this
            }
        });

        this._yearDivInnerDom = new kijs.gui.Dom({ cls: 'kijs-monthpicker-yearinnerdiv' });

        this._monthDivDom = new kijs.gui.Dom({ cls: 'kijs-monthpicker-monthdiv' });

        this._footerDivDom = new kijs.gui.Dom({ cls: 'kijs-monthpicker-footerdiv' });


        // Arrays mit 5 kijs.gui.Dom der Jahre, die angezeigt werden
        this._yearsDom = [];

        // Arrays mit 12 kijs.gui.Dom der Monate, die angezeigt werden
        this._monthsDom = [];

        // Jahre Scroll-Button up
        this._yearsScrollUpBtn = new kijs.gui.Button({
            caption: '▴',
            disableFlex: false,
            on: {
                click: this.#onYearsScrollUpBtnClick,
                context: this
            }
        });
        this._yearsScrollUpBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Jahre Scroll-Button down
        this._yearsScrollDownBtn = new kijs.gui.Button({
            caption: '▾',
            disableFlex: false,
            on: {
                click: this.#onYearsScrollDownBtnClick,
                context: this
            }
        });
        this._yearsScrollDownBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Monate
        this._createMonthsDom();

        // Jahre
        this._createYearsDom();

        // Button Aktueller Monat
        this._currentBtn = new kijs.gui.Button({
            caption: kijs.getText('Akt. Monat'),
            on: {
                click: this.#onCurrentBtnClick,
                context: this
            }
        });
        this._currentBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Button Leeren
        this._emptyBtn = new kijs.gui.Button({
            caption: kijs.getText('Leeren'),
            on: {
                click: this.#onEmptyBtnClick,
                context: this
            }
        });
        this._emptyBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Button Schliessen
        this._closeBtn = new kijs.gui.Button({
            caption: kijs.getText('Schliessen')
        });
        this._closeBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._dom.clsAdd('kijs-monthpicker');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            lastDayOfMonthAsValue: true,       // Soll beim Abfragen des Value oder Date der letzte Tag des Monats zurückgegeben werden?
            valueFormat: true,                  // Format, mit dem der value ausgeliefert wird
            minValue: { target: 'minValue' },   // Kleinster zu wählender Monat     (Date Object oder SQL-String mit einem beliebigen Datum des Monats)
            maxValue: { target: 'maxValue' },   // Grösster zu wählender Monat      (Date Object oder SQL-String mit einem beliebigen Datum des Monats)
            headerBarHide: true,                // HeaderBar ausblenden
            currentBtnHide: true,               // Aktueller Monat Button ausblenden
            emptyBtnHide: true,                 // Leer lassen Button ausblenden
            closeBtnHide: true,                 // Schliessen Button ausblenden
            value: { target: 'value' }          // (Date Object oder SQL-String mit einem beliebigen Datum des Monats)
        });

        // Events weiterleiten
        this._eventForwardsAdd('closeClick', this._closeBtn, 'click');

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get closeBtnHide() { return this._closeBtnHide; }
    set closeBtnHide(val) { this._closeBtnHide = !!val; }

    get currentBtnHide() { return this._currentBtnHide; }
    set currentBtnHide(val) { this._currentBtnHide = !!val; }

    get date() {
        if (kijs.isEmpty(this._date)) {
            return null;
        } else {
            if (this._lastDayOfMonthAsValue) {
                return kijs.Date.getLastOfMonth(this._date);
            } else {
                return kijs.Date.getFirstOfMonth(this._date);
            }
        }
    }
    set date(val) {
        if (kijs.isEmpty(val)) {
            this._date = null;
            this._startYear = (new Date()).getFullYear() - 1;
        } else {
            this._date = kijs.Date.getFirstOfMonth(kijs.Date.create(val));
            this._startYear = (this._date).getFullYear() - 1;
        }
        this._calculate(true);
    }
    
    get emptyBtnHide() { return this._emptyBtnHide; }
    set emptyBtnHide(val) { this._emptyBtnHide = !!val; }

    get headerBar() { return this._headerBar; }

    //get headerBarFormat() { return this._headerBarFormat; }
    //set headerBarFormat(val) { this._headerBarFormat = val; }

    get headerBarHide() { return this._headerBarHide; }
    set headerBarHide(val) { this._headerBarHide = !!val; }

    get lastDayOfMonthAsValue() { return this._lastDayOfMonthAsValue; }
    set lastDayOfMonthAsValue(val) { this._lastDayOfMonthAsValue = !!val; }

    get maxDate() { return this._maxDate; }
    set maxDate(val) {
        this._maxDate = kijs.isEmpty(val) ? null : kijs.Date.getLastOfMonth(kijs.Date.create(val));
    }
    
    get maxValue() {  return kijs.Date.format(this.maxDate, this._valueFormat); }
    set maxValue(val) {
        this.maxDate = val;
    }
    
    get minDate() { return this._minDate; }
    set minDate(val) {
        this._minDate = kijs.isEmpty(val) ? null : kijs.Date.getFirstOfMonth(kijs.Date.create(val));
    }

    get minValue() { return kijs.Date.format(this.minDate, this._valueFormat); }
    set minValue(val) {
        this.minDate = val;
    }

    get value() {
        let date = this.date;
        if (kijs.isEmpty(date)) {
            return '';
        } else {
            return kijs.Date.format(date, this._valueFormat);
        }
    }
    set value(val) {
        this.date = val;
    }

    get valueFormat() { return this._valueFormat; }
    set valueFormat(val) { this._valueFormat = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        
        this._headerBar.changeDisabled(!!val, true);
        
        this._currentBtn.changeDisabled(!!val, true);
        this._emptyBtn.changeDisabled(!!val, true);
        this._closeBtn.changeDisabled(!!val, true);
        
        this._yearsScrollUpBtn.changeDisabled(!!val, true);
        this._yearsScrollDownBtn.changeDisabled(!!val, true);
        
        if (this._yearsDom) {
            kijs.Array.each(this._yearsDom, function(dom) {
                dom.changeDisabled(!!val, true);
            }, this);
        }
        
        if (this._monthsDom) {
            kijs.Array.each(this._monthsDom, function(dom) {
                dom.changeDisabled(!!val, true);
            }, this);
        }
    }
    
    // overwrite
    focus(alsoSetIfNoTabIndex) {
        // Wenn möglich den Fokus auf einen Button setzen
        if (!this._closeBtnHide) {
            return this._closeBtn.focus(true);

        } else if (!this._currentBtnHide) {
            return this._currentBtn.focus(true);

        } else if (!this._emptyBtnHide) {
            return this._emptyBtn.focus(true);

        } else {
            return super.focus(alsoSetIfNoTabIndex);
        }
    }

    // Falls value ausserhalb von minValue oder maxValue ist, wird er auf den nächst möglichen Wert verändert.
    getNextValidDate(value) {
        if (this._minDate && value < this._minDate) {
            value = this._minDate;
        }
        if (this._maxDate && value > this._maxDate) {
            value = this._maxDate;
        }
        return value;
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // HeaderBar rendern
        if (!this._headerBarHide) {
            this._headerBar.renderTo(this._dom.node);
        } else if (this._headerBar.isRendered) {
            this._headerBar.unrender();
        }

        // DIV's rendern
        this._yearMonthDivDom.renderTo(this._dom.node);
        this._monthDivDom.renderTo(this._yearMonthDivDom.node);
        this._yearDivDom.renderTo(this._yearMonthDivDom.node);
        this._footerDivDom.renderTo(this._dom.node);

        // Scroll Buttons und inneres DIV rendern
        this._yearsScrollUpBtn.renderTo(this._yearDivDom.node);
        this._yearDivInnerDom.renderTo(this._yearDivDom.node);
        this._yearsScrollDownBtn.renderTo(this._yearDivDom.node);

        // Rendert die 12 Monate kijs.gui.Dom
        for (let i=0; i<12; i++) {
            this._monthsDom[i].renderTo(this._monthDivDom.node);
        }

        // Rendert die 5 Jahres kijs.gui.Dom
        for (let i=0; i<this._yearsCount; i++) {
            this._yearsDom[i].renderTo(this._yearDivInnerDom.node);
        }

        this._calculate(true);

        // currentBtn, emptyBtn, closeBtn
        if (!this._currentBtnHide) {
            this._currentBtn.renderTo(this._footerDivDom.node);
        } else if (this._currentBtn.isRendered) {
            this._currentBtn.unrender();
        }
        if (!this._emptyBtnHide) {
            this._emptyBtn.renderTo(this._footerDivDom.node);
        } else if (this._emptyBtn.isRendered) {
            this._emptyBtn.unrender();
        }
        if (!this._closeBtnHide) {
            this._closeBtn.renderTo(this._footerDivDom.node);
        } else if (this._closeBtn.isRendered) {
            this._closeBtn.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }
    
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._headerBar) {
            this._headerBar.unrender();
        }
        if (this._yearMonthDivDom) {
            this._yearMonthDivDom.unrender();
        }
        if (this._footerDivDom) {
            this._footerDivDom.unrender();
        }

        super.unrender(true);
    }


    // PROTECTED
    _calculate(scrollIntoView) {
        if (!this.isRendered) {
            return;
        }

        if (scrollIntoView) {
            if (kijs.isEmpty(this._date)) {
                this._startYear = (new Date()).getFullYear() - 1;
            } else {
                this._startYear = this._date.getFullYear() - 1;
            }
        }

        const curMonthIndex = kijs.isEmpty(this._date) ? null : this._date.getMonth();
        const curYear = kijs.isEmpty(this._date) ? (new Date()).getFullYear() : this._date.getFullYear();
        const curYearIndex = curYear - this._startYear;

        // Monate aktualisieren
        for (let i=0; i<12; i++) {
            let date = new Date(curYear, i, 1);

            // selected
            if (!kijs.isEmpty(this._date) && i === curMonthIndex) {
                this._monthsDom[i].clsAdd('kijs-selected');
            } else {
                this._monthsDom[i].clsRemove('kijs-selected');
            }

            // disabled
            this._monthsDom[i].disabled = (this._minDate && this._minDate > date) 
                    || (this._maxDate && this._maxDate < date);
        }

        // Jahre aktualisieren
        for (let i=0; i<this._yearsCount; i++) {
            let year = this._startYear + i;

            // html
            this._yearsDom[i].html = year;

            // selected
            if (i === curYearIndex) {
                this._yearsDom[i].clsAdd('kijs-selected');
            } else {
                this._yearsDom[i].clsRemove('kijs-selected');
            }

            // disabled
            this._yearsDom[i].disabled = (this._minDate && this._minDate.getFullYear() > year) 
                    || (this._maxDate && this._maxDate.getFullYear() < year);
        }

        if (!this._headerBarHide) {
            if (kijs.isEmpty(this._date)) {
                this._headerBar.html = '';
            } else {
                this._headerBar.html = this._date.toLocaleDateString(kijs.language, {
                    month: 'long',
                    year: 'numeric'
                });
            }
        }
    }

    // Erstellt die 12 Monate kijs.gui.Dom
    _createMonthsDom() {
        for (let i=0; i<12; i++) {
            this._monthsDom.push(new kijs.gui.Dom({
                html: kijs.Date.getMonthName(new Date(2000, i, 1), 'short'),
                on: {
                    click: this.#onMonthDomClick,
                    dblClick: this.#onMonthDomDblClick,
                    context: this
                }
            }));
        }
    }

    // Erstellt die 5 Jahres kijs.gui.Dom beginnend bei startYear
    _createYearsDom() {
        for (let i=0; i<this._yearsCount; i++) {
            this._yearsDom.push(new kijs.gui.Dom({
                html: this._startYear + i,
                on: {
                    click: this.#onYearDomClick,
                    dblClick: this.#onYearDomDblClick,
                    context: this
                }
            }));
        }
    }


    // PRIVATE
    // LISTENERS
    #onCurrentBtnClick(e) {
        const oldDate = this.date;
        const oldValue = this.value;
        
        let date = kijs.Date.getFirstOfMonth(new Date());

        this._date = this.getNextValidDate(date);
        this._calculate(true);

        if (!kijs.Date.compare(this.date, oldDate)) {
            this.raiseEvent('change', { 
                value: this.value,
                oldValue: oldValue,
                date: this.date,
                oldDate: oldDate
            });
        }
        this.raiseEvent('currentClick');
    }

    #onEmptyBtnClick(e) {
        const oldDate = this.date;
        const oldValue = this.value;
        
        this._date = null;
        this._calculate(true);

        if (!kijs.Date.compare(this.date, oldDate)) {
            this.raiseEvent('change', { 
                value: this.value,
                oldValue: oldValue,
                date: this.date,
                oldDate: oldDate
            });
        }
        this.raiseEvent('emptyClick');
    }

    #onMonthDomClick(e) {
        if (!e.dom.disabled) {
            const oldDate = this.date;
            const oldValue = this.value;
            const monthIndex = this._monthsDom.indexOf(e.dom);
            let date = null;

            if (kijs.isEmpty(this._date)) {
                date = new Date((new Date()).getFullYear(), monthIndex, 1);
            } else {
                date = kijs.Date.clone(this._date);
                date.setMonth(monthIndex);   // 0=Jan, 1=Feb, ...
            }

            this._date = this.getNextValidDate(date);
            this._calculate(true);

            if (!kijs.Date.compare(this.date, oldDate)) {
                this.raiseEvent('change', {
                    value: this.value,
                    oldValue: oldValue,
                    date: this.date,
                    oldDate: oldDate
                });
            }
            this.raiseEvent('monthClick');
        }
    }
    #onMonthDomDblClick(e) {
        if (!this.disabled) {
            this.raiseEvent('monthDblClick');
        }
    }

    #onNextBtnClick(e) {
        const oldDate = this.date;
        const oldValue = this.value;
        let date = null;

        if (kijs.isEmpty(this._date)) {
            date = kijs.Date.getFirstOfMonth(new Date());
        } else {
            date = kijs.Date.addMonths(this._date, 1);
        }

        this._date = this.getNextValidDate(date);
        this._calculate(true);

        if (!kijs.Date.compare(this.date, oldDate)) {
            this.raiseEvent('change', {
                value: this.value,
                oldValue: oldValue,
                date: this.date,
                oldDate: oldDate
            });
        }
    }

    #onPreviousBtnClick(e) {
        const oldDate = this.date;
        const oldValue = this.value;
        let date = null;

        if (kijs.isEmpty(this._date)) {
            date = kijs.Date.getFirstOfMonth(new Date());
        } else {
            date = kijs.Date.addMonths(this._date, -1);
        }

        this._date = this.getNextValidDate(date);
        this._calculate(true);

        if (!kijs.Date.compare(this.date, oldDate)) {
            this.raiseEvent('change', {
                value: this.value,
                oldValue: oldValue,
                date: this.date,
                oldDate: oldDate
            });
        }
    }

    #onYearDivDomWheel(e) {
        if (!this.disabled) {
            if (e.nodeEvent.deltaY < 0) {
                this.#onYearsScrollUpBtnClick();
            } else {
                this.#onYearsScrollDownBtnClick();
            }
        }
        e.nodeEvent.preventDefault();
    }

    #onYearDomClick(e) {
        if (!e.dom.disabled) {
            const oldDate = this.date;
            const oldValue = this.value;
            const year = parseInt(e.dom.html);
            let date = null;

            if (kijs.isEmpty(this._date)) {
                date = new Date(year, (new Date()).getMonth(), 1);
            } else {
                date = kijs.Date.clone(this._date);
                date.setYear(year);
            }

            this._date = this.getNextValidDate(date);
            this._calculate(true);

            if (!kijs.Date.compare(this.date, oldDate)) {
                this.raiseEvent('change', {
                    value: this.value,
                    oldValue: oldValue,
                    date: this.date,
                    oldDate: oldDate
                });
            }
            this.raiseEvent('yearClick');
        }
    }
    #onYearDomDblClick(e) {
        if (!this.disabled) {
            this.raiseEvent('yearDblClick');
        }
    }

    #onYearsScrollDownBtnClick(e) {
        this._startYear++;
        this._calculate(false);
    }

    #onYearsScrollUpBtnClick(e) {
        this._startYear--;
        this._calculate(false);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._yearsDom && this._yearsDom.length) {
            kijs.Array.each(this._yearsDom, function(dom) {
                dom.destruct();
            }, this);
        }

        if (this._monthsDom && this._monthsDom.length) {
            kijs.Array.each(this._monthsDom, function(dom) {
                dom.destruct();
            }, this);
        }

        if (this._currentBtn) {
            this._currentBtn.destruct();
        }

        if (this._emptyBtn) {
            this._emptyBtn.destruct();
        }

        if (this._closeBtn) {
            this._closeBtn.destruct();
        }

        if (this._yearsScrollUpBtn) {
            this._yearsScrollUpBtn.destruct();
        }

        if (this._yearsScrollDownBtn) {
            this._yearsScrollDownBtn.destruct();
        }

        if (this._headerBar) {
            this._headerBar.destruct();
        }

        if (this._yearDivInnerDom) {
            this._yearDivInnerDom.destruct();
        }
        if (this._yearDivDom) {
            this._yearDivDom.destruct();
        }

        if (this._monthDivDom) {
            this._monthDivDom.destruct();
        }
        if (this._yearMonthDivDom) {
            this._yearMonthDivDom.destruct();
        }

        if (this._footerDivDom) {
            this._footerDivDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._minDate = null;
        this._maxDate = null;
        this._date = null;

        this._previousBtn = null;
        this._nextBtn = null;
        this._headerBar = null;
        this._currentBtn = null;
        this._emptyBtn = null;
        this._closeBtn = null;
        this._yearsScrollUpBtn = null;
        this._yearsScrollDownBtn = null;

        this._yearsDom = null;
        this._monthsDom = null;
        this._yearDivInnerDom = null;
        this._yearDivDom = null;
        this._monthDivDom = null;
        this._yearMonthDivDom = null;
        this._footerDivDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.DatePicker
// --------------------------------------------------------------
kijs.gui.DatePicker = class kijs_gui_DatePicker extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        this._weeksCount = 6; // Wir zeigen fix 6 Wochen an

        this._minDate = null; // Min Value (Date Object)
        this._maxDate = null; // Max Value (Date Object)
        this._weekNumbersHide = false;  // Wochennummern ausblenden?
        this._startWeekday = 1;         // Erster Tag in der Ansicht (1=Montag)
                                        // TODO: Falls mal ein anderer Tag als der Montag verwendet werden soll,
                                        // geht das im Moment nicht, weil noch die Funktion kijs.Date.getMonday()
                                        // verwendet wird. Diese berücksichtigt die Einstellung hier nicht.

        this._valueFormat = 'Y-m-d';    // Format, mit dem der value ausgeliefert wird

        this._mode = 'date';             // Modus: 'date', 'week' oder 'range'

        this._date = null;              // Aktueller Wert (Bei mode 'week' und 'range' ist es das Startdatum)
        this._dateEnd = null;           // Enddatum des aktuellen Werts (nur bei Mode 'week' und 'range', sonst null

        this._headerBarHide = false;
        this._todayBtnHide = false;
        this._emptyBtnHide = false;
        this._closeBtnHide = true;

        // HeaderBar mit Buttons Previous und Next
        this._previousBtn = new kijs.gui.Button({
            iconMap: 'kijs.iconMap.Fa.circle-chevron-left',
            on: {
                click: this.#onPreviousBtnClick,
                context: this
            }
        });
        this._previousBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._nextBtn = new kijs.gui.Button({
            iconMap: 'kijs.iconMap.Fa.circle-chevron-right',
            on: {
                click: this.#onNextBtnClick,
                context: this
            }
        });
        this._nextBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._headerBar = new kijs.gui.PanelBar({
            cls: 'kijs-headerbar-center',
            elementsLeft: [this._previousBtn],
            elementsRight: [this._nextBtn],
            on: {
                click: this.#onHeaderBarClick,
                context: this
            }
        });

        this._calendarDivDom = new kijs.gui.Dom({ cls: 'kijs-datepicker-calendardiv' });
        this._calendarWeekHeadersDivDom = new kijs.gui.Dom({ cls: 'kijs-datepicker-weakheadersdiv' });

        this._footerDivDom = new kijs.gui.Dom({ cls: 'kijs-datepicker-footerdiv' });


        // Array mit den 7 Zeilen (1 x Spaltenüberschrift + 6 x Wochenzeile)
        this._rowsDom = [];

        // Array mit den einzelnen Items (Spaltenüberschriften, Wochennummer und einzelne Tage)
        this._itemsDom = [];

        // MonthPicker
        this._monthPicker = new kijs.gui.MonthPicker({
            headerBarHide: true,
            currentBtnHide: false,
            emptyBtnHide: true,
            closeBtnHide: false,
            value: new Date(),
            on: {
                change: this.#onMonthPickerChange,
                monthClick: this.#onMonthPickerMonthClick,
                closeClick: this.#onMonthPickerCloseClick,
                currentClick: this.#onMonthPickerCurrentClick,
                context: this
            }
        });

        // Spinbox mit MonthPicker
        this._spinBoxEl = new kijs.gui.SpinBox({
            target: this._headerBar,
            //offsetX: -1,
            autoSize: 'none',
            targetDomProperty: 'dom',
            ownerNodes: [this._headerBar.dom],
            cls: ['kijs-borderless'],
            parent: this
        });
        this._spinBoxEl.add(this._monthPicker);

        // Button Heute
        this._todayBtn = new kijs.gui.Button({
            caption: kijs.getText('Heute'),
            on: {
                click: this.#onTodayBtnClick,
                context: this
            }
        });
        this._todayBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Button Leeren
        this._emptyBtn = new kijs.gui.Button({
            caption: kijs.getText('Leeren'),
            on: {
                click: this.#onEmptyBtnClick,
                context: this
            }
        });
        this._emptyBtn.dom.nodeAttributeSet('tabIndex', -1);

        // Button Schliessen
        this._closeBtn = new kijs.gui.Button({
            caption: kijs.getText('Schliessen')
        });
        this._closeBtn.dom.nodeAttributeSet('tabIndex', -1);

        this._dom.clsAdd('kijs-datepicker');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            mode: true,                         // Modus: 'date', 'week' oder 'range'
            weekNumbersHide: true,              // Wochennummern ausblenden?
            valueFormat: true,                  // Format, mit dem der value ausgeliefert wird
            minValue: { target: 'minValue' },   // Kleinster zu wählender Wert     (Date Object oder SQL-String mit einem beliebigen Datum des Monats)
            maxValue: { target: 'maxValue' },   // Grösster zu wählender Wert      (Date Object oder SQL-String mit einem beliebigen Datum des Monats)
            headerBarHide: true,                // HeaderBar ausblenden
            todayBtnHide: true,                 // Heute Button ausblenden
            emptyBtnHide: true,                 // Leer lassen Button ausblenden
            closeBtnHide: true,                 // Schliessen Button ausblenden
            date: { target: 'date' },           // Date Object
            dateEnd: { target: 'dateEnd' },     // Date Object
            value: { target: 'value' },         // SQL-String
            valueEnd: { target: 'valueEnd' }    // SQL-String
        });

        // Events weiterleiten
        this._eventForwardsAdd('closeClick', this._closeBtn, 'click');

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get closeBtnHide() { return this._closeBtnHide; }
    set closeBtnHide(val) { this._closeBtnHide = !!val; }

    get date() {
        if (kijs.isEmpty(this._date)) {
            // Falls es ein End-Datum gibt dieses nehmen
            if (!kijs.isEmpty(this._dateEnd)) {
                return kijs.Date.clone(this._dateEnd);
            } else {
                return null;
            }
        } else {
            // Sicherstellen, dass das Enddatum hinter dem Startdatum liegt
            if (!kijs.isEmpty(this._dateEnd) && this._dateEnd < this._date) {
                return kijs.Date.clone(this._dateEnd);
            } else {
                return kijs.Date.clone(this._date);
            }
        }
    }
    set date(val) {
        if (kijs.isEmpty(val)) {
            this._date = null;
            this._monthPicker.date = new Date();
        } else {
            this._date = kijs.Date.getDatePart(kijs.Date.create(val));
            if (this._mode === 'week') {
                // Sicherstellen, dass die Woche mit dem Montag beginnt
                if (this._date.getDay() !== 1) {
                    this._date = kijs.Date.getMonday(this._date);
                }
                // Enddatum auch gleich setzen
                this._dateEnd = kijs.Date.addDays(this._date, 6);
            }
            this._monthPicker.date = this._date;
        }
        this._calculate();
    }

    get dateEnd() {
        if (kijs.isEmpty(this._dateEnd)) {
            return null;

        // Falls es kein Startdatum gibt, das Enddatum nicht zurückgeben (es wird als Startdatum zurückgegeben)
        } else if (kijs.isEmpty(this._date)) {
                return null;

        // Sicherstellen, dass das Enddatum hinter dem Startdatum liegt
        } else if (this._dateEnd < this._date) {
            return kijs.Date.clone(this._date);

        } else {
            return kijs.Date.clone(this._dateEnd);
        }
    }
    set dateEnd(val) {
        if (kijs.isEmpty(val)) {
            this._dateEnd = null;
        } else {
            this._dateEnd = kijs.Date.getDatePart(kijs.Date.create(val));
        }
        this._calculate();
    }
    
    get emptyBtnHide() { return this._emptyBtnHide; }
    set emptyBtnHide(val) { this._emptyBtnHide = !!val; }

    get headerBarHide() { return this._headerBarHide; }
    set headerBarHide(val) { this._headerBarHide = !!val; }

    get headerBar() { return this._headerBar; }

    get maxDate() {
        return this._maxDate;
    }
    set maxDate(val) {
        this._maxDate = kijs.isEmpty(val) ? null : kijs.Date.create(val);
    }
    
    get maxValue() {
        return kijs.Date.format(this.maxDate, this._valueFormat);
    }
    set maxValue(val) {
        this.maxDate = val;
    }

    get minDate() {
        return this._minDate;
    }
    set minDate(val) {
        this._minDate = kijs.isEmpty(val) ? null : kijs.Date.create(val);
    }

    get minValue() {
        return kijs.Date.format(this.minDate, this._valueFormat);
    }
    set minValue(val) {
        this.minDate = val;
    }

    get mode() {
        return this._mode;
    }
    set mode(val) {
        this._mode = val;
        this._calculate();
    }

    get todayBtnHide() { return this._todayBtnHide; }
    set todayBtnHide(val) { this._todayBtnHide = !!val; }

    get value() {
        if (kijs.isEmpty(this._date)) {
            return '';
        } else {
            return kijs.Date.format(this._date, this._valueFormat);
        }
    }
    set value(val) {
        this.date = val;
    }

    get valueEnd() {
        if (kijs.isEmpty(this._dateEnd)) {
            return '';
        } else {
            return kijs.Date.format(this._dateEnd, this._valueFormat);
        }
    }
    set valueEnd(val) {
        this.dateEnd = val;
    }

    get valueFormat() { return this._valueFormat; }
    set valueFormat(val) { this._valueFormat = val; }

    get weekNumbersHide() { return this._weekNumbersHide; }
    set weekNumbersHide(val) { this._weekNumbersHide = !!val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        
        this._headerBar.changeDisabled(!!val, true);
        this._monthPicker.changeDisabled(!!val, true);
        
        this._todayBtn.changeDisabled(!!val, true);
        this._emptyBtn.changeDisabled(!!val, true);
        this._closeBtn.changeDisabled(!!val, true);
        
        if (this._itemsDom) {
            kijs.Array.each(this._itemsDom, function(dom) {
                dom.changeDisabled(!!val, true);
            }, this);
        }
    }
    
    // Falls value ausserhalb von minValue oder maxValue ist, wird er auf den nächst möglichen Wert verändert.
    getNextValidDate(value) {
        if (this._minDate && value < this._minDate) {
            value = this._minDate;
        }
        if (this._maxDate && value > this._maxDate) {
            value = this._maxDate;
        }
        return value;
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // HeaderBar rendern
        if (!this._headerBarHide) {
            this._headerBar.renderTo(this._dom.node);
        } else if (this._headerBar.isRendered) {
            this._headerBar.unrender();
        }

        // DIV's rendern
        this._calendarDivDom.renderTo(this._dom.node);
        this._footerDivDom.renderTo(this._dom.node);

        // Zeilen rendern
        this._renderRowsDom();

        // Items rendern
        this._renderItemsDom();

        // Items berechnen
        this._calculate();

        // todayBtn, emptyBtn, closeBtn
        if (!this._todayBtnHide) {
            this._todayBtn.renderTo(this._footerDivDom.node);
        } else {
            this._todayBtn.unrender();
        }
        if (!this._emptyBtnHide) {
            this._emptyBtn.renderTo(this._footerDivDom.node);
        } else {
            this._emptyBtn.unrender();
        }
        if (!this._closeBtnHide) {
            this._closeBtn.renderTo(this._footerDivDom.node);
        } else {
            this._closeBtn.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        
        if (this._headerBar) {
            this._headerBar.unrender();
        }
        if (this._calendarDivDom) {
            this._calendarDivDom.unrender();
        }
        if (this._todayBtn) {
            this._todayBtn.unrender();
        }
        if (this._emptyBtn) {
            this._emptyBtn.unrender();
        }
        if (this._closeBtn) {
            this._closeBtn.unrender();
        }
        if (this._footerDivDom) {
            this._footerDivDom.unrender();
        }
        if (this._spinBoxEl) {
            this._spinBoxEl.unrender();
        }

        super.unrender(true);
    }


    // PROTECTED
    _calculate(tmpRangeEndDate = null) {
        if (!this.isRendered) {
            return;
        }

        // Sicherstellen, dass die Daten stimmen
        this._checkValueOrder();

        // Range ermitteln
        let rangeStartDate = this._date;
        let rangeEndDate = this._dateEnd;

        // Falls im Range-Modus nur das Startdatum vorhanden ist, als temporäres Enddatum das Datum unter dem Mauszeiger nehmen
        if (this._mode === 'range' && kijs.isEmpty(this._dateEnd)) {
            rangeEndDate = tmpRangeEndDate;
        }

        // Falls kein Enddatum vorhanden ist, nehmen wir das Startdatum auch als Enddatum
        if (kijs.isEmpty(rangeEndDate)) {
            rangeEndDate = rangeStartDate;
        }

        // Sicherstellen, dass das Enddatum hinter dem Startdatum liegt
        if (rangeEndDate < rangeStartDate) {
            let tmp = rangeStartDate;
            rangeStartDate = rangeEndDate;
            rangeEndDate = tmp;
            tmp = null;
        }

        const today = kijs.Date.getDatePart(new Date());
        const curMonthIndex = this._monthPicker.date.getMonth();
        const firstOfMonth = kijs.Date.getFirstOfMonth(this._monthPicker.date);
        const lastOfMonth = kijs.Date.getLastOfMonth(this._monthPicker.date);
        const monthDaysCount = lastOfMonth.getDate();
        const firstOfMonthWeekday = firstOfMonth.getDay();
        let firstOfCalendar;
        let offset, date;
        let index = 0;

        // Erster Tag im Kalender ermitteln
        firstOfCalendar = kijs.Date.clone(firstOfMonth);
        offset = firstOfMonthWeekday - this._startWeekday;
        if (offset < 0) {
            offset += 7;
        }
        firstOfCalendar = kijs.Date.addDays(firstOfCalendar, offset*-1);
        // falls im Kalender gar keine Tage des Vormonats angezeigt werden, fügen wir noch die letzte Woche des Vormonats hinzu.
        if (kijs.Date.compare(firstOfCalendar, firstOfMonth)) {
            firstOfCalendar = kijs.Date.addDays(firstOfCalendar, -7);
        }

        date = firstOfCalendar;


        // Spaltenüberschriften
        // Evtl. leere Wochennummer
        if (!this._weekNumbersHide) {
            const dom = this._itemsDom[index];
            dom.clsAdd('kijs-none');
            dom.html = '';
            index++;
        }
        // (Mo-So)
        for (let i=0; i<7; i++) {
            const dom = this._itemsDom[index];

            let weekDay = this._startWeekday + i;
            if (weekDay > 6) {
                weekDay -= 7;
            }


            dom.clsAdd('kijs-head');
            // Weekend?
            if (weekDay === 0 || weekDay === 6) {
                dom.clsAdd('kijs-weekend');
            } else {
                dom.clsRemove('kijs-weekend');
            }
            dom.html = kijs.Date.getWeekday(new Date(2001, 0, weekDay), 'narrow');
            index++;
        }

        // Wochen durchgehen
        for (let week=0; week<this._weeksCount; week++) {
            // Evtl. Wochennummer
            if (!this._weekNumbersHide) {
                const dom = this._itemsDom[index];
                dom.clsAdd('kijs-weekno');
                dom.html = parseInt(kijs.Date.format(date, 'W'));
                index++;
            }

            // und die Tage der Woche (Mo-So)
            for (let i=0; i<7; i++) {
                const dom = this._itemsDom[index];
                dom.clsAdd('kijs-day');
                dom.html = date.getDate();
                dom.date = kijs.Date.clone(date);

                // Weekend?
                if (date.getDay() === 0 || date.getDay() === 6) {
                    dom.clsAdd('kijs-weekend');
                } else {
                    dom.clsRemove('kijs-weekend');
                }

                // Tag ausserhalb vom Monat?
                if (date.getMonth() !== curMonthIndex) {
                    dom.clsAdd('kijs-outofmonth');
                } else {
                    dom.clsRemove('kijs-outofmonth');
                }

                // aktueller Tag?
                if (kijs.Date.compare(date, today)) {
                    dom.clsAdd('kijs-today');
                } else {
                    dom.clsRemove('kijs-today');
                }

                // disabled
                dom.disabled = (this._minDate && this._minDate > date) 
                        || (this._maxDate && this._maxDate < date);

                // Nur ein einzelnes Datum selektieren?
                if (kijs.Date.compare(rangeStartDate, rangeEndDate)) {
                    if (kijs.Date.compare(date, rangeStartDate)) {
                        dom.clsAdd('kijs-value');
                    } else {
                        dom.clsRemove('kijs-value');
                    }

                    dom.clsRemove('kijs-range');
                    dom.clsRemove('kijs-rangestart');
                    dom.clsRemove('kijs-rangeend');

                // Range selektieren
                } else {
                    // Liegt das Datum innerhalb des aktuellen Ranges?
                    if (!kijs.isEmpty(rangeStartDate) && rangeStartDate <= date && date <= rangeEndDate) {
                        dom.clsAdd('kijs-range');
                    } else {
                        dom.clsRemove('kijs-range');
                    }

                    // Stimmt das Datum mit dem Startdatum des Ranges überein?
                    if (kijs.Date.compare(date, rangeStartDate)) {
                        dom.clsAdd('kijs-rangestart');
                    } else {
                        dom.clsRemove('kijs-rangestart');
                    }

                    // Stimmt das Datum mit dem Enddatum des Ranges überein?
                    if (kijs.Date.compare(date, rangeEndDate)) {
                        dom.clsAdd('kijs-rangeend');
                    } else {
                        dom.clsRemove('kijs-rangeend');
                    }

                    dom.clsRemove('kijs-value');
                }

                index++;
                date = kijs.Date.addDays(date, 1);
            }

        }

        // Monat und Jahr in HeaderBar schreiben
        if (!this._headerBarHide) {
            if (kijs.isEmpty(this._monthPicker.date)) {
                this._headerBar.html = '';
            } else {
                this._headerBar.html = this._monthPicker.date.toLocaleDateString(kijs.language, {
                    month: 'long',
                    year: 'numeric'
                });
            }
        }
    }

    // Stellt sicher, dass das Enddatum hinter dem Startdatum liegt
    _checkValueOrder() {
        if (this._mode === 'date') {
            this._dateEnd = null;

        } else if (this._mode === 'week') {
            if (!kijs.isEmpty(this._date)) {

                // Sicherstellen, dass die Woche mit dem Montag beginnt
                if (this._date.getDay() !== 1) {
                    this._date = kijs.Date.getMonday(this._date);
                }
                // Enddatum
                this._dateEnd = kijs.Date.addDays(this._date, 6);
            }


        } else if (this._mode === 'range') {
            // Falls nur ein Enddatum vorhanden ist, nehmen wir das als Startdatum
            if (!kijs.isEmpty(this._dateEnd)) {
                if (kijs.isEmpty(this._date)) {
                    this._date = this._dateEnd;
                    this._dateEnd = null;

                // Falls Start- und Enddatum vorhanden sind, die Reihenfolge checken
                } else {
                    if (this._dateEnd < this._date) {
                        let tmp = this._dateEnd;
                        this._dateEnd = this._date;
                        this._date = tmp;
                    }
                }
            }
        }
    }

    // Erstellt die Kalender Items als kijs.gui.Dom
    _createItemsDom() {
        const rowsCount = this._weeksCount + 1;   // Anzahl Wochen + Spaltenheader
        const itemsCount = rowsCount * (this._weekNumbersHide ? 7 : 8);

        // Falls es schon items gibt: destruct
        if (this._itemsDom) {
            kijs.Array.each(this._itemsDom, function(dom) {
                dom.destruct();
            }, this);
            kijs.Array.clear(this._itemsDom);
        }

        // Items erstellen
        for (let i=0; i<itemsCount; i++) {
            const itm = new kijs.gui.Dom({
                on: {
                    click: this.#onItemDomClick,
                    dblClick: this.#onItemDomDblClick,
                    context: this
                }
            });
            itm.on('mouseEnter', this.#onItemDomMouseEnter, this);
            this._itemsDom.push(itm);
        }
    }

    // Spaltenüberschrift + 6 Zeilen erstellen
    _createRowsDom() {
        const count = this._weeksCount + 1;

        // Falls es schon rows gibt: destruct
        if (this._rowsDom) {
            kijs.Array.each(this._rowsDom, function(dom) {
                dom.destruct();
            }, this);
            kijs.Array.clear(this._rowsDom);
        }

        // Rows erstellen
        for (let i=0; i<count; i++) {
            this._rowsDom.push(new kijs.gui.Dom());
        }
    }

    // Rendert die 12 Monate kijs.gui.Dom
    _renderItemsDom() {
        const rowsCount = this._weeksCount + 1;   // Anzahl Wochen + Spaltenheader
        const itemsPerRow = this._weekNumbersHide ? 7 : 8;
        const itemsCount = rowsCount * itemsPerRow;
        const curItemsCount = this._itemsDom.length;

        if (curItemsCount !== itemsCount) {
            this._createItemsDom();
        }

        for (let i=0; i<itemsCount; i++) {
            let rowIndex = Math.floor(i / itemsPerRow);
            this._itemsDom[i].renderTo(this._rowsDom[rowIndex].node);
        }
    }

    // Rendert die Zeilen
    _renderRowsDom() {
        const rowsCount = this._weeksCount + 1;   // Anzahl Wochen + Spaltenheader
        const curRowsCount = this._rowsDom.length;

        if (curRowsCount !== rowsCount) {
            this._createRowsDom();
        }

        for (let i=0; i<rowsCount; i++) {
            this._rowsDom[i].renderTo(this._calendarDivDom.node);
        }
    }


    // PRIVATE
    // LISTENERS
    #onEmptyBtnClick(e) {
        const oldDate = this.date;
        const oldDateEnd = this.dateEnd;
        const oldVal = this.value;
        const oldValEnd = this.valueEnd;
        
        this._date = null;
        this._dateEnd = null;
        this._monthPicker.date = new Date();
        this._calculate();

        if (!kijs.Date.compare(this.date, oldDate)) {
            this.raiseEvent('change', {
                value: this.value, 
                date: this.date,
                valueEnd: this.valueEnd,
                dateEnd: this.dateEnd,
                oldValue: oldVal,
                oldDate: oldDate,
                oldValueEnd: oldValEnd,
                oldDateEnd: oldDateEnd
            });
        }
        this.raiseEvent('emptyClick');
    }

    #onHeaderBarClick() {
        if (this._spinBoxEl.isRendered) {
            this._spinBoxEl.close();
        } else if (!this.disabled) {
            this._spinBoxEl.show();
            this._monthPicker.focus();
        }
    }

    #onItemDomClick(e) {
        if (e.dom.clsHas('kijs-day') && !e.dom.disabled) {
            const oldDate = this.date;
            const oldDateEnd = this.dateEnd;
            const oldVal = this.value;
            const oldValEnd = this.valueEnd;
            let inputFinished = false;

            let date = this.getNextValidDate(e.dom.date);
            // nur das Datum übernehmen, wenn es gültig ist
            if (kijs.Date.compare(date, e.dom.date)) {

                // Wenn bei Range nur das Start und kein Enddatum gesetzt ist, setzen wir das Enddatum
                if (this._mode === 'range' && !kijs.isEmpty(this._date) && kijs.isEmpty(this._dateEnd)) {
                    this._dateEnd = date;
                    inputFinished = true;

                // sonst wird immer das Startdatum gesetzt
                } else {
                    this._date = date;
                    this._dateEnd = null;

                    if (this._mode !== 'range') {
                        inputFinished = true;
                    }
                }

                this._monthPicker.date = date;
                this._calculate();

                if (!kijs.Date.compare(this.date, oldDate) || !kijs.Date.compare(this.dateEnd, oldDateEnd)) {
                    this.raiseEvent('change', {
                        value: this.value, 
                        date: this.date,
                        valueEnd: this.valueEnd,
                        dateEnd: this.dateEnd,
                        oldValue: oldVal,
                        oldDate: oldDate,
                        oldValueEnd: oldValEnd,
                        oldDateEnd: oldDateEnd
                    });
                }
            }

            if (inputFinished) {
                this.raiseEvent('inputFinished');
            }
            this.raiseEvent('dayClick');
        }
    }

    #onItemDomDblClick(e) {
        if (e.dom.clsHas('kijs-day') && !e.dom.disabled) {
            this.raiseEvent('dayDblClick');
        }
    }

    #onItemDomMouseEnter(e) {
        if (this._mode === 'range') {
            if (e.dom.clsHas('kijs-day')) {
                const date = this.getNextValidDate(e.dom.date);
                this._calculate(date);
            }
        }
    }

    #onMonthPickerChange(e) {
        this._calculate();
    }

    #onMonthPickerCloseClick(e) {
        this._spinBoxEl.close();
    }

    #onMonthPickerCurrentClick(e) {
        this._spinBoxEl.close();
    }

    #onMonthPickerMonthClick(e) {
        this._spinBoxEl.close();
    }

    #onNextBtnClick(e) {
        this._monthPicker.date = kijs.Date.addMonths(this._monthPicker.date, 1);
        this._calculate();
    }

    #onPreviousBtnClick(e) {
        this._monthPicker.date = kijs.Date.addMonths(this._monthPicker.date, -1);
        this._calculate();
    }
    
    #onTodayBtnClick(e) {
        const oldDate = this.date;
        const oldDateEnd = this.dateEnd;
        const oldVal = this.value;
        const oldValEnd = this.valueEnd;

        let date = kijs.Date.getDatePart(new Date());

        this._date = this.getNextValidDate(date);
        if (this._mode === 'range') {
            this._dateEnd = kijs.Date.clone(this._date);
        } else {
            this._dateEnd = null;
        }
        this._monthPicker.date = this._date;
        this._calculate(true);

        if (!kijs.Date.compare(this.date, oldDate)) {
            this.raiseEvent('change', {
                value: this.value, 
                date: this.date,
                valueEnd: this.valueEnd,
                dateEnd: this.dateEnd,
                oldValue: oldVal,
                oldDate: oldDate,
                oldValueEnd: oldValEnd,
                oldDateEnd: oldDateEnd
            });
        }
        this.raiseEvent('todayClick');
    }
    
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._itemsDom && this._itemsDom.length) {
            kijs.Array.each(this._itemsDom, function(dom) {
                dom.destruct();
            }, this);
        }

        if (this._rowsDom && this._rowsDom.length) {
            kijs.Array.each(this._rowsDom, function(dom) {
                dom.destruct();
            }, this);
        }

        if (this._todayBtn) {
            this._todayBtn.destruct();
        }

        if (this._emptyBtn) {
            this._emptyBtn.destruct();
        }

        if (this._closeBtn) {
            this._closeBtn.destruct();
        }

        if (this._headerBar) {
            this._headerBar.destruct();
        }

        if (this._calendarDivDom) {
            this._calendarDivDom.destruct();
        }

        if (this._footerDivDom) {
            this._footerDivDom.destruct();
        }

        if (this._spinBoxEl) {
            this._spinBoxEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._minDate = null;
        this._maxDate = null;
        this._date = null;
        this._dateEnd = null;

        this._previousBtn = null;
        this._nextBtn = null;
        this._headerBar = null;
        this._todayBtn = null;
        this._emptyBtn = null;
        this._closeBtn = null;

        this._itemsDom = null;
        this._rowsDom = null;
        this._calendarDivDom = null;
        this._footerDivDom = null;

        this._spinBoxEl = null;
        this._monthPicker = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.field (namespace)
// --------------------------------------------------------------
kijs.gui.field = {};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Field (Abstract)
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Field = class kijs_gui_field_Field extends kijs.gui.Container {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // Falls ein Feld mehrere Werte zurückgibt, muss diese Variable in
        // der abgeleiteten Klasse überschrieben werden
        this._valuesMapping = [{ nameProperty: 'name' , valueProperty: 'value' }];

        this._labelHide = false;
        this._errors = [];
        this._maxLength = null;
        this._minLength = null;
        this._initialValues = {};
        this._required = false;
        this._submitValueEnable = true;
        this._validationFn = null;
        this._validationFnContext = this;
        this._validationRegExps = [];

        this._inputId = kijs.uniqId('kijs_-_input_');

        this._labelDom = new kijs.gui.Dom({
            cls: 'kijs-label',
            nodeTagName: 'label',
            htmlDisplayType: 'code',
            nodeAttribute: {
                htmlFor: this._inputId
            }
        });
        
        this._contentDom = new kijs.gui.Dom({
            cls: 'kijs-content'
        });

        this._inputWrapperDom = new kijs.gui.Dom({
            cls: 'kijs-inputwrapper'
        });
        
        this._errorIconEl = new kijs.gui.Icon({
            parent: this,
            iconMap: 'kijs.iconMap.Fa.circle-info',
            cls: 'kijs-icon-error',
            tooltip: new kijs.gui.Tooltip({ cls: 'kijs-error' }),
            visible: false
        });

        this._helpIconEl = new kijs.gui.Icon({
            parent: this,
            iconMap: 'kijs.iconMap.Fa.circle-question',
            cls: 'kijs-icon-help',
            tooltip: new kijs.gui.Tooltip({ cls: 'kijs-help' }),
            visible: false
        });
        
        this._dom.clsRemove('kijs-container');
        this._dom.clsAdd('kijs-field');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            isDirty: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            disableFlex: { target: 'disableFlex' }, // false=ganze Breite wird genutzt, true=nur die benötigte Breite wird genutzt
            labelPosition: { target: 'labelPosition' },
            isDirty: { target: 'isDirty', prio: 3000 },
            
            inputHeight: { target: 'inputHeight' },
            inputWidth: { target: 'inputWidth' },
            
            label: { target: 'html', context: this._labelDom, prio: 2 },
            labelCls: { fn: 'function', target: this._labelDom.clsAdd, context: this._labelDom },
            labelHide: true,
            labelHtmlDisplayType: { target: 'htmlDisplayType', context: this._labelDom },
            labelStyle: { fn: 'assign', target: 'style', context: this._labelDom },
            labelWidth: { target: 'labelWidth' },

            errorIcon: { target: 'errorIcon' },
            errorIconChar: { target: 'iconChar', context: this._errorIconEl },
            errorIconCls: { target: 'iconCls', context: this._errorIconEl },
            errorIconColor: { target: 'iconColor', context: this._errorIconEl },
            errorIconMap: { target: 'iconMap', context: this._errorIconEl },

            helpIcon: { target: 'helpIcon' },
            helpIconChar: { target: 'iconChar', context: this._helpIconEl },
            helpIconCls: { target: 'iconCls', context: this._helpIconEl },
            helpIconColor: { target: 'iconColor', context: this._helpIconEl },
            helpIconMap: { target: 'iconMap', context: this._helpIconEl },
            helpText: { target: 'helpText' },

            value: { target: 'value', prio: 1000 },

            maxLength: true,
            minLength: true,
            readOnly: { target: 'readOnly' },   // deaktiviert das Feld, die Buttons bleiben aber aktiv (siehe auch disabled)
            required: { target: 'required' },   // Eingabe erforderlich?
            submitValueEnable: true,    // Soll der Wert in einem container.Form übermittelt werden?

            validationFn: { target: 'validationFn' },
            validationFnContext: { target: 'validationFnContext' },
            validationRegExp: { fn: 'function', target: this.addValidationRegExp, context: this }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get contentDom() { return this._contentDom; }
    
    get disableFlex() { return this._dom.clsHas('kijs-disableFlex'); }
    set disableFlex(val) {
        if (val) {
            this._dom.clsAdd('kijs-disableFlex');
        } else {
            this._dom.clsRemove('kijs-disableFlex');
        }
        if (this.isRendered) {
            this.render();
        }
    }

    get errorIcon() { return this._errorIconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set errorIcon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._errorIconEl.iconChar = null;
            this._errorIconEl.iconCls = null;
            this._errorIconEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._errorIconEl.destruct();
            this._errorIconEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._errorIconEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "errorIcon" is not valid.`);

        }
    }

    get errorIconChar() { return this._errorIconEl.iconChar; }
    set errorIconChar(val) { this._errorIconEl.iconChar = val; }

    get errorIconCls() { return this._errorIconEl.iconCls; }
    set errorIconCls(val) { this._errorIconEl.iconCls = val; }

    get errorIconColor() { return this._errorIconEl.iconColor; }
    set errorIconColor(val) { this._errorIconEl.iconColor = val;}

    get errorIconMap() { return this._errorIconEl.iconMap; }
    set errorIconMap(val) { this._errorIconEl.iconMap = val;}

    get helpIcon() { return this._helpIconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set helpIcon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._helpIconEl.iconChar = null;
            this._helpIconEl.iconCls = null;
            this._helpIconEl.iconColor = null;

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._helpIconEl.destruct();
            this._helpIconEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._helpIconEl.applyConfig(val);
            if (this.isRendered) {
                this._helpIconEl.render();
            }

        } else {
            throw new kijs.Error(`config "helpIcon" is not valid.`);

        }
    }

    get helpIconChar() { return this._helpIconEl.iconChar; }
    set helpIconChar(val) { this._helpIconEl.iconChar = val; }

    get helpIconCls() { return this._helpIconEl.iconCls; }
    set helpIconCls(val) { this._helpIconEl.iconCls = val; }

    get helpIconColor() { return this._helpIconEl.iconColor; }
    set helpIconColor(val) { this._helpIconEl.iconColor = val; }

    get helpIconMap() { return this._helpIconEl.iconMap; }
    set helpIconMap(val) { this._helpIconEl.iconMap = val; }

    get helpText() { return this._helpIconEl.tooltip.html; }
    set helpText(val) {
        this._helpIconEl.tooltip = val;
        this._helpIconEl.visible = this._helpIconEl.tooltip && !kijs.isEmpty(this._helpIconEl.tooltip.html);
    }
    
    get inputHeight() { return this._inputWrapperDom.height; }
    set inputHeight(val) {
        this._inputWrapperDom.height = val;
        // Evtl. afterResize-Event zeitversetzt auslösen
        if (this.isRendered && this._hasSizeChanged(null, val)) {
            this._raiseAfterResizeEvent(true);
        }
    }

    get inputWidth() { return this._inputWrapperDom.width; }
    set inputWidth(val) {
        this._inputWrapperDom.width = val;
        // Bei fixer Breite: flex:none verwenden
        if (!kijs.isEmpty(val)) {
            this._inputWrapperDom.style.flex = 'none';
        } else {
            this._inputWrapperDom.style.flex = null;
        }
        // Evtl. afterResize-Event zeitversetzt auslösen
        if (this.isRendered && this._hasSizeChanged(null, val)) {
            this._raiseAfterResizeEvent(true);
        }
    }
    get inputWrapperDom() { return this._inputWrapperDom; }

    get isDirty() {
        let isDirty = false;
        kijs.Array.each(this._valuesMapping, function(map) {
            isDirty = isDirty || this._compareIsDirty(this._initialValues[map.valueProperty], this[map.valueProperty]);
        }, this);
        return isDirty;
    }
    set isDirty(val) {
        if (val) {
            throw new Error(`"isDirty" cannot be set to true.`);

        } else {
            this._initialValues = {};
            kijs.Array.each(this._valuesMapping, function(map) {
                this._initialValues[map.valueProperty] = this[map.valueProperty];
            }, this);
        }
    }

    get label() { return this._labelDom.html; }
    set label(val) {
        this._labelDom.html = val;
    }

    get labelDom() { return this._labelDom; }

    get labelHide() { return this._labelHide; }
    set labelHide(val) {
        this._labelHide = val;
        if (this.isRendered) {
            if (val) {
                this._labelDom.unrender();
            } else {
                this._labelDom.renderTo(this._dom.node, this._contentDom.node);
            }
        }
    }

    get labelHtmlDisplayType() { return this._labelDom.htmlDisplayType; }
    set labelHtmlDisplayType(val) { this._labelDom.htmlDisplayType = val; }

    get labelPosition() {
        if (this._dom.clsHas('kijs-top')) {
            return 'top';
        } else if (this._dom.clsHas('kijs-auto')) {
             return 'auto';
        } else {
            return 'left';
        }
    }
    set labelPosition(val) {
        if (!kijs.Array.contains(['auto', 'left', 'top'], val)) {
            throw new kijs.Error(`config "labelPosition" is not valid.`);
        }
        
        let cls = '';
        switch (val) {
            case 'top':
                cls = 'kijs-labelpos-top';
                break;
                
            case 'auto':
                cls = 'kijs-labelpos-auto';
                break;
                
            case 'left':
                cls = '';
                break;
                
        }
        
        this._dom.clsRemove('kijs-labelpos-top');
        this._dom.clsRemove('kijs-labelpos-auto');
        
        if (cls) {
            this._dom.clsAdd(cls);
        }
        
        if (this.isRendered) {
            this.render();
        }
    }
    
    get labelWidth() { return this._labelDom.width; }
    set labelWidth(val) { this._labelDom.width = val; }

    get readOnly() { return this._dom.clsHas('kijs-readonly'); }
    set readOnly(val) {
        if (val) {
            this._dom.clsAdd('kijs-readonly');
        } else {
            this._dom.clsRemove('kijs-readonly');
        }
    }

    get required() { return this._required; }
    set required(val) { this._required = !!val; }

    // false, falls der Wert vom Feld nicht übermittelt werden soll.
    get submitValueEnable() { return this._submitValueEnable; }
    set submitValueEnable(val) { this._submitValueEnable = !!val; }

    get validationFn() { return this._validationFn; }
    set validationFn(val) {
        let fn = kijs.getFunctionFromString(val);
        if (kijs.isFunction(fn)) {
            this._validationFn = fn;
        } else {
            throw new kijs.Error(`config "validationFn" is not valid.`);
        }
    }

    get validationFnContext() { return this._validationFnContext; }
    set validationFnContext(val) {
        let context = kijs.getObjectFromString(val);
        if (kijs.isObject(context)) {
            this._validationFnContext = context;
        } else {
            throw new kijs.Error(`config "validationFnContext" is not valid.`);
        }
    }

    // Muss überschrieben werden
    get value() { return null; }
    set value(val) {
        this.isDirty = false;
    }

    /**
     * gibt den angezeigten Wert zurück. (z.B. Combo-Anzeigewert)
     * bei einem Textfeld entspricht dies dem value.
     * @returns {String}
     */
    get valueDisplay() { return this.value; }

    /**
     * gibt den angezeigten Wert als HTML zurück. (z.B. Combo-Anzeigewert)
     * bei einem Textfeld entspricht dies dem value.
     * @returns {String}
     */
    get valueDisplayHtml() { return kijs.String.htmlspecialchars(this.value); }

    /**
     * Gibt einen Objekt zurück mit den Werten des Felds
     * Format {name: value}
     * Beispiel nur ein Wert: {value:'2021-02-01'}
     * Beispiel mehrere Werte: {value:'2021-02-01', valueEnd:'2021-02-03'}
     * @return {undefined}
     */
    get values() {
        let ret = {};
        kijs.Array.each(this._valuesMapping, function(map) {
            const fieldName = this[map.nameProperty];
            if (!kijs.isEmpty(fieldName)) {
                ret[fieldName] = this[map.valueProperty];
            }
        }, this);

        return ret;
    }

    /**
     * Für Felder mit mehreren Werten: Damit können mehrere Werte gleichzeitig
     * zugewiesen werden.
     * Beispiel mehrere Werte: {value:'2021-02-01', valueEnd:'2021-02-03'}
     * @param {Object} val
     */
    set values(val) {
        kijs.Array.each(this._valuesMapping, function(map) {
            const fieldName = this[map.nameProperty];
            if (!kijs.isEmpty(fieldName) && val.hasOwnProperty(fieldName)) {
                this[map.valueProperty] = val[fieldName];
            }
        }, this);
        this.isDirty = false;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt einen oder mehrere regulären Ausdruck zum validieren hinzu
     * @param {Object|String|Array} regExps Beispiel: { regExp: '/^[0-9]{3,4}$/', msg: 'Vierstellige Zahl erforderlich' }
     * @returns {undefined}
     */
    addValidationRegExp(regExps) {
        if (!kijs.isArray(regExps)) {
            regExps = [regExps];
        }

        kijs.Array.each(regExps, function(regExp) {
            let ok = true;

            if (typeof regExp !== 'object') {
                ok = false;
            }

            if (ok) {
                if (kijs.isRegExp(regExp.regExp)) {
                    regExp.regExp = regExp.regExp.toString();
                } else if (kijs.isString(regExp.regExp)) {
                    ok = false;
                }
            }

            if (ok) {
                this._validationRegExps.push(regExp);
            } else {
                throw new kijs.Error(`"validationRegExp" is not valid.`);
            }
        }, this);
    }

    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);

        // Icons auch aktivieren/deaktivieren
        this._errorIconEl.changeDisabled(!!val, true);
        this._helpIconEl.changeDisabled(!!val, true);

        // Buttons auch aktivieren/deaktivieren
        const buttons = this.getElementsByXtype('kijs.gui.Button', 1);
        kijs.Array.each(buttons, function(button) {
            button.changeDisabled(!!val, true);
        }, this);
    }

    /**
     * Setz den Wert auf null
     * @returns {undefined}
     */
    clear() {
        kijs.Array.each(this._valuesMapping, function(map) {
                this[map.valueProperty] = null;
        }, this);
        this.isDirty = false;
    }

    /**
     * Fügt Fehler aus einer externen Validation hinzu
     * @param {String|Array} errors
     */
    errorsAdd(errors) {
        if (!errors) {
            return;
        }

        if (!kijs.isArray(errors)) {
            errors = [errors];
        }

        this._errors = this._errors.concat(errors);

        // Fehler anzeigen, falls vorhanden
        this._displayErrors();
    }

    /**
     * Setzt die Validierungsfehler zurück
     * @returns {undefined}
     */
    errorsClear() {
        this._errors = [];

        // Fehler anzeigen, falls vorhanden
        this._displayErrors();
    }

    // overwrite
    render(superCall) {
        // Grosselternklassenaufruf von kijs.gui.Elements.render()
        // den Aufruf von kijs.gui.Container überspringen
        kijs.gui.Element.prototype.render.call(this, true);



        // Label rendern (kijs.guiDom)
        if (!this._labelHide) {
            this._labelDom.renderTo(this._dom.node);
        } else if (this._labelDom.isRendered) {
            this._labelDom.unrender();
        }
        
        // content rendern (kijs.guiDom)
        this._contentDom.renderTo(this._dom.node);
        
        // InputWrapper rendern (kijs.guiDom)
        this._inputWrapperDom.renderTo(this._contentDom.node);

        // innerDOM rendern (kijs.guiDom)
        this._innerDom.renderTo(this._contentDom.node);
        
        // Help icon rendern (kijs.gui.Icon)
        this._helpIconEl.renderTo(this._contentDom.node);

        // Error icon rendern (kijs.gui.Icon)
        this._errorIconEl.renderTo(this._contentDom.node);
        
        // Render der Elements in Funktion, damit dies
        // in Vererbungen überschrieben werden könnte.
        this._renderElements();

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt die Fehleranzeige zurück
     * @return {undefined}
     */
    errorsReset() {
        this._dom.clsRemove('kijs-error');
        this._errorIconEl.visible = false;
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._labelDom.unrender();
        this._inputWrapperDom.unrender();
        this._errorIconEl.unrender();
        this._helpIconEl.unrender();
        this._contentDom.unrender();
        super.unrender(true);
    }

    /**
     * Validiert den Inhalt des Felds
     * @param {Boolean} [ignoreEmpty=false] nicht validieren, wenn das Feld leer ist.
     * @returns {Boolean}
     */
    validate(ignoreEmpty) {
        this._errors = [];

        // Validierungen anwenden
        if (this.visible && !this.readOnly && !this.disabled) {
            this._validationRules(this.value, ignoreEmpty);
        }

        // Fehler anzeigen, falls vorhanden
        this._displayErrors();

        return kijs.isEmpty(this._errors);
    }


    /**
     * Setzt den Wert des Feldes auf den Originalwert zurück (not dirty).
     * @returns {undefined}
     */
    valuesReset() {
        kijs.Array.each(this._valuesMapping, function(map) {
            if (kijs.isDefined(this._initialValues[map.valueProperty])) {
                this[map.valueProperty] = this._initialValues[map.valueProperty];
            }
        }, this);
        // Fehler nicht mehr anzeigen
        this._dom.clsRemove('kijs-error');
        this._errorIconEl.visible = false;
    }


    // PROTECTED
    /**
     * compares the current value to the initial value.
     * @param {String|Number|Array|Object|Null} initialValue
     * @param {String|Number|Array|Object|Null} currentValue
     * @returns {Boolean}
     */
    _compareIsDirty(initialValue, currentValue) {
        if (kijs.isArray(initialValue) && kijs.isArray(currentValue)) {
            if (initialValue.length !== currentValue.length) {
                return true;
            }
            for (let i=0; i < initialValue.length; i++) {
                if (currentValue.indexOf(initialValue[i]) === -1) {
                    return true;
                }
            }
        } else if (kijs.isObject(initialValue) && kijs.isObject(currentValue)) {
            const allKeys = kijs.Array.concatUnique(Object.keys(initialValue), Object.keys(currentValue));
            for (let key of allKeys) {
                if (this._compareIsDirty(initialValue[key], currentValue[key])) {
                    return true;
                }
            }
        } else {
            if (kijs.toString(initialValue) !== kijs.toString(currentValue)) {
                return true;
            }
        }

        return false;
    }

    /**
     * Zeigt die Fehler aus this._errors im errorIcon an
     * @returns {undefined}
     */
    _displayErrors() {
        if (!kijs.isEmpty(this._errors)) {
            this._dom.clsAdd('kijs-error');
            this._errorIconEl.tooltip = this._errors;
            this._errorIconEl.visible = true;
        } else {
            this._dom.clsRemove('kijs-error');
            this._errorIconEl.visible = false;
        }
    }

    /**
     * Maximale Länge validieren
     * Wird aufgerufen von _validationRules
     * @param {String} value
     * @param {Boolean} ignoreEmpty
     * @returns {undefined}
     */
    _validateMaxLength(value, ignoreEmpty) {
        if (!kijs.isEmpty(this._maxLength)) {
            if (!kijs.isEmpty(value) && value.length > this._maxLength) {
                this._errors.push(kijs.getText('Dieses Feld darf maximal %1 Zeichen enthalten', '', this._maxLength));
            }
        }
    }
    
    /**
     * Minimale Länge validieren
     * Wird aufgerufen von _validationRules
     * @param {String} value
     * @param {Boolean} ignoreEmpty
     * @returns {undefined}
     */
    _validateMinLength(value, ignoreEmpty) {
        if (!kijs.isEmpty(this._minLength)) {
            if (!kijs.isEmpty(value) && value.length < this._minLength) {
                this._errors.push(kijs.getText('Dieses Feld muss mindestens %1 Zeichen enthalten', '', this._minLength));
            }
        }
    }
    
    /**
     * Eingabe erforderlich validieren
     * Wird aufgerufen von _validationRules
     * @param {String} value
     * @param {Boolean} ignoreEmpty
     * @returns {undefined}
     */
    _validateRequired(value, ignoreEmpty) {
        if (this._required) {
            if (kijs.isEmpty(value)) {
                this._errors.push(kijs.getText('Dieses Feld darf nicht leer sein'));
            }
        }
    }

    /**
     * mit validationFn validieren
     * Wird aufgerufen von _validationRules
     * @param {String} value
     * @param {Boolean} ignoreEmpty
     * @returns {undefined}
     */
    _validateValidationFn(value, ignoreEmpty) {
        if (kijs.isFunction(this._validationFn)) {
            if (value !== null && value.toString() !== '') {
                let error = this._validationFn.call(this._validationFnContext || this, value);
                if (error) {
                    if (kijs.isString(error)) {
                        this._errors.push(error);

                    } else if (kijs.isArray(error)) {
                        this._errors = kijs.Array.concat(this._errors, error);
                    }
                }
            }
        }
    }

    /**
     * mit validationRegExps validieren
     * Wird aufgerufen von _validationRules
     * @param {String} value
     * @param {Boolean} ignoreEmpty
     * @returns {undefined}
     */
    _validateValidationRegExps(value, ignoreEmpty) {
        if (!kijs.isEmpty(this._validationRegExps)) {
            if (value !== null && value.toString() !== '') {
                kijs.Array.each(this._validationRegExps, function(regExp) {
                    let r = kijs.String.toRegExp(regExp.regExp);
                    if (!r.exec(value.toString())) {
                        if (!kijs.isEmpty(regExp.msg)) {
                            this._errors.push(regExp.msg);
                        } else {
                            this._errors.push(kijs.getText('Dieses Feld hat einen ungültigen Wert'));
                        }
                        return;
                    }
                }, this);
            }
        }
    }
    

    
   /**
     * Diese Funktion ist zum Überschreiben gedacht
     * @param {String} value
     * @param {Boolean} [ignoreEmpty=false] nicht validieren, wenn das Feld leer ist.
     * @returns {undefined}
     */
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        // Eingabe erforderlich
        this._validateRequired(value, ignoreEmpty);

        // Minimale Länge
        this._validateMinLength(value, ignoreEmpty);

        // Maximale Länge
        this._validateMaxLength(value, ignoreEmpty);

        // validationRegExps
        this._validateValidationRegExps(value, ignoreEmpty);

        // validationFn
        this._validateValidationFn(value, ignoreEmpty);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._labelDom) {
            this._labelDom.destruct();
        }
        if (this._inputWrapperDom) {
            this._inputWrapperDom.destruct();
        }
        if (this._errorIconEl) {
            this._errorIconEl.destruct();
        }
        if (this._helpIconEl) {
            this._helpIconEl.destruct();
        }
        if (this._contentDom) {
            this._contentDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._errors = null;
        this._labelDom = null;
        this._inputWrapperDom = null;
        this._errorIconEl = null;
        this._helpIconEl = null;
        this._contentDom = null;
        this._validationFn = null;
        this._validationFnContext = null;
        this._validationRegExps = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this, Function */

// --------------------------------------------------------------
// kijs.gui.field.Text
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * blur
 * input
 *
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Text = class kijs_gui_field_Text extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._formatFn = null;
        this._formatFnContext = this;
        this._formatRegExps = [];
        this._valueTrimEnable = true;
        this._previousChangeValue = '';

        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'input',
            nodeAttribute: {
                id: this._inputId
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                context: this
            }
        });

        this._dom.clsAdd('kijs-field-text');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false
        });

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            formatFn: { target: 'formatFn' },
            formatFnContext: { target: 'formatFnContext' },
            formatRegExp: { fn: 'function', target: this.addFormatRegExp, context: this },
            inputMode: { target: 'inputMode' },
            valueTrimEnable: true,             // Sollen Leerzeichen am Anfang und Ende des Values automatisch entfernt werden?
            placeholder: { target: 'placeholder' },
            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }

    get formatFn() { return this._formatFn; }
    set formatFn(val) {
        let fn = kijs.getFunctionFromString(val);
        if (kijs.isFunction(fn)) {
            this._formatFn = fn;
        } else {
            throw new kijs.Error(`config "formatFn" is not valid.`);
        }
    }

    get formatFnContext() { return this._formatFnContext; }
    set formatFnContext(val) {
        let context = kijs.getObjectFromString(val);
        if (kijs.isObject(context)) {
            this._formatFnContext = context;
        } else {
            throw new kijs.Error(`config "formatFnContext" is not valid.`);
        }
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    get inputMode() { return this._inputDom.nodeAttributeGet('inputMode'); }
    set inputMode(val) { this._inputDom.nodeAttributeSet('inputMode', val); }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get placeholder() { this._inputDom.nodeAttributeGet('placeholder'); }
    set placeholder(val) { this._inputDom.nodeAttributeSet('placeholder', kijs.toString(val)); }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
    }

    // overwrite
    get value() {
        let val = kijs.toString(this._inputDom.nodeAttributeGet('value'));
        if (this._valueTrimEnable) {
            val = val.trim();
        }
        return val;
    }
    set value(val) {
        val = kijs.toString(val);
        val = this._formatRules(val, false);
        this._inputDom.nodeAttributeSet('value', val);
        this._previousChangeValue = val;
    }

    get valueTrimEnable() { return this._valueTrimEnable; }
    set valueTrimEnable(val) { this._valueTrimEnable = !!val; }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt einen oder mehrere regulären Ausdruck (replace) zum Formatieren hinzu
     * @param {Object|Array} regExps
     *                       Beispiel: { regExp: '/([0-9]{3})([0-9]{3})/', replace: '$1 $2'  }
     *                       Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt,
     *                       sonst replace()
     * @returns {undefined}
     */
    addFormatRegExp(regExps) {
        if (!kijs.isArray(regExps)) {
            regExps = [regExps];
        }

        kijs.Array.each(regExps, function(regExp) {
            let ok = true;

            if (typeof regExp !== 'object') {
                ok = false;
            }

            if (ok) {
                if (kijs.isRegExp(regExp.regExp)) {
                    regExp.regExp = regExp.regExp.toString();
                } else if (!kijs.isString(regExp.regExp)) {
                    ok = false;
                }
            }

            if (ok) {
                if (kijs.isString(regExp.replace) && (regExp.toUpperCase || regExp.toLowerCase)) {
                    throw new kijs.Error(`"formatRegExp" must not have a "toUpperCase" or "toLowerCase" and a "replace" at the same time.`);
                } else if (!kijs.isString(regExp.replace) && !regExp.toUpperCase && !regExp.toLowerCase) {
                    ok = false;
                }
            }

            if (ok) {
                this._formatRegExps.push(regExp);
            } else {
                throw new kijs.Error(`"formatRegExp" is not valid.`);
            }
        }, this);
    }

    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        super.unrender(true);
    }


    // PROTECTED
    /**
     * formatFn anwenden
     * Wird aufgerufen von _formatRules
     * @param {String} value
     * @param {Boolean} whileTyping true=Aufruf kommt vom input-Event. false=change oder set value
     * @returns {String}
     */
    _formatApplyFormatFn(value, whileTyping) {
        if (kijs.isFunction(this._formatFn)) {
            if (value !== null && value.toString() !== '') {
                value = this._formatFn.call(this._formatFnContext || this, value, !!whileTyping);
            }
        }
        return value;
    }
    
    /**
     * formatRegExp anwenden
     * Wird aufgerufen von _formatRules
     * @param {String} value
     * @param {Boolean} whileTyping true=Aufruf kommt vom input-Event. false=change oder set value
     * @returns {String}
     */
    _formatApplyFormatRegExp(value, whileTyping) {
        if (!kijs.isEmpty(this._formatRegExps)) {
            value = value.toString();
            if (value !== '') {
                kijs.Array.each(this._formatRegExps, function(regExp) {
                    let r = kijs.String.toRegExp(regExp.regExp);

                    // in Grossbuchstaben umwandeln
                    if (regExp.toUpperCase) {
                        // Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt
                        if (kijs.String.contains(r.flags, 'g')) {
                            value = value.replaceAll(r, function(v) { return v.toUpperCase(); });
                        // sonst nur replace
                        } else {
                            value = value.replace(r, function(v) { return v.toUpperCase(); });
                        }

                    // oder in Kleinbuchstaben umwandeln
                    } else if (regExp.toUpperCase) {
                        // Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt
                        if (kijs.String.contains(r.flags, 'g')) {
                            value = value.replaceAll(r, function(v) { return v.toLowerCase(); });
                        // sonst nur replace
                        } else {
                            value = value.replace(r, function(v) { return v.toLowerCase(); });
                        }

                    // oder durch String ersetzen
                    } else {
                        // Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt
                        if (kijs.String.contains(r.flags, 'g')) {
                            value = value.replaceAll(r, regExp.replace);
                        // sonst nur replace
                        } else {
                            value = value.replace(r, regExp.replace);
                        }

                    }
                }, this);
            }
        }
        return value;
    }

    /**
     * Diese Funktion ist zum Überschreiben gedacht
     * @param {String} value
     * @param {Boolean} whileTyping true=Aufruf kommt vom input-Event. false=change oder set value
     * @returns {String}
     */
    _formatRules(value, whileTyping) {
        // formatRegExps
        value = this._formatApplyFormatRegExp(value, whileTyping);

        // formatFn
        value = this._formatApplyFormatFn(value, whileTyping);
        
        return value;
    }


    // PRIVATE
    // LISTENERS
    #onInputDomChange(e) {
        // Sicherstellen, dass beim Verlassen des Feldes noch getrimmt wird.
        let val = this.value;
        let oldVal = this._previousChangeValue;

        // Wert neu reinschreiben (evtl. wurde er getrimmt)
        this.value = val;

        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    #onInputDomInput(e) {
        let val = kijs.toString(this._inputDom.nodeAttributeGet('value'));
        val = this._formatRules(val, true);
        this._inputDom.nodeAttributeSet('value', val);
        this.validate();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;
        this._formatFn = null;
        this._formatFnContext = null;
        this._formatRegExps = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Url
// --------------------------------------------------------------
kijs.gui.field.Url = class kijs_gui_field_Url extends kijs.gui.field.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._defaultProtocol = 'https://';
        
        this._linkButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.arrow-up-right-from-square',
            tooltip: kijs.getText('Link in neuem Tab öffnen'),
            disableFlex: true,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                click: this.#onLinkButtonClick,
                context: this
            }
        });

        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });
        
        this._dom.clsRemove('kijs-field-text');
        this._dom.clsAdd('kijs-field-url');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            inputMode: 'url'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            defaultProtocol: true,  // Standardprotokoll für URLs ohne Protokoll (default = 'https://')
            
            linkButtonHide: { target: 'linkButtonHide' },
            linkButtonIconChar: { target: 'iconChar', context: this._linkButtonEl },
            linkButtonIconCls: { target: 'iconCls', context: this._linkButtonEl },
            linkButtonIconColor: { target: 'iconColor', context: this._linkButtonEl },
            linkButtonIconMap: { target: 'iconMap', context: this._linkButtonEl }
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get defaultProtocol() { return this._defaultProtocol; }
    set defaultProtocol(val) { this._defaultProtocol = val; }
    
    get linkButton() { return this._linkButtonEl; }
    
    get linkButtonHide() { return !this._linkButtonEl.visible; }
    set linkButtonHide(val) { this._linkButtonEl.visible = !val; }

    get linkButtonIconChar() { return this._linkButtonEl.iconChar; }
    set linkButtonIconChar(val) { this._linkButtonEl.iconChar = val; }

    get linkButtonIconCls() { return this._linkButtonEl.iconCls; }
    set linkButtonIconCls(val) { this._linkButtonEl.iconCls = val; }

    get linkButtonIconColor() { return this._linkButtonEl.iconColor; }
    set linkButtonIconColor(val) { this._linkButtonEl.iconColor = val; }

    get linkButtonIconMap() { return this._linkButtonEl.iconMap; }
    set linkButtonIconMap(val) { this._linkButtonEl.iconMap = val; }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._linkButtonEl.changeDisabled(!!val, true);
    }
    
    // overwrite
    render(superCall) {
        super.render(true);
        
        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');
        
        // Link Button rendern (kijs.gui.Button)
        this._linkButtonEl.renderTo(this._buttonsDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._buttonsDom.unrender();
        
        super.unrender(true);
    }


    // PRIVATE
    // LISTENERS
    #onLinkButtonClick() {
        let val = this.value;
        
        if (!this.disabled && !kijs.isEmpty(val) && this.validate(val)) {
            // Evt. Standardprotocol hinzufügen
            if (!kijs.isEmpty(this._defaultProtocol)) {
                if (!val.match(/^[a-z0-9]+\:\/\//i)) {
                    val = this._defaultProtocol + val;
                }
            }
            window.open(val, '_blank');
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._linkButtonEl) {
            this._linkButtonEl.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._buttonsDom = null;
        this._linkButtonEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Email
// --------------------------------------------------------------
kijs.gui.field.Email = class kijs_gui_field_Email extends kijs.gui.field.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._linkButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.envelope',
            tooltip: kijs.getText('E-Mail erstellen'),
            disableFlex: true,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                click: this.#onLinkButtonClick,
                context: this
            }
        });
        
        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });
        
        this._dom.clsRemove('kijs-field-text');
        this._dom.clsAdd('kijs-field-email');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            inputMode: 'email',
            validationRegExp: { // Validierung ist hier, damit sie überschrieben werden kann
                regExp: /^[^\s\:@]+@[^\s@]+\.[a-z]+$/,
                msg: kijs.getText('Ungültige E-Mail-Adresse')
            }
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            linkButtonHide: { target: 'linkButtonHide' },
            linkButtonIconChar: { target: 'iconChar', context: this._linkButtonEl },
            linkButtonIconCls: { target: 'iconCls', context: this._linkButtonEl },
            linkButtonIconColor: { target: 'iconColor', context: this._linkButtonEl },
            linkButtonIconMap: { target: 'iconMap', context: this._linkButtonEl }
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get linkButton() { return this._linkButtonEl; }
    
    get linkButtonHide() { return !this._linkButtonEl.visible; }
    set linkButtonHide(val) { this._linkButtonEl.visible = !val; }

    get linkButtonIconChar() { return this._linkButtonEl.iconChar; }
    set linkButtonIconChar(val) { this._linkButtonEl.iconChar = val; }

    get linkButtonIconCls() { return this._linkButtonEl.iconCls; }
    set linkButtonIconCls(val) { this._linkButtonEl.iconCls = val; }

    get linkButtonIconColor() { return this._linkButtonEl.iconColor; }
    set linkButtonIconColor(val) { this._linkButtonEl.iconColor = val; }

    get linkButtonIconMap() { return this._linkButtonEl.iconMap; }
    set linkButtonIconMap(val) { this._linkButtonEl.iconMap = val; }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._linkButtonEl.changeDisabled(!!val, true);
    }
    
    // overwrite
    render(superCall) {
        super.render(true);
        
        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');
        
        // Link Button rendern (kijs.gui.Button)
        this._linkButtonEl.renderTo(this._buttonsDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._buttonsDom.unrender();
        
        super.unrender(true);
    }
    
    
    // PRIVATE
    // LISTENERS
    #onLinkButtonClick() {
        let val = this.value;
        if (!this.disabled && !kijs.isEmpty(val) && this.validate(val)) {
            kijs.Navigator.openEmailPhoneLink('mailto:' + val);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._linkButtonEl) {
            this._linkButtonEl.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._buttonsDom = null;
        this._linkButtonEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Phone
// --------------------------------------------------------------
kijs.gui.field.Phone = class kijs_gui_field_Phone extends kijs.gui.field.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._defaultCountryCallingCode = '+41';
        this._internationalCallPrefix = '00';
        
        this._inputDom.nodeAttributeSet('type', 'tel');
        
        this._linkButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.phone',
            tooltip: kijs.getText('Anrufen'),
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                click: this.#onLinkButtonClick,
                context: this
            }
        });
        
        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });
        
        this._dom.clsRemove('kijs-field-text');
        this._dom.clsAdd('kijs-field-phone');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableFlex: true,
            inputMode: 'tel',
            formatRegExp:[  // Formatierung (kann mit config ersetzt werden)
                { 
                    regExp: /^\+41([89][0-9]{2})([0-9]{3})([0-9]{3})$/, // CH 0800 + 0900
                    replace: '+41 $1 $2 $3'
                },{
                    regExp: /^\+41([1-7][0-9])([0-9]{3})([0-9]{2})([0-9]{2})$/, // CH default
                    replace: '+41 $1 $2 $3 $4'
                },{ 
                    regExp: /^\+423([0-9]{3})([0-9]{2})([0-9]{2})$/, // LI
                    replace: '+423 $1 $2 $3'
                },{ 
                    regExp: /^\+43([0-9]{3})([0-9]{4})([0-9]{6})([0-9]{4})$/, // A
                    replace: '+43 $1 $2 $3 $4'
                //},{ 
                //    regExp: /^\+49([0-9]{3})([0-9]{3})([0-9]{11})$/, // D // TODO: richtige Formatierung?
                //    replace: '+49 $1 $2 $3'
                },{ 
                    regExp: /^\+33([0-9])([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})$/, // F
                    replace: '+33 $1 $2 $3 $4 $5'
                }
            ]
        });

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            defaultCountryCallingCode: true,    // Standard Landesvorwahl
            
            linkButtonHide: { target: 'linkButtonHide' },
            linkButtonIconChar: { target: 'iconChar', context: this._linkButtonEl },
            linkButtonIconCls: { target: 'iconCls', context: this._linkButtonEl },
            linkButtonIconColor: { target: 'iconColor', context: this._linkButtonEl },
            linkButtonIconMap: { target: 'iconMap', context: this._linkButtonEl }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get defaultCountryCallingCode() { return this._defaultCountryCallingCode; }
    set defaultCountryCallingCode(val) { this._defaultCountryCallingCode = val; }

    get internationalCallPrefix() { return this._internationalCallPrefix; }
    set internationalCallPrefix(val) { this._internationalCallPrefix = val; }
    
    get linkButton() { return this._linkButtonEl; }
    
    get linkButtonHide() { return !this._linkButtonEl.visible; }
    set linkButtonHide(val) { this._linkButtonEl.visible = !val; }

    get linkButtonIconChar() { return this._linkButtonEl.iconChar; }
    set linkButtonIconChar(val) { this._linkButtonEl.iconChar = val; }

    get linkButtonIconCls() { return this._linkButtonEl.iconCls; }
    set linkButtonIconCls(val) { this._linkButtonEl.iconCls = val; }

    get linkButtonIconColor() { return this._linkButtonEl.iconColor; }
    set linkButtonIconColor(val) { this._linkButtonEl.iconColor = val; }

    get linkButtonIconMap() { return this._linkButtonEl.iconMap; }
    set linkButtonIconMap(val) { this._linkButtonEl.iconMap = val; }
    
    

    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._linkButtonEl.changeDisabled(!!val, true);
    }
    
    // overwrite
    render(superCall) {
        super.render(true);
        
        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');
        
        // Link Button rendern (kijs.gui.Button)
        this._linkButtonEl.renderTo(this._buttonsDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._buttonsDom.unrender();
        
        super.unrender(true);
    }
    
    
    // PROTECTED
    // overwrite
    _formatRules(value, whileTyping) {
        // führende 00 durch + ersetzen
        if (!kijs.isEmpty(this._internationalCallPrefix)) {
            if (value.substring(0, this._internationalCallPrefix.length) === this._internationalCallPrefix) {
                value = '+' + value.substring(this._internationalCallPrefix.length, value.length);
            }
        }
        
        // formatRegExps 
        // Diese haben hier ein anderes Verhalten. Falls keine regExp anwendung findet,
        // wird die Nummer so belassen, wie sie eingegeben wurde.
        if (this._formatRegExps) {
            let val = '';
            let origVal = '';
            
            val = value;
            
            // Alles andere als Zahlen und das + am Anfang entfernen
            val = val.replace(/(?!^\+)[^0-9]+/g, '');
            
            // Bei lokaler Nummer: Landesvorwahl hinzufügen
            if (!kijs.isEmpty(this._defaultCountryCallingCode)) {
                if (val.match(/^[0][1-9][0-9]+$/)){
                    val = this._defaultCountryCallingCode + val.substring(1);
                }
                val = val.replace(/^[0][1-9][0-9]+$/, this._defaultCountryCallingCode);
            }
            origVal = val;
            
            // Formatierung temporär anwenden           
            val = this._formatApplyFormatRegExp(value, whileTyping);
            
            // hat eine Formatierung gepasst? 
            // Dann Formatierung anwenden. Sonst nicht formatieren
            if (val !== origVal) {
                value = val;
            }
        }
        
        // Evtl. in lokale Nummer konvertieren
        if (!kijs.isEmpty(this._defaultCountryCallingCode)) {
            if (value.substring(0, this._defaultCountryCallingCode.length) === this._defaultCountryCallingCode) {
                value = value.substring(this._defaultCountryCallingCode.length, value.length);
                // Leerzeichen am Anfang entfernen
                value = value.replace(/^[ ]+/, '');
                // 0 als Präfix
                value = '0' + value;
            }
        }
        
        // formatFn
        value = this._formatApplyFormatFn(value, whileTyping);
        
        return value;
    }


    // PRIVATE
    // LISTENERS
    #onLinkButtonClick() {
        let val = this.value;
        if (!this.disabled && !kijs.isEmpty(val) && this.validate(val)) {
            
            // Alles andere als Zahlen und das + am Anfang entfernen
            val = val.replace(/(?!^\+)[^0-9]+/g, '');
            
            // Bei lokaler Nummer: Landesvorwahl hinzufügen
            if (!kijs.isEmpty(this._defaultCountryCallingCode)) {
                if (val.match(/^[0][1-9][0-9]+$/)){
                    val = this._defaultCountryCallingCode + val.substring(1);
                }
                val = val.replace(/^[0][1-9][0-9]+$/, this._defaultCountryCallingCode);
            }
            
            // Link, öffnen
            kijs.Navigator.openEmailPhoneLink('tel:' + val);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._linkButtonEl) {
            this._linkButtonEl.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._buttonsDom = null;
        this._linkButtonEl = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Iban
// --------------------------------------------------------------
kijs.gui.field.Iban = class kijs_gui_field_Iban extends kijs.gui.field.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dom.clsRemove('kijs-field-text');
        this._dom.clsAdd('kijs-field-iban');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableFlex: true,
            formatRegExp:[  // Formatierung (kann mit config ersetzt werden)
                { 
                    regExp: /\s/g, // Whitespace entfernen
                    replace: ''
                },{
                    regExp: /(\S{4})/g, // alle 4 Zeichen eine Lücke einfügen
                    replace: '$1 '
                },{ 
                    regExp: /\s$/, // Whitespace am Ende entfernen
                    replace: ''
                },{ 
                    regExp: /(.*)/g, // Buchstaben in Grossbauchstaben umwandeln
                    toUpperCase: true
                }
            ]
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    _modulo(aNumStr, aDiv) {
        let tmp = "";
        let i, r;
        for (i = 0; i < aNumStr.length; i++) {
            tmp += aNumStr.charAt(i);
            r = tmp % aDiv;
            tmp = r.toString();
        }
        return tmp / 1;
    }
    
    _validateIban(value) {
        value = kijs.toString(value).toUpperCase().replace(/\s/g, '');

        // Nicht erlaubte Zeichen?
        if (!value || /[^A-Z0-9]/.test(value)) {
            return false;
        }

        let rearrange =
            value.substring(4, value.length)
            + value.substring(0, 4);
        let alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split('');
        let alphaMap = {};
        let number = [];

        alphabet.forEach((value, index) => {
            alphaMap[value] = index + 10;
        });

        rearrange.split('').forEach((value, index) => {
            number[index] = alphaMap[value] || value;
        });

        return this._modulo(number.join('').toString(), 97) === 1;
    }
    
    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }
        
        super._validationRules(value, ignoreEmpty);

        // IBAN validieren
        if (!kijs.isEmpty(value) && !this._validateIban(value)) {
            this._errors.push(kijs.getText('Ungültige IBAN'));
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.SozVersNr
// --------------------------------------------------------------
kijs.gui.field.SozVersNr = class kijs_gui_field_SozVersNr extends kijs.gui.field.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._allowAhvNr = false;       // darf eine alte AHV-Nr eingegeben werden?
        this._allowSozVersNr = true;    // darf eine neue Soz.vers.-Nr. eingegeben werden?
        
        this._dom.clsRemove('kijs-field-text');
        this._dom.clsAdd('kijs-field-sozversnr');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableFlex: true,
            formatFn: this._formatNr,
            formatFnContext: this
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            allowAhvNr: true,       // darf eine alte AHV-Nr eingegeben werden?
            allowSozVersNr: true    // darf eine neue Soz.vers.-Nr. eingegeben werden?
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get allowAhvNr() { return this._allowAhvNr; }
    set allowAhvNr(val) { this._allowAhvNr = val; }

    get allowSozVersNr() { return this._allowSozVersNr; }
    set allowSozVersNr(val) { this._allowSozVersNr = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    _formatNr(value, whileTyping) {
        let origValue = value;
        
        // Leerzeichen und Punkte entfernen
        value = kijs.toString(value).replace(/[ \.]*/g, '');
        
        // Zwischenstand merken
        let val = value;
        
        // neue Soz.vers.-Nr. (Format: xxx.xxxx.xxxx.xx)
        if (this._allowSozVersNr) {
            val = val.replace(/^([0-9]{3})([0-9]{4})([0-9]{4})([0-9]{2})$/, '$1.$2.$3.$4');
        }

        // alte AHV-Nr.(Format: xxx.xx.xxx.xxx)
        // während der Eingabe nur formatieren, wenn die neue nicht möglich ist, 
        // weil sonst bereits nach 11 Zeichen die alte formatiert wird.
        // bei set value oder beim verlassen des Feldes wird aber richtig formatiert.
        if (this._allowAhvNr && (!this._allowSozVersNr || !whileTyping)) {
            val = val.replace(/^([0-9]{3})([0-9]{2})([0-9]{3})([0-9]{3})$/, '$1.$2.$3.$4');
        }
        
        
        
        // konnte eine Formatierung angewendet werden?
        // Wenn ja, diese zurückgeben, sonst den ursprünglichen Wert
        if (val !== value) {
            return val;
        } else {
            return origValue;
        }
    }
    
    // alte AHV-Nr. validieren
    _validateAhvNr(value) {
        value = kijs.toString(value).replace(/[ \.]*/g, '');

        // Nicht erlaubte Zeichen?
        if (!value || /[^0-9]/.test(value)) {
            return false;
        }
        
        // Länge
        if (value.length !== 11) {
            return false;
        }
        
        let x = 0;
        let z = value.substr(0,10);
        let pz = parseInt(value.substr(10));   // Prüfziffer

        x += parseInt(z.substr(0,1)) * 5;
        x += parseInt(z.substr(1,1)) * 4;
        x += parseInt(z.substr(2,1)) * 3;
        x += parseInt(z.substr(3,1)) * 2;
        x += parseInt(z.substr(4,1)) * 7;
        x += parseInt(z.substr(5,1)) * 6;
        x += parseInt(z.substr(6,1)) * 5;
        x += parseInt(z.substr(7,1)) * 4;
        x += parseInt(z.substr(8,1)) * 3;
        x += parseInt(z.substr(9,1)) * 2;

        x = 11 - (x % 11);
        if (x === 11) {
            x = 0;
        }
        if(x === 10) {
            x = -1; // Ungültige Nummer
        }
        if (x !== pz) {
            return false;
        }
        
        return true;
    }
    
    // neue Sozialversicherungs-Nr. validieren
    _validateSozVersNr(value) {
        value = kijs.toString(value).replace(/[ \.]*/g, '');
        
        // Nicht erlaubte Zeichen?
        if (!value || /[^0-9]/.test(value)) {
            return false;
        }
        
        // Länge
        if (value.length !== 13) {
            return false;
        }
        
        let x = 0;
        let z = value.substr(0,12);
        let pz = parseInt(value.substr(12));   // Prüfziffer
        
        // die einzelnen Ziffern werden von rechts nach links,
        // beginnend mit der vorletzten Ziffer, abwechselnd mit 3
        // und mit 1 multipliziert
        for (let i=11; i>=0; i--) {
            if (i%2 === 0) {
                x += parseInt(z.substr(i,1)) * 1;
            } else {
                x += parseInt(z.substr(i,1)) * 3;
            }
        }
        
        // die Prüfziffer ergänzt diese Summe dann zum nächsten
        // Vielfachen von 10
        x = parseInt(x.toString().substr(x.toString().length-1, 1));
        if (x > 0) {
            x = 10 - x;
        }
        
        if (x !== pz) {
            return false;
        }
        
        return true;
    }
    
    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }
        
        super._validationRules(value, ignoreEmpty);

        // SozVersNr validieren
        if (!kijs.isEmpty(value)) {
            let val = kijs.toString(value).replace(/[ \.]*/g, '');
            let ok = false;
            
            // neue Sozialversicherungs-Nr.
            if (val.length === 13 && this._allowSozVersNr) {
                ok = this._validateSozVersNr(value);
                
            // alte AHV-Nr.
            } else if (val.length === 11 && this._allowAhvNr) {
                ok = this._validateAhvNr(value);
                
            }
            
            if (!ok) {
                this._errors.push(kijs.getText('Ungültige Sozialversicherungs-Nr.'));
            }
        }
    }


    // PRIVATE
    // LISTENERS
    // overwrite
    #onInputDomChange(e) {
        // Sicherstellen, dass beim Verlassen des Feldes noch getrimmt und formatiert wird.
        let val = this.value;
        let oldVal = this._previousChangeValue;
        
        // Wert neu reinschreiben (evtl. wurde er getrimmt oder formatiert)
        this.value = val;
        
        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Number
// --------------------------------------------------------------
kijs.gui.field.Number = class kijs_gui_field_Number extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._allowDecimals = false;
        this._alwaysDisplayDecimals = false;
        this._decimalPrecision = 2;
        this._decimalSeparator = '.';
        this._minValue = null;
        this._maxValue = null;
        this._thousandsSeparator = '';

        this._spinStep = 1;
        this._spinDelay = 400;
        this._spinAcceleration = 20;

        this._spinDelayCurrent = null;
        this._spinDeferId = null;

        this._allowedDecimalSeparators = ['.', ','];
        this._allowedThousandsSeparators = ['\'', ' ', '`', '´'];

        this._previousChangeValue = '';

        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'input',
            nodeAttribute: {
                id: this._inputId,
                inputMode: 'decimal'
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                context: this
            }
        });

        // Spin Up/Down Buttons
        this._spinUpButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.caret-up',
            disableFlex: false,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                mouseDown: this.#onSpinUpButtonMouseDown,
                mouseUp: this.#onSpinUpButtonMouseUp,
                mouseLeave: this.#onSpinUpButtonMouseLeave,
                context: this
            }
        });
        
        this._spinDownButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.caret-down',
            disableFlex: false,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                mouseDown: this.#onSpinDownButtonMouseDown,
                mouseUp: this.#onSpinDownButtonMouseUp,
                mouseLeave: this.#onSpinDownButtonMouseLeave,
                context: this
            }
        });
        
        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });

        this._dom.clsAdd('kijs-field-number');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false,
            disableFlex: true
        });

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            allowDecimals: true,
            allowedDecimalSeparators: true,
            allowedThousandsSeparators: true,
            alwaysDisplayDecimals: true,
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            decimalPrecision: { target: 'decimalPrecision'},
            decimalSeparator: true,
            inputMode: { target: 'inputMode' },
            minValue: { target: 'minValue'},
            maxValue: { target: 'maxValue'},
            placeholder: { target: 'placeholder' },
            spinAcceleration: true,     // Beschleunigung in %
            spinButtonsHide: { target: 'spinButtonsHide' },  // Spin-Buttons ausblenden
            spinDelay: true,            // Intervall in ms
            spinStep: true,             // Schrittgrösse
            thousandsSeparator: true,
            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get allowDecimals() { return this._allowDecimals; }
    set allowDecimals(val) { this._allowDecimals = !!val; }

    get alwaysDisplayDecimals() { return this._alwaysDisplayDecimals; }
    set alwaysDisplayDecimals(val) {
        this._alwaysDisplayDecimals = !!val;
    }

    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }

    get decimalPrecision() { return this._decimalPrecision; }
    set decimalPrecision(val) {
        this._decimalPrecision = kijs.isNumeric(val) ? parseInt(val) : 2;
    }

    get decimalSeparator() { return this._decimalSeparator; }
    set decimalSeparator(val) {
        this._decimalSeparator = val;
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    // overwrite
    get inputDom() { return this._inputDom; }

    get inputMode() { return this._inputDom.nodeAttributeGet('inputMode'); }
    set inputMode(val) { this._inputDom.nodeAttributeSet('inputMode', val); }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get maxValue() { return this._maxValue; }
    set maxValue(val) {
        this._maxValue = val === null ? null : parseFloat(val);
    }

    get minValue() { return this._minValue; }
    set minValue(val) {
        this._minValue = val === null ? null : parseFloat(val);
    }

    get placeholder() { this._inputDom.nodeAttributeGet('placeholder'); }
    set placeholder(val) { this._inputDom.nodeAttributeSet('placeholder', kijs.toString(val)); }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
        this._spinUpButtonEl.disabled = val;
        this._spinDownButtonEl.disabled = val;
    }

    get spinAcceleration() { return this._spinAcceleration; }
    set spinAcceleration(val) { this._spinAcceleration = val; }

    get spinButtonsHide() { return !this._spinUpButtonEl.visible; }
    set spinButtonsHide(val) { 
        this._spinUpButtonEl.visible = !val;
        this._spinDownButtonEl.visible = !val;
    }

    get spinDelay() { return this._spinDelay; }
    set spinDelay(val) { this._spinDelay = val; }

    get spinDownButton() { return this._spinDownButtonEl; }

    get spinStep() { return this._spinStep; }
    set spinStep(val) { this._spinStep = val; }

    get spinUpButton() { return this._spinUpButtonEl; }

    get thousandsSeparator() { return this._thousandsSeparator; }
    set thousandsSeparator(val) {
        this._thousandsSeparator = val;
    }

    // overwrite
    get value() {
        let val = this._inputDom.nodeAttributeGet('value');
        val = this._unformatNumber(val);
        // Zahlen sind entweder eine Ziffer oder Null;
        return val === '' ? null : val;
    }
    // overwrite
    set value(val) {
        // Formatierung: bei ungültiger Nummer, wird der ursprüngliche Wert verwendet
        val = this._formatNumber(val);
        this._inputDom.nodeAttributeSet('value', kijs.toString(val));
        this._previousChangeValue = val;
    }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._inputDom.changeDisabled(!!val, true);
        this._spinUpButtonEl.changeDisabled(!!val, true);
        this._spinDownButtonEl.changeDisabled(!!val, true);
    }
    
    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');
        
        // Spin Buttons rendern (kijs.gui.Button)
        this._spinUpButtonEl.renderTo(this._buttonsDom.node);
        this._spinDownButtonEl.renderTo(this._buttonsDom.node);
        
        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        if (this._spinDeferId) {
            clearTimeout(this._spinDeferId);
            this._spinDeferId = null;
        }

        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        this._buttonsDom.unrender();
        
        super.unrender(true);
    }


    // PROTECTED
    // Zahl formatieren
    _formatNumber(value) {
        // vorhandene Formatierung entfernen
        value = this._unformatNumber(value);

        // Wenn Nummer nicht valide ist, wird der Ursprungswert zurückgegeben?
        if (!value.match(/^-?[0-9]+(?:\.[0-9]+)?$/)) {
            return value;
        }

        // Runden
        let digits = 0;
        if (this._allowDecimals) {
            digits = this.decimalPrecision;
        }
        value = kijs.Number.round(value, digits);

        // formatieren
        value = kijs.Number.format(
                value,
                (this._alwaysDisplayDecimals ? this._decimalPrecision : null),
                this._decimalSeparator,
                this._thousandsSeparator);

        return value;
    }

    // Startet das Hoch-/runterzählen von einem Spinnbutton
    _spinStart(dir) {
        // falls bereits gescrollt wird: abbrechen
        if (this._spinDeferId) {
            clearTimeout(this._spinDeferId);
            this._spinDeferId = null;
        }

        if (this.disabled) {
            return;
        }

        let val = this.value;
        const oldValue = val;

        if (kijs.isEmpty(val)) {
            val = 0;
        }

        val = window.parseFloat(val);

        if (window.isNaN(val)) {
            return;
        }

        switch (dir) {
            case 'up':    val += this._spinStep; break;
            case 'down':  val -= this._spinStep; break;
        }

        if (this._maxValue !== null && val > this._maxValue) {
            val = this._maxValue;
        }

        if (this._minValue !== null && val < this._minValue) {
            val = this._minValue;
        }

        val = this._formatNumber(val);
        this._inputDom.nodeAttributeSet('value', kijs.toString(val));

        let step = 10; // Minimalintervall
        if (this._spinAcceleration > 0) {
            step = parseInt(this._spinDelayCurrent / 100 * this._spinAcceleration);
        }
        this._spinDelayCurrent = this._spinDelayCurrent - step;
        if (this._spinDelayCurrent < 10) {
            this._spinDelayCurrent = 10;
        }

        // Validieren
        this.validate();

        // input-event auslösen
        this.raiseEvent('input', {
            value: val,
            oldValue: oldValue
        });

        this._spinDeferId = kijs.defer(this._spinStart, this._spinDelayCurrent, this, dir);
    }

    // Stopt das Hoch-/Runterzählen von einem Spinnbutton
    _spinStop() {
        if (this._spinDeferId) {
            clearTimeout(this._spinDeferId);
            this._spinDeferId = null;
        }

        let val = this.value;
        let oldVal = this._previousChangeValue;
        this._previousChangeValue = val;

        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    // Formatierung einer Zahl entfernen
    _unformatNumber(value) {
        value = kijs.toString(value).trim();

        // Tausendertrennzeichen entfernen
        kijs.Array.each(this._allowedThousandsSeparators, function(sep) {
            value = kijs.String.replaceAll(value, sep, '');
        }, this);

        // Dezimaltrennzeichen durch . ersetzen
        kijs.Array.each(this._allowedDecimalSeparators, function(sep) {
            value = kijs.String.replaceAll(value, sep, '.');
        }, this);

        // Falls die Zahl mit einem Dezimaltrennzeichen endet, dieses entfernen.
        value = value.replace(/[\.]+$/, '');

        return value;
    }

    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        let initialValue = value;

        super._validationRules(value, ignoreEmpty);

        value = kijs.toString(value).trim();

        // Falls das Feld leer ist, nichts weiter tun.
        if (value === '') {
            return;
        }

        // Formatierung entfernen
        value = this._unformatNumber(value);

        // valide Nummer?
        if (!value.match(/^-?[0-9]+\.?[0-9]*?$/)) {
            this._errors.push(kijs.getText('%1 ist keine gültige Nummer', '', initialValue));
            return;
        }

        // runden, damit min und max geprüft werden können
        if (this._allowDecimals) {
            value = window.parseFloat(value);
            value = kijs.Number.round(value, this._decimalPrecision);
        } else {
            value = window.parseInt(value);
        }

        // Min. value testen
        if (this._minValue !== null && value < this._minValue) {
            this._errors.push(kijs.getText('Der minimale Wert für dieses Feld ist %1', '', this._minValue));
        }

        // Max. value testen
        if (this._maxValue !== null && value > this._maxValue) {
            this._errors.push(kijs.getText('Der maximale Wert für dieses Feld ist %1', '', this._maxValue));
        }
    }


    // PRIVATE
    // LISTENERS
    #onInputDomChange(e) {
        // Beim verlassen des Feldes, Zahl auf eingestelltes Format ändern.
        // Wenn Nummer ungültig, die Nummer belassen
        let val = this.value;
        let oldVal = this._previousChangeValue;

        // Wert neu reinschreiben (evtl. wurde er Formatiert)
        this.value = val;
        
        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    #onInputDomInput(e) {
        this.validate();
    }

    #onSpinDownButtonMouseDown() {
        this._spinDelayCurrent = this._spinDelay;
        this._spinStart('down');
    }

    #onSpinDownButtonMouseLeave() {
        this._spinStop();
        this._inputDom.focus();
    }
    
    #onSpinDownButtonMouseUp() {
        this._spinStop();
        this._inputDom.focus();
    }

    #onSpinUpButtonMouseDown() {
        this._spinDelayCurrent = this._spinDelay;
        this._spinStart('up');
    }

    #onSpinUpButtonMouseLeave() {
        this._spinStop();
        this._inputDom.focus();
    }
    #onSpinUpButtonMouseUp() {
        this._spinStop();
        this._inputDom.focus();
    }
    



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }
        if (this._spinUpButtonEl) {
            this._spinUpButtonEl.destruct();
        }
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._spinDownButtonEl) {
            this._spinDownButtonEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._allowedDecimalSeparators = null;
        this._allowedThousandsSeparators = null;
        this._inputDom = null;
        this._buttonsDom = null;
        this._spinUpButtonEl = null;
        this._spinDownButtonEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Memo
// --------------------------------------------------------------
kijs.gui.field.Memo = class kijs_gui_field_Memo extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._valueTrimEnable = true;
        this._previousChangeValue = '';

        this._inputDom = new kijs.gui.Dom({
            disableEnterBubbeling: true,
            nodeTagName: 'textarea',
            nodeAttribute: {
                id: this._inputId
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                context: this
            }
        });

        this._dom.clsAdd('kijs-field-memo');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            inputMode: { target: 'inputMode' },
            valueTrimEnable: true,             // Sollen Leerzeichen am Anfang und Ende des Values automatisch entfernt werden?
            placeholder: { target: 'placeholder' },
            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    get inputMode() { return this._inputDom.nodeAttributeGet('inputMode'); }
    set inputMode(val) { this._inputDom.nodeAttributeSet('inputMode', val); }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get placeholder() { this._inputDom.nodeAttributeGet('placeholder'); }
    set placeholder(val) {
        this._inputDom.nodeAttributeSet('placeholder', kijs.toString(val));
    }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
    }

    // overwrite
    get value() {
        let val = kijs.toString(this._inputDom.nodeAttributeGet('value'));
        if (this._valueTrimEnable) {
            val = val.trim();
        }
        return val;
    }
    set value(val) {
        val = kijs.toString(val);
        this._inputDom.nodeAttributeSet('value', val);
        this._previousChangeValue = val;
    }

    get valueTrimEnable() { return this._valueTrimEnable; }
    set valueTrimEnable(val) { this._valueTrimEnable = !!val; }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }


    // overwrite
    unrender(superCall) {
        if (!superCall) {
            // Event auslösen.
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        super.unrender(true);
    }


    // PRIVATE
    // LISTENERS
    #onInputDomChange(e) {
        // Sicherstellen, dass beim Verlassen des Feldes noch getrimmt wird.
        let val = this.value;
        let oldVal = this._previousChangeValue;

        // Wert neu reinschreiben (evtl. wurde er getrimmt)
        this.value = val;

        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    #onInputDomInput(e) {
        this.validate();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Password
// --------------------------------------------------------------
kijs.gui.field.Password = class kijs_gui_field_Password extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._disableBrowserSecurityWarning = false;
        this._passwordChar = '●';
        this._valueTrimEnable = false;
        this._previousChangeValue = '';

        this._value = '';

        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'input',
            nodeAttribute: {
                id: this._inputId,
                type: 'password',
                autocomplete: 'off'
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                context: this
            }
        });

        this._dom.clsAdd('kijs-field-password');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableBrowserSecurityWarning: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            disableBrowserSecurityWarning: { prio: -1, target: 'disableBrowserSecurityWarning' },  // false: Nimmt das Standard Passwort-Feld
                                                                    // true:  Eigenes Feld, dass nicht als Kennwort-Feld erkannt wird und
                                                                    //        deshalb auch keine Warnung bei unsicherer Verbindung ausgibt
                                                                    // 'auto' bei unsicherer Verbindung && Firefox = true sonst false
            passwordChar: true,
            valueTrimEnable: true,             // Sollen Leerzeichen am Anfang und Ende des Values automatisch entfernt werden?
            placeholder: { target: 'placeholder' },

            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get disableBrowserSecurityWarning() { return this._disableBrowserSecurityWarning; }
    set disableBrowserSecurityWarning(val) {
        if (val === 'auto') {
            val = kijs.Navigator.isFirefox && window.isSecureContext === false;
        }

        // Evtl. eigenes Passwort-Feld ohne Sicherheitswarnung erstellen
        if (val) {
            this._inputDom.nodeAttributeSet('type', 'text');

            // DOM-Events
            this._inputDom.on('keyUp', this.#onInputDomKeyUp, this);
            this._inputDom.on('mouseUp', this.#onInputDomMouseUp, this);
        } else {
            this._inputDom.nodeAttributeSet('type', 'password');

            // DOM-Events
            this._inputDom.off('keyUp', this.#onInputDomKeyUp, this);
            this._inputDom.off('mouseUp', this.#onInputDomMouseUp, this);

        }

        this._disableBrowserSecurityWarning = !!val;
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get passwordChar() { return this._passwordChar; }
    set passwordChar(val) { this._passwordChar = val; }

    get placeholder() { this._inputDom.nodeAttributeGet('placeholder'); }
    set placeholder(val) { this._inputDom.nodeAttributeSet('placeholder', kijs.toString(val)); }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
    }

    // overwrite
    get value() {
        let val;

        if (this._disableBrowserSecurityWarning) {
            val = this._value;
        } else {
            val = kijs.toString(this._inputDom.nodeAttributeGet('value'));
        }
        if (this._valueTrimEnable) {
            val = val.trim();
        }
        return val;
    }
    set value(val) {
        val = kijs.toString(val);
        if (this._disableBrowserSecurityWarning) {
            this._value = val;
            this._inputDom.nodeAttributeSet('value', val.replace(/./g, this._passwordChar));
        } else {
            this._inputDom.nodeAttributeSet('value', val);
        }
        this._previousChangeValue = val;
    }

    get valueTrimEnable() { return this._valueTrimEnable; }
    set valueTrimEnable(val) { this._valueTrimEnable = !!val; }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        super.unrender(true);
    }


    // PROTECTED
    // Stellt sicher, dass der Cursor nur ans Feldende gesetzt oder alles markiert werden kann
    _reposCursor() {
        const val = this._inputDom.node.value;
        const len = val.length;

        if (this._inputDom.node.selectionStart===0 && this._inputDom.node.selectionEnd===len)  {
            // alles ist markiert: ok
        } else if (this._inputDom.node.selectionStart===len && this._inputDom.node.selectionEnd===len)  {
            // cursor ist am Ende: ok
        } else {
            // sonst alles markieren
            this._inputDom.node.selectionStart = 0;
            this._inputDom.node.selectionEnd = len;
        }
    }


    // PRIVATE
    // LISTENERS
    #onInputDomChange(e) {
        // Sicherstellen, dass beim Verlassen des Feldes noch getrimmt wird.
        let val = this.value;
        let oldVal = this._previousChangeValue;

        // Wert neu reinschreiben (evtl. wurde er getrimmt)
        this.value = val;

        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    #onInputDomInput(e) {
        if (this._disableBrowserSecurityWarning) {
            const val = kijs.toString(this._inputDom.nodeAttributeGet('value'));
            const len = val.length;

            this._value = kijs.isEmpty(this._value) ? '' : this._value;

            // Neue Zeichen ermittteln
            var newChars = kijs.String.replaceAll(val, this._passwordChar, '');

            // Ist das Feld nun leer?
            if (val === '') {
                this._value = '';

            // Sonst: Wenn das erste Zeichen neu ist, so ist der ganze Wert neu
            } else if (val.substr(0,1) !== this._passwordChar) {
                this._value = newChars;

            // Sonst: Wenn das letzte Zeichen neu ist, so bleibt der Anfang evtl. bestehen
            // und die neuen Zeichen werden am Ende angefügt
            } else if (val.substr(len-1,1) !== this._passwordChar) {
                // alte Zeichen bleiben bestehen
                const oldChars = this._value.substr(0, len - newChars.length);
                this._value = oldChars + newChars;

            // Oder wurde mit Backspace das letzte Zeichen gelöscht?
            } else if (len < this._value.length) {
                this._value = this._value.substr(0, len);

            }

            this._inputDom.nodeAttributeSet('value', this._value.replace(/./g, this._passwordChar));
        }

        this.validate();
    }

    #onInputDomKeyUp(e) {
        this._reposCursor();
    }

    #onInputDomMouseUp(e) {
        kijs.defer(this._reposCursor, 10, this);
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.ListView
// --------------------------------------------------------------
kijs.gui.field.ListView = class kijs_gui_field_ListView extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        this._minSelectCount = null;
        this._maxSelectCount = null;
        this._previousChangeValue = [];
        this._value = null;

        this._listView = new kijs.gui.ListView({});

        this._dom.clsAdd('kijs-field-listview');
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            ddName: kijs.uniqId('listView.element')
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            showCheckBoxes: { target: 'showCheckBoxes', context: this._listView },
            selectType: { target: 'selectType', context: this._listView },
            
            captionField: { target: 'captionField', context: this._listView },
            iconCharField: { target: 'iconCharField', context: this._listView },
            iconMapField: { target: 'iconMapField', context: this._listView },
            iconClsField: { target: 'iconClsField', context: this._listView },
            iconColorField: { target: 'iconColorField', context: this._listView },
            tooltipField: { target: 'tooltipField', context: this._listView },
            valueField: { target: 'valueField', context: this._listView },
            
            ddName: { target: 'ddName', context: this._listView },
            ddPosAfterFactor: { target: 'ddPosAfterFactor', context: this._listView },
            ddPosBeforeFactor: { target: 'ddPosBeforeFactor', context: this._listView },
            sortable: { target: 'sortable', context: this._listView },
            ddTarget: { target: 'ddTarget', context: this._listView },
            
            rpcSaveFn: { target: 'rpcSaveFn', context: this._listView },
            rpcSaveArgs: { target: 'rpcSaveArgs', context: this._listView },
            autoSave: { target: 'autoSave', context: this._listView }, // Auto-Speichern bei DD
            
            minSelectCount: true,
            maxSelectCount: true,

            data: { prio: 1000, target: 'data', context: this._listView },
            value: { prio: 1001, target: 'value' }
        });

        // Listeners
        this._listView.on('selectionChange', this.#onListViewSelectionChange, this);
        this._listView.once('afterLoad', this.#onceListViewAfterLoad, this);
        this._eventForwardsAdd('ddOver', this._listView);
        this._eventForwardsAdd('ddDrop', this._listView.dom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get captionField() { return this._listView.captionField; }
    set captionField(val) { this._listView.captionField = val; }

    get data() { return this._listView.data; }
    set data(val) { this._listView.data = val; }

    // overwrite
    get elements() { return this._listView.elements; }

    // overwrite
    get hasFocus() { return this._listView.hasFocus; }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get listView() { return this._listView; }
    
    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._listView.disabled = val || this._dom.clsHas('kijs-disabled');
    }

    get selectType() { return this._listView.selectType; }
    set selectType(val) { this._listView.selectType = val; }

    // overwrite
    get value() { return this._listView.value; }
    set value(val) {
        this._value = val;
        this._listView.value = this._value;
        this._previousChangeValue = this._value;
    }

    get valueField() { return this._listView.valueField; }
    set valueField(val) { this._listView.valueField = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt Daten hinzu
     * @param {Array} data
     * @returns {undefined}
     */
    addData(data) {
        this._listView.addData(data);
    }

    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._listView.changeDisabled(!!val || this._dom.clsHas('kijs-readonly'), false);
    }

    // overwrite
    focus(alsoSetIfNoTabIndex) {
        return this._listView.focus(alsoSetIfNoTabIndex);
    }
    
    /**
     * Füllt das Listview mit Daten vom Server
     * @param {Object|Null} [args] Objekt mit Argumenten, die an die remoteFn übergeben werden
     * @param {Boolean} [superCall=false]
     * @returns {Promise}
     */
    load(args, superCall=false) {
        return new Promise((resolve, reject) => {
            super.load(args, true).then((e) => {
                let config = e.responseData.config ?? {};
                
                // Falls ein neuer Wert zurückgegeben wird, diesen nehmen
                if (kijs.isDefined(config.value)) {
                    this._value = config.value;
                }
                
                this._listView.data = config.data;

                if (!kijs.isEmpty(this._value)) {
                    this.value = this._value;
                }
                
                if (!kijs.isEmpty(config.selectFilters)) {
                    this._listView.selectByFilters(config.selectFilters);
                }
                
                // 'afterLoad' auslösen
                if (!superCall) {
                    this.raiseEvent('afterLoad', e);
                }
                
                // Promise ausführen
                resolve(e);
                
            }).catch((ex) => {
                reject(ex);
                
            });
        });
    }

    // overwrite
    render(superCall) {
        super.render(true);

        this._listView.renderTo(this._inputWrapperDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._listView.unrender();
        super.unrender(true);
    }


    // PROTECTED
    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        super._validationRules(value, ignoreEmpty);

        // minSelectCount
        if (!kijs.isEmpty(this._minSelectCount)) {
            const minSelectCount = this._minSelectCount;

            if (kijs.isArray(value)) {
                if (value.length < minSelectCount) {
                    this._errors.push(`Min. ${minSelectCount} müssen ausgewählt werden`);
                }
            } else if (kijs.isEmpty(value) && minSelectCount > 0) {
                this._errors.push(`Min. ${minSelectCount} müssen ausgewählt werden`);
            }
        }

        // maxSelectCount
        if (!kijs.isEmpty(this._maxSelectCount)) {
            const maxSelectCount = this._maxSelectCount;

            if (kijs.isArray(value)) {
                if (value.length > maxSelectCount) {
                    this._errors.push(`Max. ${maxSelectCount} dürfen ausgewählt werden`);
                }
            } else if (!kijs.isEmpty(value) && maxSelectCount < 1) {
                this._errors.push(`Max. ${maxSelectCount} dürfen ausgewählt werden`);
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onceListViewAfterLoad() {
        this.isDirty = false; // reset the dirty flag after first loading data from remote
    }

    #onListViewSelectionChange() {
        const val = this.value;

        this.raiseEvent('input', { oldValue: this._previousChangeValue, value: val });
        this.raiseEvent('change', { oldValue: this._previousChangeValue, value: val });
        this._previousChangeValue = val;

        this.validate();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._listView) {
            this._listView.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._listView = null;
        this._minSelectCount = null;
        this._maxSelectCount = null;
        this._previousChangeValue = [];
        this._value = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Switch
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Switch = class kijs_gui_field_Switch extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._checked = 0;                          // 0=unchecked, 1=checked

        this._valueChecked = true;
        this._valueUnchecked = false;
        this._dragPosXStart = null;
        this._dragHasDistance = false;
        
        this._inputDom = new kijs.gui.Dom({
            cls: 'kijs-toggleBorder',
            nodeTagName: 'div'
        });
        this._inputDom.nodeAttributeSet('tabIndex', 0);

        this._togglePointDom = new kijs.gui.Dom({
            cls: 'kijs-togglePoint',
            nodeTagName: 'div',
            on: {
                mouseDown: this.#onMouseDown,
                context: this
            }
        });
        
        // Touch-Devices
        if (kijs.Navigator.isTouch) {
            this._togglePointDom.on('touchStart', this.#onTouchStart, this);
        }

        this._iconEl = new kijs.gui.Icon({
            parent: this
        });

        this._captionDom = new kijs.gui.Dom({
            cls: 'kijs-caption',
            nodeTagName: 'span',
            htmlDisplayType: 'code'
        });

        this._dom.clsAdd('kijs-field-switch');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            captionHtmlDisplayType: 'code',
            disableFlex: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            caption: { target: 'html', context: this._captionDom, prio: 2 },
            captionCls: { fn: 'function', target: this._captionDom.clsAdd, context: this._captionDom },
            captionHide: true,
            captionHtmlDisplayType: { target: 'htmlDisplayType', context: this._captionDom, prio: 1 },
            captionStyle: { fn: 'assign', target: 'style', context: this._captionDom },
            captionWidth: { target: 'captionWidth' },

            icon: { target: 'icon' },
            iconChar: { target: 'iconChar', context: this._iconEl },
            iconCls: { target: 'iconCls', context: this._iconEl },
            iconColor: { target: 'iconColor', context: this._iconEl },
            iconMap: { target: 'iconMap', context: this._iconEl },

            valueChecked: { prio: 1002, target: '_valueChecked' },
            valueUnchecked: { prio: 1002, target: '_valueUnchecked' },

            value: { prio: 1003, target: 'value' },
            checked: { prio: 1004, target: 'checked' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('blur', this._inputDom);

        // Listeners
        this._labelDom.on('click', this.#onClick, this);
        this._inputWrapperDom.on('click', this.#onClick, this);
        this._inputDom.on('spacePress', this.#onSpacePress, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._captionDom.html; }
    set caption(val) {
        this._captionDom.html = val;
    }

    get captionDom() { return this._captionDom; }

    get captionHtmlDisplayType() { return this._captionDom.htmlDisplayType; }
    set captionHtmlDisplayType(val) { this._captionDom.htmlDisplayType = val; }

    get captionWidth() { return this._captionDom.width; }
    set captionWidth(val) { this._captionDom.width = val; }

    get checked() { return this._checked; }
    set checked(val) {
        if (val === 1 || val === '1' || val === true) {
            this._checked = 1;
        } else if (val === 0 || val === '0' || val === false || kijs.isEmpty(val)) {
            this._checked = 0;
        } else {
            throw new kijs.Error(`config "checked" is not valid.`);
        }
        this._updateTogglePoint(this._checked);
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get icon() { return this._iconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set icon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconEl.iconChar = null;
            this._iconEl.iconCls = null;
            this._iconEl.iconColor = null;
            if (this.isRendered) {
                this.render();
            }

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconEl.destruct();
            this._iconEl = val;
            if (this.isRendered) {
                this.render();
            }

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconEl.applyConfig(val);
            if (this.isRendered) {
                this.render();
            }

        } else {
            throw new kijs.Error(`config "icon" is not valid.`);

        }
    }

    get iconChar() { return this._iconEl.iconChar; }
    set iconChar(val) { this._iconEl.iconChar = val; }

    get iconCls() { return this._iconEl.iconCls; }
    set iconCls(val) { this._iconEl.iconCls = val; }

    get iconColor() { return this._iconEl.iconColor; }
    set iconColor(val) { this._iconEl.iconColor = val; }

    get iconMap() { return this._iconEl.iconMap; }
    set iconMap(val) { this._iconEl.iconMap = val; }

    get inputWrapperDom() { return this._inputWrapperDom; }

    // overwrite
    get isEmpty() { return this._checked === 0; }

    // overwrite
    get value() {
        switch (this._checked) {
            case 0: return this._valueUnchecked;
            case 1: return this._valueChecked;
        }
    }
    set value(val) {
        if (val === this._valueUnchecked || val === false || val === 0 || val === '0') {
            this._checked = 0;
        } else if (val === this._valueChecked || val === true || val === 1 || val === '1') {
            this._checked = 1;
        } else if (val === null) {
            this._checked = 0;
        } else {
            throw new kijs.Error(`config "value" is not valid.`);
        }
        this._updateTogglePoint(this._checked);
    }

    get valueChecked() { return this._valueChecked; }
    set valueChecked(val) { this._valueChecked = val; }

    get valueUnchecked() { return this._valueUnchecked; }
    set valueUnchecked(val) { this._valueUnchecked = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    focus(alsoSetIfNoTabIndex) {
        return this._inputDom.focus(alsoSetIfNoTabIndex);
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Toggle-Border rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Toggle-Punkt rendern (kijs.guiDom)
        this._togglePointDom.renderTo(this._inputDom.node);
        this._updateTogglePoint(this._checked);

        // Span icon rendern (kijs.gui.Icon)
        if (!this._iconEl.isEmpty) {
            this._iconEl.renderTo(this._inputWrapperDom.node);
        } else if (this._iconEl.isRendered) {
            this._iconEl.unrender();
        }

        // Span caption rendern (kijs.guiDom)
        if (!this._captionDom.isEmpty) {
            this._captionDom.renderTo(this._inputWrapperDom.node);
        } else if (this._captionDom.isRendered) {
            this._captionDom.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._togglePointDom.unrender();
        this._inputDom.unrender();
        this._iconEl.unrender();
        this._captionDom.unrender();
        super.unrender(true);
    }


    // PROTECTED
    _dragEnd(e) {
        const checked = this._dom.clsHas('kijs-checked') ? 1 : 0;

        this._togglePointDom.style.marginLeft = null;
        
        // Wurde ein Weg von mehr als 1 Pixel zurückgelegt: Click-Event verhindern
        if (this._dragHasDistance) {
            kijs.defer(function(){
                this._dragHasDistance = false;
            }, 50, this);
        }
        
        if (checked !== this._checked) {
            // focus setzen
            this.focus();

            const oldChecked = this._checked;
            const oldValue = this.value;

            this._checked = checked;

            //this._updateTogglePoint(this._checked);
            this.validate();

            this.raiseEvent('change', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
        }
        this._dragPosXStart = null;
    }
    
    _dragMove(x) {
        let deltaX = x - this._dragPosXStart;

        // Max Position berechnen
        const max = this._inputDom.width - this._togglePointDom.height;

        // Falls Checked muss noch der bestehende margin addiert werden
        if (this._checked) {
            deltaX += max;
        }

        // Begrenzen auf Min/Max-Werte
        if (deltaX > max) {
            deltaX = max;
        } else if (deltaX < 0) {
            deltaX = 0;
        }
        
        // Wurde ein Weg von mehr als 1 Pixel zurückgelegt, dann wird später das
        // Click-Event verhindert.
        if (deltaX > 1) {
            this._dragHasDistance = true;
        }
        
        // In der Mitte ist die Schaltschwelle
        const checked = deltaX > max/2 ? 1 : 0;
        this._updateTogglePoint(checked);

        this._togglePointDom.style.marginLeft = deltaX + 'px';
    }
    
    _dragStart(x) {
        // Startposition merken
        this._dragPosXStart = x;
    }

    _updateTogglePoint(checked) {
        let cls;
        
        if (checked) {
            cls = 'kijs-checked';
        } else {
            cls = 'kijs-unchecked';
        }

        this._dom.clsRemove(['kijs-checked', 'kijs-unchecked']);
        this._dom.clsAdd(cls);
    }

    // overwrite
    _validateRequired(value, ignoreEmpty) {
        if (this._required) {
            if (!value) {
                this._errors.push(kijs.getText('Dieses Feld darf nicht leer sein'));
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onClick(e) {
        if (!this.readOnly && !this.disabled && !this._dragHasDistance) {
            const oldChecked = this._checked;
            const oldValue = this.value;

            this._checked = this._checked ? 0 : 1;

            this._updateTogglePoint(this._checked);
            this._inputDom.focus();
            this.validate();

            this.raiseEvent('input', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
            
            this.raiseEvent('change', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
        }
    }

    #onSpacePress(e) {
        if (!this.readOnly && !this.disabled) {
            const oldChecked = this._checked;
            const oldValue = this.value;

            this._checked = this._checked ? 0 : 1;

            this._updateTogglePoint(this._checked);
            this.validate();

            this.raiseEvent('change', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
        }
        // Bildlauf der Space-Taste verhindern
        e.nodeEvent.preventDefault();
    }
    
    #onMouseDown(e) {
        if (!this.readOnly && !this.disabled) {
            this._dragStart(e.nodeEvent.clientX);
        
            // mouseMove und mouseUp Listeners aufs document setzen
            kijs.Dom.addEventListener('mousemove', document, this.#onMouseMove, this);
            kijs.Dom.addEventListener('mouseup', document, this.#onMouseUp, this);
        }
    }
    
    #onMouseMove(e) {
        if (!this.readOnly && !this.disabled && this._dragPosXStart !== null) {
            this._dragMove(e.nodeEvent.clientX);
        }
    }
    
    #onMouseUp(e) {
        // Beim ersten Auslösen des Listeners, gleich wieder entfernen
        kijs.Dom.removeEventListener('mousemove', document, this);
        kijs.Dom.removeEventListener('mouseup', document, this);

        if (!this.readOnly && !this.disabled && this._dragPosXStart !== null) {
            this._dragEnd(e);
        }
    }
    
    #onTouchEnd(e) {
        // Beim ersten Auslösen des Listeners, gleich wieder entfernen
        this._inputWrapperDom.off('touchMove', this.#onTouchMove, this);
        this._inputWrapperDom.off('touchEnd', this.#onTouchEnd, this);
        
        if (!this.readOnly && !this.disabled && this._dragPosXStart !== null) {
            this._dragEnd(e);
        }
    }
    
    #onTouchMove(e) {
        if (!this.readOnly && !this.disabled && this._dragPosXStart !== null) {
            this._dragMove(e.nodeEvent.touches[0].clientX);

            // Bubbeling und native Listeners verhindern
            e.nodeEvent.stopPropagation();
            e.nodeEvent.preventDefault();
        }
    }
    
    #onTouchStart(e) {
        if (!this.readOnly && !this.disabled) {
            this._dragStart(e.nodeEvent.touches[0].clientX);
            
            // touchMove und touchEnd Listeners setzen
            this._inputWrapperDom.on('touchMove', this.#onTouchMove, this);
            this._inputWrapperDom.on('touchEnd', this.#onTouchEnd, this);
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._togglePointDom) {
            this._togglePointDom.destruct();
        }

        if (this._inputDom) {
            this._inputDom.destruct();
        }

        if (this._iconEl) {
            this._iconEl.destruct();
        }

        if (this._captionDom) {
            this._captionDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._togglePointDom = null;
        this._inputDom = null;
        this._iconEl = null;
        this._captionDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Checkbox
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Checkbox = class kijs_gui_field_Checkbox extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._checked = 0;                          // 0=unchecked, 1=checked, 2=indeterminated

        this._checkedIconMap = 'kijs.iconMap.Fa.check';
        this._determinatedIconMap = 'kijs.iconMap.Fa.minus';
        this._uncheckedIconMap = null;

        this._threeState = false;                   // Erreichen des dritte Status "Intermediate" per Klick möglich?

        this._valueChecked = true;
        this._valueDeterminated = 2;
        this._valueUnchecked = false;

        this._inputWrapperDom.nodeAttributeSet('tabIndex', 0);

        this._checkboxIconEl = new kijs.gui.Icon({
            parent: this,
            cls: 'kijs-checkbox-input'
        });

        this._iconEl = new kijs.gui.Icon({
            parent: this,
            cls: 'kijs-checkbox-icon'
        });

        this._captionDom = new kijs.gui.Dom({
            cls: 'kijs-caption',
            nodeTagName: 'span',
            htmlDisplayType: 'code'
        });

        this._dom.clsAdd('kijs-field-checkbox');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false,
            captionHtmlDisplayType: 'code',
            disableFlex: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            caption: { target: 'html', context: this._captionDom, prio: 2 },
            captionCls: { fn: 'function', target: this._captionDom.clsAdd, context: this._captionDom },
            captionHide: true,
            captionHtmlDisplayType: { target: 'htmlDisplayType', context: this._captionDom, prio: 1 },
            captionStyle: { fn: 'assign', target: 'style', context: this._captionDom },
            captionWidth: { target: 'captionWidth' },

            checkedIconMap: true,
            determinatedIconMap: true,
            uncheckedIconMap: true,

            icon: { target: 'icon' },
            iconChar: { target: 'iconChar', context: this._iconEl },
            iconCls: { target: 'iconCls', context: this._iconEl },
            iconColor: { target: 'iconColor', context: this._iconEl },
            iconMap: { target: 'iconMap', context: this._iconEl },

            threeState: { prio: 1001, target: '_threeState' },

            valueChecked: { prio: 1002, target: '_valueChecked' },
            valueUnchecked: { prio: 1002, target: '_valueUnchecked' },
            valueDeterminated: { prio: 1002, target: '_valueDeterminated' },

            value: { prio: 1003, target: 'value' },
            checked: { prio: 1004, target: 'checked' }
        });

        // Event-Weiterleitungen von this._inputWrapperDom
        this._eventForwardsAdd('focus', this._inputWrapperDom);
        this._eventForwardsAdd('blur', this._inputWrapperDom);

        // Listeners
        this._labelDom.on('click', this.#onClick, this);
        this._inputWrapperDom.on('click', this.#onClick, this);
        this._inputWrapperDom.on('spacePress', this.#onSpacePress, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._captionDom.html; }
    set caption(val) {
        this._captionDom.html = val;
    }

    get captionDom() { return this._captionDom; }

    get captionHtmlDisplayType() { return this._captionDom.htmlDisplayType; }
    set captionHtmlDisplayType(val) { this._captionDom.htmlDisplayType = val; }

    get captionWidth() { return this._captionDom.width; }
    set captionWidth(val) { this._captionDom.width = val; }

    get checkboxIcon() { return this._checkboxIconEl; }

    get checked() { return this._checked; }
    set checked(val) {
        if (val === 2 || val === '2') {
            this._checked = 2;
        } else if (val === 1 || val === '1' || val === true) {
            this._checked = 1;
        } else if (val === 0 || val === '0' || val === false || kijs.isEmpty(val)) {
            this._checked = 0;
        } else {
            throw new kijs.Error(`config "checked" is not valid.`);
        }
        this._updateCheckboxIcon();
    }

    // overwrite
    get hasFocus() { return this._inputWrapperDom.hasFocus; }

    get icon() { return this._iconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set icon(val) {
        // Icon zurücksetzen?
        if (kijs.isEmpty(val)) {
            this._iconEl.iconChar = null;
            this._iconEl.iconCls = null;
            this._iconEl.iconColor = null;

        // kijs.gui.Icon Instanz
        } else if (val instanceof kijs.gui.Icon) {
            this._iconEl.destruct();
            this._iconEl = val;

        // Config Objekt
        } else if (kijs.isObject(val)) {
            this._iconEl.applyConfig(val);

        } else {
            throw new kijs.Error(`config "icon" is not valid.`);

        }
        
        if (this.isRendered) {
            this.render();
        }
    }

    get iconChar() { return this._iconEl.iconChar; }
    set iconChar(val) { this._iconEl.iconChar = val; }

    get iconCls() { return this._iconEl.iconCls; }
    set iconCls(val) { this._iconEl.iconCls = val; }

    get iconColor() { return this._iconEl.iconColor; }
    set iconColor(val) { this._iconEl.iconColor = val; }

    get iconMap() { return this._iconEl.iconMap; }
    set iconMap(val) { this._iconEl.iconMap = val; }

    get inputWrapperDom() { return this._inputWrapperDom; }

    // overwrite
    get isEmpty() { return this._checked === 0; }

    get threeState() { return this._threeState; }
    set threeState(val) { this._threeState = val; }

    // overwrite
    get value() {
        switch (this._checked) {
            case 0: return this._valueUnchecked;
            case 1: return this._valueChecked;
            case 2: return this._valueDeterminated;
        }
    }
    set value(val) {
        if (val === this._valueUnchecked || val === false || val === 0 || val === '0') {
            this._checked = 0;
        } else if (val === this._valueChecked || val === true || val === 1 || val === '1') {
            this._checked = 1;
        } else if (val === this._valueDeterminated ||val === 2) {
            this._checked = 2;
        } else if (val === null) {
            this._checked = 0;
        } else {
            throw new kijs.Error(`config "value" is not valid.`);
        }
        this._updateCheckboxIcon();
    }

    get valueChecked() { return this._valueChecked; }
    set valueChecked(val) { this._valueChecked = val; }

    get valueDeterminated() { return this._valueDeterminated; }
    set valueDeterminated(val) { this._valueDeterminated = val; }

    get valueUnchecked() { return this._valueUnchecked; }
    set valueUnchecked(val) { this._valueUnchecked = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    focus(alsoSetIfNoTabIndex) {
        return this._inputWrapperDom.focus(alsoSetIfNoTabIndex);
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Checkbox rendern (kijs.guiDom)
        this._checkboxIconEl.renderTo(this._inputWrapperDom.node);
        this._updateCheckboxIcon();

        // Span icon rendern (kijs.gui.Icon)
        if (!this._iconEl.isEmpty) {
            this._iconEl.renderTo(this._inputWrapperDom.node);
        } else if (this._iconEl.isRendered) {
            this._iconEl.unrender();
        }

        // Span caption rendern (kijs.guiDom)
        if (!this._captionDom.isEmpty) {
            this._captionDom.renderTo(this._inputWrapperDom.node);
        } else if (this._captionDom.isRendered) {
            this._captionDom.unrender();
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._checkboxIconEl.unrender();
        this._iconEl.unrender();
        this._captionDom.unrender();
        super.unrender(true);
    }


    // PROTECTED
    _updateCheckboxIcon() {
        let cls, iconMap;

        switch (this._checked) {
            case 0:
                cls = 'kijs-unchecked';
                iconMap = this._uncheckedIconMap;
                break;

            case 1:
                cls = 'kijs-checked';
                iconMap = this._checkedIconMap;
                break;

            case 2:
                cls = 'kijs-determinated';
                iconMap = this._determinatedIconMap;
                break;
        }

        this._dom.clsRemove(['kijs-checked', 'kijs-determinated', 'kijs-unchecked']);
        this._dom.clsAdd(cls);
        this._checkboxIconEl.iconMap = iconMap;
    }

    // overwrite
    _validateRequired(value, ignoreEmpty) {
        if (this._required) {
            if (!value) {
                this._errors.push(kijs.getText('Dieses Feld darf nicht leer sein'));
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onClick(e) {
        if (!this.readOnly && !this.disabled) {
            const oldChecked = this._checked;
            const oldValue = this.value;

            this._checked ++;

            if (this._threeState) {
                if (this._checked > 2) {
                    this._checked = 0;
                }
            } else {
                if (this._checked > 1) {
                    this._checked = 0;
                }
            }

            this._updateCheckboxIcon();
            this._checkboxIconEl.focus();
            this.validate();

            this.raiseEvent('input', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
            this.raiseEvent('change', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
        }
    }

    #onSpacePress(e) {
        if (!this.readOnly && !this.disabled) {
            const oldChecked = this._checked;
            const oldValue = this.value;

            this._checked ++;

            if (this._threeState) {
                if (this._checked > 2) {
                    this._checked = 0;
                }
            } else {
                if (this._checked > 1) {
                    this._checked = 0;
                }
            }

            this._updateCheckboxIcon();
            this.validate();

            this.raiseEvent('change', {
                checked: this._checked,
                oldChecked: oldChecked,
                value: this.value,
                oldValue: oldValue
            });
        }
        // Bildlauf der Space-Taste verhindern
        e.nodeEvent.preventDefault();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._checkboxIconEl) {
            this._checkboxIconEl.destruct();
        }

        if (this._iconEl) {
            this._iconEl.destruct();
        }

        if (this._captionDom) {
            this._captionDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._checkboxIconEl = null;
        this._iconEl = null;
        this._captionDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */


// TODO: Eigenschaft "checkedValues" entfernen. Der Name ist verwirrend und es besteht eine grosse
// Ähnlichkeit zu value. Evtl. dafür neue Funktionen: checkAll(), uncheckAll() oder noch besser die 
// Filter des zugrundeliegenden DataView verwenden.

// --------------------------------------------------------------
// kijs.gui.field.CheckboxGroup
// --------------------------------------------------------------
kijs.gui.field.CheckboxGroup = class kijs_gui_field_CheckboxGroup extends kijs.gui.field.ListView {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._checkedAll = false;

        this._dom.clsRemove('kijs-field-listview');
        this._dom.clsAdd('kijs-field-checkboxgroup');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableFlex: true,
            showCheckBoxes: true,
            selectType: 'simple',
            captionField: 'caption',
            valueField: 'value'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            checkedAll: { target: 'checkedAll', prio: 1005 }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // Alle Checkboxen auswählen / sind ausgewählt
    get checkedAll () { return this.value.length === this.data.length; }
    set checkedAll (val) {
        this._checkedAll = !!val;
        if (this.data) {
           this._checkAll(val);
        }
    }

    // DEPRECATED
    // Checkboxen die ausgewählt werden sollen / sind
    // TODO: unterschied zu value?
    get checkedValues () { return this.value.length ? this.value : []; }
    set checkedValues (val) {
        let value = this.value;

        if (!kijs.isArray(val)){
            val = [val];
        }
        kijs.Array.each(val, function(v){
            if (kijs.Array.contains(value, v)){
                kijs.Array.remove(value, v);
            } else {
                value.push(v);
            }

        }, this);

        this.value = value;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------

    // overwrite
    load(args, superCall=false) {
        return super.load(args, true).then((e) => {
            if (this._checkedAll) {
                this._checkAll(true);
            }

            // 'afterLoad' auslösen
            if (!superCall) {
                this.raiseEvent('afterLoad', e);
            }
        });
    }

    // PROTECTED
    _checkAll(val) {
        let ids = [];

        if (val) {
            kijs.Array.each(this.data, function (row) {
                ids.push(row[this.valueField]);
            }, this);
        }
        this.value = ids;
    }
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Color
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * blur
 * input
 *
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Color = class kijs_gui_field_Color extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._previousChangeValue = '';
        this._defaultColor = '#ffffff'; // Standardfarbe wenn leer.
                                        // Weil das native Color-Field kann nicht leer sein.

        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'input',
            nodeAttribute: {
                type: 'color',
                id: this._inputId,
                value: this._defaultColor
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                context: this
            }
        });

        this._dom.clsAdd('kijs-field-color');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false,
            disableFlex: true
        });

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' }   // De-/aktiviert die Browservorschläge
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.disabled = val || this._dom.clsHas('kijs-disabled');
    }

    // overwrite
    get value() {
        let val = this._inputDom.nodeAttributeGet('value');
        return kijs.toString(val).toLowerCase();
    }
    set value(val) {
        val = kijs.toString(val);

        if (kijs.isEmpty(val)) {
            val = this._defaultColor;
        } else {
            val = kijs.Graphic.colorGetHex(val);
        }

        this._inputDom.nodeAttributeSet('value', val);
        this._previousChangeValue = val;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._inputDom.changeDisabled(!!val || this._dom.clsHas('kijs-readonly'), false);
    }

    // overwrite
    focus(alsoSetIfNoTabIndex) {
        return this._inputDom.focus(alsoSetIfNoTabIndex);
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        super.unrender(true);
    }


    // PRIVATE
    // LISTENERS
    #onInputDomChange(e) {
        // Sicherstellen, dass beim Verlassen des Feldes noch getrimmt wird.
        let val = this.value;
        let oldVal = this._previousChangeValue;

        // und das change event auslösen
        if (val !== oldVal) {
            this.raiseEvent('change', { oldValue: oldVal, value: val } );
        }
    }

    #onInputDomInput(e) {
        this.validate();
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.OptionGroup
// --------------------------------------------------------------
kijs.gui.field.OptionGroup = class kijs_gui_field_OptionGroup extends kijs.gui.field.ListView {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dom.clsRemove('kijs-field-listview');
        this._dom.clsAdd('kijs-field-optiongroup');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            disableFlex: true,
            showCheckBoxes: true,
            selectType: 'singleAndEmpty',
            valueField: 'value',
            captionField: 'caption'
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // overwrite
    get required() { return super.required; }
    set required(val) {
        this.selectType = val ? 'single' : 'singleAndEmpty';
        super.required = !!val;
    }
    
};
/* global kijs, this */

// TODO: load() Funktion überarbeiten, so dass sie einen Basisklassenaufruf macht.
// TODO: force-Argument bei Load entfernen. Die Anzahl eingegebenen Zeichen nicht
//       in der Load Funktion überprüfen, sondern in #onInputDomKeyUp

// --------------------------------------------------------------
// kijs.gui.field.Combo
// --------------------------------------------------------------
kijs.gui.field.Combo = class kijs_gui_field_Combo extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._minChars = null;
        this._minSelectCount = null;
        this._maxSelectCount = null;
        this._caption = null;
        this._oldCaption = null;
        this._oldValue = null;
        this._value = '';
        this._keyUpDeferId = null;
        this._remoteSort = false;   // TODO: umbenennen nach remoteFilter
        this._forceSelection = true;
        this._firstLoaded = false;
        this._showPlaceholder = true; // TODO: umbenennen nach placeholder, wo ein Text übergeben werden kann, wie in kijs.gui.field.Text?
        this._selectFirst = false;

        this._inputDom = new kijs.gui.Dom({
            disableEscBubbeling: true,
            nodeTagName: 'input',
            nodeAttribute: {
                id: this._inputId
            }
        });

        this._listViewEl = new kijs.gui.ListView({
            scrollableY: false,
            autoLoad: false,
            focusable: false
        });

        this._spinButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.caret-down',
            disableFlex: true,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                click: this.#onSpinButtonClick,
                context: this
            }
        });

        this._spinBoxEl = new kijs.gui.SpinBox({
            parent: this,
            cls: 'kijs-field-combo-spinbox',
            scrollableY: 'auto',
            target: this,
            targetDomProperty: 'inputWrapperDom',
            ownerNodes: [this._inputWrapperDom, this._spinButtonEl.dom],
            elements: [
                this._listViewEl
            ],
            style: {
                maxHeight: '400px'
            }
        });

        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });

        this._dom.clsAdd('kijs-field-combo');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false,
            scrollableY: 'auto',
            minChars: 'auto',
            valueField: 'value',
            captionField: 'caption',
            iconCharField: 'iconChar',
            iconMapField: 'iconMap'
        });

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            autoLoad: { target: 'autoLoad' },
            inputMode: { target: 'inputMode' },
            remoteSort: true,
            showPlaceholder: true,
            forceSelection: true,
            selectFirst: true,

            showCheckBoxes: { target: 'showCheckBoxes', context: this._listViewEl },
            selectType: { target: 'selectType', context: this._listViewEl },

            rpcLoadFn: { target: 'rpcLoadFn', context: this._listViewEl },
            rpcLoadArgs: { target: 'rpcLoadArgs', context: this._listViewEl },
            rpc: { target: 'rpc', context: this._listViewEl },

            minChars: { target: 'minChars', prio: 2}, // Nicht beachtet, wenn remoteSort false ist

            captionField: { target: 'captionField', context: this._listViewEl },
            iconCharField: { target: 'iconCharField', context: this._listViewEl },
            iconClsField: { target: 'iconClsField', context: this._listViewEl },
            iconColorField: { target: 'iconColorField', context: this._listViewEl },
            iconMapField: { target: 'iconMapField', context: this._listViewEl },
            tooltipField: { target: 'tooltipField', context: this._listViewEl },
            valueField: { target: 'valueField', context: this._listViewEl },

            minSelectCount: true,
            maxSelectCount: true,

            data: { prio: 1000, target: 'data' },
            value: { prio: 1001, target: 'value' },

            spinButtonHide: { target: 'spinButtonHide' },
            spinButtonIconChar: { target: 'iconChar', context: this._spinButtonEl },
            spinButtonIconCls: { target: 'iconCls', context: this._spinButtonEl },
            spinButtonIconColor: { target: 'iconColor', context: this._spinButtonEl },
            spinButtonIconMap: { target: 'iconMap', context: this._spinButtonEl },

            // Attribute für SpinBoxEl weiterreichen
            scrollableX: { target: 'scrollableX', context: this._spinboxEl },
            scrollableY: { target: 'scrollableY', context: this._spinboxEl },

            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);
        this._eventForwardsAdd('keyDown', this._inputDom);
        this._eventForwardsAdd('afterLoad', this._listViewEl);

//        this._eventForwardsRemove('enterPress', this._dom);
//        this._eventForwardsRemove('enterEscPress', this._dom);
//        this._eventForwardsRemove('escPress', this._dom);
//        this._eventForwardsAdd('enterPress', this._inputDom);
//        this._eventForwardsAdd('enterEscPress', this._inputDom);
//        this._eventForwardsAdd('escPress', this._inputDom);

        // Listeners
        this._inputDom.on('blur', this.#onInputDomBlur, this);
        this._inputDom.on('change', this.#onInputDomChange, this);
        this._inputDom.on('input', this.#onInputDomInput, this);
        this._inputDom.on('keyUp', this.#onInputDomKeyUp, this);
        this._inputDom.on('keyDown', this.#onInputDomKeyDown, this);
        this._listViewEl.on('afterLoad', this.#onListViewElAfterLoad, this);
        this._listViewEl.on('click', this.#onListViewElClick, this);
        this._spinBoxEl.on('click', this.#onSpinBoxElClick, this);
        this._spinBoxEl.on('close', this.#onSpinBoxElClose, this);
        this._spinBoxEl.on('show', this.#onSpinBoxElShow, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }

    get autoLoad() {
        return this.hasListener('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
    }
    set autoLoad(val) {
        if (val) {
            this.on('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
        } else {
            this.off('afterFirstRenderTo', this.#onAfterFirstRenderTo, this);
        }
    }

    get buttonsDom() { return this._buttonsDom; }

    get captionField() { return this._listViewEl.captionField; }
    set captionField(val) { this._listViewEl.captionField = val; }

    // overwrite
    get data() {
        return this._listViewEl.data;
    }
    set data(val) {
        this._listViewEl.data = val;
        if (this._selectFirst) {
            this.value = this._listViewEl.data[0].value;
        }
    }

   // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get inputDom() { return this._inputDom; }

    get inputMode() { return this._inputDom.nodeAttributeGet('inputMode'); }
    set inputMode(val) { this._inputDom.nodeAttributeSet('inputMode', val); }

    get minChars() { return this._minChars; }
    set minChars(val) {
        if (val === 'auto') {
            // remote combo
            if (this._listViewEl.rpcLoadFn) {
                this._minChars = 4;

            // local combo
            } else {
                this._minChars = 0;
            }
        } else if (kijs.isInteger(val) && val > 0) {
            this._minChars = val;

        } else {
            throw new kijs.Error(`invalid argument for parameter minChars in kijs.gui.field.Combo`);
        }
    }

    get oldValue() { return this._oldValue; }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._listViewEl.disabled = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
    }

    get rpc() { return this._listViewEl.rpc; }
    set rpc(val) { this._listViewEl.rpc = val; }

    get rpcLoadArgs() { return this._listViewEl.rpcLoadArgs; }
    set rpcLoadArgs(val) { this._listViewEl.rpcLoadArgs = val; }

    get rpcLoadFn() { return this._listViewEl.rpcLoadFn; }
    set rpcLoadFn(val) { this._listViewEl.rpcLoadFn = val; }

    /**
     * Berechnet die Höhe für die spinBox
     * @returns {Number}
     */
    get spinBoxHeight() {
        return this._inputWrapperDom.height;
    }

    /**
     * Berechnet die Breite für die spinBox
     * @returns {Number}
     */
    get spinBoxWidth() {
        let width = this._inputWrapperDom.width;
        if (this._spinButtonEl.visible) {
            width += this._spinButtonEl.width;
        }
        return width;
    }

    get spinButton() { return this._spinButtonEl; }

    get spinButtonHide() { return !this._spinButtonEl.visible; }
    set spinButtonHide(val) { this._spinButtonEl.visible = !val; }

    get spinButtonIconChar() { return this._spinButtonEl.iconChar; }
    set spinButtonIconChar(val) { this._spinButtonEl.iconChar = val; }

    get spinButtonIconCls() { return this._spinButtonEl.iconCls; }
    set spinButtonIconCls(val) { this._spinButtonEl.iconCls = val; }

    get spinButtonIconColor() { return this._spinButtonEl.iconColor; }
    set spinButtonIconColor(val) { this._spinButtonEl.iconColor = val; }

    get spinButtonIconMap() { return this._spinButtonEl.iconMap; }
    set spinButtonIconMap(val) { this._spinButtonEl.iconMap = val; }

    // overwrite
    get value() { return this._value; }
    set value(val) {
        let valueIsInStore = val === '' || val === null || this._isValueInStore(val);
        this._oldCaption = this._caption;
        this._oldValue = this._value;
        this._caption  = this._getCaptionFromValue(val);
        this._value = val;
        this._listViewEl.value = val;

        // falls das value nicht im store ist, vom server laden
        if (this._remoteSort) {
            if (!valueIsInStore && this._firstLoaded) {
                this.load(null, true);
            }
            // store leeren, wenn value gelöscht wird.
            if (this._value === '' || this._value === null) {
//                this._listViewEl.data = [];
            }
        }

        this._inputDom.nodeAttributeSet('value', kijs.toString(this._caption));
    }

    // overwrite
    get valueDisplay() {
        return this._caption;
    }

    get valueField() { return this._listViewEl.valueField; }
    set valueField(val) { this._listViewEl.valueField = val; }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._spinButtonEl.changeDisabled(!!val, true);

        if (this._spinBoxEl) {
            this._spinBoxEl.changeDisabled(!!val, true);
        }

        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    /**
     * Füllt das Combo mit Daten vom Server
     * TODO: Funktion sollte folgende Argumente haben: load(args=null, superCall=false)
     * TODO: Die Anzahl getippten Zeichen sollten vorher gezählt werden.
     * @param {Array} args Array mit Argumenten, die an die remoteFn übergeben werden
     * @param {Boolean} forceLoad true, wenn immer geladen werden soll
     * @param {String} query Suchstring
     * @returns {undefined}
     */
    load(args=null, forceLoad=false, query=null) {
        args = kijs.isObject(args) ? args : {};
        args.remoteSort = !!this._remoteSort;
        args.value = this.value;
        args.query = null;

        if (this._remoteSort) {
            args.query = kijs.toString(query);

            // Wenn eine Eingabe erfolgt, oder bei forceLoad, laden
            if (forceLoad || args.query.length >= this._minChars) {
                this._listViewEl.load(args).then((e) => {
                    let config = e.responseData.config ?? {};

                    // Nach dem Laden das value neu setzen,
                    // damit die caption erscheint (ohne change-event)
                    if (query === null && this._isValueInStore(this.value)) {
                        this.value = this._value;

                    // value mit dem RPC zurückgeben (mit change-event)
                    } else if (query === null && kijs.isDefined(config.value) && config.value !== null && this._isValueInStore(config.value)) {
                        if (kijs.toString(config.value) !== kijs.toString(this.value)) {
                            this.value = config.value;
                        }

                    }
                });

            } else {
                this._listViewEl.data = [];
                this._addPlaceholder(kijs.getText('Schreiben Sie mindestens %1 Zeichen, um die Suche zu starten', '', this._minChars) + '.');
            }

        } else if (!this._firstLoaded || forceLoad) {
            // alle Datensätze laden
            this._listViewEl.load(args)
                .then((e) => {
                    let config = e.responseData.config ?? {};

                    // Nach dem Laden das value neu setzen,
                    // damit das Label erscheint (ohne change-event)
                    if (query === null && this._isValueInStore(this.value)) {
                        this.value = this._value;

                    // value mit dem RPC zurückgeben (mit change-event)
                    } else if (query === null && kijs.isDefined(config.value) && config.value !== null && this._isValueInStore(config.value)) {
                        if (kijs.toString(config.value) !== kijs.toString(this.value)) {
                            this.value = config.value;
                        }
                    }

                    this.validate(true);
                });
        }

        // Flag setzen
        this._firstLoaded = true;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');

        // Spin Button rendern (kijs.gui.Button)
        this._spinButtonEl.renderTo(this._buttonsDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // timer abbrechen
        if (this._keyUpDeferId) {
            window.clearTimeout(this._keyUpDeferId);
            this._keyUpDeferId = null;
        }

        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        this._buttonsDom.unrender();

        if (this._spinBoxEl) {
            this._spinBoxEl.unrender();
        }

        super.unrender(true);
    }


    // PROTECTED
    /**
     * Fügt dem listView einen Platzhalter hinzu.
     * @param {String} text Nachricht, die angezeigt wird.
     */
    _addPlaceholder(text) {
        if (this._showPlaceholder) {

            if (this._listViewEl.down('kijs-gui-field-combo-placeholder')) {
                this._listViewEl.down('kijs-gui-field-combo-placeholder').html = text;

            } else {
                this._listViewEl.add({
                    xtype: 'kijs.gui.Container',
                    name: 'kijs-gui-field-combo-placeholder',
                    cls: 'kijs-placeholder',
                    html: text,
                    htmlDisplayType: 'code'
                });
            }
        }
    }

    /**
     * Caption zu einem Value ermitteln
     * @param {String|Number|null} val
     * @returns {String}
     */
    _getCaptionFromValue(val) {
        let found = false;
        let caption = null;
        kijs.Array.each(this._listViewEl.data, function(row) {
            if (row[this.valueField] === val) {
                found = true;
                caption = row[this.captionField];
                return false;
            }
        }, this);

        // Falls kein Datensatz existiert, zeigen wir halt den value an
        if (!found) {
            caption = val;
        }

        return kijs.toString(caption);
    }

    /**
     * Prüft, ob ein value im Store ist.
     * @param {String|Number|null} val
     * @returns {Boolean}
     */
    _isValueInStore(val) {
        let found = false;

        if (this._listViewEl) {
            kijs.Array.each(this._listViewEl.data, function (row) {
                if (row[this.valueField] === val) {
                    found = true;
                    return false;
                }
            }, this);
        }

        return found;
    }

    /**
     * Schreibt einen Vorschlag ins Textfeld.
     * Funktion wird vom KeyDown verzögert ausgeführt.
     * @param {String} key
     * @returns {undefined}
     */
    _setProposal(key) {
        let inputVal = this._inputDom.nodeAttributeGet('value'),
            matchVal='';

        inputVal = kijs.toString(inputVal).trim();

        // Exakten Wert suchen
        if (inputVal && key !== 'Backspace' && key !== 'Delete') {
            kijs.Array.each(this._listViewEl.data, function(row) {
                if (kijs.isString(row[this.captionField]) && row[this.captionField].toLowerCase() === inputVal.toLowerCase()) {
                    matchVal = row[this.captionField];
                    return false;
                }
            }, this);

            // Beginn suchen
            if (matchVal === '') {
                kijs.Array.each(this._listViewEl.data, function(row) {
                    let caption = row[this.captionField];

                    if (
                        kijs.isString(caption)
                        && inputVal.length <= caption.length
                        && caption.substr(0, inputVal.length).toLowerCase() === inputVal.toLowerCase()
                    ) {
                        matchVal = caption;
                        return false;
                    }

                }, this);
            }

            // Es wurde eine Übereinstimmung gefunden
            if (matchVal) {
                this._inputDom.nodeAttributeSet('value', kijs.toString(matchVal));

                // Differenz selektieren
                if (matchVal.length !== inputVal.length) {
                    this._inputDom.node.setSelectionRange(inputVal.length, matchVal.length);
                }
            }

            // Elemente des Dropdowns filtern
            this._listViewEl.applyFilters({field:this.captionField, value: inputVal, compare: 'part'});

        } else if (key === 'Backspace' || key === 'Delete') {
            this._listViewEl.applyFilters({field:this.captionField, value: inputVal, compare: 'part'});

        } else {

            // Filter des Dropdowns zurücksetzen
            this._listViewEl.applyFilters(null);
        }
    }

    _setScrollPositionToSelection() {
        let sel = this._listViewEl.getSelected();
        if (kijs.isObject(sel) && (sel instanceof kijs.gui.dataView.element.Base)) {
            if (kijs.isNumber(sel.top) && this._spinBoxEl.isRendered) {
                let spH = this._spinBoxEl.dom.height, spSt = this._spinBoxEl.dom.node.scrollTop;

                let minScrollValue = sel.top;
                let maxScrollValue = sel.top - spH + sel.height;

                // prüfen, ob selektion ausserhalb von Scrollbar
                if (this._spinBoxEl.dom.node.scrollTop === 0 || this._spinBoxEl.dom.node.scrollTop > minScrollValue) {
                    this._spinBoxEl.dom.node.scrollTop = minScrollValue;

                } else if (this._spinBoxEl.dom.node.scrollTop < maxScrollValue) {
                    this._spinBoxEl.dom.node.scrollTop = maxScrollValue+5;
                }
            }
        }
    }

    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        super._validationRules(value, ignoreEmpty);

        // Wert muss in der Liste vorhanden sein.
        if (this._forceSelection && !this._remoteSort && !kijs.isEmpty(value)) {
            let match = false;
            kijs.Array.each(this._listViewEl.data, function(row) {
                if (row[this.valueField] === value) {
                    match = true;
                    return false;
                }
            }, this);

            if (!match) {
                this._errors.push(kijs.getText('Der Wert "%1" ist nicht in der Liste enthalten', '', value) + '.');
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onAfterFirstRenderTo(e) {
        // forceLoad, wenn value vorhanden ist (damit label geladen wird)
        this.load(null, this.value !== '');
    }

    #onInputDomBlur() {
        // blur nur ausführen, wenn Trigger nicht offen ist und Feld kein Focus hat
        kijs.defer(function() {
            if (this._spinBoxEl && this._inputDom && !this._spinBoxEl.isRendered && !this._inputDom.hasFocus) {
               this.raiseEvent('blur');
            }
        }, 200, this);
    }

    #onInputDomChange(e) {
        // change event nicht berücksichtigen, wenn die spinbox
        // offen ist.
        if (this._spinBoxEl.isRendered) {
            return;
        }

        let inputVal = this._inputDom.nodeAttributeGet('value'),
            match = false,
            matchVal = '',
            oldVal = this.value,
            changed = false;

        inputVal = kijs.toString(inputVal).trim();

        // Leerer Wert = feld löschen
        if (inputVal === '') {
            match = true;

        } else {

            // Wert im Store suchen.
            kijs.Array.each(this._listViewEl.data, function(row) {
                if (kijs.isString(row[this.captionField]) && row[this.captionField].toLowerCase() === inputVal.toLowerCase()) {
                    match = true;
                    matchVal = row[this.valueField];
                    return false;
                }
            }, this);
        }

        if (match && matchVal !== this.value) {
            this.value = matchVal;
            changed = true;

        // Es wurde ein Wert eingegeben, der nicht im Store ist, und das ist erlaubt.
        } else if (!match && !this._forceSelection) {
            if (inputVal !== this.value) {
                this.value = inputVal;
                changed = true;
            }

        // Es wurde ein Wert eingegeben, der nicht im Store ist, daher Feld
        // auf letzten gültigen Wert zurücksetzen.
        } else {
            this.value = this._value;
        }

        // validieren
        this.validate();

        // change-event
        if (changed) {
            this.raiseEvent('input', { value: this.value, oldValue: oldVal });
            this.raiseEvent('change', { value: this.value, oldValue: oldVal });
        }
    }

    #onInputDomInput(e) {
        this._spinBoxEl.show();
    }

    #onInputDomKeyDown(e) {
        // event beim listView ausführen, damit selektion geändert werden kann.
        if (this._listViewEl.getSelected()) {
            this._listViewEl.handleKeyDown(e.nodeEvent);

        } else if (e.nodeEvent.key === 'ArrowDown') {
            let indx = this._listViewEl.elements.length > 0 && kijs.isDefined(this._listViewEl.elements[0].index) ? this._listViewEl.elements[0].index : null;
            if (indx !== null) {
                this._listViewEl.selectByIndex(indx);
            }
        }

        // Scroll
        if (e.nodeEvent.key === 'ArrowDown' || e.nodeEvent.key === 'ArrowUp') {
            // scrollen
            this._setScrollPositionToSelection();
        }

        // wenn Enter gedrückt wird, listview schliessen und ausgewählten Datensatz übernehmen.
        if (e.nodeEvent.key === 'Enter') {
            let dataViewElement = this._listViewEl.getSelected();
            this._spinBoxEl.close();

            if (dataViewElement && (dataViewElement instanceof kijs.gui.dataView.element.Base)) {
                let newVal = dataViewElement.dataRow[this.valueField],
                    oldVal = this.value,
                    changed = newVal !== this.value;
                this.value = newVal;

                if (changed) {
                    this.raiseEvent('change', {value: this.value, oldValue: oldVal});
                }
            }

            // event stoppen
            e.nodeEvent.stopPropagation();

        // Esc: Schliessen
        } else if (e.nodeEvent.key === 'Escape') {
            this._spinBoxEl.close();

            // Selektion zurücksetzen
            this._listViewEl.value = this.value;

            // event stoppen
            e.nodeEvent.stopPropagation();
        }
    }

    #onInputDomKeyUp(e) {
        // Steuerbefehle ignorieren
        let specialKeys = [
            'ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight', 'ContextMenu',
            'Delete', 'Insert', 'Home', 'End', 'Alt', 'NumpadEnter',
            'AltGraph', 'ContextMenu', 'Control', 'Shift',
            'Enter', 'CapsLock', 'Tab', 'OS', 'Escape', 'Space'
        ];
        if (kijs.Array.contains(specialKeys, e.nodeEvent.code) || kijs.Array.contains(specialKeys, e.nodeEvent.key)) {
            return;
        }

        // bestehendes Defer löschen
        if (this._keyUpDeferId) {
            window.clearTimeout(this._keyUpDeferId);
            this._keyUpDeferId = null;
        }

        // neues Defer schreiben
        this._keyUpDeferId = kijs.defer(function() {
            if (this._remoteSort) {
                this.load(null, false, this._inputDom.nodeAttributeGet('value'));

            } else {
                this._setProposal(e.nodeEvent.key);
            }
        }, this._remoteSort ? 1000 : 500, this);
    }

    #onListViewElAfterLoad(e) {
        if (!this._remoteSort) {
            this.value = this._value;
        }

        if (this._selectFirst && this._listViewEl.data.length) {
            this.value = this._listViewEl.data[0].value;
        }

        // Spinbox Nachricht anhängen
        if (e.responseData && e.responseData.spinboxMessage) {
            this._addPlaceholder(e.responseData.spinboxMessage);
        }
    }

    #onListViewElClick(e) {
        this._spinBoxEl.close();

        if (this.value !== this._listViewEl.value) {
            let oldVal = this.value;
            this.value = this._listViewEl.value;

            // validieren
            this.validate();

            this.raiseEvent('input', {value: this.value, oldValue: oldVal});
            this.raiseEvent('change', {value: this.value, oldValue: oldVal});
        }
    }

    #onSpinBoxElClick() {
        this._inputDom.focus();
    }

    #onSpinBoxElClose() {
        this._inputDom.focus();
        this.#onInputDomBlur();
    }

    #onSpinBoxElShow() {
        this._setScrollPositionToSelection();
    }

    #onSpinButtonClick(e) {
        if (this.disabled || this.readOnly) {
             return;
        }
        if (this._spinBoxEl) {
            if (this._spinBoxEl.isRendered) {
                this._spinBoxEl.close();
            } else {
                this._spinBoxEl.show();
            }
        }

        this._listViewEl.applyFilters();

        if (this._listViewEl.data.length === 0 && this._remoteSort) {
            this._addPlaceholder(kijs.getText('Schreiben Sie mindestens %1 Zeichen, um die Suche zu starten', '', this._minChars) + '.');
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }
        if (this._spinBoxEl) {
            this._spinBoxEl.destruct();
        }
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._spinButtonEl) {
            this._spinButtonEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;
        this._listViewEl = null;
        this._oldValue = null;
        this._spinBoxEl = null;
        this._buttonsDom = null;
        this._spinButtonEl = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Display
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * blur
 * input
 *
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Display = class kijs_gui_field_Display extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._clickableLinks = false;
        this._formatFn = null;
        this._formatFnContext = this;
        this._formatRegExps = [];
        this._value = '';
        this._valueDisplayType = 'code';    // Darstellung der Eigenschaft 'value'. Default: 'code'
                                            // html: als html-Inhalt (innerHtml)
                                            // code: Tags werden als Text angezeigt
                                            // text: Tags werden entfernt
        this._valueTrimEnable = true;


        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'div',
            htmlDisplayType: 'html',
            nodeAttribute: {
                id: this._inputId
            }
        });

        this._dom.clsAdd('kijs-field-display');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            submitValueEnable: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            clickableLinks: true,         // Weblink zum anklicken machen
            formatFn: { target: 'formatFn' },
            formatFnContext: { target: 'formatFnContext' },
            formatRegExp: { fn: 'function', target: this.addFormatRegExp, context: this },
            valueDisplayType: true,
            valueTrimEnable: true       // Sollen Leerzeichen am Anfang und Ende des Values automatisch entfernt werden?
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get clickableLinks() { return this._clickableLinks; }
    set clickableLinks(val) {
        this._clickableLinks = !!val;
        if (this.isRendered) {
            this.value = this._value;
        }
    }

    get formatFn() { return this._formatFn; }
    set formatFn(val) {
        let fn = kijs.getFunctionFromString(val);
        if (kijs.isFunction(fn)) {
            this._formatFn = fn;
        } else {
            throw new kijs.Error(`config "formatFn" is not valid.`);
        }
    }

    get formatFnContext() { return this._formatFnContext; }
    set formatFnContext(val) {
        let context = kijs.getObjectFromString(val);
        if (kijs.isObject(context)) {
            this._formatFnContext = context;
        } else {
            throw new kijs.Error(`config "formatFnContext" is not valid.`);
        }
    }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this._inputDom.html); }

    // overwrite
    get value() {
        let val = kijs.toString(this._value);
        if (this._valueTrimEnable) {
            val = val.trim();
        }
        return val;
    }
    set value(val) {
        val = kijs.toString(val);
        val = this._formatRules(val, false);
        this._value = val;
        
        switch (this._valueDisplayType) {
            case 'code':
                val = kijs.String.htmlspecialchars(val);
                break;

            case 'text':
                let d = document.createElement('div');
                d.innerHTML = val;
                val = d.innerText || d.textContent || '';
                d = null;
                break;

            case 'html':
            default:
                // nix
                break;
        }
        
        // Hyperlinks einfügen
        if (this._clickableLinks) {
            val = this._linkify(val);
        }

        // Zeilenumbrüche einfügen
        val = this._insertLineBreaks(val);

        this._inputDom.html = val;
    }

    get valueDisplayType() { return this._valueDisplayType; }
    set valueDisplayType(val) { this._valueDisplayType = val; }

    get valueTrimEnable() { return this._valueTrimEnable; }
    set valueTrimEnable(val) { this._valueTrimEnable = !!val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Fügt einen oder mehrere regulären Ausdruck (replace) zum Formatieren hinzu
     * @param {Object|Array} regExps
     *                       Beispiel: { regExp: '/([0-9]{3})([0-9]{3})/', replace: '$1 $2'  }
     *                       Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt,
     *                       sonst replace()
     * @returns {undefined}
     */
    addFormatRegExp(regExps) {
        if (!kijs.isArray(regExps)) {
            regExps = [regExps];
        }

        kijs.Array.each(regExps, function(regExp) {
            let ok = true;

            if (typeof regExp !== 'object') {
                ok = false;
            }

            if (ok) {
                if (kijs.isRegExp(regExp.regExp)) {
                    regExp.regExp = regExp.regExp.toString();
                } else if (!kijs.isString(regExp.regExp)) {
                    ok = false;
                }
            }

            if (ok) {
                if (kijs.isString(regExp.replace) && (regExp.toUpperCase || regExp.toLowerCase)) {
                    throw new kijs.Error(`"formatRegExp" must not have a "toUpperCase" or "toLowerCase" and a "replace" at the same time.`);
                } else if (!kijs.isString(regExp.replace) && !regExp.toUpperCase && !regExp.toLowerCase) {
                    ok = false;
                }
            }

            if (ok) {
                this._formatRegExps.push(regExp);
            } else {
                throw new kijs.Error(`"formatRegExp" is not valid.`);
            }
        }, this);
    }

    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input-DIV rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._inputDom.unrender();
        super.unrender(true);
    }

    // overwrite
    validate() {
        // display kann nicht invalid sein,
        // da der User nichts ändern kann.
        return true;
    }


    // PROTECTED
    /**
     * formatFn anwenden
     * Wird aufgerufen von _formatRules
     * @param {String} value
     * @param {Boolean} whileTyping true=Aufruf kommt vom input-Event. false=change oder set value
     * @returns {String}
     */
    _formatApplyFormatFn(value, whileTyping) {
        if (kijs.isFunction(this._formatFn)) {
            if (value !== null && value.toString() !== '') {
                value = this._formatFn.call(this._formatFnContext || this, value, !!whileTyping);
            }
        }
        return value;
    }
    
    /**
     * formatRegExp anwenden
     * Wird aufgerufen von _formatRules
     * @param {String} value
     * @param {Boolean} whileTyping true=Aufruf kommt vom input-Event. false=change oder set value
     * @returns {String}
     */
    _formatApplyFormatRegExp(value, whileTyping) {
        if (!kijs.isEmpty(this._formatRegExps)) {
            value = value.toString();
            if (value !== '') {
                kijs.Array.each(this._formatRegExps, function(regExp) {
                    let r = kijs.String.toRegExp(regExp.regExp);
                    
                    // in Grossbuchstaben umwandeln
                    if (regExp.toUpperCase) {
                        // Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt
                        if (kijs.String.contains(r.flags, 'g')) {
                            value = value.replaceAll(r, function(v) { return v.toUpperCase(); });
                        // sonst nur replace
                        } else {
                            value = value.replace(r, function(v) { return v.toUpperCase(); });
                        }

                    // oder in Kleinbuchstaben umwandeln
                    } else if (regExp.toUpperCase) {
                        // Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt
                        if (kijs.String.contains(r.flags, 'g')) {
                            value = value.replaceAll(r, function(v) { return v.toLowerCase(); });
                        // sonst nur replace
                        } else {
                            value = value.replace(r, function(v) { return v.toLowerCase(); });
                        }

                    // oder durch String ersetzen
                    } else {
                        // Wenn das literal /g vorhanden ist, wird replaceAll ausgeführt
                        if (kijs.String.contains(r.flags, 'g')) {
                            value = value.replaceAll(r, regExp.replace);
                        // sonst nur replace
                        } else {
                            value = value.replace(r, regExp.replace);
                        }

                    }
                }, this);
            }
        }
        return value;
    }

    /**
     * Diese Funktion ist zum Überschreiben gedacht
     * @param {String} value
     * @param {Boolean} whileTyping Wird während der Eingabe formatiert (input) oder definitiv (change oder set value)
     * @returns {String}
     */
    _formatRules(value, whileTyping) {
        // formatRegExps
        value = this._formatApplyFormatRegExp(value, whileTyping);

        // formatFn
        value = this._formatApplyFormatFn(value, whileTyping);
        
        return value;
    }

    // Ersetzt /n durch <br>
    _insertLineBreaks(txt) {
        return txt.replace(/\n/gim, '<br>');
    }

    // Ersetzt Links durch <a>-Tags
    _linkify(txt) {
        let pattern;
        
        // URLs, beginnend mit 'http://', 'https://' oder 'ftp://'
        pattern = /(\b(https?|ftp):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/gim;
        txt = txt.replace(pattern, '<a href="$1" target="_blank" tabindex="-1">$1</a>');

        // URLs beginnend mit 'www.' Vorher darf kein '/' sein
        pattern = /(^|[^\/])(www\.[\S]+(\b|$))/gim;
        txt = txt.replace(pattern, '$1<a href="http://$2" target="_blank" tabindex="-1">$2</a>');

        // E-Mailadressen
        // https://stackoverflow.com/questions/42407785/regex-extract-email-from-strings
        pattern = /((?:[a-z0-9+!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\]))/gim;
        txt = txt.replace(pattern, '<a href="mailto:$1" tabindex="-1">$1</a>');
        return txt;
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;
        this._formatFn = null;
        this._formatFnContext = null;
        this._formatRegExps = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Month
// --------------------------------------------------------------
/**
 * CONFIG-Parameter
 * ----------
 * date                     aktueller Wert als JavaScript Date-Objekt.
 * value                    aktueller Wert als SQL-String (siehe auch "valueFormat")
 * valueFormat              Format des SQL-Strings default:'Y-m-d (gilt für value, minValue und maxValue)
 * lastDayOfMonthAsValue    als date oder value wird normalerweise der 1. Tag des Monats zurückgegeben,
 *                          falls der letzte Tag gewünscht wird, lastDayOfMonthAsValue=true setzen.
 * emptyBtnHide             damit kann die "Leeren"-Schaltfläche ausgeblendet werden.
 * minDate, maxDate         min- und max Datum als JavaScript Date-Objekt oder null, für keine Einschränkung.
 *                          Beim minDate wird fix der 1. Tag des Monats genommen, bei maxDate der letzte Tag des Monats.
 * minValue, maxValue       gleich wie minDate und maxDate, hier aber als SQL-String (siehe auch "valueFormat").
 * year2000Threshold        Wenn zweistellige Jahreszahlen eingegeben werden, können sie automatisch in vierstellige
 *                          umgewandelt werden. Dazu kann hier der Schwellwert angegeben werden. Default=30. Keine Umwandlung=Null
 *
 * EVENTS
 * ----------
 * blur
 * change
 * focus
 * input
 *
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Month = class kijs_gui_field_Month extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._previousChangeDate = null;  // Wird verwendet um das Change Event nur bei einer Wertänderung auszulösen

        this._year2000Threshold = 30;   // Wenn zweistellige Jahreszahlen eingegeben werden,
                                        // wird bei Zahlen >= diesem Wert eine 1900er Jahreszahl erstellt, sonst eine 2000er.
                                        // Null=Umwandlung ausgeschaltet.

        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'input',
            nodeAttribute: {
                id: this._inputId
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                context: this
            }
        });

        this._monthPicker = new kijs.gui.MonthPicker({
            headerBarHide: true,
            currentBtnHide: false,
            closeBtnHide: true,
            cls: ['kijs-borderless'],
            on: {
                monthClick: this.#onMonthPickerMonthClick,
                currentClick: this.#onMonthPickerCurrentClick,
                emptyClick: this.#onMonthPickerEmptyClick,
                change: this.#onMonthPickerChange,
                context: this
            }
        });

        this._spinButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.calendar-days',
            disableFlex: true,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                click: this.#onSpinButtonClick,
                context: this
            }
        });
        
        this._spinBoxEl = new kijs.gui.SpinBox({
            parent: this,
            target: this,
            autoSize: 'none',
            targetDomProperty: 'inputWrapperDom',
            ownerNodes: [this._inputWrapperDom, this._spinButtonEl.dom],
            elements: [
                this._monthPicker
            ]
        });
        
        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });
        
        this._dom.clsAdd('kijs-field-month');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false,
            disableFlex: true
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            year2000Threshold: true,
            emptyBtnHide: { target: 'maxDate', context: this._monthPicker },
            inputMode: { target: 'inputMode' },
            valueFormat: { target: 'valueFormat', context: this._monthPicker },
            lastDayOfMonthAsValue: { target: 'lastDayOfMonthAsValue', context: this._monthPicker },
            maxDate: { target: 'maxDate', context: this._monthPicker },
            minDate: { target: 'minDate', context: this._monthPicker },
            maxValue: { target: 'maxValue', context: this._monthPicker },
            minValue: { target: 'minValue', context: this._monthPicker },
            
            spinButtonHide: { target: 'spinButtonHide' },
            spinButtonIconChar: { target: 'iconChar', context: this._spinButtonEl },
            spinButtonIconCls: { target: 'iconCls', context: this._spinButtonEl },
            spinButtonIconColor: { target: 'iconColor', context: this._spinButtonEl },
            spinButtonIconMap: { target: 'iconMap', context: this._spinButtonEl },
            
            placeholder: { target: 'placeholder' },
            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }

    get buttonsDom() { return this._buttonsDom; }

    get date() {
        return this._monthPicker.date;
    }
    set date(val) {
        this._monthPicker.date = val;
        this._updateInputValue();
        this._previousChangeDate = this._monthPicker.date;
    }

    get emptyBtnHide() { return this._monthPicker.emptyBtnHide; }
    set emptyBtnHide(val) { this._monthPicker.emptyBtnHide = !!val; }

    // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    get inputMode() { return this._inputDom.nodeAttributeGet('inputMode'); }
    set inputMode(val) { this._inputDom.nodeAttributeSet('inputMode', val); }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get lastDayOfMonthAsValue() { return this._monthPicker.lastDayOfMonthAsValue; }
    set lastDayOfMonthAsValue(val) { this._monthPicker.lastDayOfMonthAsValue = !!val; }

    get placeholder() { this._inputDom.nodeAttributeGet('placeholder'); }
    set placeholder(val) { this._inputDom.nodeAttributeSet('placeholder', kijs.toString(val)); }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
    }

    /**
     * Berechnet die Höhe für die spinBox
     * @returns {Number}
     */
    get spinBoxHeight() {
        return this._inputWrapperDom.height;
    }

    /**
     * Berechnet die Breite für die spinBox
     * @returns {Number}
     */
    get spinBoxWidth() {
        let width = this._inputWrapperDom.width;
        if (this._spinButtonEl.visible) {
            width += this._spinButtonEl.width;
        }
        return width;
    }

    get spinButton() { return this._spinButtonEl; }

    get spinButtonHide() { return !this._spinButtonEl.visible; }
    set spinButtonHide(val) { this._spinButtonEl.visible = !val; }

    get spinButtonIconChar() { return this._spinButtonEl.iconChar; }
    set spinButtonIconChar(val) { this._spinButtonEl.iconChar = val; }

    get spinButtonIconCls() { return this._spinButtonEl.iconCls; }
    set spinButtonIconCls(val) { this._spinButtonEl.iconCls = val; }

    get spinButtonIconColor() { return this._spinButtonEl.iconColor; }
    set spinButtonIconColor(val) { this._spinButtonEl.iconColor = val; }

    get spinButtonIconMap() { return this._spinButtonEl.iconMap; }
    set spinButtonIconMap(val) { this._spinButtonEl.iconMap = val; }

    // overwrite
    get value() {
        return this._monthPicker.value;
    }
    set value(val) {
        this.date = val;
    }

    get valueFormat() { return this._monthPicker.valueFormat; }
    set valueFormat(val) { this._monthPicker.valueFormat = val; }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._spinButtonEl.changeDisabled(!!val, true);
        
        if (this._spinBoxEl) {
            this._spinBoxEl.changeDisabled(!!val, true);
        }
        
        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);
        
        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');
        
        // Spin Button rendern (kijs.gui.Button)
        this._spinButtonEl.renderTo(this._buttonsDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }
        this._monthPicker.unrender();
        this._inputDom.unrender();

        this._buttonsDom.unrender();
        
        if (this._spinBoxEl) {
            this._spinBoxEl.unrender();
        }

        super.unrender(true);
    }


    // PROTECTED
    _parseStringToMonth(strInput) {
        let year = null;
        let monthIndex = null; // 0=Jan, 1=Feb, ...
        let index;

        const months = [];
        const monthsShort = [];
        for (let i=0; i<12; i++) {
            months[i] = kijs.Date.getMonthName(new Date(2000, i, 1), 'long');
            monthsShort[i] = kijs.Date.getMonthName(new Date(2000, i, 1), 'short');
        }

        // String in Bestandteile (Wörter) aufteilen
        strInput = kijs.toString(strInput).trim();
        let arr = strInput.split(' ');

        // Der String darf aus ein oder zwei Bestandteilen bestehen
        if (arr.length < 1 || arr.length > 2) {
            return null;
        }

        // Bestandteile duchgehen und versuchen den Monat und das Jahr zu ermitteln
        for (let i=0; i<arr.length; i++) {
            let str = arr[i];

            // Handelt es sich um eine Jahreszahl?
            if (kijs.isNumeric(str)) {
                if (kijs.isEmpty(year)) {
                    year = parseInt(str);
                    // Evtl. aus zweistelliger Jahrezahl eine vierstellige machen
                    if (!kijs.isEmpty(this._year2000Threshold) && year >= 0 && year <= 99) {
                        if (year >= this._year2000Threshold) {
                            year += 1900;
                        } else {
                            year += 2000;
                        }
                    }
                } else {
                    return null;
                }
            }

            // Handelt es sich um einen Monatsnamen
            index = months.findIndex(month => month.toLowerCase() === str.toLowerCase());
            if (index === -1) {
                index = monthsShort.findIndex(month => month.toLowerCase() === str.toLowerCase());
            }
            if (index >= 0) {
                if (kijs.isEmpty(monthIndex)) {
                    monthIndex = index;
                } else {
                    return null;
                }
            }
        }

        // Das Jahr ist optional
        if (kijs.isEmpty(year)) {
            year = (new Date()).getFullYear();
        }

        // Der Monat nicht
        if (kijs.isEmpty(monthIndex)) {
            return null;
        }

        return new Date(year, monthIndex, 1);
    }

    _updateInputValue() {
        let val = '';
        if (!kijs.isEmpty(this._monthPicker.date)) {
            val = this._monthPicker.date.toLocaleDateString(kijs.language, {
                month: 'long',
                year: 'numeric'
            });
        }
        this._inputDom.nodeAttributeSet('value', val);
    }

    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        if (!kijs.isEmpty(value)) {
            const date = kijs.Date.create(value);

            // Min. value
            if (this._monthPicker.minDate !== null && date < this._monthPicker.minDate) {
                this._errors.push(
                    kijs.getText('Der minimale Wert für dieses Feld ist %1',
                        '',
                        this._monthPicker.minDate.toLocaleDateString(kijs.language, {
                            month: 'long',
                            year: 'numeric'
                        })
                    )
                );
            }

            // Max. value
            if (this._monthPicker.maxDate !== null && date > this._monthPicker.maxDate) {
                this._errors.push(
                    kijs.getText('Der maximale Wert für dieses Feld ist %1',
                        '',
                        this._monthPicker.maxDate.toLocaleDateString(kijs.language, {
                            month: 'long',
                            year: 'numeric'
                        })
                    )
                );
            }
        }

        super._validationRules(value, ignoreEmpty);
    }


    // PRIVATE
    // LISTENERS
    #onInputDomChange(e) {
        let oldDate = this._previousChangeDate;
        let oldValue = '';
        if (!kijs.isEmpty(oldDate)) {
            oldValue = kijs.Date.format(oldDate, this._monthPicker.valueFormat);
        };

        this._previousChangeDate = this._monthPicker.date;

        this._updateInputValue();
        this.validate();

        if (!kijs.Date.compare(this._monthPicker.date, oldDate)) {
            this.raiseEvent('change', {
                date: this.date,
                oldDate: oldDate,
                value: this.value,
                oldValue: oldValue
            });
        }
    }

    #onInputDomInput(e) {
        const rawValue = this._inputDom.nodeAttributeGet('value');
        const date = this._parseStringToMonth(rawValue);

        this.errorsReset();

        this._monthPicker.date = date;
    }

    #onMonthPickerChange(e) {
        let oldDate = this._previousChangeDate;
        let oldValue = '';
        if (!kijs.isEmpty(oldDate)) {
            oldValue = kijs.Date.format(oldDate, this._monthPicker.valueFormat);
        };

        this._previousChangeDate = this._monthPicker.date;

        this._updateInputValue();
        this.validate();

        if (!kijs.Date.compare(this._monthPicker.date, oldDate)) {
            this.raiseEvent('input', {
                date: this.date,
                oldDate: oldDate,
                value: this.value,
                oldValue: oldValue
            });
            this.raiseEvent('change', {
                date: this.date,
                oldDate: oldDate,
                value: this.value,
                oldValue: oldValue
            });
        }
    }

    #onMonthPickerEmptyClick(e) {
        this._spinBoxEl.close();
        this._inputDom.focus();
    }

    #onMonthPickerCurrentClick(e) {
        this._spinBoxEl.close();
        this._inputDom.focus();
    }

    #onMonthPickerMonthClick(e) {
        this._spinBoxEl.close();
        this._inputDom.focus();
    }
    
    #onSpinButtonClick(e) {
        if (this.disabled || this.readOnly) {
             return;
        }
        if (this._spinBoxEl) {
            if (this._spinBoxEl.isRendered) {
                this._spinBoxEl.close();
            } else {
                this._spinBoxEl.show();
            }
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }
        if (this._monthPicker) {
            this._monthPicker.destruct();
        }
        if (this._spinBoxEl) {
            this._spinBoxEl.destruct();
        }
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._spinButtonEl) {
            this._spinButtonEl.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;
        this._monthPicker = null;
        this._spinBoxEl = null;
        this._buttonsDom = null;
        this._spinButtonEl = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.DateTime
// --------------------------------------------------------------
kijs.gui.field.DateTime = class kijs_gui_field_DateTime extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // overwrite
        this._valuesMapping = [
            { nameProperty: 'name' , valueProperty: 'value' },
            { nameProperty: 'nameEnd' , valueProperty: 'valueEnd' }
        ];

        this._nameEnd = '';

        this._mode = 'date';             // Modus: 'date', 'time', 'dateTime', 'week' oder 'range'

        this._timeRequired = false;

        this._displayWeekFormat = 'W Y'; // Anzeigeformat für die Woche (nur bei mode='week')
        this._displayWeekPrefix = '';    // Präfix für die Anzeige der Woche (nur bei mode='week')
        this._valueDateFormat = '';     // Format für den Datums-Teil des value (leer=auto)
        this._valueTimeFormat = '';     // Format für den Uhrzeit-Teil des value (leer=auto)

        this._year2000Threshold = 30;   // Wenn zweistellige Jahreszahlen eingegeben werden,
                                        // wird bei Zahlen >= diesem Wert eine 1900er Jahreszahl erstellt, sonst eine 2000er.
                                        // Null=Umwandlung ausgeschaltet.

        this._useDefaultSpinButtonIcon = !kijs.isDefined(config.spinButtonIconChar);

        this._previousChangeValue = null;         // Wird verwendet um das Change Event nur bei einer Wertänderung auszulösen
        this._previousChangeValueEnd = null;      // Wird verwendet um das Change Event nur bei einer Wertänderung auszulösen

        this._inputDom = new kijs.gui.Dom({
            nodeTagName: 'input',
            nodeAttribute: {
                id: this._inputId
            },
            on: {
                change: this.#onInputDomChange,
                input: this.#onInputDomInput,
                dblClick: this.#onInputDomDblClick,
                context: this
            }
        });
        this._dom.clsAdd('kijs-field-datetime');

        this._datePicker = new kijs.gui.DatePicker({
            parent: this,
            on: {
                change: this.#onDatePickerChange,
                inputFinished: this.#onDatePickerInputFinished,
                todayClick: this.#onDatePickerTodayClick,
                emptyClick: this.#onDatePickerEmptyClick,
                context: this
            }
        });

        this._seperatorEl = new kijs.gui.Separator({});

        this._timePicker = new kijs.gui.TimePicker({
            parent: this,
            inputHide: false,
            on: {
                change: this.#onTimePickerChange,
                inputFinished: this.#onTimePickerInputFinished,
                nowClick: this.#onTimePickerNowClick,
                emptyClick: this.#onTimePickerEmptyClick,
                context: this
            }
        });

        this._spinButtonEl = new kijs.gui.Button({
            parent: this,
            cls: 'kijs-inline',
            iconMap: 'kijs.iconMap.Fa.calendar',
            disableFlex: true,
            nodeAttribute: {
                tabIndex: -1
            },
            on: {
                click: this.#onSpinButtonClick,
                context: this
            }
        });
        
        this._spinBoxEl = new kijs.gui.SpinBox({
            parent: this,
            target: this,
            autoSize: 'none',
            cls: ['kijs-flexrow', 'kijs-spinbox-datetime'],
            targetDomProperty: 'inputWrapperDom',
            ownerNodes: [this._inputWrapperDom, this._spinButtonEl.dom],
            elements: [
                this._datePicker,
                this._seperatorEl,
                this._timePicker
            ],
            on: {
                close: this.#onSpinBoxElClose,
                context: this
            }
        });
        
        this._buttonsDom = new kijs.gui.Dom({
            cls: 'kijs-buttons'
        });
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            autocomplete: false,
            disableFlex: true,
            mode: 'date',
            displayWeekPrefix: kijs.getText('KW %1', 'week number'),
            virtualKeyboardPolicy: 'manual'      // Mobile: Tastatur nicht automatisch öffnen
        });

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autocomplete: { target: 'autocomplete' },   // De-/aktiviert die Browservorschläge
            inputMode: { target: 'inputMode' },
            nameEnd: true,
            mode: { target: 'mode' },           // Modus: 'date', 'time', 'dateTime', 'week' oder 'range'
            secondsHide: { target: 'secondsHide', context: this._timePicker },   // Sekunden auch erfassen?
            minutesHide: { target: 'minutesHide', context: this._timePicker },   // Minuten auch erfassen?
            timeRequired: true,                 // Muss die Zeit eingegeben werden?
            maxValue: { target: 'maxValue', context: this._datePicker },
            minValue: { target: 'minValue', context: this._datePicker },
            year2000Threshold: true,
            displayWeekFormat: true,            // Anzeigeformat für die Woche (nur bei mode='week')
            displayWeekPrefix: true,            // Präfix für die Anzeige der Woche (nur bei mode='week')
            valueDateFormat: true,              // Format für den Datums-Teil des value (leer=auto)
            valueTimeFormat: true,              // Format für den Uhrzeit-Teil des value (leer=auto)
            emptyBtnHide: { target: 'emptyBtnHide', context: this._datePicker },
            date: { target: 'date' },           // Date Object
            dateEnd: { target: 'dateEnd' },     // Date Object
            value: { target: 'value' },         // Datum als SQL-String
            valueEnd: { target: 'valueEnd' },    // End-Datum als SQL-String
            
            spinButtonHide: { target: 'spinButtonHide' },
            spinButtonIconChar: { target: 'iconChar', context: this._spinButtonEl },
            spinButtonIconCls: { target: 'iconCls', context: this._spinButtonEl },
            spinButtonIconColor: { target: 'iconColor', context: this._spinButtonEl },
            spinButtonIconMap: { target: 'iconMap', context: this._spinButtonEl },
            
            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Event-Weiterleitungen von this._inputDom
        this._eventForwardsAdd('blur', this._inputDom);
        this._eventForwardsAdd('focus', this._inputDom);
        this._eventForwardsAdd('input', this._inputDom);

        this._eventForwardsRemove('enterPress', this._dom);
        this._eventForwardsRemove('enterEscPress', this._dom);
        this._eventForwardsRemove('escPress', this._dom);
        this._eventForwardsAdd('enterPress', this._inputDom);
        this._eventForwardsAdd('enterEscPress', this._inputDom);
        this._eventForwardsAdd('escPress', this._inputDom);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this._createSpinBoxElements();
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get autocomplete() { return this._inputDom.nodeAttributeGet('autocomplete'); }
    set autocomplete(val) {
        let value = 'on';

        if (kijs.isString(val)) {
            value = val;
        } else if (val === false) {
            value = 'off';
        }

        // De-/aktiviert die Browservorschläge
        this._inputDom.nodeAttributeSet('autocomplete', value);
    }
    
    get buttonsDom() { return this._buttonsDom; }
    
    // Gibt das Datum zurück. Falls nur eine Uhrzeit existiert, wird das Datum vom 01.01.1970 genommen
    get date() {
        let date = null;

        if (this._hasDate()) {
            date = this._datePicker.date;
        }

        if (this._hasTime() && !kijs.isEmpty(this._timePicker.value)) {
            if (kijs.isEmpty(date)) {
                date = kijs.Date.getDatePart(new Date('1970-01-01'));
            }

            // Datum und Uhrzeit zusammenfügen
            let sqlDate = kijs.Date.getSqlDate(date);
            sqlDate += ' ' + this._timePicker.value;
            date = kijs.Date.create(sqlDate);
        }

        return date;
    }
    set date(val) {
        const datetime = kijs.Date.create(val);

        if (kijs.isEmpty(datetime)) {
            this._datePicker.date = null;
            this._timePicker.value = '';
        } else {
            if (this._hasDate()) {
                this._datePicker.date = kijs.Date.getDatePart(datetime);
            } else {
                this._datePicker.date = null;
            }

            if (this._hasTime()) {
                this._timePicker.value = kijs.Date.format(datetime, 'H:i:s');
            } else {
                this._timePicker.value = '';
            }
        }

        this._previousChangeValue = this.value;
        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());
    }

    get dateEnd() {
        let date = null;
        if (this._hasDate()) {
            date = this._datePicker.dateEnd;
        }
        return date;
    }
    set dateEnd(val) {
        const date = kijs.Date.create(val);

        if (kijs.isEmpty(date)) {
            this._datePicker.dateEnd = null;
        } else {
            if (this._hasDate()) {
                this._datePicker.dateEnd = kijs.Date.getDatePart(date);
            } else {
                this._datePicker.dateEnd = null;
            }
            // Wenn es ein end-Datum gibt, gibt es nie eine Uhrzeit
            this._timePicker.value = '';
        }

        this._previousChangeValueEnd = this.valueEnd;
        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());
    }

    // overwrite
    get datePicker() { return this._datePicker; }

   // overwrite
    get hasFocus() { return this._inputDom.hasFocus; }

    get inputDom() { return this._inputDom; }

    get inputMode() { return this._inputDom.nodeAttributeGet('inputMode'); }
    set inputMode(val) { this._inputDom.nodeAttributeSet('inputMode', val); }

    get isEmpty() { return kijs.isEmpty(this.value); }

    get maxDate() { return this._datePicker.maxDate; }
    set maxDate(val) { this._datePicker.maxDate = val; }

    get maxValue() { return this._datePicker.maxValue; }
    set maxValue(val) { this._datePicker.maxalue = val; }

    get minDate() { return this._datePicker.minDate; }
    set minDate(val) { this._datePicker.minDate = val; }

    get minValue() { return this._datePicker.minValue; }
    set minValue(val) { this._datePicker.minValue = val; }

    get mode() {
        return this._mode;
    }
    set mode(val) {
        if (!kijs.Array.contains(['date','time','dateTime','week','range'], val)) {
            throw new kijs.Error('unknown mode');
        }

        this._mode = val;

        this._dom.clsRemove(['kijs-date','kijs-time','kijs-dateTime','kijs-week','kijs-range']);
        this._dom.clsAdd('kijs-' + val);

        this._createSpinBoxElements();
        this.value = null;
    }

    get nameEnd() { return this._nameEnd; }
    set nameEnd(val) { this._nameEnd = val; }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        this._inputDom.nodeAttributeSet('readOnly', !!val);
    }

    /**
     * Berechnet die Höhe für die spinBox
     * @returns {Number}
     */
    get spinBoxHeight() {
        return this._inputWrapperDom.height;
    }

    /**
     * Berechnet die Breite für die spinBox
     * @returns {Number}
     */
    get spinBoxWidth() {
        let width = this._inputWrapperDom.width;
        if (this._spinButtonEl.visible) {
            width += this._spinButtonEl.width;
        }
        return width;
    }

    get spinButton() { return this._spinButtonEl; }
    
    get spinButtonHide() { return !this._spinButtonEl.visible; }
    set spinButtonHide(val) { this._spinButtonEl.visible = !val; }

    get spinButtonIconChar() { return this._spinButtonEl.iconChar; }
    set spinButtonIconChar(val) { this._spinButtonEl.iconChar = val; }

    get spinButtonIconCls() { return this._spinButtonEl.iconCls; }
    set spinButtonIconCls(val) { this._spinButtonEl.iconCls = val; }

    get spinButtonIconColor() { return this._spinButtonEl.iconColor; }
    set spinButtonIconColor(val) { this._spinButtonEl.iconColor = val; }

    get spinButtonIconMap() { return this._spinButtonEl.iconMap; }
    set spinButtonIconMap(val) { this._spinButtonEl.iconMap = val; }

    get timePicker() { return this._timePicker; }

    get timeRequired() { return this._timeRequired; }
    set timeRequired(val) { this._timeRequired = !!val; }

    // overwrite
    get value() {
        const valDateStart = this._datePicker.date;
        const valDateEnd = this._datePicker.dateEnd;
        const valTime = this._timePicker.value;
        let ret = '';
        let format = '';

        let datetime = null;
        let dateFormat = '';
        let timeFormat = '';

        // Startdatum (und evtl. -Uhrzeit)
        // Wenn noch eine Uhrzeit verwendet wird: mit Uhrzeit ergänzen
        if (this._hasTime()) {
            // falls kein Datum existiert, den 01.01.1970 nehmen
            if (kijs.isEmpty(valDateStart)) {
                datetime = kijs.Date.getDatePart(new Date('1970-01-01'));
            } else {
                datetime = kijs.Date.getDatePart(valDateStart);
            }

            // Datum und Uhrzeit zusammenfügen
            if (!kijs.isEmpty(valTime)) {
                let sqlDate = kijs.Date.getSqlDate(datetime);
                sqlDate += ' ' + valTime;
                datetime = kijs.Date.create(sqlDate);
            }

        // sonst nur das Datum
        } else {
            if (kijs.isEmpty(valDateStart)) {
                datetime = null;
            } else {
                datetime = kijs.Date.getDatePart(valDateStart);
            }
        }

        // Format für den Datums-Teil ermitteln
        if (!kijs.isEmpty(valDateStart)) {
            if (kijs.isEmpty(this._valueDateFormat)) {
                switch (this._mode) {
                    case 'range':
                    case 'week':
                    case 'date':
                    case 'dateTime':
                        dateFormat = 'Y-m-d';
                        break;
                }
            } else {
                dateFormat = this._valueDateFormat;
            }
        }

        // Format für den Uhrzeit-Teil ermitteln
        if (!kijs.isEmpty(valTime)) {
            if (kijs.isEmpty(this._valueTimeFormat)) {
                switch (this._mode) {
                    // Falls ein ganzer SQL-Date-String verlangt wird, die komplete Uhrzeit nehmen
                    case 'dateTime':
                        timeFormat = 'H:i:s';
                        break;

                    // Wenn nur die Uhrzeit verlangt wird: anhand der Stellen automatisch ermitteln
                    case 'time':
                        if (this._timePicker.minutesHide) {
                            timeFormat = 'H';
                        } else if (this._timePicker.secondsHide) {
                            timeFormat = 'H:i';
                        } else {
                            timeFormat = 'H:i:s';
                        }
                        break;
                }
            } else {
                timeFormat = this._valueTimeFormat;
            }
        }

        // Datums- und Uhrzeitformat zusammenfügen
        if (dateFormat && timeFormat) {
            format = dateFormat + ' ' + timeFormat;
        } else if (dateFormat) {
            format = dateFormat;
        } else if (timeFormat) {
            format = timeFormat;
        }

        if (format) {
            ret = kijs.Date.format(datetime, format);
        }

        // Falls leer
        if (kijs.isEmpty(ret)) {
            // bei nur Uhrzeit = Leerstring
            if (this._mode === 'time') {
                ret = '';
            // sonst immer = Null
            } else {
                ret = null;
            }
        }

        return ret;
    }
    set value(val) {
        let arr;
        let ok = kijs.isString(val);

        // Splitten nach ' '
        if (ok) {
            arr = val.split(' ');
        }

        // index des Datums und Uhrzeit ermitteln
        let dateIndex = null;
        let timeIndex = null;
        if (this._hasDate()) {
            dateIndex = 0;
            if (this._hasTime()) {
                timeIndex = 1;
            }
        } else {
            timeIndex = 0;
        }

        // Anzahl Bestandteile des Strings überprüfen
        if (timeIndex === 1) {
            // Der String darf aus ein bis zwei Bestandteilen bestehen
            if (ok && (arr.length < 1 || arr.length > 2)) {
                ok = false;
            }
        }

        // Datum
        if (ok && dateIndex !== null && arr.length >= dateIndex+1) {
            this._datePicker.value = arr[dateIndex];
            if (kijs.isEmpty(this._datePicker.date)) {
                ok = false;
            }
        } else {
            this._datePicker.value = null;
        }

        // Uhrzeit
        if (ok && timeIndex !== null && arr.length >= timeIndex+1) {
            this._timePicker.value = arr[timeIndex];
        } else {
            this._timePicker.value = '';
        }

        this._previousChangeValue = this.value;
        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());
    }

    get valueEnd() {
        let date = null;
        let dateFormat = this._valueDateFormat;

        if (this._hasDate()) {
            date = this._datePicker.dateEnd;
        }

        if (kijs.isEmpty(dateFormat)) {
            dateFormat = 'Y-m-d';
        }

        if (kijs.isEmpty(date)) {
            return null;
        } else {
            return kijs.Date.format(date, dateFormat);
        }
    }
    set valueEnd(val) {
        this.dateEnd = val;
    }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() { return this._inputDom.nodeAttributeGet('virtualKeyboardPolicy'); }
    set virtualKeyboardPolicy(val) { this._inputDom.nodeAttributeSet('virtualKeyboardPolicy', val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        this._spinButtonEl.changeDisabled(!!val, true);
        
        if (this._spinBoxEl) {
            this._spinBoxEl.changeDisabled(!!val, true);
        }
        
        this._inputDom.changeDisabled(!!val, true);
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        let nde = this._inputDom.focus(alsoSetIfNoTabIndex);
        if (selectText) {
            if (nde) {
                nde.select();
            }
        }
        return nde;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // Input rendern (kijs.guiDom)
        this._inputDom.renderTo(this._inputWrapperDom.node);

        // Buttons-Container rendern (kijs.gui.Dom)
        this._buttonsDom.renderTo(this._contentDom.node, this._inputWrapperDom.node, 'after');
        
        // Spin Button rendern (kijs.gui.Button)
        this._spinButtonEl.renderTo(this._buttonsDom.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._datePicker.unrender();
        this._seperatorEl.unrender();
        this._timePicker.unrender();
        this._spinBoxEl.unrender();
        this._inputDom.unrender();
        this._buttonsDom.unrender();
        
        if (this._spinBoxEl) {
            this._spinBoxEl.unrender();
        }
        
        super.unrender(true);
    }


    // PROTECTED
    _createSpinBoxElements() {
        const hasDate = this._hasDate();
        const hasTime = this._hasTime();
        
        // spinIcon
        if (this._useDefaultSpinButtonIcon) {
            this.spinButtonIconMap = hasDate ? 'kijs.iconMap.Fa.calendar' : 'kijs.iconMap.Fa.clock';
        }

        // Inhalt zuerst entfernen
        this._spinBoxEl.removeAll({
            preventRender: true,
            preventDestruct: true
        });

        if (hasDate) {
            this._spinBoxEl.add(this._datePicker, null, { preventRender: true });
        }

        if (hasDate && hasTime) {
            this._spinBoxEl.add(this._seperatorEl, null, { preventRender: true });
        }

        if (hasTime) {
            this._spinBoxEl.add(this._timePicker, null, { preventRender: true });
        }

        if (this._spinBoxEl.isRendered) {
            this._spinBoxEl.render();
        }

        switch (this._mode) {
            case 'range':
            case 'week':
            case 'date':
                this._datePicker.mode = this._mode;
                break;
            case 'time':
            case 'dateTime':
                this._datePicker.mode = 'date';
                break;
        }
    }

    /**
     * Ermittelt den Wert für die Anzeige (display) im entsprechenden Format.
     * Falls keine Format definiert wurde, wird aufgrund der Einstellungen eines definiert
     * @return {String}
     */
    _getDisplayValue() {
        const valDateStart = this._datePicker.date;
        const valDateEnd = this._datePicker.dateEnd;
        const valTime = this._timePicker.value;

        let ret = '';

        // DisplayValue zurückgeben
        switch (this._mode) {
            // range
            case 'range':
                let txtStart = '';
                let txtEnd = '';

                if (!kijs.isEmpty(valDateStart)) {
                    txtStart = valDateStart.toLocaleDateString(kijs.language, {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                }

                if (!kijs.isEmpty(valDateEnd)) {
                    txtEnd = valDateEnd.toLocaleDateString(kijs.language, {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                }

                ret = kijs.getText('%1 bis %2', '', [txtStart, txtEnd]).trim();
                break;

            // week
            case 'week':
                if (!kijs.isEmpty(valDateStart) && !kijs.isEmpty(valDateEnd)) {
                   
                    // Der 1.1. eines Jahres kann noch zur letzten Woche des Vorjahres gehören
                    // und der 31.12. bereits zur 1. Woche des nächsten Jahres.
                    // damit das richtige Jahr angezeigt wird, je nachdem das start- oder enddatum nehmen.
                    if (valDateStart.getMonth >= 6) {
                        ret = kijs.Date.format(valDateEnd, this._displayWeekFormat);
                    } else {
                        ret = kijs.Date.format(valDateStart, this._displayWeekFormat);
                    }

                    // Evtl. Präfix einfügen
                    if (!kijs.isEmpty(this._displayWeekPrefix)) {
                        ret = kijs.String.replaceAll(this._displayWeekPrefix, '%1', ret);
                    }
                }
                break;

            // date, time und dateTime
            case 'date':
            case 'time':
            case 'dateTime':
                let datetime = null;
                let formatOptions = {};

                // Startdatum (und evtl. -Uhrzeit)
                // Wenn noch eine Uhrzeit verwendet wird: mit Uhrzeit ergänzen
                if (this._hasTime()) {
                    // falls kein Datum existiert, den 01.01.1970 nehmen
                    if (kijs.isEmpty(valDateStart)) {
                        datetime = kijs.Date.getDatePart(new Date('1970-01-01'));
                    } else {
                        datetime = kijs.Date.getDatePart(valDateStart);
                    }

                    // Datum und Uhrzeit zusammenfügen
                    if (!kijs.isEmpty(valTime)) {
                        let sqlDate = kijs.Date.getSqlDate(datetime);
                        sqlDate += ' ' + valTime;
                        datetime = kijs.Date.create(sqlDate);
                    }

                // sonst nur das Datum
                } else {
                    if (kijs.isEmpty(valDateStart)) {
                        datetime = null;
                    } else {
                        datetime = kijs.Date.getDatePart(valDateStart);
                    }
                }

                // Format für den Datums-Teil ermitteln
                if (!kijs.isEmpty(valDateStart)) {
                    switch (this._mode) {
                        case 'date':
                        case 'dateTime':
                            formatOptions.day = '2-digit';
                            formatOptions.month = '2-digit';
                            formatOptions.year = 'numeric';
                            break;
                    }
                }

                // Format für den Uhrzeit-Teil ermitteln
                if (!kijs.isEmpty(valTime)) {
                    switch (this._mode) {
                        case 'dateTime':
                        case 'time':
                            if (this._timePicker.minutesHide) {
                                formatOptions.hour = '2-digit';
                            } else if (this._timePicker.secondsHide) {
                                formatOptions.hour = '2-digit';
                                formatOptions.minute = '2-digit';
                            } else {
                                formatOptions.hour = '2-digit';
                                formatOptions.minute = '2-digit';
                                formatOptions.second = '2-digit';
                            }
                            break;
                    }
                }

                if (!kijs.isEmpty(formatOptions)) {
                    if (formatOptions.year || formatOptions.month || formatOptions.day ) {
                        ret = datetime.toLocaleDateString(kijs.language, formatOptions);
                    } else {
                        ret = datetime.toLocaleTimeString(kijs.language, formatOptions);
                    }
                }

            break;
        }

        return ret;
    }

    /**
     * Wird der DatePicker angezeigt?
     * @return {unresolved}
     */
    _hasDate() {
        return this._mode === 'date' || this._mode === 'dateTime' || this._mode === 'week' || this._mode === 'range';
    }

    /**
     * Wird der TimePicker angezeigt?
     * @return {unresolved}
     */
    _hasTime() {
        return this._mode === 'time' || this._mode === 'dateTime';
    }

    _parseString(strInput) {
        let ok = false;

        switch (this._mode) {
            case 'date':
                this._datePicker.value = kijs.Date.parseLocalDateString(strInput, this._year2000Threshold);
                this._datePicker.valueEnd = null;
                this._timePicker.value = '';
                break;

            case 'time':
                this._datePicker.value = null;
                this._datePicker.valueEnd = null;
                this._timePicker.value = kijs.Date.parseLocalTimeString(strInput);
                break;

            case 'dateTime':
                let dateTime = kijs.Date.parseLocalDateTimeString(strInput, this._year2000Threshold);
                if (dateTime) {
                    this._datePicker.value = kijs.Date.getDatePart(dateTime);
                    this._datePicker.valueEnd = null;
                    this._timePicker.value = kijs.Date.format(dateTime, 'H:i:s');
                } else {
                    this._datePicker.value = null;
                    this._datePicker.valueEnd = null;
                    this._timePicker.value = '';
                }
                break;

            case 'week':
                let date = kijs.Date.parseLocalWeekString(strInput, this._year2000Threshold);

                if (date) {
                    this._datePicker.value = date;
                    this._datePicker.valueEnd = kijs.Date.getSunday(date);
                    this._timePicker.value = '';
                } else {
                    this._datePicker.value = null;
                    this._datePicker.valueEnd = null;
                    this._timePicker.value = '';
                }
                break;
                
            case 'range':
                let seperators = ['-', 'bis', 'to', 'until', 'till', 'by', 'jusqu\'au', 'jusque', 'fino al', 'fino a', 'al', 'au', 'à'];
                let dateStart = null;
                let dateEnd = null;
                let arr;
                
                ok = true;

                // Falls noch nicht vorhanden, den Separator der aktuellen Sprache hinzufügen.
                let sep = kijs.getText('%1 bis %2');
                sep = sep.replace('%1', '');
                sep = sep.replace('%2', '');
                sep = sep.trim();
                if (!kijs.Array.contains(seperators, sep)) {
                    seperators.push(sep);
                }

                // Zulässige Trennzeichen durch #|@# ersetzen
                for (let i=0; i<seperators.length; i++) {
                    strInput = kijs.String.replaceAll(strInput, seperators[i], '#|@#');
                }

                // Splitten nach #|@#
                arr = strInput.split('#|@#');

                // Werte Trimmen
                for (let i=0; i<arr.length; i++) {
                    arr[i] = arr[i].trim();
                }

                // Der String muss aus zwei Bestandteilen bestehen
                if (arr.length !== 2) {
                    ok = false;
                }

                // Datum von
                if (ok) {
                    dateStart = kijs.Date.parseLocalDateString(arr[0], this._year2000Threshold);
                    if (kijs.isEmpty(dateStart)) {
                        ok = false;
                    }
                }

                // Datum bis
                if (ok) {
                    dateEnd = kijs.Date.parseLocalDateString(arr[1], this._year2000Threshold);
                    if (kijs.isEmpty(dateEnd)) {
                        ok = false;
                    }
                }

                if (ok) {
                    this._datePicker.value = dateStart;
                    this._datePicker.valueEnd = dateEnd;
                    this._timePicker.value = '';
                } else {
                    this._datePicker.value = null;
                    this._datePicker.valueEnd = null;
                    this._timePicker.value = '';
                }
                break;
        }
    }
    
    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        const date = this._datePicker.date;
        const dateEnd = this._datePicker.dateEnd;
        const time = this._timePicker.value;

        // Datum validieren
        if (this._hasDate()) {
            if (!kijs.isEmpty(date) || !kijs.isEmpty(dateEnd)) {

                // Start- und Enddatum validieren
                if (this._mode === 'range' || this._mode === 'week') {

                    // Es fehlt das Start- oder Enddatum
                    if (kijs.isEmpty(date) || kijs.isEmpty(dateEnd)) {
                        this._errors.push(kijs.getText('Es fehlt das Start- oder Enddatum'));
                    }

                    // Min. value
                    if ( (!kijs.isEmpty(date) && !kijs.isEmpty(this._datePicker.minDate) && date < this._datePicker.minDate)
                            || (!kijs.isEmpty(dateEnd) && !kijs.isEmpty(this._datePicker.minDate) && dateEnd < this._datePicker.minDate) ) {

                        this._errors.push(
                            kijs.getText('Der minimale Wert für dieses Feld ist %1',
                                '',
                                this._datePicker.minDate.toLocaleDateString(kijs.language, {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric'
                                })
                            )
                        );
                    }

                    // Max. value
                    if ( (!kijs.isEmpty(date) && !kijs.isEmpty(this._datePicker.maxDate) && date > this._datePicker.maxDate)
                            || (!kijs.isEmpty(dateEnd) && !kijs.isEmpty(this._datePicker.maxDate) && dateEnd < this._datePicker.maxDate) ) {

                        this._errors.push(
                            kijs.getText('Der maximale Wert für dieses Feld ist %1',
                                '',
                                this._datePicker.maxDate.toLocaleDateString(kijs.language, {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric'
                                })
                            )
                        );
                    }

                // nur Startdatum validieren
                } else {

                    // Min. value
                    if (!kijs.isEmpty(date) && !kijs.isEmpty(this._datePicker.minDate) && date < this._datePicker.minDate) {
                        this._errors.push(
                            kijs.getText('Der minimale Wert für dieses Feld ist %1',
                                '',
                                this._datePicker.minDate.toLocaleDateString(kijs.language, {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric'
                                })
                            )
                        );
                    }

                    // Max. value
                    if (!kijs.isEmpty(date) && !kijs.isEmpty(this._datePicker.maxDate) && date > this._datePicker.maxDate) {
                        this._errors.push(
                            kijs.getText('Der maximale Wert für dieses Feld ist %1',
                                '',
                                this._datePicker.maxDate.toLocaleDateString(kijs.language, {
                                    day: '2-digit',
                                    month: '2-digit',
                                    year: 'numeric'
                                })
                            )
                        );
                    }

                }

            } else if (kijs.isEmpty(date) && !kijs.isEmpty(value)) {
                this._errors.push(kijs.getText('Das Datum darf nicht leer sein'));

            }
        }

        // Uhrzeit validieren
        if (this._hasTime()) {
            if (this._timeRequired && kijs.isEmpty(time) && !kijs.isEmpty(value)) {
                this._errors.push(kijs.getText('Die Uhrzeit darf nicht leer sein'));
            }
        }

        super._validationRules(value, ignoreEmpty);
    }

    /**
     * Ergänzt die 0 einer Zahl.
     * @param {Integer|String} number
     * @param {Integer} lenght
     * @returns {String}
     */
    _zeroPad(number, lenght=2) {
        number = kijs.toString(number);
        while (number.length < lenght) {
            number = '0' + number;
        }
        return number;
    }


    // PRIVATE
    // LISTENERS
    #onDatePickerChange(e) {
        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());
    }

    #onDatePickerEmptyClick(e) {
        this._timePicker.value = '';

        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());

        this._spinBoxEl.close();
    }

    #onDatePickerInputFinished(e) {
        if (!this._hasTime()) {
            this._spinBoxEl.close();
        }
    }

    #onDatePickerTodayClick(e) {
        if (!this._hasTime()) {
            this._spinBoxEl.close();
        }
    }

    #onInputDomChange(e) {
        this._parseString(e.nodeEvent.target.value);

        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());

        this.validate();

        // Falls etwas geändert hat: Change Event auslösen
        const value = this.value;
        const valueEnd = this.valueEnd;
        if (this._previousChangeValue !== value || this._previousChangeValueEnd !== valueEnd) {
            this.raiseEvent('input', {
                value: value,
                valueEnd: valueEnd,
                oldValue: this._previousChangeValue,
                oldValueEnd: this._previousChangeValueEnd
            });
            this.raiseEvent('change', {
                value: value,
                valueEnd: valueEnd,
                oldValue: this._previousChangeValue,
                oldValueEnd: this._previousChangeValueEnd
            });
            this._previousChangeValue = value;
            this._previousChangeValueEnd = valueEnd;
        }
    }

    #onInputDomDblClick() {
        // Mobile: Tastatur anzeigen beim Doppelklick
        // Funktioniert nur in Chrome
        if ('virtualKeyboard' in window.navigator) {
            window.navigator.virtualKeyboard.show();
        }
    }

    #onInputDomInput(e) {
        this.errorsReset();
    }

    #onSpinBoxElClose(e) {
        this.validate();

        // Falls etwas geändert hat: Change Event auslösen
        const value = this.value;
        const valueEnd = this.valueEnd;
        if (this._previousChangeValue !== value || this._previousChangeValueEnd !== valueEnd) {
            this.raiseEvent('input', {
                value: value,
                valueEnd: valueEnd,
                oldValue: this._previousChangeValue,
                oldValueEnd: this._previousChangeValueEnd
            });
            this.raiseEvent('change', {
                value: value,
                valueEnd: valueEnd,
                oldValue: this._previousChangeValue,
                oldValueEnd: this._previousChangeValueEnd
            });
            this._previousChangeValue = value;
            this._previousChangeValueEnd = valueEnd;
        }
    }

    #onSpinButtonClick(e) {
        if (this.disabled || this.readOnly) {
             return;
        }
        if (this._spinBoxEl) {
            if (this._spinBoxEl.isRendered) {
                this._spinBoxEl.close();
            } else {
                this._spinBoxEl.show();
            }
        }
    }
    
    #onTimePickerChange(e) {
        this._inputDom.nodeAttributeSet('value', this._getDisplayValue());
    }

    #onTimePickerEmptyClick(e) {
        this._spinBoxEl.close();
    }
    #onTimePickerInputFinished(e) {
        this._spinBoxEl.close();
    }

    #onTimePickerNowClick(e) {
        if (!this._hasDate() || !kijs.isEmpty(this._datePicker.date)) {
            this._spinBoxEl.close();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._inputDom) {
            this._inputDom.destruct();
        }
        if (this._datePicker) {
            this._datePicker.destruct();
        }
        if (this._seperatorEl) {
            this._seperatorEl.destruct();
        }
        if (this._timePicker) {
            this._timePicker.destruct();
        }
        if (this._spinBoxEl) {
            this._spinBoxEl.destruct();
        }
        if (this._buttonsDom) {
            this._buttonsDom.destruct();
        }
        if (this._spinButtonEl) {
            this._spinButtonEl.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._inputDom = null;
        this._datePicker = null;
        this._seperatorEl = null;
        this._timePicker = null;
        this._spinBoxEl = null;
        this._buttonsDom = null;
        this._spinButtonEl = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.field.Range
// --------------------------------------------------------------

// TODO: Besser direkt von kijs.gui.field.Field erben?
// TODO: Vertikale Schieber?
// TODO: Wert anzeigen
// TODO: der default von disableFlex sollte false sein

/**
 * EVENTS
 * ----------
 * blur
 * input
 *
 * // Geerbte Events
 * add
 * afterFirstRenderTo
 * afterRender
 * afterResize
 * beforeAdd
 * beforeRemove
 * changeVisibility
 * childElementAfterResize
 * dblClick
 * contextMenu
 * destruct
 * drag
 * dragEnd
 * dragLeave
 * dragOver
 * dragStart
 * drop
 * focus
 * mouseDown
 * mouseLeave
 * mouseMove
 * mouseUp
 * remove
 * wheel
 *
 * // key events
 * keyDown
 * enterPress
 * enterEscPress
 * escPress
 * spacePress
 */
kijs.gui.field.Range = class kijs_gui_field_Range extends kijs.gui.field.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._inputDom.nodeAttributeSet('type', 'range');
        this._dom.clsRemove('kijs-field-text');
        this._dom.clsAdd('kijs-field-range');

         // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            min  : 0,
            max  : 100,
            step : 1,
            value: 50
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            min: { target: 'min' },
            max: { target: 'max' },
            step: { target: 'step' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // overwrite
    get isEmpty() { return false; }

    set max(val) { this._inputDom.nodeAttributeSet('max', val); }
    get max() { return this._inputDom.nodeAttributeGet('max'); }

    set min(val) { this._inputDom.nodeAttributeSet('min', val); }
    get min() { return this._inputDom.nodeAttributeGet('min'); }

    // overwrite
    // 'range' kennt das HTML-Attribut readOnly nicht,
    // darum disabled benutzen.
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        if (val) {
            this._inputDom.disabled = true;
        } else {
            this._inputDom.disabled = false;
        }
    }

    set step(val) { this._inputDom.nodeAttributeSet('step', val); }
    get step() { return parseInt(this._inputDom.nodeAttributeGet('step')); }

    set value(val) { super.value = val; }
    get value() { return parseInt(super.value); }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid (namespace)
// --------------------------------------------------------------
kijs.gui.grid = {};
/* global kijs, this */

// TODO: load() ist nicht kompatibel mit Basisklasse
// TODO: Sortable für Spaltenreihenfolge
// TODO: Sortable für Zeilenreihenfolge
// --------------------------------------------------------------
// kijs.gui.grid.Grid
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * afterLoad
 * beforeSelectionChange
 * selectionChange
 * rowClick
 * rowDblClick
 *
 */
kijs.gui.grid.Grid = class kijs_gui_grid_Grid extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._rpc = null;                   // Instanz von kijs.gui.Rpc
        this._rows = [];
        this._columnConfigs = [];
        this._primaryKeys = [];
        this._rpcLoadFn = null;
        this._rpcLoadArgs = null;
        this._rpcSaveFn = null;      // TODO: Wird nicht verwendet !!!!!!!!!
        this._rpcSaveArgs = null;    // TODO: Wird nicht verwendet !!!!!!!!!
        this._waitMaskTarget = null;
        this._waitMaskTargetDomProperty = null;

        this._autoLoad = true;              // Datensätze nach dem Rendern automatisch vom Server laden
        this._remoteDataLoaded = 0;         // Anzahl im Grid geladener Datensätze
        this._remoteDataStartIndex = 0;     // Start-Index für Datensätze, die als nächstes geladen werden
        this._remoteDataStep = 100;         // Anzahl Datensätze, die pro request hinzugefügt werden.
        this._remoteDataTotal = null;       // Falls von Server verfügbar die total verfügbaren Datensätze, sonst die bisher geladenen
        this._remoteDataLastRowCnt = 0;     // Anzahl Datensätze des letzten Remote-Loads
        this._getRemoteMetaData = true;     // Metadaten laden?
        this._isLoading = false;            // wird zurzeit geladen?
        this._remoteSort = null;            // Remote-Sortierung

        this._lastSelectedRow = null;       // letzte Zeile, die selektiert wurde
        this._currentRow = null;            // Zeile, welche zurzeit fokusiert ist
        this._selectType = 'single';        // multiselect: single|multi|simple|none
        this._focusable = true;             // ob das grid focusiert weden kann
        this._filterable = false;

        // Intersection Observer (endless grid loader)
        this._intersectionObserver = null;

        this._dom.clsAdd('kijs-grid');

        // dom - elemente erstellen

        // 3 Zeilen
        this._topDom = new kijs.gui.Dom({cls: 'kijs-top'});
        this._middleDom = new kijs.gui.Dom({cls: 'kijs-center'});
        this._bottomDom = new kijs.gui.Dom({cls: 'kijs-bottom'});

        this._tableContainerDom = new kijs.gui.Dom({cls: 'kijs-tablecontainer', on:{scroll: this.#onTableScroll, context: this}});
        this._tableDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._headerContainerDom = new kijs.gui.Dom({cls: 'kijs-headercontainer'});
        this._headerDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._footerContainerDom = new kijs.gui.Dom({cls: 'kijs-footercontainer'});
        this._footerDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._leftContainerDom = new kijs.gui.Dom({cls: 'kijs-leftcontainer'});
        this._leftDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._rightContainerDom = new kijs.gui.Dom({cls: 'kijs-rightcontainer'});
        this._rightDom = new kijs.gui.Dom({nodeTagName: 'table'});

        // header
        this._headerLeftContainerDom = new kijs.gui.Dom({cls: 'kijs-headercontainer-left'});
        this._headerLeftDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._headerRightContainerDom = new kijs.gui.Dom({cls: 'kijs-headercontainer-right'});
        this._headerRightDom = new kijs.gui.Dom({nodeTagName: 'table'});

        // footer
        this._footerLeftContainerDom = new kijs.gui.Dom({cls: 'kijs-footercontainer-left'});
        this._footerLeftDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._footerRightContainerDom = new kijs.gui.Dom({cls: 'kijs-footercontainer-right'});
        this._footerRightDom = new kijs.gui.Dom({nodeTagName: 'table'});

        // header / filter
        this._header = new kijs.gui.grid.Header({parent: this});
        this._filter = new kijs.gui.grid.Filter({parent: this});

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            waitMaskTarget           : this,
            waitMaskTargetDomProperty: 'dom'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autoLoad:       true,
            rpc:            { target: 'rpc' },  // Instanz von kijs.gui.Rpc oder Name einer RPC
            rpcLoadFn:      true,
            rpcLoadArgs:    true,
            rpcSaveFn:      true,
            rpcSaveArgs:    true,
            waitMaskTarget: true,
            waitMaskTargetDomProperty: true,

            columnConfigs:  { fn: 'function', target: this.columnConfigAdd, context: this },
            primaryKeys:    { target: 'primaryKeys' },
            data:           { target: 'data' },
            remoteDataStep: { target: 'remoteDataStep' },

            focusable: true,
            filterable: true,
            filterVisible: { target: 'filterVisible' },
            selectType: { target: 'selectType' } // 'none': Es kann nichts selektiert werden
                                                 // 'single' (default): Es kann nur ein Datensatz selektiert werden
                                                 // 'multi': Mit den Shift- und Ctrl-Tasten können mehrere Datensätze selektiert werden.
                                                 // 'simple': Es können mehrere Datensätze selektiert werden. Shift- und Ctrl-Tasten müssen dazu nicht gedrückt werden.
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this.on('keyDown', this.#onKeyDown, this);
    }


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get current() { return this._currentRow; }
    /**
     * Setzt die aktuelle Zeile, die den Fokus erhalten wird.
     * Null = automatische Ermittlung
     * Um den Fokus zu setzen verwenden Sie stattdessen die Funktion .focus() von der Zeile.
     * @param {kijs.gui.grid.Row|null} cRow
     * @returns {undefined}
     */
    set current(cRow) {
        // Falls kein cRow übergeben wurde:
        if (!cRow && !kijs.isEmpty(this._rows)) {

            // Falls es schon ein gültiges Current-Zeile gibt, dieses nehmen
            if (this._currentRow && kijs.Array.contains(this._rows, this._currentRow)) {
                cRow = this._currentRow;
            }

            // Sonst die erste selektierte Zeile
            if (!cRow) {
                let sel = this.getSelected();
                if (!kijs.isEmpty(sel)) {
                    if (kijs.isArray(sel)) {
                        sel = sel[0];
                    }
                    cRow = sel;
                }
            }

            // Sonst halt die erste Zeile
            if (!cRow) {
                cRow = this._rows[0];
            }
        }

        this._currentRow = cRow;

        kijs.Array.each(this._rows, function(row) {
            if (row === cRow) {
                row.dom.clsAdd('kijs-current');
            } else {
                row.dom.clsRemove('kijs-current');
            }
            // Nur das currentRow darf den Fokus erhalten können
            if (this._focusable && row === cRow) {
                cRow.dom.nodeAttributeSet('tabIndex', 0);
            } else {
                row.dom.nodeAttributeSet('tabIndex', undefined);
            }
        }, this);
    }

    get columnConfigs() { return this._columnConfigs; }

    set data(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        this.rowsRemoveAll();
        this.rowsAdd(val);
    }
    get data() {
        let dataRows = [];
        kijs.Array.each(this._rows, function(row) {
            dataRows.push(row.dataRow);
        }, this);
        return dataRows;
    }

    get filter() { return this._filter; }

    get filterable() { return this._filterable; }
    set filterable(val) { this._filterable = !!val; }

    get filterVisible() { return this._filter.visible; }
    set filterVisible(val) { this._filter.visible = !!val; }

    get firstRow() {
        if (this._rows.length > 0) {
            return this._rows[0];
        }
        return null;
    }

    get lastRow() {
        if (this._rows.length > 0) {
            return this._rows[this._rows.length-1];
        }
        return null;
    }

    set primaryKeys(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        kijs.Array.each(val, function(k) {
           if (!kijs.isString(k)) {
               throw new kijs.Error('invalid primary key');
           }
        }, this);
        this._primaryKeys = val;
    }
    get primaryKeys() { return this._primaryKeys; }

    get remoteDataStep() { return this._remoteDataStep; }
    set remoteDataStep(val) {
        if (!kijs.isInteger(val)) {
            val = 100;
        }
        this._remoteDataStep = val;
    }

    get rows() { return this._rows; }

    get rowsCount() { return this._remoteDataTotal || this._remoteDataLoaded; }

    get rpc() {
        return this._rpc || kijs.getRpc('default');
    }
    set rpc(val) {
        if (kijs.isString(val)) {
            val = kijs.getRpc(val);
        }

        if (val instanceof kijs.gui.Rpc) {
            this._rpc = val;
        } else {
            throw new kijs.Error(`Unknown format on config "rpc"`);
        }
    }

    get rpcLoadArgs() { return this._rpcLoadArgs; }
    set rpcLoadArgs(val) { this._rpcLoadArgs = val; }

    get rpcSaveArgs() { return this._rpcSaveArgs; }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }

    get selectType() { return this._selectType; }
    set selectType(val) {
        if (!kijs.Array.contains(['single', 'multi', 'simple', 'none'], val)) {
            throw new kijs.Error('invalid value for selectType');
        }
        this._selectType = val;
    }


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Entfernt alle Selektionen
     * @param {Boolean} [preventSelectionChange=false]    Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    clearSelections(preventSelectionChange) {
        this.unSelect(this._rows, preventSelectionChange);
    }

    /**
     * Setzt alle dirty-records zurück.
     * @returns {undefined}
     */
    commit() {
        kijs.Array.each(this._rows, function(row) {
            row.commit();
        }, this);
    }

    columnConfigAdd(columnConfigs) {
        if (!kijs.isArray(columnConfigs)) {
            columnConfigs = [columnConfigs];
        }

        kijs.Array.each(columnConfigs, function(columnConfig) {
            let inst = this._getInstance(columnConfig, 'kijs.gui.grid.columnConfig.Text', kijs.gui.grid.columnConfig.ColumnConfig);
            inst.grid = this;
            this._columnConfigs.push(inst);
        }, this);

        if (this.isRendered) {
            this.render();
        }
    }

    /**
     * Gibt eine columnConfig anhand ihres valueField-Wertes zurück
     * @param {String} valueField
     * @returns {kijs.gui.grid.columnConfig.ColumnConfig|null}
     */
    getColumnConfigByValueField(valueField) {
        let cC = null;
        kijs.Array.each(this._columnConfigs, function(columnConfig) {
            if (columnConfig.valueField === valueField) {
                cC = columnConfig;
                return false;
            }
        }, this);

        return cC;
    }

    /**
     * Gibt die rows zurück, welche das dirty-flag haben.
     * @returns {Array}
     */
    getDirtyRows() {
        let dirtyRows = [];
        kijs.Array.each(this._rows, function(row) {
            if (row.isDirty) {
                dirtyRows.push(row);
            }
        }, this);

        return dirtyRows;
    }

    /**
     * Gibt die selektieten Zeilen zurück
     * Bei selectType='single' wird das Row direkt zurückgegeben, sonst ein Array mit den Zeilen
     * @returns {Array|kijs.gui.grid.Row|null}
     */
    getSelected() {
        let ret = [];
        for (let i=0; i<this._rows.length; i++) {
            if (this._rows[i].selected) {
                ret.push(this._rows[i]);
            }
        }

        if (this._selectType === 'none') {
            return null;

        } else if (this._selectType === 'single') {
            return ret.length ? ret[0] : null;

        } else {
            return ret;
        }
    }

    /**
     * Gibt die IDs der selektierten Datensätze zurück.
     * @returns {Array}
     */
    getSelectedIds() {
        let rows = this.getSelected(),
            hasPrimarys = this._primaryKeys.length > 0,
            multiPrimarys = this._primaryKeys.length > 1;

        // keine Rows selektiert
        if (!rows) {
            return [];
        }

        // single type: Es kommt ein Objekt
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        // Falls keine Primaries vorhanden sind, werden die rows zurückgegeben.
        if (!hasPrimarys) {
            return rows;

        // Falls nur ein primary existiert, wird ein array mit den Ids zurückgegeben
        } else if (!multiPrimarys) {
            let ids = [], primaryKey = this._primaryKeys[0];
            kijs.Array.each(rows, function(row) {
                ids.push(row.dataRow[primaryKey]);
            }, this);

            return ids;

        // Mehrere primary keys: Pro Zeile ein Objekt mit dem Ids zurückgeben
        } else {
            let ids = [];
            kijs.Array.each(rows, function(row) {
                let idRow = {};
                kijs.Array.each(this._primaryKeys, function(pk) {
                    idRow[pk] = row.dataRow[pk];
                }, this);
                ids.push(idRow);
            }, this);

            return ids;
        }
    }

    /**
     * TODO: Wir müssten nur einzelne Rows updaten können.
     * Wenn Zeile 1000 geändert wird sind wir wieder bei 1 und müssen bis Zeile 1000 scrollen, da diese nicht mehr geladen ist.
     * Als Workaround laden wir bei resetData = false alle im Grid vorhandenen Rows neu. Siehe this._remoteLoad():
     *
     * Lädt die Daten im Grid neu.
     * @param {Boolean} restoreSelection
     * @param {Boolean} resetData Vollständig & von Anfang an neu laden (z.B. beim Filtern, Sortieren)
     * @returns {Promise}
     */
    reload(restoreSelection = true, resetData = true) {
        let selected = this.getSelectedIds();
        return this._remoteLoad(resetData).then((responseData) => {

            // Selektion wiederherstellen
            if (selected && restoreSelection) {
                this.selectByIds(selected, false, true);
            }

            if (
                this._tableDom.node
                && !this._tableDom.node.height
                && !this._tableDom.node.scrollWidth
                && this._header.node.scrollWidth
            ) {

                // Falls keine Zeilen vorhanden sind, lässt sich die Tabelle nicht mehr scrollen.
                // Also geben wir der leeren Tabelle eine Grösse, damit man dort scrollen kann.
                this._tableDom.width = this._header.node.scrollWidth;
                this._tableDom.height = 200;
            } else {
                this._tableDom.width = null;
                this._tableDom.height = null;
            }

            return responseData;
        });
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // Elemente in den haupt-dom
        this._topDom.renderTo(this._dom.node);
        this._middleDom.renderTo(this._dom.node);
        this._bottomDom.renderTo(this._dom.node);

        // header / filter
        this._headerLeftContainerDom.renderTo(this._topDom.node);
        this._headerContainerDom.renderTo(this._topDom.node);
        this._headerRightContainerDom.renderTo(this._topDom.node);

        // center (grid)
        this._leftContainerDom.renderTo(this._middleDom.node);
        this._tableContainerDom.renderTo(this._middleDom.node);
        this._rightContainerDom.renderTo(this._middleDom.node);

        // footer (summary)
        this._footerLeftContainerDom.renderTo(this._bottomDom.node);
        this._footerContainerDom.renderTo(this._bottomDom.node);
        this._footerRightContainerDom.renderTo(this._bottomDom.node);

        // header
        this._headerLeftDom.renderTo(this._headerLeftContainerDom.node);
        this._headerDom.renderTo(this._headerContainerDom.node);
        this._headerRightDom.renderTo(this._headerRightContainerDom.node);

        // center
        this._leftDom.renderTo(this._leftContainerDom.node);
        this._tableDom.renderTo(this._tableContainerDom.node);
        this._rightDom.renderTo(this._rightContainerDom.node);

        // bottom
        this._footerLeftDom.renderTo(this._footerLeftContainerDom.node);
        this._footerDom.renderTo(this._footerContainerDom.node);
        this._footerRightDom.renderTo(this._footerRightContainerDom.node);

        // header / filter
        this._header.renderTo(this._headerDom.node);
        this._filter.renderTo(this._headerDom.node);

        // rows
        this._renderRows();

        // footer (TODO)

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }

        // Daten laden
        if (this._autoLoad) {
            this._autoLoad = false; // Daten nur beim ersten rendern automatisch laden.
            kijs.defer(function() {
                if (this._remoteDataLoaded === 0) {
                    this._remoteLoad(true);
                }
            }, 30, this);
        }
    }

    /**
     * Fügt eine neue Zeile hinzu oder aktualisiert eine bestehende
     * @param {Array} rows
     * @param {Number} startOffset Offset, ab dem die Rows einsortiert werden, wenn bestehende rows aktualisiert werden
     * @returns {Number} Anzahl neue Zeilen
     */
    rowsAdd(rows, startOffset=null) {
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        let renderStartOffset = this._rows.length,
            newRows = 0,
            rowPos=0,
            offsets=[];

        kijs.Array.each(rows, function(row) {
            let currentPos = null;

            // instanz einer row gegeben. Direkt einfügen
            if (row instanceof kijs.gui.grid.Row) {
                row.parent = this;
                this._rows.push(row);

                // Position der neuen row merken
                currentPos = this._rows.length-1;

            } else {

                // row per primary key suchen
                let pRow = this._getRowByPrimaryKey(row);

                if (pRow) {

                    // bestehende row updaten
                    pRow.updateDataRow(row);

                    // Position der bestehenden Row merken
                    currentPos = this._rows.indexOf(pRow);

                } else {
                    newRows++;

                    // neue row hinzufügen
                    this._rows.push(new kijs.gui.grid.Row({
                        parent: this,
                        dataRow: row,
                        on: {
                            click: this.#onRowClick,
                            dblClick: this.#onRowDblClick,
                            context: this
                        }
                    }));

                    // Position der neuen row merken
                    currentPos = this._rows.length-1;
                }
            }

            // korrekt einsortieren
            if (startOffset !== null && currentPos !== (startOffset + rowPos)) {
                kijs.Array.move(this._rows, currentPos, startOffset + rowPos);
            }
            offsets.push(startOffset + rowPos);

            // Zähler
            rowPos++;

        }, this);

        // Alle Elemente ab dem ersten neu eingefügten Element neu rendern
        if (offsets.length > 0) {
            renderStartOffset = kijs.Array.min(offsets);
        }
        if (this.isRendered && this._rows.length > renderStartOffset) {
            this._renderRows(renderStartOffset);
        }

        return newRows;
    }

    rowsRemove(rows) {
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        kijs.Array.each(rows, function(delRow) {

            // Row-Objekt: Dieses entfernen
            if (delRow instanceof kijs.gui.grid.Row) {
                kijs.Array.remove(this._rows, delRow);
                delRow.destruct();

            } else {
                // DataRow-Objekt: Suchen und entfernen
                kijs.Array.each(this._rows, function(row) {
                    if (row.dataRow === delRow) {
                        this.rowsRemove([row]);
                    }
                }, this);
            }
        }, this);
    }

    rowsRemoveAll() {
        this._remoteDataLoaded = 0;
        this._remoteDataStartIndex = 0;
        while (this._rows.length > 0) {
            this.rowsRemove(this._rows[0]);
        }
        this.scrollTo(0);
    }

    scrollTo(scrollTop, scrollLeft) {
        if (kijs.isInteger(scrollTop)) {
            if (this._leftContainerDom && this._leftContainerDom.node && this._leftContainerDom.node.scrollTop) {
                this._leftContainerDom.node.scrollTop = scrollTop;
            }
            if (this._rightContainerDom && this._rightContainerDom.node && this._rightContainerDom.node.scrollTop) {
                this._rightContainerDom.node.scrollTop = scrollTop;
            }
        }

        if (kijs.isInteger(scrollLeft)) {
            if (this._headerContainerDom && this._headerContainerDom.node && this._headerContainerDom.node.scrollTop) {
                this._headerContainerDom.node.scrollLeft = scrollLeft;
            }
            if (this._footerContainerDom && this._footerContainerDom.node && this._footerContainerDom.node.scrollTop) {
                this._footerContainerDom.node.scrollLeft = scrollLeft;
            }
        }
    }

    /**
     * Selektiert eine oder mehrere Zeilen
     * @param {kijs.gui.grid.Row|Array} rows oder Array mit Zeilen, die selektiert werden sollen
     * @param {Boolean} [keepExisting=false]  Soll die bestehende selektion belassen werden?
     * @param {Boolean} [preventEvent=false]  Soll der SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    select(rows, keepExisting=false, preventEvent=false) {
        if (kijs.isEmpty(rows)) {
            rows = [];
        }

        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        // beforeSelectionChange-Event
        if (!preventEvent) {
            let beforeSelectionChangeArgs = {rows: rows, unSelect: false, keepExisting: keepExisting, cancel: false};
            this.raiseEvent('beforeSelectionChange', beforeSelectionChangeArgs);

            // selectionChange verhindern?
            if (beforeSelectionChangeArgs.cancel === true) {
                return false;
            }
        }

        if (!keepExisting) {
            this.clearSelections(true);
        }

        kijs.Array.each(rows, function(row) {
            row.selected = true;
            row.focus();
        }, this);

        // SelectionChange auslösen
        if (!preventEvent) {
            this.raiseEvent('selectionChange', { rows: rows, unSelect: false });
        }

        return true;
    }

    /**
     * Selektiert alle Zeilen zwischen row1 und row2
     * @param {kijs.gui.grid.Row} row1
     * @param {kijs.gui.grid.Row} row2
     * @param {Boolean} [keepExisting=true]                Soll die bestehende Selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]     Soll das SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    selectBetween(row1, row2, keepExisting=true, preventSelectionChange=false) {
        let found = false;
        let rows = [];

        // Alle Zeilen zwischen dem vorher selektierten Row und dem aktuellen Row selektieren
        kijs.Array.each(this._rows, function(row) {
            if (!found) {
                if (row === row1) {
                    found = 'row1';
                } else if (row === row2) {
                    found = 'row2';
                }
            }

            if (found) {
                rows.push(row);
            }

            if ((found==='row1' && row===row2) || (found==='row2' && row===row1)) {
                return false;
            }
        }, this);


        if (!kijs.isEmpty(rows)) {
            return this.select(rows, keepExisting, preventSelectionChange);
        }

        return true;
    }

    /**
     * Selektiert Datensätze anhand der ID
     * @param {Array} ids Array vonIds [id1, id2] oder bei mehreren primaryKeys ein Objekt mit {pkName: pkValue, pk2Name: pk2Value}
     * @param {Boolean} [keepExisting=false]  Soll die bestehende Selektion belassen werden?
     * @param {Boolean} [preventEvent=false]  Soll der SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    selectByIds(ids, keepExisting=false, preventEvent=false) {
        let hasPrimarys = this._primaryKeys.length > 0,
            multiPrimarys = this._primaryKeys.length > 1,
            rows = [];

        if (!kijs.isArray(ids)) {
            ids = [ids];
        }

        // Keine Primarys, keine ID's
        if (!hasPrimarys || !ids) {
            return;
        }

        // Array mit ID's übergeben: umwandeln in Array mit Objekten
        if (!multiPrimarys && !kijs.isObject(ids[0])) {
            let pk = this._primaryKeys[0];
            for (let i=0; i<ids.length; i++) {
                let val = ids[i];
                ids[i] = {};
                ids[i][pk] = val;
            }
        }

        // Zeilen holen
        for (let i=0; i<ids.length; i++) {
            if (kijs.isObject(ids[i])) {
                let match=false;

                kijs.Array.each(this._rows, function(row) {
                    match = true;

                    for (let idKey in ids[i]) {
                        if (row.dataRow[idKey] !== ids[i][idKey]) {
                            match = false;
                        }
                    }

                    if (match) {
                        rows.push(row);
                    }

                }, this);

            }
        }

        return this.select(rows, keepExisting, preventEvent);
    }


    /**
     * Selektiert eine oder mehrere Zeilen
     * @param {Array|Object} filters                    Array mit Objektdefinitionen der Zeilen, die selektiert werden sollen
     *                                                  Beispiel 1 (nur ein Datensatz wird selektiert bei nur einem Primary-Field):
     *                                                  { field: "Id", value: 123 }
     *
     *                                                  Beispiel 2 (mehrere werden selektiert bei nur einem Primary-Field):
     *                                                  [ { field: "Id", value: 123 }, { field: "Id", value: 124 } ]
     *
     *                                                  Beispiel 3 (nur ein Datensatz wird selektiert bei mehreren Primary-Fields):
     *                                                  [
     *                                                    { field: "Name", value: "Muster" },
     *                                                    { field: "Vorname", value: "Max" }
     *                                                  ]
     *
     *                                                  Beispiel 4 (mehrere Datensätze werden selektiert bei mehreren Primary-Fields):
     *                                                  [
     *                                                    [
     *                                                      { field: "Name", value: "Muster" },
     *                                                      { field: "Vorname", value: "Max" }
     *                                                    ],[
     *                                                      { field: "Name", value: "Muster" },
     *                                                      { field: "Vorname", value: "Max" }
     *                                                    ]
     *                                                  ]
     *
     * @param {Boolean} [keepExisting=false]            Soll die bestehende Selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]  Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    selectByFilters(filters, keepExisting, preventSelectionChange) {
        if (kijs.isEmpty(filters)) {
            filters = [];
        }

        // Evtl. das Format ändern auf: [ [{...}, {...}], [{...}, {...}] ]
        if (kijs.isObject(filters)) {
            filters = [filters];
        }
        for (let i=0; i<filters.length; i++) {
            if (kijs.isObject(filters[i])) {
                filters[i] = [filters[i]];
            }
        }

        // Nun die Zeilen durchgehen und wenn sie zum Filter passen: die Zeile vormerken
        const selRows = [];
        if (!kijs.isEmpty(filters)) {
            kijs.Array.each(this._rows, function(row) {
                const dataRow = row.dataRow;

                kijs.Array.each(filters, function(filterFields) {
                    let ok = false;
                    kijs.Array.each(filterFields, function(filterField) {
                        if (kijs.isEmpty(filterField.value) || kijs.isEmpty(filterField.field)) {
                            throw new kijs.Error(`Unknown filter format.`);
                        }

                        if (filterField.value === dataRow[filterField.field]) {
                            ok = true;
                        } else {
                            ok = false;
                            return false;
                        }
                    }, this);
                    if (ok) {
                        selRows.push(row);
                        return false;
                    }
                }, this);

            }, this);
        }

        // Zeilen selektieren
        const success = this.select(selRows, keepExisting, preventSelectionChange);

        // Element mit Fokus neu ermitteln
        if (success) {
            this._currentRow = null;
            this.current = null;
        }

        return success;
    }

    /**
     * Sortiert die Tabelle nach einer bestimmten Spalte.
     * @param {String} field
     * @param {String} [direction] ASC oder DESC
     * @returns {undefined}
     */
    sort(field, direction='ASC') {
        direction = direction.toUpperCase();
        if (!kijs.Array.contains(['ASC', 'DESC'], direction)) {
            throw new kijs.Error('invalid value for sort direction');
        }

        // entsprechende columnConfig finden
        let columnConfig = null;
        kijs.Array.each(this._columnConfigs, function(cC) {
            if (cC.valueField === field) {
                columnConfig = cC;
                return false;
            }
        }, this);

        if (columnConfig === null) {
            throw new kijs.Error('invalid sort field name');
        }

        this._remoteSort = {
            field: field,
            direction: direction
        };

        // store laden
        this._remoteLoad(true);
    }

    /**
     * Startet das editieren.
     * @param {null|Int|Array|kijs.gui.grid.cell.Cell} offset  Int: Row-Index; Array: [RowIndex, CellIndex].
     * @param {Boolean} reverse
     * @returns {kijs.gui.grid.cell.Cell|null} Die cell oder null, falls keine gefunden.
     */
    startCellEdit(offset=null, reverse=false) {
        let cellToEdit = null;
        let offsetMatch = offset === null;

        kijs.Array.each(this.rows, function(row, rowIndex) {
            kijs.Array.each(row.cells, function(cell, cellIndex) {

                // wird ein Int angegeben, ist der offset die row-nummer
                if (kijs.isInteger(offset) && offset === rowIndex) {
                    offsetMatch = true;
                }

                // Wird ein Array [1, 2] angegeben, wird nach [RowIndex, CellIndex] gesucht.
                if (kijs.isArray(offset) && offset.length === 2
                        && kijs.isInteger(offset[0]) && kijs.isInteger(offset[1])
                        && ((offset[0] === rowIndex && cellIndex >= offset[1]) || rowIndex > offset[0])) {
                    offsetMatch = true;
                }

                // edit starten falls cell gefunden.
                if (offsetMatch && cell.columnConfig.editable) {
                    this.select(row);
                    this.current = row;
                    cell.startCellEdit();
                    cellToEdit = cell;
                    return false;
                }

                // offset ist eine cell: nächste cell bearbeiten
                if (!offsetMatch && offset === cell) {
                    offsetMatch = true;
                }

            }, this, reverse);

            if (cellToEdit) {
                return false;
            }

        }, this, reverse);

        return cellToEdit;
    }

    /**
     * Stoppt alle aktiven Edits
     * @param {Boolean} cancelEdit true, falls Abgebrochen werden soll
     * @returns {undefined}
     */
    stopCellEdit(cancelEdit=false) {
        kijs.Array.each(this.rows, function(row) {
            kijs.Array.each(row.cells, function(cell) {
                cell.stopCellEdit(cancelEdit);
            }, this);
        }, this);

    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // header / filter
        this._header.unrender();
        this._filter.unrender();

        // bottom
        this._footerLeftDom.unrender();
        this._footerDom.unrender();
        this._footerRightDom.unrender();

        // center
        this._leftDom.unrender();
        this._tableDom.unrender();
        this._rightDom.unrender();

        // header
        this._headerLeftDom.unrender();
        this._headerDom.unrender();
        this._headerRightDom.unrender();

        // footer (summary)
        this._footerLeftContainerDom.unrender();
        this._footerContainerDom.unrender();
        this._footerRightContainerDom.unrender();

        // center (grid)
        this._leftContainerDom.unrender();
        this._tableContainerDom.unrender();
        this._rightContainerDom.unrender();

        // header / filter
        this._headerLeftContainerDom.unrender();
        this._headerContainerDom.unrender();
        this._headerRightContainerDom.unrender();

        this._topDom.unrender();
        this._middleDom.unrender();
        this._bottomDom.unrender();

        super.unrender(true);
    }

    /**
     * Deselektiert ein oder mehrere Zeilen
     * @param {kijs.gui.grid.Row|Array} rows Row oder Array mit Zeilen, die deselektiert werden sollen
     * @param {Boolean} [preventEvent=false]     Soll das (Before-)SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    unSelect(rows, preventEvent=false) {
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        // beforeSelectionChange-Event
        if (!preventEvent) {
            let beforeSelectionChangeArgs = {rows: rows, unSelect: true, keepExisting: false, cancel: false};
            this.raiseEvent('beforeSelectionChange', beforeSelectionChangeArgs);

            // selectionChange verhindern?
            if (beforeSelectionChangeArgs.cancel === true) {
                return false;
            }
        }

        kijs.Array.each(rows, function(row) {
            row.selected = false;
        }, this);

        if (!preventEvent) {
            this.raiseEvent('selectionChange', { rows: rows, unSelect: true } );
        }

        return true;
    }



    // PROTECTED
    /**
     * Es kann eine Config oder eine Instanz übergeben werden. Wird eine config übergeben, wird eine instanz
     * erstellt. Wenn eine Instanz übergeben wird, wird deren typ geprüft.
     * @param {Object} configOrInstance
     * @param {String} defaultXType wird verwendet wenn in der config kein xtype definiert wurde.
     * @param {constructor} requiredClass
     * @returns {inst}
     */
    _getInstance(configOrInstance, defaultXType, requiredClass=null) {
        let inst = null;

        // Standard-Objekt übergeben: instanz von xType erstellen und config übergeben
        if (kijs.isObject(configOrInstance) && configOrInstance.constructor === window.Object) {
            configOrInstance.xtype = configOrInstance.xtype || defaultXType;
            configOrInstance.grid = this;

            let constructor = kijs.getObjectFromString(configOrInstance.xtype);
            if (constructor === false) {
                throw new kijs.Error('invalid xtype ' + configOrInstance.xtype);
            }
            delete configOrInstance.xtype;
            inst = new constructor(configOrInstance);


        } else if (kijs.isObject(configOrInstance)) {
            inst = configOrInstance;
        }

        if (requiredClass !== null) {
            if (!kijs.isObject(inst) || !(inst instanceof requiredClass)) {
                throw new kijs.Error('instance not from class ' + requiredClass.name);
            }
        }

        return inst;
    }

    /**
     * Sucht eine Row anhand des Primary keys
     * @param {Object} data
     * @returns {kijs.gui.grid.Row|null} die Row oder null, wenn nicht gefunden.
     */
    _getRowByPrimaryKey(data) {
        let rowMatch = null;
        if (this._primaryKeys && this._primaryKeys.length > 0) {

            kijs.Array.each(this._rows, function(row) {
                let primMatch = true;

                kijs.Array.each(this._primaryKeys, function(primaryKey) {
                    if (!data[primaryKey] || data[primaryKey] !== row.dataRow[primaryKey]) {
                        primMatch = false;
                        return false;
                    }
                }, this);

                if (primMatch) {
                    rowMatch = row;
                    return false;
                }

            }, this);
        }

        return rowMatch;
    }

    _remoteLoad(resetData=false, loadNextData=false) {
        return new Promise((resolve, reject) => {
            if (
                this._rpcLoadFn
                && !this._isLoading
                && (
                    !this._remoteDataLoaded // Erster Aufruf
                    || resetData            // Alles neu laden
                    || !loadNextData        // Reload der letzten geladenen Daten
                    || this._remoteDataLastRowCnt === this._remoteDataStep // Letzter Aufruf hatte nicht die letzten Rows, sonst wären es weniger als _remoteDataStep
                )
            ) {
                this._isLoading = true;

                let args = {};
                args.config = {};
                args.config.sort = this._remoteSort;
                args.config.getMetaData = this._getRemoteMetaData;
                args.config.filter = this._filter.getFilters();

                // alle Daten neu laden
                if (resetData) {
                    this._remoteDataStartIndex = 0;
                } else if (loadNextData) {
                    this._remoteDataStartIndex += this._remoteDataStep;
                } else {

                    // Bei normalem Reload (Update) alle bisher geladenen Daten neu laden.
                    // Dazu muss _remoteDataStep angepasst werden und alle weiteren Requests laden auch so viele Daten.
                    // TODO Besser ist es nur den / die geänderten Daten neu zu laden. Siehe this.reload().
                    // Das Grid aktualisiert dann nur diese Zeilen (ist schon so).
                    this._remoteDataStep += this._remoteDataStartIndex;
                    this._remoteDataStartIndex = 0;
                }

                args.config.start = this._remoteDataStartIndex;
                args.config.limit = this._remoteDataStep;

                if (kijs.isObject(this._rpcLoadArgs)) {
                    args = Object.assign(args, this._rpcLoadArgs);
                }

                // Lademaske wird angezeigt, wenn das erste Mal geladen wird, oder
                // wenn sämtliche Datensätze neu geladen werden.
                let showWaitMask = this._remoteDataStartIndex === 0;

                // RPC ausführen
                this.rpc.do({
                    remoteFn: this._rpcLoadFn,
                    owner: this,
                    data: args,
                    cancelRunningRpcs: true,                                        // Cancel running
                    waitMaskTarget: showWaitMask ? this._waitMaskTarget : 'none',   // Wait Mask Target
                    waitMaskTargetDomProperty: this._waitMaskTargetDomProperty      // Wait Mask Target Dom Property
                }).then((e) => {
                    this._remoteProcess(e, args, resetData);
                    resolve(e.responseData);
                }).catch((ex) => {
                    reject(ex);
                });
            }
        });
    }

    _remoteProcess(e, args, resetData) {
        // columns
        if (kijs.isArray(e.responseData.columns)) {
            kijs.Array.clear(this._columnConfigs);
            this.columnConfigAdd(e.responseData.columns);

            this._getRemoteMetaData = false;
        }

        // primary keys
        if (e.responseData.primaryKeys) {
            this.primaryKeys = e.responseData.primaryKeys;
        }

        if (resetData) {
            this.rowsRemoveAll();
        }

        // rows
        let addedRowsCnt = 0;
        if (kijs.isArray(e.responseData.rows)) {

            // Datensätze hinzufügen
            if (e.responseData.rows.length > 0) {
                this._remoteDataLastRowCnt = e.responseData.rows.length;
                addedRowsCnt = this.rowsAdd(e.responseData.rows, args.start);
            }

            // Anzahl DS zählen
            this._remoteDataLoaded += addedRowsCnt;
        }

        // Total Datensätze
        if (kijs.isInteger(e.responseData.count)) {
            this._remoteDataTotal = e.responseData.count;
        } else if (e.responseData.rows && e.responseData.rows.length) {
            this._remoteDataTotal = args.start + e.responseData.rows.length;
        }

        // Sortierungs-Icon in Header-Bar
        this._header.setSortIcons(kijs.isObject(e.responseData.sort) ? e.responseData.sort : this._remoteSort);

        this._isLoading = false;

        // event
        this.raiseEvent('afterLoad', e);
    }

    _renderRows(offset=0) {
        for (let i=offset; i<this._rows.length; i++) {
            this._rows[i].renderTo(this._tableDom.node);
        }

        this._setIntersectionObserver();
    }

    /**
     * Selektiert eine Zeile und berücksichtigt dabei die selectType und die Tasten shift und ctrl
     * @param {kijs.gui.grid.Row} row
     * @param {Boolean} shift   // Shift gedrückt?
     * @param {Boolean} ctrl    // Ctrl gedrückt?
     * @returns {Boolean}
     */
    _selectRow(row, shift, ctrl) {
        let success = false;

        if (!row) {
            return false;
        }

        // darf überhaupt selektiert werden?
        switch (this._selectType) {
            case 'single':
                shift = false;
                ctrl = false;
                break;

            case 'multi':
                // nix
                break;

            case 'simple':
                ctrl = true;
                break;

            case 'none':
            default:
                return false;
        }

        // Shift: von der selektierten bis zur ausgewählten
        if (shift && this._lastSelectedRow) {

            // selektieren
            if (this.selectBetween(this._lastSelectedRow, row, !!ctrl, false)) {
                this.current = row;
                success = true;
            }

        } else {

            // ctrl und bereits selektiert: Abwählen
            if (ctrl && row.selected) {
                if (this.unSelect(row)) {
                    this.current = null;
                    success = true;
                }
                if (row === this._lastSelectedRow) {
                    this._lastSelectedRow = null;
                }
            } else {
                if (this.select(row, !!ctrl)) {
                    this.current = row;
                    success = true;
                }
                if (row.selected) {
                    this._lastSelectedRow = row;
                }
            }
        }
        return success;
    }

    /**
     * Setzt den intersection observer auf die letzte row.
     * @returns {undefined}
     */
    _setIntersectionObserver() {
        // Der Intersection Observer beobachtet die Scroll-Position und wirft ein Event, wenn
        // das Scrolling gegen das Ende der Seite kommt.
        if (window.IntersectionObserver) {
            if (!this._intersectionObserver || this._intersectionObserver.root !== this._tableContainerDom.node) {
                this._intersectionObserver = new IntersectionObserver(this.#onIntersect.bind(this), {
                    root: this._tableContainerDom.node,
                    rootMargin: '100px',
                    threshold: 0
                });
            }

            // observer auf letzte zeile setzen
            if (this._intersectionObserver) {
                this._intersectionObserver.disconnect();

                if (this._rows.length > 0) {
                    this._intersectionObserver.observe(this._rows[this._rows.length - 1].node);
                }
            }
        }
    }



    // PRIVATE
    // LISTENERS
    /**
     * Wird ausgelöst, wenn die Scrollbar 200px von der letzten Zeile entfernt ist.
     * @param {IntersectionObserverEntrys} intersections
     * @returns {undefined}
     */
    #onIntersect(intersections) {
        if (intersections.length > 0) {
            kijs.Array.each(intersections, function(intersection) {
                if (intersection.isIntersecting) {
                    this._remoteLoad(false, true);
                }
            }, this);
        }
    }

    #onKeyDown(e) {
        let kCode=e.nodeEvent.code, ctrl=e.nodeEvent.ctrlKey, shift=e.nodeEvent.shiftKey;

        if (!this.disabled) {
            let targetRow = null;

            if (this._currentRow) {
                switch (kCode) {
                    case 'ArrowDown': targetRow = this._currentRow.next; break;
                    case 'ArrowUp': targetRow = this._currentRow.previous; break;
                    case 'Space': targetRow = this._currentRow; break;
                }
            }

            if (!this.disabled && targetRow) {
                if (this._selectRow(targetRow, shift, ctrl)) {
                    targetRow.focus();
                }

                e.nodeEvent.preventDefault();
            }
        }
    }

    #onRowClick(e) {
        let targetRow = e.element, ctrl=e.nodeEvent.ctrlKey, shift=e.nodeEvent.shiftKey;

        if (!this.disabled && this._selectRow(targetRow, shift, ctrl)) {
            targetRow.focus();
        }

        // Event weiterreichen
        this.raiseEvent('rowClick', e);
    }

    #onRowDblClick(e) {
        // Event weiterreichen
        this.raiseEvent('rowDblClick', e);
    }

    #onTableScroll(e) {
        let scrollTop = e.dom.node.scrollTop;
        let scrollLeft = e.dom.node.scrollLeft;

        this._headerContainerDom.node.scrollLeft = scrollLeft;
        this._footerContainerDom.node.scrollLeft = scrollLeft;

        this._leftContainerDom.node.scrollTop = scrollTop;
        this._rightContainerDom.node.scrollTop = scrollTop;
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // header / filter
        this._header.destruct();
        this._filter.destruct();

        // bottom
        this._footerLeftDom.destruct();
        this._footerDom.destruct();
        this._footerRightDom.destruct();

        // center
        this._leftDom.destruct();
        this._tableDom.destruct();
        this._rightDom.destruct();

        // header
        this._headerLeftDom.destruct();
        this._headerDom.destruct();
        this._headerRightDom.destruct();

        // footer (summary)
        this._footerLeftContainerDom.destruct();
        this._footerContainerDom.destruct();
        this._footerRightContainerDom.destruct();

        // center (grid)
        this._leftContainerDom.destruct();
        this._tableContainerDom.destruct();
        this._rightContainerDom.destruct();

        // header / filter
        this._headerLeftContainerDom.destruct();
        this._headerContainerDom.destruct();
        this._headerRightContainerDom.destruct();

        this._topDom.destruct();
        this._middleDom.destruct();
        this._bottomDom.destruct();

        // Variablen (Objekte/Arrays) leeren
        // -----------------------------------

        // header / filter
        this._header = null;
        this._filter = null;

        // bottom
        this._footerLeftDom = null;
        this._footerDom = null;
        this._footerRightDom = null;

        // center
        this._leftDom = null;
        this._tableDom = null;
        this._rightDom = null;

        // header
        this._headerLeftDom = null;
        this._headerDom = null;
        this._headerRightDom = null;

        // footer (summary)
        this._footerLeftContainerDom = null;
        this._footerContainerDom = null;
        this._footerRightContainerDom = null;

        // center (grid)
        this._leftContainerDom = null;
        this._tableContainerDom = null;
        this._rightContainerDom = null;

        // header / filter
        this._headerLeftContainerDom = null;
        this._headerContainerDom = null;
        this._headerRightContainerDom = null;

        this._topDom = null;
        this._middleDom = null;
        this._bottomDom = null;

        this._rpc = null;
        this._rpcLoadArgs = null;
        this._rpcSaveArgs = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.Row
// --------------------------------------------------------------
kijs.gui.grid.Row = class kijs_gui_grid_Row extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // dom type
        this._dom.nodeTagName = 'tr';

        this._dataRow = null;
        this._cells = [];

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            dataRow: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get cells() {
        let cells = [];
        for (let i=0; i<this._cells.length; i++) {
            cells.push(this._cells[i].cell);
        }
        return cells;
    }

    get current() { return !!this._dom.clsHas('kijs-current'); }
    set current(val) {
        if (val) {
            this._dom.clsAdd('kijs-current');
        } else {
            this._dom.clsRemove('kijs-current');
        }
    }

    get dataRow() { return this._dataRow; }
    set dataRow(val) { this._dataRow = val; }

    get grid() { return this.parent; }
    
    get impair() {
        return this.rowIndex % 2 === 0;
    }

    get isDirty() {
        let isDirty = false;
        kijs.Array.each(this._cells, function(cell) {
            if (cell.cell && cell.cell.isDirty) {
                isDirty = true;
                return false;
            }
        }, this);
        return isDirty;
    }

    get next() {
        let i = this.rowIndex + 1;
        if (i > this.grid.rows.length -1) {
            return null;
        }
        return this.grid.rows[i];
    }

    get previous() {
        let i = this.rowIndex - 1;
        if (i < 0) {
            return null;
        }
        return this.grid.rows[i];
    }

    get rowIndex() {
        return this.grid.rows.indexOf(this);
    }

    get selected() { return !!this._dom.clsHas('kijs-selected'); }
    set selected(val) {
        if (val) {
            this._dom.clsAdd('kijs-selected');
        } else {
            this._dom.clsRemove('kijs-selected');
        }
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Setzt alle 'dirty' records zurück.
     * @returns {undefined}
     */
    commit() {
        kijs.Array.each(this._cells, function(cell) {
            if (cell.cell) {
                cell.cell.isDirty = false;
            }
        }, this);
    }

    /**
     * Sucht eine Cell anhand der Cell-Config
     * @param {Object} config
     * @returns {kijs.gui.grid.cell.Cell|null} die Cell oder null, wenn nicht gefunden.
     */
    getCellByConfig(config) {
        let cell = null;

        for (let i = 0; i < this._cells.length; i++) {
            if (this._cells[i].columnConfig === config) {
                if (this._cells[i].cell) {
                    cell = this._cells[i].cell;
                }
                break;
            }
        }

        return cell;
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // cells erstellen
        this._createCells();

        // cells sortieren
        this._sortCells();

        // cells rendern
        kijs.Array.each(this.cells, function(cell) {
            cell.renderTo(this._dom.node);
        }, this);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // cells unrendern
        kijs.Array.each(this.cells, function(cell) {
            cell.unrender();
        }, this);

        super.unrender(true);
    }
    
    /**
     * Aktualisiert die DataRow. Falls an der Row etwas geändert hat,
     * wird die Zeile aktualisiert.
     *
     * @param {Object} newDataRow
     * @returns {undefined}
     */
    updateDataRow(newDataRow) {
        let cell = null;

        // Wenn bereits gerendert, vergleichen und falls geändert neu rendern
        if (this.isRendered) {
            kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
                if (newDataRow[columnConfig.displayField] !== this.dataRow[columnConfig.displayField]) {
                    cell = this.getCellByConfig(columnConfig);
                    if (cell) {
                        cell.setValue(newDataRow[columnConfig.displayField], true, false, false);
                    }
                }
            }, this);
        }

        // aktualisieren
        this.dataRow = newDataRow;
    }


    // PROTECTED
    _createCells() {
        let newColumnConfigs = [];

        // Prüfen, ob für jede columnConfig eine cell existiert.
        // Wenn nicht, in Array schreiben.
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            if (!this.getCellByConfig(columnConfig)) {
                newColumnConfigs.push(columnConfig);
            }
        }, this);

        // Falls cell noch nicht vorhanden, neue cell erstellen.
        kijs.Array.each(newColumnConfigs, function(columnConfig) {
            let cellConfig = columnConfig.cellConfig;
            let constr = kijs.getObjectFromString(cellConfig.xtype);

            if (!constr) {
                throw new kijs.Error('invalid cell xtype for column ' + columnConfig.caption);
            }

            // change listener
            columnConfig.on('change', this.#onColumnConfigChange, this);

            cellConfig.parent = this;
            delete cellConfig.xtype;

            let cell = new constr(cellConfig);
            cell.loadFromDataRow();

            this._cells.push({columnConfig: columnConfig, cell: cell});
        }, this);
    }

    _sortCells() {
        this._cells.sort(function(a, b) {
            if (a.columnConfig.position < b.columnConfig.position) {
                return -1;
            }
            if (a.columnConfig.position > b.columnConfig.position) {
                return 1;
            }
            return 0;
        });
    }


    // PRIVATE
    // LISTENERS
    #onColumnConfigChange(e) {
        if ('visible' in e || 'width' in e) {
            kijs.Array.each(this.cells, function(cell) {
                if (e.columnConfig === cell.columnConfig) {
                    cell.render();
                    return false;
                }
            }, this);

        }
        if ('position' in e) {
            this.render();
        }
    }

    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // cells destructen
        kijs.Array.each(this.cells, function(cell) {
            cell.columnConfig.off('change', this.#onColumnConfigChange, this);
            cell.destruct();
        }, this);

        // Variablen (Objekte/Arrays) leeren
        this._cells = null;
        this._dataRow = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.Fi.grid.Filter
// --------------------------------------------------------------
kijs.gui.grid.Filter = class kijs_gui_grid_Filter extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // dom type
        this._dom.nodeTagName = 'tr';

        this._filters = [];
        this._filterReloadDeferId = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-grid-filter',
            visible: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    
    

    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filters() {
        let filters = [];
        for (let i=0; i<this._filters.length; i++) {
            filters.push(this._filters[i].filter);
        }
        return filters;
    }

    get grid() { return this.parent; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Gibt die Filter-Objekte als Array  zurück, welche auf dem Server angewendet werden.
     * @returns {undefined}
     */
    getFilters() {
        let filters = [];

        kijs.Array.each(this.filters, function(filter) {
            if (filter.isFiltered) {
                filters.push(filter.filter);
            }
        }, this);

        return filters;
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        // filters erstellen
        this._createFilters();

        // filters sortieren
        this._sortFilters();

        // filters rendern
        kijs.Array.each(this.filters, function(filter) {
            filter.renderTo(this._dom.node);
        }, this);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt alle Filter zurück.
     * @returns {undefined}
     */
    reset() {
        kijs.Array.each(this.filters, function(filter) {
            filter.reset();
        }, this);
    }
    
    // overwrite
    unrender(superCall) {
        // timer abbrechen
        if (this._filterReloadDeferId) {
            window.clearTimeout(this._filterReloadDeferId);
            this._filterReloadDeferId = null;
        }
        
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // filters unrendern
        kijs.Array.each(this.filters, function(filter) {
            filter.unrender();
        }, this);

        super.unrender(true);
    }


    // PROTECTED
    _createFilters() {
        let newColumnConfigs = [];

        // Prüfen, ob für jede columnConfig einen Filter existiert.
        // Wenn nicht, in Array schreiben.
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            let exist = false;
            for (let i=0; i<this._filters.length; i++) {
                if (this._filters[i].columnConfig === columnConfig) {
                    exist = true;
                    break;
                }
            }
            if (!exist) {
                newColumnConfigs.push(columnConfig);
            }
        }, this);

        // Falls Filter noch nicht vorhanden, neue Filter erstellen.
        kijs.Array.each(newColumnConfigs, function(columnConfig) {
            let filterConfig = columnConfig.filterConfig;
            let constr = kijs.getObjectFromString(filterConfig.xtype);

            if (!constr) {
                throw new kijs.Error('invalid filter xtype for column ' + columnConfig.caption);
            }

            // change listener
            columnConfig.on('change', this.#onColumnConfigChange, this);

            filterConfig.parent = this;
            delete filterConfig.xtype;

            let filter = new constr(filterConfig);
            filter.on('filter', this.#onFilter, this);
            this._filters.push({columnConfig: columnConfig, filter: filter});
        }, this);
    }

    _filterHasFocus() {
        let hasFocus = false;
        kijs.Array.each(this.filters, function(filter) {
            if (filter.hasFocus()) {
                hasFocus = true;
                return false;
            }
        }, this);
        return hasFocus;
    }
    
    _sortFilters() {
        this._filters.sort(function(a, b) {
            if (a.columnConfig.position < b.columnConfig.position) {
                return -1;
            }
            if (a.columnConfig.position > b.columnConfig.position) {
                return 1;
            }
            return 0;
        });
    }


    // PRIVATE
    // LISTENERS
    #onColumnConfigChange(e) {
        if ('visible' in e || 'width' in e) {
            kijs.Array.each(this.filters, function(filter) {
                if (e.columnConfig === filter.columnConfig) {
                    filter.render();
                    return false;
                }
            }, this);

        }
        if ('position' in e) {
            this.render();
        }
    }

    #onFilter(e) {
        let forceReload = !!e.forceReload;

        // Filter verzögert zurücksetzen, da der "Filter"
        // Event gleich mehrmals von mehreren Filtern kommen kann.
        if (this._filterReloadDeferId) {
            window.clearTimeout(this._filterReloadDeferId);
            this._filterReloadDeferId = null;
        }

        // Es wird nur neu gefiltert, wenn entweder force gewählt wurde oder kein Filterfeld den Focus hat.
        this._filterReloadDeferId = kijs.defer(function() {
            if (forceReload || !this._filterHasFocus()) {
                this.grid.reload();
            }
        }, 50, this);
    }


    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // filters destructen
        kijs.Array.each(this.filters, function(filter) {
            filter.columnConfig.off('change', this.#onColumnConfigChange, this);
            filter.destruct();
        }, this);

        // Variablen (Objekte/Arrays) leeren
        this._filters = null;
        if (this._dataRow) {
            this._dataRow = null;
        }

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// TODO: Damit Drag&Drop funktioniert, muss diese Klasse von kijs.gui.Container
// erben!


// --------------------------------------------------------------
// kijs.gui.grid.Header
// --------------------------------------------------------------
kijs.gui.grid.Header = class kijs_gui_grid_Header extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        // dom type
        this._dom.nodeTagName = 'tr';
        
        this._cells = [];
        
        /*this._ddName = kijs.uniqId('kijs.gui.grid.HeaderCell');
        
        this.ddTarget = {
            ddMarkerTagName: 'td',
            posBeforeFactor: 0.666,
            posAfterFactor: 0.666,
            mapping: {
                [this._ddName]:{
                    allowMove: true,
                    allowCopy: false,
                    allowLink: false,
                    disableMarkerAutoSize: false
                }
            },
            on: {
                drop: this.#onDrop,
                context: this
            }
        };*/
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-grid-header'
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get cells() {
        let cells = [];
        for (let i=0; i<this._cells.length; i++) {
            cells.push(this._cells[i].cell);
        }
        return cells;
    }
    
    /*get ddTarget() { 
        return this._ddTarget; 
    }
    set ddTarget(val) {
        // config-object
        if (kijs.isObject(val)) {
            if (kijs.isEmpty(this._ddTarget)) {
                val.ownerEl = this;
                if (kijs.isEmpty(val.ownerDomProperty)) {
                    val.ownerDomProperty = 'dom';
                }
                this._ddTarget = new kijs.gui.dragDrop.Target(val);
            } else {
                this._ddTarget.applyConfig(val);
            }

        // null
        } else if (val === null) {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;

        } else {
            throw new kijs.Error(`ddTarget must be a object or null`);

        }
    }*/

    get grid() { return this.parent; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    clear() {
        // cells entfernen
        kijs.Array.each(this._cells, function(cell) {
            cell.cell.destruct();
        }, this);
        kijs.Array.clear(this._cells);
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // cells erstellen
        this._createCells();

        // cells sortieren
        this._sortCells();

        // cells rendern
        kijs.Array.each(this.cells, function(cell) {
            cell.renderTo(this._dom.node);
        }, this);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt bei allen columns das richtige Sort-Icon
     * @param {Array|Object} sort
     * @returns {undefined}
     */
    setSortIcons(sort) {
        if (kijs.isObject(sort) && sort.field && sort.direction) {
            sort = [sort];
        }

        if (!kijs.isArray(sort)) {
            return;
        }

        let sortedCells = [];
        kijs.Array.each(this._cells, function(headerCell) {
            kijs.Array.each(sort, function(srt) {
                if (srt.field === headerCell.cell.columnConfig.displayField) {
                    headerCell.cell.sort = srt.direction;
                    sortedCells.push(headerCell.cell);
                }
            }, this);
        }, this);

        // icon von header, welche nicht sortiert wurden, entfernen
        kijs.Array.each(this._cells, function(headerCell) {
            if (!kijs.Array.contains(sortedCells, headerCell.cell)) {
                headerCell.cell.sort = '';
            }
        });

    }
    
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // cells unrendern
        kijs.Array.each(this.cells, function(cell) {
            cell.unrender();
        }, this);

        super.unrender(true);
    }


    // PROTECTED
    _createCells() {
        let newColumnConfigs = [];

        // Prüfen, ob für jede columnConfig eine headerCell existiert.
        // Wenn nicht, in Array schreiben.
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            let exist = false;
            for (let i=0; i<this._cells.length; i++) {
                if (this._cells[i].columnConfig === columnConfig) {
                    exist = true;
                    break;
                }
            }
            if (!exist) {
                newColumnConfigs.push(columnConfig);
            }
        }, this);

        // Falls cell noch nicht vorhanden, neue cell erstellen.
        kijs.Array.each(newColumnConfigs, function(columnConfig) {
            let cell = new kijs.gui.grid.HeaderCell({
                parent: this,
                columnConfig: columnConfig/*,
                ddSource:{
                    name: this._ddName,
                    allowMove: true,
                    allowCopy: false,
                    allowLink: false,
                    ownerDomProperty: 'dom'
                }*/
            });

            // change listener
            columnConfig.on('change', this.#onColumnConfigChange, this);

            cell.loadFromColumnConfig();

            this._cells.push({columnConfig: columnConfig, cell: cell});
        }, this);
    }

    _sortCells() {
        this._cells.sort(function(a, b) {
            if (a.columnConfig.position < b.columnConfig.position) {
                return -1;
            }
            if (a.columnConfig.position > b.columnConfig.position) {
                return 1;
            }
            return 0;
        });
    }


    // PRIVATE
    // LISTENERS
    #onColumnConfigChange(e) {
        if ('visible' in e || 'width' in e || 'caption' in e || 'resizable' in e || 'sortable' in e) {
            kijs.Array.each(this.cells, function(cell) {
                if (e.columnConfig === cell.columnConfig) {
                    if (e.caption) {
                        cell.caption = e.caption;
                    } else {
                        cell.render();
                    }
                    return false;
                }
            }, this);

        }
        if ('position' in e) {
            this.render();
        }
    }

    // TODO !!!!!
    /*#onDrop(e) {
        console.log('drop');
        //let tIndex = this.header.cells.indexOf(e.targetElement);
        //let sIndex = this.header.cells.indexOf(e.sourceElement);
        //let pos = e.position.position;

        //if (!this._splitterMove && tIndex !== -1 && sIndex !== -1 && tIndex !== sIndex && (pos === 'left' || pos === 'right')) {
        //    if (pos === 'right') {
        //        tIndex += 1;
        //    }
        //    this.header.grid.columnConfigs[sIndex].position = tIndex;
        //}
    }*/
    
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        if (this._ddTarget) {
            this._ddTarget.destruct();
        }
        
        // cells destructen
        kijs.Array.each(this.cells, function(cell) {
            cell.destruct();
        }, this);

        // Variablen (Objekte/Arrays) leeren
        this._cells = null;
        //this._ddTarget = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.HeaderCell
// --------------------------------------------------------------
kijs.gui.grid.HeaderCell = class kijs_gui_grid_HeaderCell extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._overflowTooltipDisable = false;   // Tooltip auf Spaltenkopf, wenn caption zu lang
        
        // DOM type
        this._dom.nodeTagName = 'td';
        this._columnConfig = null;
        this._initialPos = 0;
        this._splitterMove = false;
        this._sort = null;

        // DOM für label
        this._captionContainerDom = new kijs.gui.Dom({cls:'kijs-caption'});
        this._captionDom = new kijs.gui.Dom({nodeTagName:'span', htmlDisplayType: 'code'});
        this._sortDom = new kijs.gui.Dom({nodeTagName:'span', cls:'kijs-sort', htmlDisplayType: 'code'});

        this._helpIconEl = new kijs.gui.Icon({
            parent  : this,
            iconChar: 0xf29C,
            iconCls : 'kijs-icon-help kijs-tooltip-icon',
            visible : false,
            tooltip : new kijs.gui.Tooltip({
                cls: 'kijs-help',
                followPointer: false
            })
        });

        // DOM für Menu
        this._menuButtonEl = new kijs.gui.Button({
            parent: this,
            disableFlex: false,
            smallPaddings: false,
            menuElements: [
                {
                    name    : 'btn-sort-asc',
                    caption : kijs.getText('Aufsteigend sortieren'),
                    iconMap: 'kijs.iconMap.Fa.arrow-down-a-z',
                    on: {
                        click: function() {
                            this.header.grid.sort(this.columnConfig.valueField, 'ASC');
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                },{
                    name    : 'btn-sort-desc',
                    caption : kijs.getText('Absteigend sortieren'),
                    iconMap: 'kijs.iconMap.Fa.arrow-down-z-a',
                    on: {
                        click: function() {
                            this.header.grid.sort(this.columnConfig.valueField, 'DESC');
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                },{
                    name    : 'btn-columns',
                    caption : kijs.getText('Spalten') + '...',
                    iconMap: 'kijs.iconMap.Fa.table-columns',
                    on: {
                        click: function() {
                            (new kijs.gui.grid.ColumnWindow({parent: this})).show();
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                },{
                    name    : 'btn-filters',
                    caption : kijs.getText('Filter') + '...',
                    iconMap: 'kijs.iconMap.Fa.filter',
                    on: {
                        click: function() {
                            this.parent.grid.filter.visible = !this.parent.grid.filter.visible;
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                }
            ]
        });

        // DOM für Schieber
        this._splitterDom = new kijs.gui.Dom({
            cls:'kijs-splitter',
            on: {
                mouseDown: this.#onSplitterMouseDown,
                context: this
            }
        });

        // DOM für Schieber overlay
        this._overlayDom = new kijs.gui.Dom({cls:'kijs-splitter-overlay'});

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columnConfig: true,
            
            overflowTooltipDisable: true,
            
            sort: { target: 'sort' },

            helpIcon: { target: 'helpIcon' },
            helpIconChar: { target: 'iconChar', context: this._helpIconEl },
            helpIconCls: { target: 'iconCls', context: this._helpIconEl },
            helpIconColor: { target: 'iconColor', context: this._helpIconEl },
            helpIconMap: { target: 'iconMap', context: this._helpIconEl },
            helpText: { target: 'helpText' }
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._captionDom.html; }
    set caption(val) { this.setCaption(val); }

    get columnConfig() { return this._columnConfig; }
    set columnConfig(val) { this._columnConfig = val; }

    get header() { return this.parent; }

    get helpIcon() { return this._helpIconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set helpIcon(val) {
        if (kijs.isEmpty(val)) {

            // Icon zurücksetzen?
            this._helpIconEl.iconChar = null;
            this._helpIconEl.iconCls = null;
            this._helpIconEl.iconColor = null;

        } else if (val instanceof kijs.gui.Icon) {

            // kijs.gui.Icon Instanz
            this._helpIconEl.destruct();
            this._helpIconEl = val;
            if (this.isRendered) {
                this.render();
            }

        } else if (kijs.isObject(val)) {

            // Config Objekt
            this._helpIconEl.applyConfig(val);
            if (this.isRendered) {
                this._helpIconEl.render();
            }

        } else {
            throw new kijs.Error(`config "helpIcon" is not valid.`);
        }
    }

    get helpIconChar() { return this._helpIconEl.iconChar; }
    set helpIconChar(val) { this._helpIconEl.iconChar = val; }

    get helpIconCls() { return this._helpIconEl.iconCls; }
    set helpIconCls(val) { this._helpIconEl.iconCls = val; }

    get helpIconColor() { return this._helpIconEl.iconColor; }
    set helpIconColor(val) { this._helpIconEl.iconColor = val; }

    get helpIconMap() { return this._helpIconEl.iconMap; }
    set helpIconMap(val) { this._helpIconEl.iconMap = val; }

    get helpText() { return this._helpIconEl.tooltip.html; }
    set helpText(val) {
        this._helpIconEl.tooltip.html = val;
        this._helpIconEl.visible = !kijs.isEmpty(this._helpIconEl.tooltip.html);
    }

    get index() {
        if (this.header) {
            return this.header.cells.indexOf(this);
        }
        return null;
    }
    
    get overflowTooltipDisable() { return this.overflowTooltipDisable; }
    set overflowTooltipDisable(val) {
        this._overflowTooltipDisable = !!val;
        if (this.isRendered) {
            this._updateHeaderToolTip();
        }
    }
    
    get sort() { return this._sort; }
    set sort(val) {
        if (val === 'DESC') {
            this._sortDom.html = String.fromCodePoint(0xf0d7); // caret-down
            this._sort = val;

        } else if (val === 'ASC') {
            this._sortDom.html = String.fromCodePoint(0xf0d8); // caret-up
            this._sort = val;

        } else {
            this._sortDom.html = '';
            this._sort = null;
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Setzt das caption der Zelle.
     * @param {String} caption
     * @param {Boolean} [updateColumnConfig=true] true, falls kein change-event ausgelöst werden soll.
     * @returns {undefined}
     */
    setCaption(caption, updateColumnConfig=true) {
        // HTML aktualisieren
        this._captionDom.html = caption;

        if (updateColumnConfig) {
            this._columnConfig.caption = caption;
        }

        if (this.isRendered) {
            this.render();
        }
    }

    /**
     * Lädt das value von der dataRow
     * @returns {undefined}
     */
    loadFromColumnConfig() {
        // Caption
        let c = this._columnConfig.caption;
        this.setCaption(c, false);

        // Tooltip
        if (this._columnConfig.tooltip) {
            this.helpText = this._columnConfig.tooltip;
        } else {
            this.helpText = '';
        }

        this._menuButtonEl.menu.down('btn-filters').visible = !!this.parent.grid.filterable;
        this._menuButtonEl.menu.down('btn-sort-asc').visible = !!this._columnConfig.sortable;
        this._menuButtonEl.menu.down('btn-sort-desc').visible = !!this._columnConfig.sortable;
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // container
        this._captionContainerDom.renderTo(this._dom.node);

        // caption dom
        this._captionDom.renderTo(this._captionContainerDom.node);

        // sort dom
        this._sortDom.renderTo(this._captionContainerDom.node);

        // Help icon rendern (kijs.gui.Icon)
        this._helpIconEl.renderTo(this._dom.node);

        // dropdown
        this._menuButtonEl.renderTo(this._dom.node);

        // Splitter
        this._splitterDom.renderTo(this._dom.node);

        // Breite
        this._dom.width = this._columnConfig.width;

        // sichtbar?
        this.visible = this._columnConfig.visible;

        // Caption als Tooltip anzeigen, wenn nicht genung Platz im Spaltenkopf
        kijs.defer(this._updateHeaderToolTip, 50, this);
        this._updateHeaderToolTip();
        
        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._captionDom.unrender();
        this._captionContainerDom.unrender();
        this._helpIconEl.unrender();
        this._menuButtonEl.unrender();
        this._splitterDom.unrender();

        super.unrender(true);
    }
    
    
    // PROTECTED
    /**
     * Aktualisiert die Overlay-Position aufgrund der Mauszeigerposition
     * @param {Number} xAbs     Mausposition clientX
     * @param {Number} yAbs     Mausposition clientY
     * @returns {undefined}
     */
    _updateOverlayPosition(xAbs, yAbs) {
        // Berechnet aus der absoluten Position bezogen zum Browserrand,
        // die relative Position bezogen zum übergeordneten DOM-Node
        const parentPos = kijs.Dom.getAbsolutePos(this.parent.grid.dom.node);
        const newPos = {
            x: xAbs - parentPos.x,
            y: yAbs - parentPos.x
        };

        this._overlayDom.left = newPos.x;
    }
    
    
    // Caption als Tooltip anzeigen, wenn nicht genung Platz im Spaltenkopf
    _updateHeaderToolTip() {
        if (!this.isRendered) {
            return;
        }
        if (!this._overflowTooltipDisable && this._captionContainerDom.width > 0) {
            if (this._captionDom.width >= this._captionContainerDom.width) {
                this._captionDom.tooltip = this.caption;
            } else {
                this._captionDom.tooltip = null;
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onSplitterMouseDown(e) {
        if (!this._columnConfig.resizable) {
            return;
        }
        this._splitterMove = true;

        this._initialPos = e.nodeEvent.clientX;

        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.clientX, e.nodeEvent.clientY);

        // Overlay rendern
        this._overlayDom.render();
        this.parent.grid.dom.node.appendChild(this._overlayDom.node);

        // mousemove und mouseup Listeners auf das document setzen
        kijs.Dom.addEventListener('mousemove', document, this.#onSplitterMouseMove, this);
        kijs.Dom.addEventListener('mouseup', document, this.#onSplitterMouseUp, this);
    }

    #onSplitterMouseMove(e) {
        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.clientX, e.nodeEvent.clientY);
    }

    #onSplitterMouseUp(e) {
        // Beim ersten Auslösen des Listeners, gleich wieder entfernen
        kijs.Dom.removeEventListener('mousemove', document, this);
        kijs.Dom.removeEventListener('mouseup', document, this);

        // Overlay wieder ausblenden
        this._overlayDom.unrender();

        // Differenz zur vorherigen Position ermitteln
        let offset = e.nodeEvent.clientX - this._initialPos;

        if (this._columnConfig.resizable) {
            this._columnConfig.width = Math.max(this._columnConfig.width + offset, 40);
        }

        this._splitterMove = false;
    }

    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        this._captionDom.destruct();
        this._captionContainerDom.destruct();
        this._helpIconEl.destruct();
        this._menuButtonEl.destruct();
        this._splitterDom.destruct();

        // Variablen (Objekte/Arrays) leeren
        this._captionDom = null;
        this._helpIconEl = null;
        this._menuButtonEl = null;
        this._splitterDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.grid.ColumnWindow
// --------------------------------------------------------------
kijs.gui.grid.ColumnWindow = class kijs_gui_grid_ColumnWindow extends kijs.gui.Window {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dom.clsAdd('kijs-columnwindow');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            caption: kijs.getText('Spalten'),
            iconMap: 'kijs.iconMap.Fa.table-columns',
            closable: true,
            maximizable: false,
            scrollableY: 'auto',
            resizable: false,
            modal: true,
            width: 200,

            innerStyle: {
                padding: '10px'
            },

            footerElements:[
                {
                    xtype: 'kijs.gui.Button',
                    caption: kijs.getText('OK'),
                    style: { flex: 1 },
                    isDefault: true,
                    on: {
                        click: this.#onOkClick,
                        context: this
                    }
                },{
                    xtype: 'kijs.gui.Button',
                    caption: kijs.getText('Abbrechen'),
                    isDefault: false,
                    on: {
                        click: this.#onCancelClick,
                        context: this
                    }
                }
            ]
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {

        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get grid() { return this.parent.header.grid; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    show() {
        let data = [];
        let values = [];
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            data.push({valueField: columnConfig.valueField, caption: columnConfig.caption });
            if (columnConfig.visible) {
                values.push(columnConfig.valueField);
            }
        }, this);

        this.add({
            xtype: 'kijs.gui.field.CheckboxGroup',
            name: 'fields',
            labelHide: true,
            valueField: 'valueField',
            captionField: 'caption',
            data: data,
            value: values,
            sortable: true
        });

        this.down('fields').on('ddOver', this.#onDdOver, this);
        this.down('fields').on('change', this.#onCheckChange, this);

        // anzeigen
        super.show();
    }


    // PRIVATE
    // LISTENERS
    #onCheckChange(e) {
        let unchecked = kijs.Array.diff(e.oldValue, e.value);

        kijs.Array.each(unchecked, function(valueField) {
            let columnConfig = this.grid.getColumnConfigByValueField(valueField);

            // uncheck verhindern, hacken wieder setzen
            if (!columnConfig.hideable) {
                kijs.defer(function() {
                    let flds = this.down('fields').value;
                    flds.push(valueField);
                    this.down('fields').value = flds;
                },20, this);
            }

        }, this);
    }
    
    #onDdOver(e) {
        const vF = e.sourceElement ? e.sourceElement.dataRow.valueField : null;

        // columnConfig Suchen und prüfen ob sortierbar
        let columnConfig = this.grid.getColumnConfigByValueField(vF);
        let allowDd = columnConfig ? columnConfig.sortable : false;

        return allowDd;
    }
    
    #onOkClick() {
        let flds = this.down('fields').value;
        
        // Sichtbarkeit übernehmen
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            columnConfig.visible = kijs.Array.contains(flds, columnConfig.valueField);
        }, this);
        
        // Sortierung übernehmen
        let elements = this.down('fields').elements;
        for (let i=0; i<elements.length; i++) {
            let vF = elements[i].dataRow.valueField;

            // columnConfig Suchen und Position schreiben
            let columnConfig = this.grid.getColumnConfigByValueField(vF);
            if (columnConfig) {
                columnConfig.position = i;
            }
        }

        // Fenster schliessen
        this.destruct();
    }
    
    #onCancelClick(e) {
        // Fenster schliessen
        this.destruct();
    }
    


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Basisklasse auch entladen
        super.destruct(true);
    }
    
};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid.column (namespace)
// --------------------------------------------------------------
kijs.gui.grid.columnConfig = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column (Abstract)
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.ColumnConfig = class kijs_gui_grid_columnConfig_ColumnConfig extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // check if abstract
        if (kijs.isObject(config)) {
            throw new kijs.Error('do not create a instance of kijs.gui.grid.columnConfig.ColumnConfig directly');
        }

        this._caption = '';
        this._visible = true;
        this._hideable = true;
        this._position = null;
        this._resizable = true;
        this._sortable = true;
        this._tooltip = '';
        this._valueField = '';
        this._displayField = '';
        this._width = 100;

        // xtypes
        this._cellXtype = null;
        this._filterXtype = null;
        this._headerCellXtype = null;
        this._editorXtype = null;

        // Editable?
        this._editable = false;
        this._clicksToEdit = 2;

        // Configs
        this._cellConfig = null;
        this._filterConfig = null;
        this._editorConfig = null;
        this._defaultConfig = {};

        // grid
        this._grid = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            grid: true,
            cellXtype: true,
            filterXtype: true,
            headerCellXtype: true,
            editorXtype: true,

            caption: { target: 'caption' },
            editable: true,
            clicksToEdit: true,
            visible: true,
            hideable: true,
            position: true,
            resizable: true,
            sortable: true,
            tooltip: true,
            valueField: true,
            displayField: true,
            width: true,

            cellConfig: { target: 'cellConfig' },
            filterConfig: { target: 'filterConfig' },
            editorConfig: { target: 'editorConfig' }
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (this._cellConfig === null) {
            this.cellConfig = this._cellXtype;
        }
        if (this.filterConfig === null) {
            this.filterConfig = this._filterXtype;
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._caption; }
    set caption(val) {
        this._caption = val;
        this.raiseEvent('change', {columnConfig: this, caption: val});
    }

    get cellConfig() {
        let cCnf =  this._cellConfig ? kijs.Object.clone(this._cellConfig) : {};
        cCnf.columnConfig = this;
        if (!cCnf.xtype) {
            cCnf.xtype = this._cellXtype;
        }
        return cCnf;
    }
    set cellConfig(val) {
        if (kijs.isString(val)) {
            this._cellConfig = {
                xtype: val
            };
        } else if (kijs.isObject(val)) {
            this._cellConfig = val;
        }
    }

    get clicksToEdit() { return this._clicksToEdit; }
    set clicksToEdit(val) { this._clicksToEdit = val === 1 ? 1 : 2; }

    get displayField() { return this._displayField ? this._displayField : this._valueField; }
    set displayField(val) { this._displayField = val; }

    get editable() { return this._editable; }
    set editable(val) {
        this._editable = !!val;
        this.raiseEvent('change', {columnConfig: this, editable: !!val});
    }

    get editorConfig() { return this._editorConfig; }
    set editorConfig(val) {
        this._editorConfig = kijs.isObject(val) ? val : null;
    }

    get editorXtype() { return this._editorXtype; }
    set editorXtype(val) {
        this._editorXtype = kijs.isString(val) ? val : null;
    }

    get filterConfig() {
        let cCnf =  this._filterConfig || {xtype: this._filterXtype};
        cCnf.columnConfig = this;
        return cCnf;
    }
    set filterConfig(val) {
        if (kijs.isString(val)) {
            this._filterConfig = {
                xtype: val
            };
        } else if (kijs.isObject(val)) {
            this._filterConfig = val;
            if (!this._filterConfig.xtype) {
                this._filterConfig.xtype = this._filterXtype;
            }
            this._filterConfig.columnConfig = this;
        }
    }

    get grid() { return this._grid; }
    set grid(val) { this._grid = val; }

    get hideable() { return this._hideable; }
    set hideable(val) {
        this._hideable = !!val;
        this.raiseEvent('change', {columnConfig: this, hideable: !!val});
    }

    get position() {
        if (!kijs.isEmpty(this._position)) {
            return this._position;
        } else if (this._grid) {
            return this._grid.columnConfigs.indexOf(this);
        }
        return false;
    }
    set position(val) {
        if (val !== this.position) {
            this.raiseEvent('change', {columnConfig: this, position: this.position});
        }
    }

    get resizable() { return this._resizable; }
    set resizable(val) {
        this._resizable = !!val;
        this.raiseEvent('change', {columnConfig: this, resizable: !!val});
    }

    get sortable() { return this._sortable; }
    set sortable(val) {
        this._sortable = !!val;
        this.raiseEvent('change', {columnConfig: this, sortable: !!val});
    }

    get tooltip() { return this._tooltip };
    set tooltip(val) {
        this._tooltip = val;
        this.raiseEvent('change', {columnConfig: this, tooltip: val});
    }

    get valueField() { return this._valueField ? this._valueField : this._displayField; }
    set valueField(val) { this._valueField = val; }

    get visible() { return this._visible; }
    set visible(val) {
        if (!val && !this.hideable) {
            return;
        }
        if (val !== this._visible) {
            this._visible = !!val;
            this.raiseEvent('change', {columnConfig: this, visible: !!val});
        }
    }

    get width() { return this._width; }
    set width(val) {
        if (!kijs.isNumeric(val)) {
            throw new kijs.Error('invalid width value for columnConfig');
        }
        this._width = val;
        this.raiseEvent('change', {columnConfig: this, width: val});
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    applyConfig(config={}, preventEvents=false) {
        // evtl. afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        if (preventEvents) {
            this._preventAfterResize = true;
        }

        // Config zuweisen
        kijs.Object.assignConfig(this, config, this._configMap);

        // Evtl. afterResize-Event wieder zulassen
        if (preventEvents) {
            this._preventAfterResize = prevAfterRes;
        }
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Text = class kijs_gui_grid_columnConfig_Text extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Text';
        this._filterXtype = 'kijs.gui.grid.filter.Text';
        this._editorXtype = 'kijs.gui.field.Text';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // Keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Date = class kijs_gui_grid_columnConfig_Date extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Date';
        this._filterXtype = 'kijs.gui.grid.filter.Date';

        // Editor
        this._editorXtype = 'kijs.gui.field.Date';

        this._hasTime = false;
        this._format = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            hasTime: true,
            format: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (!this._format) {
            if (this._hasTime) {
                this._format = 'd.m.Y H:i';
            } else {
                this._format = 'd.m.Y';
            }
        }

        this.cellConfig = {
            hasTime: this._hasTime,
            format: this._format
        };
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Number = class kijs_gui_grid_columnConfig_Number extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Number';
        this._filterXtype = 'kijs.gui.grid.filter.Number';
        this._editorXtype = 'kijs.gui.field.Number';

        this._decimalPrecision = null;
        this._decimalSeparator = '.';
        this._thousandsSeparator = '\'';

        this._numberStyles = [];

        this._unitBefore = '';
        this._unitAfter = '';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            decimalPrecision: true,
            decimalSeparator: true,
            thousandsSeparator: true,
            numberStyles: true,
            unitBefore: true,
            unitAfter: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this.cellConfig = {
            decimalPrecision: this._decimalPrecision,
            decimalSeparator: this._decimalSeparator,
            thousandsSeparator: this._thousandsSeparator,
            numberStyles: this._numberStyles,
            unitBefore: this._unitBefore,
            unitAfter: this._unitAfter
        };
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    /**
     * Gibt die Argumente für den Celleditor zurück
     * @returns {Object}
     */
    get editorConfig() {
        let editorConfig = super.editorConfig;

        if (this._editorXtype === 'kijs.gui.field.Number') {
            if (!kijs.isObject(editorConfig)) {
                editorConfig = {};
            }
            // config für Nummerfeld übernehmen
            if (this._decimalPrecision !== null && !kijs.isDefined(editorConfig.decimalPrecision)) {
                editorConfig.decimalPrecision = this._decimalPrecision;
            }
            if (this._decimalSeparator !== null && !kijs.isDefined(editorConfig.decimalSeparator)) {
                editorConfig.decimalSeparator = this._decimalSeparator;
            }
            if (this._thousandsSeparator !== null && !kijs.isDefined(editorConfig.thousandsSeparator)) {
                editorConfig.thousandsSeparator = this._thousandsSeparator;
            }
            
        }
        return editorConfig;
    }
    set editorConfig(val) {
        super.editorConfig = val;
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Checkbox = class kijs_gui_grid_columnConfig_Checkbox extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Checkbox';
        this._filterXtype = 'kijs.gui.grid.filter.Checkbox';

        this._editorXtype = null;

        this._disabled = false;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            disabled: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this.cellConfig = {
            disabled: this._disabled
        };
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.columnConfig.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Icon = class kijs_gui_grid_columnConfig_Icon extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Icon';
        this._filterXtype = 'kijs.gui.grid.filter.Icon';
        this._iconCharField = null;
        this._iconClsField = null;
        this._iconMapField = null;
        this._iconColorField = null;
        this._tooltipField = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {

        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            iconCharField:  true,
            iconClsField:  true,
            iconMapField:  true,
            iconColorField: true,
            tooltipField: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get displayField() { return super.displayField ? super.displayField : this._iconCharField; }
    set displayField(val) { this.iconCharField = val; }
    
    get iconCharField() { return this._iconCharField ? this._iconCharField : super.displayField; }
    set iconCharField(val) { this._iconCharField = val; }

    get iconClsField() { return this._iconClsField; }
    set iconClsField(val) { this._iconClsField = val; }

    get iconColorField() { return this._iconColorField; }
    set iconColorField(val) { this._iconColorField = val; }

    get iconMapField() { return this._iconMapField; }
    set iconMapField(val) { this._iconMapField = val; }

    get tooltipField() { return this._tooltipField; }
    set tooltipField(val) { this._tooltipField = val; }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid.cell (namespace)
// --------------------------------------------------------------
kijs.gui.grid.cell = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Cell (Abstract)
// --------------------------------------------------------------
kijs.gui.grid.cell.Cell = class kijs_gui_grid_cell_Cell extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // DOM type
        this._dom.nodeTagName = 'td';

        this._initialValue = null;
        this._columnConfig = null;
        this._cellEditor = null;
        this._cellEditorValue = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            htmlDisplayType: 'code'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columnConfig: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this._dom.on('dblClick', this.#onDblClick, this);
        this._dom.on('click', this.#onClick, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get cellIndex() { return this.row.grid.columnConfigs.indexOf(this._columnConfig); }
    
    get columnConfig() { return this._columnConfig; }
    set columnConfig(val) { this._columnConfig = val; }

    get isDirty() { return kijs.toString(this._initialValue) !== kijs.toString(this.value); }
    set isDirty(val) {
        if (val === false) {
            this._initialValue = kijs.toString(this.value);
            this._dom.clsRemove('kijs-grid-cell-dirty');
        } else {
            this._initialValue = null;
            this._dom.clsAdd('kijs-grid-cell-dirty');
        }
    }

    get initialValue() { return this._initialValue; }

    get row() { return this.parent; }

    get rowIndex() { return this.row.rowIndex; }
    
    get value() { return this._dom.html; }
    set value(val) { this.setValue(val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Lädt das value von der dataRow
     * @returns {undefined}
     */
    loadFromDataRow() {
        let dF = this._columnConfig.displayField;
        if (this.row && this.row.dataRow && kijs.isDefined(this.row.dataRow[dF])) {
            this.setValue(this.row.dataRow[dF], true, false, false);
        }
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        // breite
        this._dom.width = this._columnConfig.width;

        // sichtbar?
        this.visible = this._columnConfig.visible;

        // Editable-Zeilen: Klasse hinzufügen
        if (this._columnConfig.editable) {
            this._dom.clsAdd('kijs-grid-cell-editable');
        } else {
            this._dom.clsRemove('kijs-grid-cell-editable');
        }

        // Dirty-Zeilen: Klasse hinzufügen
        if (this.isDirty) {
            this._dom.clsAdd('kijs-grid-cell-dirty');
        } else {
            this._dom.clsRemove('kijs-grid-cell-dirty');
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt den Wert auf den Standardwert zurück
     * @param {Boolean} [silent=false] true, falls kein change-event ausgelöst werden soll.
     * @returns {undefined}
     */
    resetValue(silent=false) {
        this.setValue(this.initialValue, silent);
    }

    /**
     * Setzt das Display-Value der Zelle.
     * @param {String} value
     * @param {Boolean} [silent=false] true, falls kein change-event ausgelöst werden soll.
     * @param {Boolean} [markDirty=true] false, falls der Eintrag nicht als geändert markiert werden soll.
     * @param {Boolean} [updateDataRow=true] false, falls die dataRow nicht aktualisiert werden soll.
     * @returns {undefined}
     */
    setValue(value, silent=false, markDirty=true, updateDataRow=true) {
        let changed = kijs.toString(value) !== kijs.toString(this._dom.html);

        // HTML aktualisieren
        this._setDomHtml(value);

        // dataRow aktualisieren
        if (updateDataRow) {
            this._writeDisplayValueToRow(value);
        }

        if (!markDirty) {
            this.isDirty = false;
        }

        // change event bei cell, row und grid aufrufen.
        if (!silent && changed) {
            this.raiseEvent('change', {value: value, valueDisplay: value});
            this.row.raiseEvent('change', {value: value, valueDisplay: value, cell: this});
            this.row.grid.raiseEvent('change', {value: value, valueDisplay: value, row: this.row, cell: this});
        }

        if (this.isRendered) {
            this.render();
        }
    }

    startCellEdit() {
        if (this._columnConfig.editorXtype) {
            // editor starten
            let editor = kijs.getObjectFromString(this._columnConfig.editorXtype);

            if (!editor) {
                throw new kijs.Error('invalid xtype for cell editor');
            }

            let eArgs = this._getEditorArgs();
            if (kijs.isObject(this._columnConfig.editorConfig)) {
                eArgs = Object.assign(eArgs, this._columnConfig.editorConfig);
            }

            // value speichern, um Änderungen nachzuverfolgen
            this._cellEditorValue = eArgs.value;

            this._cellEditor = new editor(eArgs);

            // Nach dem rendern den focus aufs Feld legen, damit beim blur der Editor wieder geschlossen wird.
            this._cellEditor.on('afterRender', function() {
                kijs.defer(function() {
                    this._cellEditor.focus(false, true);
                }, 100, this);
            }, this);

            // Inhalt Löschen und Textfeld in dom rendern
            kijs.Dom.removeAllChildNodes(this._dom.node);
            this._cellEditor.renderTo(this._dom.node);

            this.dom.clsAdd('kijs-celledit');

            // Event auf dem Grid aufrufen
            this.row.grid.raiseEvent('startCellEdit', {cell: this});

            // falls bei einer anderen cell der edit gestartet wird, diesen hier beenden
            this.row.grid.once('startCellEdit', function(e) {
                if (e.cell !== this) {
                    this.stopCellEdit();
                }
            }, this);
        }
    }

    stopCellEdit(cancelEdit=false) {
        if (this._cellEditor) {

            // value lesen und Editor schliessen
            let val = this._cellEditor.value,
                valDsp = this._cellEditor.valueDisplay,
                valDspHtml = this._cellEditor.valueDisplayHtml;

            this._cellEditor.unrender();
            this._cellEditor = null;

            this.dom.clsRemove('kijs-celledit');

            if (cancelEdit) {
                this.setValue(this.value, true, false, false);

            } else {

                // in Row setzen
                let dtRw = this.row.dataRow;

                if (kijs.isObject(dtRw)) {
                    dtRw[this._columnConfig.valueField] = val;

                    // falls der Wert eines abweichenden Displayfield gespeichert werden soll.
                    if (this._columnConfig.displayField !== this._columnConfig.valueField) {
                        dtRw[this._columnConfig.displayField] = this.htmlDisplayType === 'html' ? valDspHtml : valDsp;
                    }
                }

                // Cell-Value setzen
                // wird mit silent aufgerufen, damit der Event separat aufgerufen und valueDisplay mitgegeben werden kann.
                if (this.htmlDisplayType === 'html') {
                    this.setValue(valDspHtml, true, true, false);
                } else {
                    this.setValue(valDsp, true, true, false);
                }

                // Event auf dem Grid aufrufen
                this.row.grid.raiseEvent('stopCellEdit', {cell: this});

                // Änderung: Event aufrufen
                if (kijs.toString(val) !== kijs.toString(this._cellEditorValue)) {
                    this.raiseEvent('change', {value: val, valueDisplay: valDsp});
                    this.row.raiseEvent('change', {value: val, valueDisplay: valDsp, cell: this});
                    this.row.grid.raiseEvent('change', {value: val, valueDisplay: valDsp, row: this.row, cell: this});
                }
                this._cellEditorValue = null;
            }
        }
    }
    
    // overwrite
    unrender(superCall) {

        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._cellEditor) {
            this._cellEditor.unrender();
            this._cellEditor = null;
        }

        super.unrender(true);
    }


    // PROTECTED
    /**
     * Argumente, welche dem Editor beim Instanzieren übergeben werden.
     * @returns {Object}
     */
    _getEditorArgs() {
        return {
            labelHide: true,
            value: this.row.dataRow[this._columnConfig.valueField],
            parent: this,
            on: {
                blur: this.#onFieldBlur,
                keyDown: this.#onFieldKeyDown,
                click: function(e) { e.nodeEvent.stopPropagation(); }, // click event stoppen, damit row focus nicht nimmt.
                context: this
            }
        };
    }

    /**
     * Setzt das HTML im DOM. Kann in abgeleiteter Klasse überschrieben werden,
     * falls ein anderer Wert angezeigt werden soll als das Value.
     * @param {String} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        this._dom.html = value;
    }

    /**
     * Schreibt das value zurück in die DataRow
     * @param {String} value
     * @returns {undefined}
     */
    _writeDisplayValueToRow(value) {
        let vF = this._columnConfig.displayField;
        if (this.row) {
            this.row.dataRow[vF] = value;
        }
    }

    
    // PRIVATE
    // LISTENERS
    #onClick() {
        if (this._columnConfig.editable && !this._cellEditor && this._columnConfig.clicksToEdit === 1) {
            this.startCellEdit();
        }
    }

    #onDblClick() {
        if (this._columnConfig.editable && !this._cellEditor && this._columnConfig.clicksToEdit === 2) {
            this.startCellEdit();
        }
    }

    #onFieldBlur() {
        kijs.defer(function() {
            this.stopCellEdit();
        }, 200, this);
    }

    #onFieldKeyDown(e) {
        // keyDown event stoppen, damit grid keyDown nicht nimmt.
        e.nodeEvent.stopPropagation();

        // Mit Tab-Taste ins nächste editierbare Feld springen.
        if (e.nodeEvent.key === 'Tab' && e.nodeEvent.ctrlKey === false) {
            this.stopCellEdit();
            this.row.grid.startCellEdit(this, e.nodeEvent.shiftKey === true);

        } else if (e.nodeEvent.key === 'Enter') {
            this.stopCellEdit();
            this.row.grid.startCellEdit([this.rowIndex+1, this.cellIndex]);

        } else if (e.nodeEvent.key === 'Escape') {
            this.stopCellEdit(true);
            this.row.focus();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {

            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Text
// --------------------------------------------------------------
kijs.gui.grid.cell.Text = class kijs_gui_grid_cell_Text extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {

        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }


};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Date
// --------------------------------------------------------------
kijs.gui.grid.cell.Date = class kijs_gui_grid_cell_Date extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._hasTime = false;
        this._format = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            hasTime: true,
            format: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (!this._format) {
            if (this._hasTime) {
                this._format = 'd.m.Y H:i';
            } else {
                this._format = 'd.m.Y';
            }
        }
    }


    // PROTECTED
    // Overwrite
    _getEditorArgs() {
        let eArgs = super._getEditorArgs();

        eArgs.hasTime = this._hasTime;
        eArgs.displayFormat = this._format;

        return eArgs;
    }

    /**
     * Zahl rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        let date = kijs.Date.create(value);

        if (kijs.isDate(date)) {
            this._dom.html = kijs.Date.format(date, this._format);
        } else {
            this._dom.html = value;
        }
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Number
// --------------------------------------------------------------
kijs.gui.grid.cell.Number = class kijs_gui_grid_cell_Number extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // value
        this._numValue = null;

        // Nummer-Einstellungen
        this._decimalPrecision = null;
        this._decimalSeparator = '.';
        this._thousandsSeparator = '\'';

        this._numberStyles = [];
        this._unitBefore = '';
        this._unitAfter = '';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-grid-cell-number'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            decimalPrecision: true,
            decimalSeparator: true,
            thousandsSeparator: true,
            numberStyles: {target: 'numberStyles'},
            unitBefore: true,
            unitAfter: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTER/SETTER
    // --------------------------------------------------------------
    get numberStyles() { return this._numberStyles; }
    set numberStyles(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        this._numberStyles = val;
    }

    get value() { return this._numValue; }
    set value(val) { super.value = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    setValue(value, silent=false, markDirty=true, updateDataRow=true) {
        let num = parseFloat(value);
        if (kijs.isNumber(num)) {
            this._numValue = num;
        } else {
            this._numValue = value;
        }

        super.setValue(this._numValue, silent, markDirty, updateDataRow);
    }


    // PROTECTED
    // Overwrite
    _getEditorArgs() {
        let eArgs = super._getEditorArgs();

        eArgs.allowDecimals = this._decimalPrecision > 0;
        eArgs.alwaysDisplayDecimals = this._decimalPrecision > 0;
        eArgs.decimalPrecision = this._decimalPrecision;
        eArgs.decimalSeparator = this._decimalSeparator;
        eArgs.thousandsSeparator = this._thousandsSeparator;

        return eArgs;
    }
    
    /**
     * Gibt den Style für eine Nummer zurück
     * @param {Number} number
     * @returns {Object}
     */
    _getNumberStyle(number) {
        let style = {};

        kijs.Array.each(this._numberStyles, function(numberStyle) {
            let from = kijs.isNumber(numberStyle.from) ? numberStyle.from : Number.MIN_SAFE_INTEGER,
                to = kijs.isNumber(numberStyle.to) ? numberStyle.to : Number.MAX_SAFE_INTEGER;

            if (number >= from && number <= to) {
                for (let key in numberStyle) {
                    if (key !== 'from' && key !== 'to') {
                        style[key] = numberStyle[key];
                    }
                }
            }
        }, this);

        return style;
    }

    /**
     * Zahl rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        let num = parseFloat(value);

        if (kijs.isNumber(num)) {
            this._dom.html = this._unitBefore + kijs.Number.format(num, this._decimalPrecision, this._decimalSeparator, this._thousandsSeparator) + this._unitAfter;

            // styles anwenden
            let numberStyle = this._getNumberStyle(num);
            for (let styleKey in numberStyle) {
                this._dom.style[styleKey] = numberStyle[styleKey];
            }

        } else if (value) {
            this._dom.html = this._unitBefore + kijs.toString(value) + this._unitAfter;

        } else {
            this._dom.html = value;
        }
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Checkbox
// --------------------------------------------------------------
kijs.gui.grid.cell.Checkbox = class kijs_gui_grid_cell_Checkbox extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // value
        this._checked = false;
        this._disabled = false;

        // class
        this._dom.clsAdd('kijs-grid-cell-checkbox');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this._dom.on('click', this.#onClick, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // Overwrite
    get value() { return this._checked; }
    set value(val) { this.setValue(val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(val, callFromParent);
        this._disabled = !!val;
    }

    /**
     * Setzt das value der Zelle.
     * @param {String} value
     * @param {Boolean} [silent=false] true, falls kein change-event ausgelöst werden soll.
     * @param {Boolean} [markDirty=true] false, falls der Eintrag nicht als geändert markiert werden soll.
     * @param {Boolean} [updateDataRow=true] false, falls die dataRow nicht aktualisiert werden soll.
     * @returns {undefined}
     */
    setValue(value, silent=false, markDirty=true, updateDataRow=true) {
        value = (value === true || value === 1 || value === '1');
        this._checked = value;
        return super.setValue(value, silent, markDirty, updateDataRow);
    }


    // PROTECTED
    /**
     * icon rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        if (value === true || value === 1 || value === '1') {
            this._dom.html = String.fromCharCode(0xf046); // fa-check-square-o
        } else {
            this._dom.html = String.fromCharCode(0xf096); // fa-square-o
        }
    }

    
    // PRIVATE
    // LISTENERS
    #onClick() {
        if (this._disabled) {
            return;
        }

        // value invertieren
        this.setValue(!this._checked);
    }

    /**
     * overwrite
     * prevent edit
     */
    #onDblClick() {
        return;
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {

            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Icon
// --------------------------------------------------------------
kijs.gui.grid.cell.Icon = class kijs_gui_grid_cell_Icon extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._iconCls = null;
        this._icon = null;
        this._originalIcon = null;
        this._iconColor = null;

        //this._dom.nodeTagName = 'span';
        this._dom.clsAdd('kijs-icon');

        // class
        this.dom.clsAdd('kijs-grid-cell-icon');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            iconChar: true,   // Alias für html
            iconCls: { target: 'iconCls' },
            iconColor: { target: 'iconColor' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get icon() { return this._icon; }

    set iconCls(val) { this._addIconCls(val); }
    get iconCls() { return this._iconCls; }

    set iconColor(val) { this._dom.style.color = val; this._iconColor = val; }
    get iconColor() { return this._iconColor; }

    set isDirty(val) {}
    get isDirty() { return false; }
    
    get originalIcon() { return this._originalIcon; }
    
    

    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // Overwrite
    loadFromDataRow() {
        super.loadFromDataRow();

        if (this.row && this.row.dataRow) {

            // icon Farbe
            if (this.columnConfig.iconColorField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconColorField])) {
               this._iconColor = this.row.dataRow[this.columnConfig.iconColorField];
               this._dom.style.color = this._iconColor;
            }

            // iconMap
            if (this.columnConfig.iconMapField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconMapField])) {
                let value = this.row.dataRow[this.columnConfig.iconMapField];
                this._setDomHtml(value);
            }

            // iconChar
            if (this.columnConfig.iconCharField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconCharField])) {
                let value = this.row.dataRow[this.columnConfig.iconCharField];
                this._setDomHtml(value);
            }

            // CSS-Klasse hinzufügen
            if (this.columnConfig.iconClsField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconClsField])) {
                let cls = this.row.dataRow[this.columnConfig.iconClsField];
                this._addIconCls(cls);
            }

            // Tooltip hinzufügen
            if (this.columnConfig.tooltipField && kijs.isDefined(this.row.dataRow[this.columnConfig.tooltipField])) {
                let tooltip = this.row.dataRow[this.columnConfig.tooltipField];
                this._dom.tooltip = kijs.String.nl2br(kijs.String.htmlspecialchars(tooltip));
            }
        }
    }


    // PROTECTED
    /**
     * Icon Klasse hinzufügen
     * @param val
     * @private
     */
    _addIconCls(val) {
        if (!kijs.isString(val) && val) {
            throw new kijs.Error(`config "iconCls" is not a string`);
        }
        if (this._iconCls) {
            this._dom.clsRemove(this._iconCls);
        }
        this._iconCls = val;
        if (this._iconCls) {
            this._dom.clsAdd(this._iconCls);
        }
    }
    
    /**
     * Icon rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        this._originalIcon = value;

        if (kijs.isString(value) && value.substr(0,2) === '&#') {
            value = kijs.String.htmlentities_decode(value).codePointAt(0);
        }

        if (kijs.isString(value) && !isNaN(parseInt(value))) {
            value = parseInt(value);
        }

        if (kijs.isString(value) && value.substr(0, 4) === 'kijs') {
            let iconMap = kijs.getObjectFromString(value);
            if (kijs.isInteger(iconMap.char)) {
                value = iconMap.char;
            }
            if (kijs.isDefined(iconMap.cls)) {
                this._addIconCls(iconMap.cls);
            }
        }

        if (!kijs.isNumber(value)) {
            value = null;
        }

        this._icon = value;
        this._dom.html = kijs.isInteger(value) ? String.fromCodePoint(value) : '';
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid.filter (namespace)
// --------------------------------------------------------------
kijs.gui.grid.filter = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Filter (Abstract)
// --------------------------------------------------------------
kijs.gui.grid.filter.Filter = class kijs_gui_grid_filter_Filter extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // DOM type
        this._dom.nodeTagName = 'td';
        this._columnConfig;
        this._filter = {};

        this._checkboxFilterGroup = null;

        this._searchContainer = new kijs.gui.Dom();
        this._removeFilterIcon = new kijs.gui.Dom({
            cls: 'kijs-grid-filter-reset'
        });

        this._menuButton = new kijs.gui.Button({
            parent: this,
            icon2Map: 'kijs.iconMap.Fa.filter', // fa-filter
            menuElements: []
        });


        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columnConfig: true,
            checkboxFilterValues: { target: 'checkboxFilterValues' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get checkboxFilterValues() { return this._checkboxFilterGroup ? this._checkboxFilterGroup.value : []; }
    set checkboxFilterValues(val) {
        // convert data to array
        if (!kijs.isArray(val)) {
            val = [val];
        }
        let data = [];
        kijs.Array.each(val, (arrVal) => {
            if (kijs.isString(arrVal)) {
                data.push({caption: arrVal, value: arrVal});
            } else if (kijs.isObject(arrVal) && kijs.isDefined(arrVal.caption) && kijs.isDefined(arrVal.value)) {
                data.push(arrVal);
            }
        });

        // checkboxgruppe
        if (this._checkboxFilterGroup === null) {
            this._checkboxFilterGroup = new kijs.gui.field.CheckboxGroup({
                cls: 'kijs-filter-checkboxgroup',
                disableFlex: false,
                on: {
                    change: this._applyToGrid,
                    context: this
                }
            });
        }

        // Daten hinzufügen
        this._checkboxFilterGroup.data = data;
    }
    
    get columnConfig() { return this._columnConfig; }
    
    get filter() {
        let flt = {
            type: '',
            valueField: this._columnConfig.valueField
        };
        if (this._checkboxFilterGroup) {
            flt.checkboxFilter = this.checkboxFilterValues;
        }
        return flt;
    }
    
    get isFiltered() { return !!(this.checkboxFilterValues.length > 0); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    hasFocus() {
        return !!this._menuButton.menu.isRendered;
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        this._searchContainer.renderTo(this._dom.node);
        this._removeFilterIcon.renderTo(this._dom.node);

        this._menuButton.menu.removeAll({
            preventRender: true,
            preventDestruct: true
        });
        this._menuButton.menu.add(this._getMenuButtons());
        this._menuButton.renderTo(this._removeFilterIcon.node);

        // breite
        this._dom.width = this._columnConfig.width;

        // sichtbar?
        this.visible = this._columnConfig.visible;

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    reset() {
        // Filter zurücksetzen
        if (this._checkboxFilterGroup !== null) {
            this._checkboxFilterGroup.checkedAll = false;
        }

        // muss in abgeleiteter Klasse überschrieben werden
        this._applyToGrid();
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._searchContainer.unrender();
        this._removeFilterIcon.unrender();

        super.unrender(true);
    }
    
    
    // PROTECTED
    // wendet den Filter auf das grid an.
    _applyToGrid(forceReload=false) {
        this.raiseEvent('filter', {filter: this.filter, forceReload: forceReload});
    }

    _getCheckboxMenuButtons() {
        return this._checkboxFilterGroup !== null ? ['-', this._checkboxFilterGroup] : [];
    }

    _getDefaultMenuButtons() {
        return [
            {
                caption : kijs.getText('Filter löschen'),
                iconMap: 'kijs.iconMap.Fa.filter-circle-xmark',
                on: {
                    click: function() {
                        this.reset();
                        this._menuButton.menu.close();
                    },
                    context: this
                }
            },{
                caption : kijs.getText('Alle Filter löschen'),
                iconMap: 'kijs.iconMap.Fa.filter-circle-xmark',
                on: {
                    click: function() {
                        this.parent.reset();
                        this._menuButton.menu.close();
                    },
                    context: this
                }
            }
        ];
    }

    _getMenuButtons() {
        return kijs.Array.concat(this._getDefaultMenuButtons(), this._getCheckboxMenuButtons());
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        this._searchContainer.destruct();
        this._removeFilterIcon.destruct();

        // Variablen (Objekte/Arrays) leeren
        this._searchContainer = null;
        this._removeFilterIcon = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Text
// --------------------------------------------------------------
kijs.gui.grid.filter.Text = class kijs_gui_grid_filter_Text extends kijs.gui.grid.filter.Filter {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // compare types
        this._compareTypes = {
            equal: kijs.getText('Ist gleich...'),
            unequal: kijs.getText('Ist nicht gleich...'),
            begin: kijs.getText('Beginnt mit...'),
            end: kijs.getText('Endet mit...'),
            part: kijs.getText('Enthält...'),
            notpart: kijs.getText('Enthält nicht...')
        };

        this._applyFilter = true;
        this._compare = 'begin'; // full, part
        this._searchField = new kijs.gui.field.Text({
            labelHide: true,
            on: {
                change: function() {
                    if (this._applyFilter) {
                        this._applyToGrid();
                    }
                    this._applyFilter = true;
                },
                keyDown: this.#onKeyDown,
                context: this
            }
        });

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            placeholder: kijs.getText('Suche') + '...'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            placeholder: {target: 'placeholder'},
            compare: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'text',
            search: this._searchField.value,
            compare: this._compare
        });
    }

    get isFiltered() { return super.isFiltered || this._searchField.value !== ''; }

    get placeholder() { return this._searchField.placeholder; }
    set placeholder(val) { this._searchField.placeholder = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    hasFocus() {
        if (super.hasFocus() || this._searchField.hasFocus) {
            return true;
        }

        return false;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        this._searchField.renderTo(this._searchContainer.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    reset() {
        this._searchField.value = '';
        super.reset();
    }


    // PROTECTED
    // overwrite
    _getMenuButtons() {
        let compareButtons = [];

        if (this._compare !== false && this._compareTypes) {
            compareButtons.push('-');

            for (const compareType in this._compareTypes) {
                compareButtons.push({
                    name: 'btn_compare_' + compareType,
                    caption : this._compareTypes[compareType],
                    iconMap: this._compare === compareType ? 'kijs.iconMap.Fa.square-check' : 'kijs.iconMap.Fa.square',
                    on: {
                        click: this.#onCompareBtnClick,
                        context: this
                    }
                });
            }
        }

        return kijs.Array.concat(this._getDefaultMenuButtons(),
            compareButtons,
            this._getCheckboxMenuButtons()
        );
    }


    // PRIVATE
    // LISTENERS
    #onCompareBtnClick(e) {
        this._menuButton.menu.close();

        if (e.element.name && e.element.name.substring(0, 'btn_compare_'.length) === 'btn_compare_') {
            this._compare = e.element.name.substring('btn_compare_'.length);
        }

        kijs.Array.each(e.element.parent.elements, function(element) {
            if (element.name === e.element.name) {
                element.iconMap = 'kijs.iconMap.Fa.square-check';

            } else if (element.name && element.name.substr(0, 'btn_compare_'.length) === 'btn_compare_') {
                element.iconMap = 'kijs.iconMap.Fa.square';
            }
        });
    }

    #onKeyDown(e) {
        e.nodeEvent.stopPropagation();
        if (e.nodeEvent.key === 'Enter') {
            e.nodeEvent.preventDefault();
            this._applyToGrid(true);
            this._applyFilter = false;
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._searchField) {
            this._searchField.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._searchField = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Number
// --------------------------------------------------------------
kijs.gui.grid.filter.Number = class kijs_gui_grid_filter_Number extends kijs.gui.grid.filter.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // compare types
        this._compareTypes = {
            equal: kijs.getText('Ist gleich...'),
            unequal: kijs.getText('Ist nicht gleich...'),
            smaller: kijs.getText('Kleiner als...'),
            bigger: kijs.getText('Grösser als...')
        };

        this._compare = 'equal';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            placeholder: kijs.getText('Filtern') + '...'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            compare: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'number',
            search: this._searchField.value,
            compare: this._compare
        });
    }

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Date
// --------------------------------------------------------------
kijs.gui.grid.filter.Date = class kijs_gui_grid_filter_Date extends kijs.gui.grid.filter.Number {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'date'
        });
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        
        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Checkbox
// --------------------------------------------------------------
kijs.gui.grid.filter.Checkbox = class kijs_gui_grid_filter_Checkbox extends kijs.gui.grid.filter.Filter {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._checkedType = '';
        this._searchContainer.clsAdd('kijs-icon');
        this._compare = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'checkbox',
            checkbox: this._compare
        });
    }

    get isFiltered() { return super.isFiltered || this._compare !== null; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    _applyToGrid() {
        if (this._compare === 'checked') {
            this._searchContainer.html = String.fromCharCode(kijs.iconMap.Fa['square-check'].char);
        } else if (this._compare === 'unchecked') {
            this._searchContainer.html = String.fromCharCode(kijs.iconMap.Fa['square'].char);
        } else {
            this._searchContainer.html = '';
        }

        super._applyToGrid();
    }

    // overwrite
    _getMenuButtons() {
        return kijs.Array.concat(this._getDefaultMenuButtons(), ['-',{
            name: 'btn_compare_checked',
            caption : kijs.getText('Alle angewählten'),
            iconMap: 'kijs.iconMap.Fa.square-check', //  fa-square-o
            on: {
                click: this.#onFilterChange,
                context: this
            }
        },{
            caption : kijs.getText('Alle nicht angewählten'),
            name: 'btn_compare_unchecked',
            iconMap: 'kijs.iconMap.Fa.square-check', // fa-square-o
            on: {
                click: this.#onFilterChange,
                context: this
            }
        }]);
    }


    // PRIVATE
    // LISTENERS
    #onFilterChange(e) {
        if (e.element.name === 'btn_compare_checked') {
            this._compare = 'checked';
        } else if (e.element.name === 'btn_compare_unchecked') {
            this._compare = 'unchecked';
        }

        kijs.Array.each(e.element.parent.elements, function(element) {
            if (element.name === e.element.name) {
                element.iconMap = 'kijs.iconMap.Fa.square-check';
            } else if (kijs.Array.contains(['btn_compare_checked', 'btn_compare_unchecked'], element.name)) {
                element.iconMap = 'kijs.iconMap.Fa.square';
            }
        });

        this._applyToGrid();
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Icon
// --------------------------------------------------------------
kijs.gui.grid.filter.Icon = class kijs_gui_grid_filter_Icon extends kijs.gui.grid.filter.Filter {

    
    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._compare = 'begin'; // full, part
        this._searchField = new kijs.gui.field.Text({disabled: true});
        this._checkboxGroup = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this.parent.grid.on('afterLoad', this.#onAfterLoad, this);
    }
    
    

    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'icon',
            icons: this._checkboxGroup ? this._checkboxGroup.value : null
        });
    }

    get isFiltered() { return this._checkboxGroup ? this._checkboxGroup.value ? true : false : false; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    render(superCall) {
        super.render(true);

        this._searchField.renderTo(this._searchContainer.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }
    
    reset() {
        if (this._checkboxGroup) {
            this._checkboxGroup.checkedAll = true;
        }
        super.reset();
    }


    // PROTECTED
    _checkIcons() {
        let icons = [];
        let iconsCheck = [];
        let dataCnt = this._checkboxGroup ? this._checkboxGroup.data.length : 0;

        if (dataCnt <= this.columnConfig.iconsCnt) {

            // Alle Zeilen und Zellen vom Grid durchsuchen
            kijs.Array.each(this.parent.grid.rows, function(row) {
                    kijs.Array.each(row.cells, function(cell) {

                        // Überprüfen ob Zelle mit dem iconCharField übereinstimmt
                        if (cell.columnConfig.iconCharField === this.columnConfig.iconCharField){
                            let contains = false;

                            // Überprüfen ob Icon schon in einem der Arrays ist
                            if (icons.length > 0) {
                                kijs.Array.each(icons, function(value){
                                        if (value.id === cell.originalIcon && value.icon === cell.icon && value.color === cell.iconColor && value.caption === cell.caption){
                                            contains = true;
                                        }
                                }, this);
                            }
                            if (this._checkboxGroup && !contains){
                                kijs.Array.each(this._checkboxGroup.data, function(data){
                                    if (data.id === cell.originalIcon && data.icon === cell.icon && data.color === cell.iconColor  && data.caption === cell.caption){
                                        contains = true;
                                    }
                                }, this);
                            }

                            // Icon dem Filter hinzufügen
                            if (!contains){
                                icons.push({id:cell.originalIcon, icon: cell.icon, color: cell.iconColor, caption: cell.caption});
                                iconsCheck.push(cell.originalIcon);
                            }
                        }
                    }, this);
            }, this);
        }
        return [icons, iconsCheck, dataCnt];
    }


    // PRIVATE
    // LISTENERS
    #onAfterLoad(e) {;
        let checkIcons = this._checkIcons();
        let icons = checkIcons[0];
        let iconsCheck = checkIcons[1];
        let dataCnt = checkIcons[2];

        // CheckboxGroup erstellen
        if (this._checkboxGroup === null && dataCnt + icons.length <= this.columnConfig.iconsCnt) {
            this._checkboxGroup = new kijs.gui.field.CheckboxGroup ({
                name: 'icons',
                valueField: 'id',
                iconCharField: 'icon',
                iconColorField: 'color',
                captionField: 'caption',
                data: icons,
                cls: 'kijs-filter-icon-checkboxgroup',
                checkedAll: true,
                on: {
                    change: this.#onFilterChange,
                    context: this
                }
            });
            this._menuButton.menu.add(['-', this._checkboxGroup]);

        } else if (this._checkboxGroup && icons.length > 0 ) {

            // Daten hinzufügen
            if (dataCnt + icons.length <= this.columnConfig.iconsCnt){
                this._checkboxGroup.addData(icons);
                this._checkboxGroup.checkedValues = iconsCheck;

            // CheckboxGroup entfernen
            } else {
                this._menuButton.menu.remove(['-', this._checkboxGroup]);
                this._checkboxGroup = null;
            }
        }
    }

    #onFilterChange() {
       this._applyToGrid();
    }

    #onKeyDown(e) {
        e.nodeEvent.stopPropagation();
        if (e.nodeEvent.key === 'Enter') {
            e.nodeEvent.preventDefault();
            this._applyToGrid();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        if (this._searchField) {
            this._searchField.destruct();
        }
        if (this._checkboxGroup) {
            this._checkboxGroup.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._searchField = null;
        this._checkboxGroup = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid (namespace)
// --------------------------------------------------------------
kijs.gui.grid = {};
/* global kijs, this */

// TODO: load() ist nicht kompatibel mit Basisklasse
// TODO: Sortable für Spaltenreihenfolge
// TODO: Sortable für Zeilenreihenfolge
// --------------------------------------------------------------
// kijs.gui.grid.Grid
// --------------------------------------------------------------
/**
 * EVENTS
 * ----------
 * afterLoad
 * beforeSelectionChange
 * selectionChange
 * rowClick
 * rowDblClick
 *
 */
kijs.gui.grid.Grid = class kijs_gui_grid_Grid extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._rpc = null;                   // Instanz von kijs.gui.Rpc
        this._rows = [];
        this._columnConfigs = [];
        this._primaryKeys = [];
        this._rpcLoadFn = null;
        this._rpcLoadArgs = null;
        this._rpcSaveFn = null;      // TODO: Wird nicht verwendet !!!!!!!!!
        this._rpcSaveArgs = null;    // TODO: Wird nicht verwendet !!!!!!!!!
        this._waitMaskTarget = null;
        this._waitMaskTargetDomProperty = null;

        this._autoLoad = true;              // Datensätze nach dem Rendern automatisch vom Server laden
        this._remoteDataLoaded = 0;         // Anzahl im Grid geladener Datensätze
        this._remoteDataStartIndex = 0;     // Start-Index für Datensätze, die als nächstes geladen werden
        this._remoteDataStep = 100;         // Anzahl Datensätze, die pro request hinzugefügt werden.
        this._remoteDataTotal = null;       // Falls von Server verfügbar die total verfügbaren Datensätze, sonst die bisher geladenen
        this._remoteDataLastRowCnt = 0;     // Anzahl Datensätze des letzten Remote-Loads
        this._getRemoteMetaData = true;     // Metadaten laden?
        this._isLoading = false;            // wird zurzeit geladen?
        this._remoteSort = null;            // Remote-Sortierung

        this._lastSelectedRow = null;       // letzte Zeile, die selektiert wurde
        this._currentRow = null;            // Zeile, welche zurzeit fokusiert ist
        this._selectType = 'single';        // multiselect: single|multi|simple|none
        this._focusable = true;             // ob das grid focusiert weden kann
        this._filterable = false;

        // Intersection Observer (endless grid loader)
        this._intersectionObserver = null;

        this._dom.clsAdd('kijs-grid');

        // dom - elemente erstellen

        // 3 Zeilen
        this._topDom = new kijs.gui.Dom({cls: 'kijs-top'});
        this._middleDom = new kijs.gui.Dom({cls: 'kijs-center'});
        this._bottomDom = new kijs.gui.Dom({cls: 'kijs-bottom'});

        this._tableContainerDom = new kijs.gui.Dom({cls: 'kijs-tablecontainer', on:{scroll: this.#onTableScroll, context: this}});
        this._tableDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._headerContainerDom = new kijs.gui.Dom({cls: 'kijs-headercontainer'});
        this._headerDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._footerContainerDom = new kijs.gui.Dom({cls: 'kijs-footercontainer'});
        this._footerDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._leftContainerDom = new kijs.gui.Dom({cls: 'kijs-leftcontainer'});
        this._leftDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._rightContainerDom = new kijs.gui.Dom({cls: 'kijs-rightcontainer'});
        this._rightDom = new kijs.gui.Dom({nodeTagName: 'table'});

        // header
        this._headerLeftContainerDom = new kijs.gui.Dom({cls: 'kijs-headercontainer-left'});
        this._headerLeftDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._headerRightContainerDom = new kijs.gui.Dom({cls: 'kijs-headercontainer-right'});
        this._headerRightDom = new kijs.gui.Dom({nodeTagName: 'table'});

        // footer
        this._footerLeftContainerDom = new kijs.gui.Dom({cls: 'kijs-footercontainer-left'});
        this._footerLeftDom = new kijs.gui.Dom({nodeTagName: 'table'});

        this._footerRightContainerDom = new kijs.gui.Dom({cls: 'kijs-footercontainer-right'});
        this._footerRightDom = new kijs.gui.Dom({nodeTagName: 'table'});

        // header / filter
        this._header = new kijs.gui.grid.Header({parent: this});
        this._filter = new kijs.gui.grid.Filter({parent: this});

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            waitMaskTarget           : this,
            waitMaskTargetDomProperty: 'dom'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            autoLoad:       true,
            rpc:            { target: 'rpc' },  // Instanz von kijs.gui.Rpc oder Name einer RPC
            rpcLoadFn:      true,
            rpcLoadArgs:    true,
            rpcSaveFn:      true,
            rpcSaveArgs:    true,
            waitMaskTarget: true,
            waitMaskTargetDomProperty: true,

            columnConfigs:  { fn: 'function', target: this.columnConfigAdd, context: this },
            primaryKeys:    { target: 'primaryKeys' },
            data:           { target: 'data' },
            remoteDataStep: { target: 'remoteDataStep' },

            focusable: true,
            filterable: true,
            filterVisible: { target: 'filterVisible' },
            selectType: { target: 'selectType' } // 'none': Es kann nichts selektiert werden
                                                 // 'single' (default): Es kann nur ein Datensatz selektiert werden
                                                 // 'multi': Mit den Shift- und Ctrl-Tasten können mehrere Datensätze selektiert werden.
                                                 // 'simple': Es können mehrere Datensätze selektiert werden. Shift- und Ctrl-Tasten müssen dazu nicht gedrückt werden.
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this.on('keyDown', this.#onKeyDown, this);
    }


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get current() { return this._currentRow; }
    /**
     * Setzt die aktuelle Zeile, die den Fokus erhalten wird.
     * Null = automatische Ermittlung
     * Um den Fokus zu setzen verwenden Sie stattdessen die Funktion .focus() von der Zeile.
     * @param {kijs.gui.grid.Row|null} cRow
     * @returns {undefined}
     */
    set current(cRow) {
        // Falls kein cRow übergeben wurde:
        if (!cRow && !kijs.isEmpty(this._rows)) {

            // Falls es schon ein gültiges Current-Zeile gibt, dieses nehmen
            if (this._currentRow && kijs.Array.contains(this._rows, this._currentRow)) {
                cRow = this._currentRow;
            }

            // Sonst die erste selektierte Zeile
            if (!cRow) {
                let sel = this.getSelected();
                if (!kijs.isEmpty(sel)) {
                    if (kijs.isArray(sel)) {
                        sel = sel[0];
                    }
                    cRow = sel;
                }
            }

            // Sonst halt die erste Zeile
            if (!cRow) {
                cRow = this._rows[0];
            }
        }

        this._currentRow = cRow;

        kijs.Array.each(this._rows, function(row) {
            if (row === cRow) {
                row.dom.clsAdd('kijs-current');
            } else {
                row.dom.clsRemove('kijs-current');
            }
            // Nur das currentRow darf den Fokus erhalten können
            if (this._focusable && row === cRow) {
                cRow.dom.nodeAttributeSet('tabIndex', 0);
            } else {
                row.dom.nodeAttributeSet('tabIndex', undefined);
            }
        }, this);
    }

    get columnConfigs() { return this._columnConfigs; }

    set data(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        this.rowsRemoveAll();
        this.rowsAdd(val);
    }
    get data() {
        let dataRows = [];
        kijs.Array.each(this._rows, function(row) {
            dataRows.push(row.dataRow);
        }, this);
        return dataRows;
    }

    get filter() { return this._filter; }

    get filterable() { return this._filterable; }
    set filterable(val) { this._filterable = !!val; }

    get filterVisible() { return this._filter.visible; }
    set filterVisible(val) { this._filter.visible = !!val; }

    get firstRow() {
        if (this._rows.length > 0) {
            return this._rows[0];
        }
        return null;
    }

    get lastRow() {
        if (this._rows.length > 0) {
            return this._rows[this._rows.length-1];
        }
        return null;
    }

    set primaryKeys(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        kijs.Array.each(val, function(k) {
           if (!kijs.isString(k)) {
               throw new kijs.Error('invalid primary key');
           }
        }, this);
        this._primaryKeys = val;
    }
    get primaryKeys() { return this._primaryKeys; }

    get remoteDataStep() { return this._remoteDataStep; }
    set remoteDataStep(val) {
        if (!kijs.isInteger(val)) {
            val = 100;
        }
        this._remoteDataStep = val;
    }

    get rows() { return this._rows; }

    get rowsCount() { return this._remoteDataTotal || this._remoteDataLoaded; }

    get rpc() {
        return this._rpc || kijs.getRpc('default');
    }
    set rpc(val) {
        if (kijs.isString(val)) {
            val = kijs.getRpc(val);
        }

        if (val instanceof kijs.gui.Rpc) {
            this._rpc = val;
        } else {
            throw new kijs.Error(`Unknown format on config "rpc"`);
        }
    }

    get rpcLoadArgs() { return this._rpcLoadArgs; }
    set rpcLoadArgs(val) { this._rpcLoadArgs = val; }

    get rpcSaveArgs() { return this._rpcSaveArgs; }
    set rpcSaveArgs(val) { this._rpcSaveArgs = val; }

    get selectType() { return this._selectType; }
    set selectType(val) {
        if (!kijs.Array.contains(['single', 'multi', 'simple', 'none'], val)) {
            throw new kijs.Error('invalid value for selectType');
        }
        this._selectType = val;
    }


    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Entfernt alle Selektionen
     * @param {Boolean} [preventSelectionChange=false]    Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    clearSelections(preventSelectionChange) {
        this.unSelect(this._rows, preventSelectionChange);
    }

    /**
     * Setzt alle dirty-records zurück.
     * @returns {undefined}
     */
    commit() {
        kijs.Array.each(this._rows, function(row) {
            row.commit();
        }, this);
    }

    columnConfigAdd(columnConfigs) {
        if (!kijs.isArray(columnConfigs)) {
            columnConfigs = [columnConfigs];
        }

        kijs.Array.each(columnConfigs, function(columnConfig) {
            let inst = this._getInstance(columnConfig, 'kijs.gui.grid.columnConfig.Text', kijs.gui.grid.columnConfig.ColumnConfig);
            inst.grid = this;
            this._columnConfigs.push(inst);
        }, this);

        if (this.isRendered) {
            this.render();
        }
    }

    /**
     * Gibt eine columnConfig anhand ihres valueField-Wertes zurück
     * @param {String} valueField
     * @returns {kijs.gui.grid.columnConfig.ColumnConfig|null}
     */
    getColumnConfigByValueField(valueField) {
        let cC = null;
        kijs.Array.each(this._columnConfigs, function(columnConfig) {
            if (columnConfig.valueField === valueField) {
                cC = columnConfig;
                return false;
            }
        }, this);

        return cC;
    }

    /**
     * Gibt die rows zurück, welche das dirty-flag haben.
     * @returns {Array}
     */
    getDirtyRows() {
        let dirtyRows = [];
        kijs.Array.each(this._rows, function(row) {
            if (row.isDirty) {
                dirtyRows.push(row);
            }
        }, this);

        return dirtyRows;
    }

    /**
     * Gibt die selektieten Zeilen zurück
     * Bei selectType='single' wird das Row direkt zurückgegeben, sonst ein Array mit den Zeilen
     * @returns {Array|kijs.gui.grid.Row|null}
     */
    getSelected() {
        let ret = [];
        for (let i=0; i<this._rows.length; i++) {
            if (this._rows[i].selected) {
                ret.push(this._rows[i]);
            }
        }

        if (this._selectType === 'none') {
            return null;

        } else if (this._selectType === 'single') {
            return ret.length ? ret[0] : null;

        } else {
            return ret;
        }
    }

    /**
     * Gibt die IDs der selektierten Datensätze zurück.
     * @returns {Array}
     */
    getSelectedIds() {
        let rows = this.getSelected(),
            hasPrimarys = this._primaryKeys.length > 0,
            multiPrimarys = this._primaryKeys.length > 1;

        // keine Rows selektiert
        if (!rows) {
            return [];
        }

        // single type: Es kommt ein Objekt
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        // Falls keine Primaries vorhanden sind, werden die rows zurückgegeben.
        if (!hasPrimarys) {
            return rows;

        // Falls nur ein primary existiert, wird ein array mit den Ids zurückgegeben
        } else if (!multiPrimarys) {
            let ids = [], primaryKey = this._primaryKeys[0];
            kijs.Array.each(rows, function(row) {
                ids.push(row.dataRow[primaryKey]);
            }, this);

            return ids;

        // Mehrere primary keys: Pro Zeile ein Objekt mit dem Ids zurückgeben
        } else {
            let ids = [];
            kijs.Array.each(rows, function(row) {
                let idRow = {};
                kijs.Array.each(this._primaryKeys, function(pk) {
                    idRow[pk] = row.dataRow[pk];
                }, this);
                ids.push(idRow);
            }, this);

            return ids;
        }
    }

    /**
     * TODO: Wir müssten nur einzelne Rows updaten können.
     * Wenn Zeile 1000 geändert wird sind wir wieder bei 1 und müssen bis Zeile 1000 scrollen, da diese nicht mehr geladen ist.
     * Als Workaround laden wir bei resetData = false alle im Grid vorhandenen Rows neu. Siehe this._remoteLoad():
     *
     * Lädt die Daten im Grid neu.
     * @param {Boolean} restoreSelection
     * @param {Boolean} resetData Vollständig & von Anfang an neu laden (z.B. beim Filtern, Sortieren)
     * @returns {Promise}
     */
    reload(restoreSelection = true, resetData = true) {
        let selected = this.getSelectedIds();
        return this._remoteLoad(resetData).then((responseData) => {

            // Selektion wiederherstellen
            if (selected && restoreSelection) {
                this.selectByIds(selected, false, true);
            }

            if (
                this._tableDom.node
                && !this._tableDom.node.height
                && !this._tableDom.node.scrollWidth
                && this._header.node.scrollWidth
            ) {

                // Falls keine Zeilen vorhanden sind, lässt sich die Tabelle nicht mehr scrollen.
                // Also geben wir der leeren Tabelle eine Grösse, damit man dort scrollen kann.
                this._tableDom.width = this._header.node.scrollWidth;
                this._tableDom.height = 200;
            } else {
                this._tableDom.width = null;
                this._tableDom.height = null;
            }

            return responseData;
        });
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // Elemente in den haupt-dom
        this._topDom.renderTo(this._dom.node);
        this._middleDom.renderTo(this._dom.node);
        this._bottomDom.renderTo(this._dom.node);

        // header / filter
        this._headerLeftContainerDom.renderTo(this._topDom.node);
        this._headerContainerDom.renderTo(this._topDom.node);
        this._headerRightContainerDom.renderTo(this._topDom.node);

        // center (grid)
        this._leftContainerDom.renderTo(this._middleDom.node);
        this._tableContainerDom.renderTo(this._middleDom.node);
        this._rightContainerDom.renderTo(this._middleDom.node);

        // footer (summary)
        this._footerLeftContainerDom.renderTo(this._bottomDom.node);
        this._footerContainerDom.renderTo(this._bottomDom.node);
        this._footerRightContainerDom.renderTo(this._bottomDom.node);

        // header
        this._headerLeftDom.renderTo(this._headerLeftContainerDom.node);
        this._headerDom.renderTo(this._headerContainerDom.node);
        this._headerRightDom.renderTo(this._headerRightContainerDom.node);

        // center
        this._leftDom.renderTo(this._leftContainerDom.node);
        this._tableDom.renderTo(this._tableContainerDom.node);
        this._rightDom.renderTo(this._rightContainerDom.node);

        // bottom
        this._footerLeftDom.renderTo(this._footerLeftContainerDom.node);
        this._footerDom.renderTo(this._footerContainerDom.node);
        this._footerRightDom.renderTo(this._footerRightContainerDom.node);

        // header / filter
        this._header.renderTo(this._headerDom.node);
        this._filter.renderTo(this._headerDom.node);

        // rows
        this._renderRows();

        // footer (TODO)

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }

        // Daten laden
        if (this._autoLoad) {
            this._autoLoad = false; // Daten nur beim ersten rendern automatisch laden.
            kijs.defer(function() {
                if (this._remoteDataLoaded === 0) {
                    this._remoteLoad(true);
                }
            }, 30, this);
        }
    }

    /**
     * Fügt eine neue Zeile hinzu oder aktualisiert eine bestehende
     * @param {Array} rows
     * @param {Number} startOffset Offset, ab dem die Rows einsortiert werden, wenn bestehende rows aktualisiert werden
     * @returns {Number} Anzahl neue Zeilen
     */
    rowsAdd(rows, startOffset=null) {
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        let renderStartOffset = this._rows.length,
            newRows = 0,
            rowPos=0,
            offsets=[];

        kijs.Array.each(rows, function(row) {
            let currentPos = null;

            // instanz einer row gegeben. Direkt einfügen
            if (row instanceof kijs.gui.grid.Row) {
                row.parent = this;
                this._rows.push(row);

                // Position der neuen row merken
                currentPos = this._rows.length-1;

            } else {

                // row per primary key suchen
                let pRow = this._getRowByPrimaryKey(row);

                if (pRow) {

                    // bestehende row updaten
                    pRow.updateDataRow(row);

                    // Position der bestehenden Row merken
                    currentPos = this._rows.indexOf(pRow);

                } else {
                    newRows++;

                    // neue row hinzufügen
                    this._rows.push(new kijs.gui.grid.Row({
                        parent: this,
                        dataRow: row,
                        on: {
                            click: this.#onRowClick,
                            dblClick: this.#onRowDblClick,
                            context: this
                        }
                    }));

                    // Position der neuen row merken
                    currentPos = this._rows.length-1;
                }
            }

            // korrekt einsortieren
            if (startOffset !== null && currentPos !== (startOffset + rowPos)) {
                kijs.Array.move(this._rows, currentPos, startOffset + rowPos);
            }
            offsets.push(startOffset + rowPos);

            // Zähler
            rowPos++;

        }, this);

        // Alle Elemente ab dem ersten neu eingefügten Element neu rendern
        if (offsets.length > 0) {
            renderStartOffset = kijs.Array.min(offsets);
        }
        if (this.isRendered && this._rows.length > renderStartOffset) {
            this._renderRows(renderStartOffset);
        }

        return newRows;
    }

    rowsRemove(rows) {
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        kijs.Array.each(rows, function(delRow) {

            // Row-Objekt: Dieses entfernen
            if (delRow instanceof kijs.gui.grid.Row) {
                kijs.Array.remove(this._rows, delRow);
                delRow.destruct();

            } else {
                // DataRow-Objekt: Suchen und entfernen
                kijs.Array.each(this._rows, function(row) {
                    if (row.dataRow === delRow) {
                        this.rowsRemove([row]);
                    }
                }, this);
            }
        }, this);
    }

    rowsRemoveAll() {
        this._remoteDataLoaded = 0;
        this._remoteDataStartIndex = 0;
        while (this._rows.length > 0) {
            this.rowsRemove(this._rows[0]);
        }
        this.scrollTo(0);
    }

    scrollTo(scrollTop, scrollLeft) {
        if (kijs.isInteger(scrollTop)) {
            if (this._leftContainerDom && this._leftContainerDom.node && this._leftContainerDom.node.scrollTop) {
                this._leftContainerDom.node.scrollTop = scrollTop;
            }
            if (this._rightContainerDom && this._rightContainerDom.node && this._rightContainerDom.node.scrollTop) {
                this._rightContainerDom.node.scrollTop = scrollTop;
            }
        }

        if (kijs.isInteger(scrollLeft)) {
            if (this._headerContainerDom && this._headerContainerDom.node && this._headerContainerDom.node.scrollTop) {
                this._headerContainerDom.node.scrollLeft = scrollLeft;
            }
            if (this._footerContainerDom && this._footerContainerDom.node && this._footerContainerDom.node.scrollTop) {
                this._footerContainerDom.node.scrollLeft = scrollLeft;
            }
        }
    }

    /**
     * Selektiert eine oder mehrere Zeilen
     * @param {kijs.gui.grid.Row|Array} rows oder Array mit Zeilen, die selektiert werden sollen
     * @param {Boolean} [keepExisting=false]  Soll die bestehende selektion belassen werden?
     * @param {Boolean} [preventEvent=false]  Soll der SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    select(rows, keepExisting=false, preventEvent=false) {
        if (kijs.isEmpty(rows)) {
            rows = [];
        }

        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        // beforeSelectionChange-Event
        if (!preventEvent) {
            let beforeSelectionChangeArgs = {rows: rows, unSelect: false, keepExisting: keepExisting, cancel: false};
            this.raiseEvent('beforeSelectionChange', beforeSelectionChangeArgs);

            // selectionChange verhindern?
            if (beforeSelectionChangeArgs.cancel === true) {
                return false;
            }
        }

        if (!keepExisting) {
            this.clearSelections(true);
        }

        kijs.Array.each(rows, function(row) {
            row.selected = true;
            row.focus();
        }, this);

        // SelectionChange auslösen
        if (!preventEvent) {
            this.raiseEvent('selectionChange', { rows: rows, unSelect: false });
        }

        return true;
    }

    /**
     * Selektiert alle Zeilen zwischen row1 und row2
     * @param {kijs.gui.grid.Row} row1
     * @param {kijs.gui.grid.Row} row2
     * @param {Boolean} [keepExisting=true]                Soll die bestehende Selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]     Soll das SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    selectBetween(row1, row2, keepExisting=true, preventSelectionChange=false) {
        let found = false;
        let rows = [];

        // Alle Zeilen zwischen dem vorher selektierten Row und dem aktuellen Row selektieren
        kijs.Array.each(this._rows, function(row) {
            if (!found) {
                if (row === row1) {
                    found = 'row1';
                } else if (row === row2) {
                    found = 'row2';
                }
            }

            if (found) {
                rows.push(row);
            }

            if ((found==='row1' && row===row2) || (found==='row2' && row===row1)) {
                return false;
            }
        }, this);


        if (!kijs.isEmpty(rows)) {
            return this.select(rows, keepExisting, preventSelectionChange);
        }

        return true;
    }

    /**
     * Selektiert Datensätze anhand der ID
     * @param {Array} ids Array vonIds [id1, id2] oder bei mehreren primaryKeys ein Objekt mit {pkName: pkValue, pk2Name: pk2Value}
     * @param {Boolean} [keepExisting=false]  Soll die bestehende Selektion belassen werden?
     * @param {Boolean} [preventEvent=false]  Soll der SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    selectByIds(ids, keepExisting=false, preventEvent=false) {
        let hasPrimarys = this._primaryKeys.length > 0,
            multiPrimarys = this._primaryKeys.length > 1,
            rows = [];

        if (!kijs.isArray(ids)) {
            ids = [ids];
        }

        // Keine Primarys, keine ID's
        if (!hasPrimarys || !ids) {
            return;
        }

        // Array mit ID's übergeben: umwandeln in Array mit Objekten
        if (!multiPrimarys && !kijs.isObject(ids[0])) {
            let pk = this._primaryKeys[0];
            for (let i=0; i<ids.length; i++) {
                let val = ids[i];
                ids[i] = {};
                ids[i][pk] = val;
            }
        }

        // Zeilen holen
        for (let i=0; i<ids.length; i++) {
            if (kijs.isObject(ids[i])) {
                let match=false;

                kijs.Array.each(this._rows, function(row) {
                    match = true;

                    for (let idKey in ids[i]) {
                        if (row.dataRow[idKey] !== ids[i][idKey]) {
                            match = false;
                        }
                    }

                    if (match) {
                        rows.push(row);
                    }

                }, this);

            }
        }

        return this.select(rows, keepExisting, preventEvent);
    }


    /**
     * Selektiert eine oder mehrere Zeilen
     * @param {Array|Object} filters                    Array mit Objektdefinitionen der Zeilen, die selektiert werden sollen
     *                                                  Beispiel 1 (nur ein Datensatz wird selektiert bei nur einem Primary-Field):
     *                                                  { field: "Id", value: 123 }
     *
     *                                                  Beispiel 2 (mehrere werden selektiert bei nur einem Primary-Field):
     *                                                  [ { field: "Id", value: 123 }, { field: "Id", value: 124 } ]
     *
     *                                                  Beispiel 3 (nur ein Datensatz wird selektiert bei mehreren Primary-Fields):
     *                                                  [
     *                                                    { field: "Name", value: "Muster" },
     *                                                    { field: "Vorname", value: "Max" }
     *                                                  ]
     *
     *                                                  Beispiel 4 (mehrere Datensätze werden selektiert bei mehreren Primary-Fields):
     *                                                  [
     *                                                    [
     *                                                      { field: "Name", value: "Muster" },
     *                                                      { field: "Vorname", value: "Max" }
     *                                                    ],[
     *                                                      { field: "Name", value: "Muster" },
     *                                                      { field: "Vorname", value: "Max" }
     *                                                    ]
     *                                                  ]
     *
     * @param {Boolean} [keepExisting=false]            Soll die bestehende Selektion belassen werden?
     * @param {Boolean} [preventSelectionChange=false]  Soll das SelectionChange-Event verhindert werden?
     * @returns {undefined}
     */
    selectByFilters(filters, keepExisting, preventSelectionChange) {
        if (kijs.isEmpty(filters)) {
            filters = [];
        }

        // Evtl. das Format ändern auf: [ [{...}, {...}], [{...}, {...}] ]
        if (kijs.isObject(filters)) {
            filters = [filters];
        }
        for (let i=0; i<filters.length; i++) {
            if (kijs.isObject(filters[i])) {
                filters[i] = [filters[i]];
            }
        }

        // Nun die Zeilen durchgehen und wenn sie zum Filter passen: die Zeile vormerken
        const selRows = [];
        if (!kijs.isEmpty(filters)) {
            kijs.Array.each(this._rows, function(row) {
                const dataRow = row.dataRow;

                kijs.Array.each(filters, function(filterFields) {
                    let ok = false;
                    kijs.Array.each(filterFields, function(filterField) {
                        if (kijs.isEmpty(filterField.value) || kijs.isEmpty(filterField.field)) {
                            throw new kijs.Error(`Unknown filter format.`);
                        }

                        if (filterField.value === dataRow[filterField.field]) {
                            ok = true;
                        } else {
                            ok = false;
                            return false;
                        }
                    }, this);
                    if (ok) {
                        selRows.push(row);
                        return false;
                    }
                }, this);

            }, this);
        }

        // Zeilen selektieren
        const success = this.select(selRows, keepExisting, preventSelectionChange);

        // Element mit Fokus neu ermitteln
        if (success) {
            this._currentRow = null;
            this.current = null;
        }

        return success;
    }

    /**
     * Sortiert die Tabelle nach einer bestimmten Spalte.
     * @param {String} field
     * @param {String} [direction] ASC oder DESC
     * @returns {undefined}
     */
    sort(field, direction='ASC') {
        direction = direction.toUpperCase();
        if (!kijs.Array.contains(['ASC', 'DESC'], direction)) {
            throw new kijs.Error('invalid value for sort direction');
        }

        // entsprechende columnConfig finden
        let columnConfig = null;
        kijs.Array.each(this._columnConfigs, function(cC) {
            if (cC.valueField === field) {
                columnConfig = cC;
                return false;
            }
        }, this);

        if (columnConfig === null) {
            throw new kijs.Error('invalid sort field name');
        }

        this._remoteSort = {
            field: field,
            direction: direction
        };

        // store laden
        this._remoteLoad(true);
    }

    /**
     * Startet das editieren.
     * @param {null|Int|Array|kijs.gui.grid.cell.Cell} offset  Int: Row-Index; Array: [RowIndex, CellIndex].
     * @param {Boolean} reverse
     * @returns {kijs.gui.grid.cell.Cell|null} Die cell oder null, falls keine gefunden.
     */
    startCellEdit(offset=null, reverse=false) {
        let cellToEdit = null;
        let offsetMatch = offset === null;

        kijs.Array.each(this.rows, function(row, rowIndex) {
            kijs.Array.each(row.cells, function(cell, cellIndex) {

                // wird ein Int angegeben, ist der offset die row-nummer
                if (kijs.isInteger(offset) && offset === rowIndex) {
                    offsetMatch = true;
                }

                // Wird ein Array [1, 2] angegeben, wird nach [RowIndex, CellIndex] gesucht.
                if (kijs.isArray(offset) && offset.length === 2
                        && kijs.isInteger(offset[0]) && kijs.isInteger(offset[1])
                        && ((offset[0] === rowIndex && cellIndex >= offset[1]) || rowIndex > offset[0])) {
                    offsetMatch = true;
                }

                // edit starten falls cell gefunden.
                if (offsetMatch && cell.columnConfig.editable) {
                    this.select(row);
                    this.current = row;
                    cell.startCellEdit();
                    cellToEdit = cell;
                    return false;
                }

                // offset ist eine cell: nächste cell bearbeiten
                if (!offsetMatch && offset === cell) {
                    offsetMatch = true;
                }

            }, this, reverse);

            if (cellToEdit) {
                return false;
            }

        }, this, reverse);

        return cellToEdit;
    }

    /**
     * Stoppt alle aktiven Edits
     * @param {Boolean} cancelEdit true, falls Abgebrochen werden soll
     * @returns {undefined}
     */
    stopCellEdit(cancelEdit=false) {
        kijs.Array.each(this.rows, function(row) {
            kijs.Array.each(row.cells, function(cell) {
                cell.stopCellEdit(cancelEdit);
            }, this);
        }, this);

    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // header / filter
        this._header.unrender();
        this._filter.unrender();

        // bottom
        this._footerLeftDom.unrender();
        this._footerDom.unrender();
        this._footerRightDom.unrender();

        // center
        this._leftDom.unrender();
        this._tableDom.unrender();
        this._rightDom.unrender();

        // header
        this._headerLeftDom.unrender();
        this._headerDom.unrender();
        this._headerRightDom.unrender();

        // footer (summary)
        this._footerLeftContainerDom.unrender();
        this._footerContainerDom.unrender();
        this._footerRightContainerDom.unrender();

        // center (grid)
        this._leftContainerDom.unrender();
        this._tableContainerDom.unrender();
        this._rightContainerDom.unrender();

        // header / filter
        this._headerLeftContainerDom.unrender();
        this._headerContainerDom.unrender();
        this._headerRightContainerDom.unrender();

        this._topDom.unrender();
        this._middleDom.unrender();
        this._bottomDom.unrender();

        super.unrender(true);
    }

    /**
     * Deselektiert ein oder mehrere Zeilen
     * @param {kijs.gui.grid.Row|Array} rows Row oder Array mit Zeilen, die deselektiert werden sollen
     * @param {Boolean} [preventEvent=false]     Soll das (Before-)SelectionChange-Event verhindert werden?
     * @returns {Boolean} Erfolgreich?
     */
    unSelect(rows, preventEvent=false) {
        if (!kijs.isArray(rows)) {
            rows = [rows];
        }

        // beforeSelectionChange-Event
        if (!preventEvent) {
            let beforeSelectionChangeArgs = {rows: rows, unSelect: true, keepExisting: false, cancel: false};
            this.raiseEvent('beforeSelectionChange', beforeSelectionChangeArgs);

            // selectionChange verhindern?
            if (beforeSelectionChangeArgs.cancel === true) {
                return false;
            }
        }

        kijs.Array.each(rows, function(row) {
            row.selected = false;
        }, this);

        if (!preventEvent) {
            this.raiseEvent('selectionChange', { rows: rows, unSelect: true } );
        }

        return true;
    }



    // PROTECTED
    /**
     * Es kann eine Config oder eine Instanz übergeben werden. Wird eine config übergeben, wird eine instanz
     * erstellt. Wenn eine Instanz übergeben wird, wird deren typ geprüft.
     * @param {Object} configOrInstance
     * @param {String} defaultXType wird verwendet wenn in der config kein xtype definiert wurde.
     * @param {constructor} requiredClass
     * @returns {inst}
     */
    _getInstance(configOrInstance, defaultXType, requiredClass=null) {
        let inst = null;

        // Standard-Objekt übergeben: instanz von xType erstellen und config übergeben
        if (kijs.isObject(configOrInstance) && configOrInstance.constructor === window.Object) {
            configOrInstance.xtype = configOrInstance.xtype || defaultXType;
            configOrInstance.grid = this;

            let constructor = kijs.getObjectFromString(configOrInstance.xtype);
            if (constructor === false) {
                throw new kijs.Error('invalid xtype ' + configOrInstance.xtype);
            }
            delete configOrInstance.xtype;
            inst = new constructor(configOrInstance);


        } else if (kijs.isObject(configOrInstance)) {
            inst = configOrInstance;
        }

        if (requiredClass !== null) {
            if (!kijs.isObject(inst) || !(inst instanceof requiredClass)) {
                throw new kijs.Error('instance not from class ' + requiredClass.name);
            }
        }

        return inst;
    }

    /**
     * Sucht eine Row anhand des Primary keys
     * @param {Object} data
     * @returns {kijs.gui.grid.Row|null} die Row oder null, wenn nicht gefunden.
     */
    _getRowByPrimaryKey(data) {
        let rowMatch = null;
        if (this._primaryKeys && this._primaryKeys.length > 0) {

            kijs.Array.each(this._rows, function(row) {
                let primMatch = true;

                kijs.Array.each(this._primaryKeys, function(primaryKey) {
                    if (!data[primaryKey] || data[primaryKey] !== row.dataRow[primaryKey]) {
                        primMatch = false;
                        return false;
                    }
                }, this);

                if (primMatch) {
                    rowMatch = row;
                    return false;
                }

            }, this);
        }

        return rowMatch;
    }

    _remoteLoad(resetData=false, loadNextData=false) {
        return new Promise((resolve, reject) => {
            if (
                this._rpcLoadFn
                && !this._isLoading
                && (
                    !this._remoteDataLoaded // Erster Aufruf
                    || resetData            // Alles neu laden
                    || !loadNextData        // Reload der letzten geladenen Daten
                    || this._remoteDataLastRowCnt === this._remoteDataStep // Letzter Aufruf hatte nicht die letzten Rows, sonst wären es weniger als _remoteDataStep
                )
            ) {
                this._isLoading = true;

                let args = {};
                args.config = {};
                args.config.sort = this._remoteSort;
                args.config.getMetaData = this._getRemoteMetaData;
                args.config.filter = this._filter.getFilters();

                // alle Daten neu laden
                if (resetData) {
                    this._remoteDataStartIndex = 0;
                } else if (loadNextData) {
                    this._remoteDataStartIndex += this._remoteDataStep;
                } else {

                    // Bei normalem Reload (Update) alle bisher geladenen Daten neu laden.
                    // Dazu muss _remoteDataStep angepasst werden und alle weiteren Requests laden auch so viele Daten.
                    // TODO Besser ist es nur den / die geänderten Daten neu zu laden. Siehe this.reload().
                    // Das Grid aktualisiert dann nur diese Zeilen (ist schon so).
                    this._remoteDataStep += this._remoteDataStartIndex;
                    this._remoteDataStartIndex = 0;
                }

                args.config.start = this._remoteDataStartIndex;
                args.config.limit = this._remoteDataStep;

                if (kijs.isObject(this._rpcLoadArgs)) {
                    args = Object.assign(args, this._rpcLoadArgs);
                }

                // Lademaske wird angezeigt, wenn das erste Mal geladen wird, oder
                // wenn sämtliche Datensätze neu geladen werden.
                let showWaitMask = this._remoteDataStartIndex === 0;

                // RPC ausführen
                this.rpc.do({
                    remoteFn: this._rpcLoadFn,
                    owner: this,
                    data: args,
                    cancelRunningRpcs: true,                                        // Cancel running
                    waitMaskTarget: showWaitMask ? this._waitMaskTarget : 'none',   // Wait Mask Target
                    waitMaskTargetDomProperty: this._waitMaskTargetDomProperty      // Wait Mask Target Dom Property
                }).then((e) => {
                    this._remoteProcess(e, args, resetData);
                    resolve(e.responseData);
                }).catch((ex) => {
                    reject(ex);
                });
            }
        });
    }

    _remoteProcess(e, args, resetData) {
        // columns
        if (kijs.isArray(e.responseData.columns)) {
            kijs.Array.clear(this._columnConfigs);
            this.columnConfigAdd(e.responseData.columns);

            this._getRemoteMetaData = false;
        }

        // primary keys
        if (e.responseData.primaryKeys) {
            this.primaryKeys = e.responseData.primaryKeys;
        }

        if (resetData) {
            this.rowsRemoveAll();
        }

        // rows
        let addedRowsCnt = 0;
        if (kijs.isArray(e.responseData.rows)) {

            // Datensätze hinzufügen
            if (e.responseData.rows.length > 0) {
                this._remoteDataLastRowCnt = e.responseData.rows.length;
                addedRowsCnt = this.rowsAdd(e.responseData.rows, args.start);
            }

            // Anzahl DS zählen
            this._remoteDataLoaded += addedRowsCnt;
        }

        // Total Datensätze
        if (kijs.isInteger(e.responseData.count)) {
            this._remoteDataTotal = e.responseData.count;
        } else if (e.responseData.rows && e.responseData.rows.length) {
            this._remoteDataTotal = args.start + e.responseData.rows.length;
        }

        // Sortierungs-Icon in Header-Bar
        this._header.setSortIcons(kijs.isObject(e.responseData.sort) ? e.responseData.sort : this._remoteSort);

        this._isLoading = false;

        // event
        this.raiseEvent('afterLoad', e);
    }

    _renderRows(offset=0) {
        for (let i=offset; i<this._rows.length; i++) {
            this._rows[i].renderTo(this._tableDom.node);
        }

        this._setIntersectionObserver();
    }

    /**
     * Selektiert eine Zeile und berücksichtigt dabei die selectType und die Tasten shift und ctrl
     * @param {kijs.gui.grid.Row} row
     * @param {Boolean} shift   // Shift gedrückt?
     * @param {Boolean} ctrl    // Ctrl gedrückt?
     * @returns {Boolean}
     */
    _selectRow(row, shift, ctrl) {
        let success = false;

        if (!row) {
            return false;
        }

        // darf überhaupt selektiert werden?
        switch (this._selectType) {
            case 'single':
                shift = false;
                ctrl = false;
                break;

            case 'multi':
                // nix
                break;

            case 'simple':
                ctrl = true;
                break;

            case 'none':
            default:
                return false;
        }

        // Shift: von der selektierten bis zur ausgewählten
        if (shift && this._lastSelectedRow) {

            // selektieren
            if (this.selectBetween(this._lastSelectedRow, row, !!ctrl, false)) {
                this.current = row;
                success = true;
            }

        } else {

            // ctrl und bereits selektiert: Abwählen
            if (ctrl && row.selected) {
                if (this.unSelect(row)) {
                    this.current = null;
                    success = true;
                }
                if (row === this._lastSelectedRow) {
                    this._lastSelectedRow = null;
                }
            } else {
                if (this.select(row, !!ctrl)) {
                    this.current = row;
                    success = true;
                }
                if (row.selected) {
                    this._lastSelectedRow = row;
                }
            }
        }
        return success;
    }

    /**
     * Setzt den intersection observer auf die letzte row.
     * @returns {undefined}
     */
    _setIntersectionObserver() {
        // Der Intersection Observer beobachtet die Scroll-Position und wirft ein Event, wenn
        // das Scrolling gegen das Ende der Seite kommt.
        if (window.IntersectionObserver) {
            if (!this._intersectionObserver || this._intersectionObserver.root !== this._tableContainerDom.node) {
                this._intersectionObserver = new IntersectionObserver(this.#onIntersect.bind(this), {
                    root: this._tableContainerDom.node,
                    rootMargin: '100px',
                    threshold: 0
                });
            }

            // observer auf letzte zeile setzen
            if (this._intersectionObserver) {
                this._intersectionObserver.disconnect();

                if (this._rows.length > 0) {
                    this._intersectionObserver.observe(this._rows[this._rows.length - 1].node);
                }
            }
        }
    }



    // PRIVATE
    // LISTENERS
    /**
     * Wird ausgelöst, wenn die Scrollbar 200px von der letzten Zeile entfernt ist.
     * @param {IntersectionObserverEntrys} intersections
     * @returns {undefined}
     */
    #onIntersect(intersections) {
        if (intersections.length > 0) {
            kijs.Array.each(intersections, function(intersection) {
                if (intersection.isIntersecting) {
                    this._remoteLoad(false, true);
                }
            }, this);
        }
    }

    #onKeyDown(e) {
        let kCode=e.nodeEvent.code, ctrl=e.nodeEvent.ctrlKey, shift=e.nodeEvent.shiftKey;

        if (!this.disabled) {
            let targetRow = null;

            if (this._currentRow) {
                switch (kCode) {
                    case 'ArrowDown': targetRow = this._currentRow.next; break;
                    case 'ArrowUp': targetRow = this._currentRow.previous; break;
                    case 'Space': targetRow = this._currentRow; break;
                }
            }

            if (!this.disabled && targetRow) {
                if (this._selectRow(targetRow, shift, ctrl)) {
                    targetRow.focus();
                }

                e.nodeEvent.preventDefault();
            }
        }
    }

    #onRowClick(e) {
        let targetRow = e.element, ctrl=e.nodeEvent.ctrlKey, shift=e.nodeEvent.shiftKey;

        if (!this.disabled && this._selectRow(targetRow, shift, ctrl)) {
            targetRow.focus();
        }

        // Event weiterreichen
        this.raiseEvent('rowClick', e);
    }

    #onRowDblClick(e) {
        // Event weiterreichen
        this.raiseEvent('rowDblClick', e);
    }

    #onTableScroll(e) {
        let scrollTop = e.dom.node.scrollTop;
        let scrollLeft = e.dom.node.scrollLeft;

        this._headerContainerDom.node.scrollLeft = scrollLeft;
        this._footerContainerDom.node.scrollLeft = scrollLeft;

        this._leftContainerDom.node.scrollTop = scrollTop;
        this._rightContainerDom.node.scrollTop = scrollTop;
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // header / filter
        this._header.destruct();
        this._filter.destruct();

        // bottom
        this._footerLeftDom.destruct();
        this._footerDom.destruct();
        this._footerRightDom.destruct();

        // center
        this._leftDom.destruct();
        this._tableDom.destruct();
        this._rightDom.destruct();

        // header
        this._headerLeftDom.destruct();
        this._headerDom.destruct();
        this._headerRightDom.destruct();

        // footer (summary)
        this._footerLeftContainerDom.destruct();
        this._footerContainerDom.destruct();
        this._footerRightContainerDom.destruct();

        // center (grid)
        this._leftContainerDom.destruct();
        this._tableContainerDom.destruct();
        this._rightContainerDom.destruct();

        // header / filter
        this._headerLeftContainerDom.destruct();
        this._headerContainerDom.destruct();
        this._headerRightContainerDom.destruct();

        this._topDom.destruct();
        this._middleDom.destruct();
        this._bottomDom.destruct();

        // Variablen (Objekte/Arrays) leeren
        // -----------------------------------

        // header / filter
        this._header = null;
        this._filter = null;

        // bottom
        this._footerLeftDom = null;
        this._footerDom = null;
        this._footerRightDom = null;

        // center
        this._leftDom = null;
        this._tableDom = null;
        this._rightDom = null;

        // header
        this._headerLeftDom = null;
        this._headerDom = null;
        this._headerRightDom = null;

        // footer (summary)
        this._footerLeftContainerDom = null;
        this._footerContainerDom = null;
        this._footerRightContainerDom = null;

        // center (grid)
        this._leftContainerDom = null;
        this._tableContainerDom = null;
        this._rightContainerDom = null;

        // header / filter
        this._headerLeftContainerDom = null;
        this._headerContainerDom = null;
        this._headerRightContainerDom = null;

        this._topDom = null;
        this._middleDom = null;
        this._bottomDom = null;

        this._rpc = null;
        this._rpcLoadArgs = null;
        this._rpcSaveArgs = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.Row
// --------------------------------------------------------------
kijs.gui.grid.Row = class kijs_gui_grid_Row extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // dom type
        this._dom.nodeTagName = 'tr';

        this._dataRow = null;
        this._cells = [];

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            dataRow: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get cells() {
        let cells = [];
        for (let i=0; i<this._cells.length; i++) {
            cells.push(this._cells[i].cell);
        }
        return cells;
    }

    get current() { return !!this._dom.clsHas('kijs-current'); }
    set current(val) {
        if (val) {
            this._dom.clsAdd('kijs-current');
        } else {
            this._dom.clsRemove('kijs-current');
        }
    }

    get dataRow() { return this._dataRow; }
    set dataRow(val) { this._dataRow = val; }

    get grid() { return this.parent; }
    
    get impair() {
        return this.rowIndex % 2 === 0;
    }

    get isDirty() {
        let isDirty = false;
        kijs.Array.each(this._cells, function(cell) {
            if (cell.cell && cell.cell.isDirty) {
                isDirty = true;
                return false;
            }
        }, this);
        return isDirty;
    }

    get next() {
        let i = this.rowIndex + 1;
        if (i > this.grid.rows.length -1) {
            return null;
        }
        return this.grid.rows[i];
    }

    get previous() {
        let i = this.rowIndex - 1;
        if (i < 0) {
            return null;
        }
        return this.grid.rows[i];
    }

    get rowIndex() {
        return this.grid.rows.indexOf(this);
    }

    get selected() { return !!this._dom.clsHas('kijs-selected'); }
    set selected(val) {
        if (val) {
            this._dom.clsAdd('kijs-selected');
        } else {
            this._dom.clsRemove('kijs-selected');
        }
    }
    
    
    
    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Setzt alle 'dirty' records zurück.
     * @returns {undefined}
     */
    commit() {
        kijs.Array.each(this._cells, function(cell) {
            if (cell.cell) {
                cell.cell.isDirty = false;
            }
        }, this);
    }

    /**
     * Sucht eine Cell anhand der Cell-Config
     * @param {Object} config
     * @returns {kijs.gui.grid.cell.Cell|null} die Cell oder null, wenn nicht gefunden.
     */
    getCellByConfig(config) {
        let cell = null;

        for (let i = 0; i < this._cells.length; i++) {
            if (this._cells[i].columnConfig === config) {
                if (this._cells[i].cell) {
                    cell = this._cells[i].cell;
                }
                break;
            }
        }

        return cell;
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // cells erstellen
        this._createCells();

        // cells sortieren
        this._sortCells();

        // cells rendern
        kijs.Array.each(this.cells, function(cell) {
            cell.renderTo(this._dom.node);
        }, this);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // cells unrendern
        kijs.Array.each(this.cells, function(cell) {
            cell.unrender();
        }, this);

        super.unrender(true);
    }
    
    /**
     * Aktualisiert die DataRow. Falls an der Row etwas geändert hat,
     * wird die Zeile aktualisiert.
     *
     * @param {Object} newDataRow
     * @returns {undefined}
     */
    updateDataRow(newDataRow) {
        let cell = null;

        // Wenn bereits gerendert, vergleichen und falls geändert neu rendern
        if (this.isRendered) {
            kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
                if (newDataRow[columnConfig.displayField] !== this.dataRow[columnConfig.displayField]) {
                    cell = this.getCellByConfig(columnConfig);
                    if (cell) {
                        cell.setValue(newDataRow[columnConfig.displayField], true, false, false);
                    }
                }
            }, this);
        }

        // aktualisieren
        this.dataRow = newDataRow;
    }


    // PROTECTED
    _createCells() {
        let newColumnConfigs = [];

        // Prüfen, ob für jede columnConfig eine cell existiert.
        // Wenn nicht, in Array schreiben.
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            if (!this.getCellByConfig(columnConfig)) {
                newColumnConfigs.push(columnConfig);
            }
        }, this);

        // Falls cell noch nicht vorhanden, neue cell erstellen.
        kijs.Array.each(newColumnConfigs, function(columnConfig) {
            let cellConfig = columnConfig.cellConfig;
            let constr = kijs.getObjectFromString(cellConfig.xtype);

            if (!constr) {
                throw new kijs.Error('invalid cell xtype for column ' + columnConfig.caption);
            }

            // change listener
            columnConfig.on('change', this.#onColumnConfigChange, this);

            cellConfig.parent = this;
            delete cellConfig.xtype;

            let cell = new constr(cellConfig);
            cell.loadFromDataRow();

            this._cells.push({columnConfig: columnConfig, cell: cell});
        }, this);
    }

    _sortCells() {
        this._cells.sort(function(a, b) {
            if (a.columnConfig.position < b.columnConfig.position) {
                return -1;
            }
            if (a.columnConfig.position > b.columnConfig.position) {
                return 1;
            }
            return 0;
        });
    }


    // PRIVATE
    // LISTENERS
    #onColumnConfigChange(e) {
        if ('visible' in e || 'width' in e) {
            kijs.Array.each(this.cells, function(cell) {
                if (e.columnConfig === cell.columnConfig) {
                    cell.render();
                    return false;
                }
            }, this);

        }
        if ('position' in e) {
            this.render();
        }
    }

    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // cells destructen
        kijs.Array.each(this.cells, function(cell) {
            cell.columnConfig.off('change', this.#onColumnConfigChange, this);
            cell.destruct();
        }, this);

        // Variablen (Objekte/Arrays) leeren
        this._cells = null;
        this._dataRow = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.Fi.grid.Filter
// --------------------------------------------------------------
kijs.gui.grid.Filter = class kijs_gui_grid_Filter extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // dom type
        this._dom.nodeTagName = 'tr';

        this._filters = [];
        this._filterReloadDeferId = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-grid-filter',
            visible: false
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    
    

    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filters() {
        let filters = [];
        for (let i=0; i<this._filters.length; i++) {
            filters.push(this._filters[i].filter);
        }
        return filters;
    }

    get grid() { return this.parent; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Gibt die Filter-Objekte als Array  zurück, welche auf dem Server angewendet werden.
     * @returns {undefined}
     */
    getFilters() {
        let filters = [];

        kijs.Array.each(this.filters, function(filter) {
            if (filter.isFiltered) {
                filters.push(filter.filter);
            }
        }, this);

        return filters;
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        // filters erstellen
        this._createFilters();

        // filters sortieren
        this._sortFilters();

        // filters rendern
        kijs.Array.each(this.filters, function(filter) {
            filter.renderTo(this._dom.node);
        }, this);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt alle Filter zurück.
     * @returns {undefined}
     */
    reset() {
        kijs.Array.each(this.filters, function(filter) {
            filter.reset();
        }, this);
    }
    
    // overwrite
    unrender(superCall) {
        // timer abbrechen
        if (this._filterReloadDeferId) {
            window.clearTimeout(this._filterReloadDeferId);
            this._filterReloadDeferId = null;
        }
        
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // filters unrendern
        kijs.Array.each(this.filters, function(filter) {
            filter.unrender();
        }, this);

        super.unrender(true);
    }


    // PROTECTED
    _createFilters() {
        let newColumnConfigs = [];

        // Prüfen, ob für jede columnConfig einen Filter existiert.
        // Wenn nicht, in Array schreiben.
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            let exist = false;
            for (let i=0; i<this._filters.length; i++) {
                if (this._filters[i].columnConfig === columnConfig) {
                    exist = true;
                    break;
                }
            }
            if (!exist) {
                newColumnConfigs.push(columnConfig);
            }
        }, this);

        // Falls Filter noch nicht vorhanden, neue Filter erstellen.
        kijs.Array.each(newColumnConfigs, function(columnConfig) {
            let filterConfig = columnConfig.filterConfig;
            let constr = kijs.getObjectFromString(filterConfig.xtype);

            if (!constr) {
                throw new kijs.Error('invalid filter xtype for column ' + columnConfig.caption);
            }

            // change listener
            columnConfig.on('change', this.#onColumnConfigChange, this);

            filterConfig.parent = this;
            delete filterConfig.xtype;

            let filter = new constr(filterConfig);
            filter.on('filter', this.#onFilter, this);
            this._filters.push({columnConfig: columnConfig, filter: filter});
        }, this);
    }

    _filterHasFocus() {
        let hasFocus = false;
        kijs.Array.each(this.filters, function(filter) {
            if (filter.hasFocus()) {
                hasFocus = true;
                return false;
            }
        }, this);
        return hasFocus;
    }
    
    _sortFilters() {
        this._filters.sort(function(a, b) {
            if (a.columnConfig.position < b.columnConfig.position) {
                return -1;
            }
            if (a.columnConfig.position > b.columnConfig.position) {
                return 1;
            }
            return 0;
        });
    }


    // PRIVATE
    // LISTENERS
    #onColumnConfigChange(e) {
        if ('visible' in e || 'width' in e) {
            kijs.Array.each(this.filters, function(filter) {
                if (e.columnConfig === filter.columnConfig) {
                    filter.render();
                    return false;
                }
            }, this);

        }
        if ('position' in e) {
            this.render();
        }
    }

    #onFilter(e) {
        let forceReload = !!e.forceReload;

        // Filter verzögert zurücksetzen, da der "Filter"
        // Event gleich mehrmals von mehreren Filtern kommen kann.
        if (this._filterReloadDeferId) {
            window.clearTimeout(this._filterReloadDeferId);
            this._filterReloadDeferId = null;
        }

        // Es wird nur neu gefiltert, wenn entweder force gewählt wurde oder kein Filterfeld den Focus hat.
        this._filterReloadDeferId = kijs.defer(function() {
            if (forceReload || !this._filterHasFocus()) {
                this.grid.reload();
            }
        }, 50, this);
    }


    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // filters destructen
        kijs.Array.each(this.filters, function(filter) {
            filter.columnConfig.off('change', this.#onColumnConfigChange, this);
            filter.destruct();
        }, this);

        // Variablen (Objekte/Arrays) leeren
        this._filters = null;
        if (this._dataRow) {
            this._dataRow = null;
        }

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// TODO: Damit Drag&Drop funktioniert, muss diese Klasse von kijs.gui.Container
// erben!


// --------------------------------------------------------------
// kijs.gui.grid.Header
// --------------------------------------------------------------
kijs.gui.grid.Header = class kijs_gui_grid_Header extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        // dom type
        this._dom.nodeTagName = 'tr';
        
        this._cells = [];
        
        /*this._ddName = kijs.uniqId('kijs.gui.grid.HeaderCell');
        
        this.ddTarget = {
            ddMarkerTagName: 'td',
            posBeforeFactor: 0.666,
            posAfterFactor: 0.666,
            mapping: {
                [this._ddName]:{
                    allowMove: true,
                    allowCopy: false,
                    allowLink: false,
                    disableMarkerAutoSize: false
                }
            },
            on: {
                drop: this.#onDrop,
                context: this
            }
        };*/
        
        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-grid-header'
        });
        
        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get cells() {
        let cells = [];
        for (let i=0; i<this._cells.length; i++) {
            cells.push(this._cells[i].cell);
        }
        return cells;
    }
    
    /*get ddTarget() { 
        return this._ddTarget; 
    }
    set ddTarget(val) {
        // config-object
        if (kijs.isObject(val)) {
            if (kijs.isEmpty(this._ddTarget)) {
                val.ownerEl = this;
                if (kijs.isEmpty(val.ownerDomProperty)) {
                    val.ownerDomProperty = 'dom';
                }
                this._ddTarget = new kijs.gui.dragDrop.Target(val);
            } else {
                this._ddTarget.applyConfig(val);
            }

        // null
        } else if (val === null) {
            if (this._ddTarget) {
                this._ddTarget.destruct();
            }
            this._ddTarget = null;

        } else {
            throw new kijs.Error(`ddTarget must be a object or null`);

        }
    }*/

    get grid() { return this.parent; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    clear() {
        // cells entfernen
        kijs.Array.each(this._cells, function(cell) {
            cell.cell.destruct();
        }, this);
        kijs.Array.clear(this._cells);
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // cells erstellen
        this._createCells();

        // cells sortieren
        this._sortCells();

        // cells rendern
        kijs.Array.each(this.cells, function(cell) {
            cell.renderTo(this._dom.node);
        }, this);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt bei allen columns das richtige Sort-Icon
     * @param {Array|Object} sort
     * @returns {undefined}
     */
    setSortIcons(sort) {
        if (kijs.isObject(sort) && sort.field && sort.direction) {
            sort = [sort];
        }

        if (!kijs.isArray(sort)) {
            return;
        }

        let sortedCells = [];
        kijs.Array.each(this._cells, function(headerCell) {
            kijs.Array.each(sort, function(srt) {
                if (srt.field === headerCell.cell.columnConfig.displayField) {
                    headerCell.cell.sort = srt.direction;
                    sortedCells.push(headerCell.cell);
                }
            }, this);
        }, this);

        // icon von header, welche nicht sortiert wurden, entfernen
        kijs.Array.each(this._cells, function(headerCell) {
            if (!kijs.Array.contains(sortedCells, headerCell.cell)) {
                headerCell.cell.sort = '';
            }
        });

    }
    
    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        // cells unrendern
        kijs.Array.each(this.cells, function(cell) {
            cell.unrender();
        }, this);

        super.unrender(true);
    }


    // PROTECTED
    _createCells() {
        let newColumnConfigs = [];

        // Prüfen, ob für jede columnConfig eine headerCell existiert.
        // Wenn nicht, in Array schreiben.
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            let exist = false;
            for (let i=0; i<this._cells.length; i++) {
                if (this._cells[i].columnConfig === columnConfig) {
                    exist = true;
                    break;
                }
            }
            if (!exist) {
                newColumnConfigs.push(columnConfig);
            }
        }, this);

        // Falls cell noch nicht vorhanden, neue cell erstellen.
        kijs.Array.each(newColumnConfigs, function(columnConfig) {
            let cell = new kijs.gui.grid.HeaderCell({
                parent: this,
                columnConfig: columnConfig/*,
                ddSource:{
                    name: this._ddName,
                    allowMove: true,
                    allowCopy: false,
                    allowLink: false,
                    ownerDomProperty: 'dom'
                }*/
            });

            // change listener
            columnConfig.on('change', this.#onColumnConfigChange, this);

            cell.loadFromColumnConfig();

            this._cells.push({columnConfig: columnConfig, cell: cell});
        }, this);
    }

    _sortCells() {
        this._cells.sort(function(a, b) {
            if (a.columnConfig.position < b.columnConfig.position) {
                return -1;
            }
            if (a.columnConfig.position > b.columnConfig.position) {
                return 1;
            }
            return 0;
        });
    }


    // PRIVATE
    // LISTENERS
    #onColumnConfigChange(e) {
        if ('visible' in e || 'width' in e || 'caption' in e || 'resizable' in e || 'sortable' in e) {
            kijs.Array.each(this.cells, function(cell) {
                if (e.columnConfig === cell.columnConfig) {
                    if (e.caption) {
                        cell.caption = e.caption;
                    } else {
                        cell.render();
                    }
                    return false;
                }
            }, this);

        }
        if ('position' in e) {
            this.render();
        }
    }

    // TODO !!!!!
    /*#onDrop(e) {
        console.log('drop');
        //let tIndex = this.header.cells.indexOf(e.targetElement);
        //let sIndex = this.header.cells.indexOf(e.sourceElement);
        //let pos = e.position.position;

        //if (!this._splitterMove && tIndex !== -1 && sIndex !== -1 && tIndex !== sIndex && (pos === 'left' || pos === 'right')) {
        //    if (pos === 'right') {
        //        tIndex += 1;
        //    }
        //    this.header.grid.columnConfigs[sIndex].position = tIndex;
        //}
    }*/
    
    

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        if (this._ddTarget) {
            this._ddTarget.destruct();
        }
        
        // cells destructen
        kijs.Array.each(this.cells, function(cell) {
            cell.destruct();
        }, this);

        // Variablen (Objekte/Arrays) leeren
        this._cells = null;
        //this._ddTarget = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.HeaderCell
// --------------------------------------------------------------
kijs.gui.grid.HeaderCell = class kijs_gui_grid_HeaderCell extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);
        
        this._overflowTooltipDisable = false;   // Tooltip auf Spaltenkopf, wenn caption zu lang
        
        // DOM type
        this._dom.nodeTagName = 'td';
        this._columnConfig = null;
        this._initialPos = 0;
        this._splitterMove = false;
        this._sort = null;

        // DOM für label
        this._captionContainerDom = new kijs.gui.Dom({cls:'kijs-caption'});
        this._captionDom = new kijs.gui.Dom({nodeTagName:'span', htmlDisplayType: 'code'});
        this._sortDom = new kijs.gui.Dom({nodeTagName:'span', cls:'kijs-sort', htmlDisplayType: 'code'});

        this._helpIconEl = new kijs.gui.Icon({
            parent  : this,
            iconChar: 0xf29C,
            iconCls : 'kijs-icon-help kijs-tooltip-icon',
            visible : false,
            tooltip : new kijs.gui.Tooltip({
                cls: 'kijs-help',
                followPointer: false
            })
        });

        // DOM für Menu
        this._menuButtonEl = new kijs.gui.Button({
            parent: this,
            disableFlex: false,
            smallPaddings: false,
            menuElements: [
                {
                    name    : 'btn-sort-asc',
                    caption : kijs.getText('Aufsteigend sortieren'),
                    iconMap: 'kijs.iconMap.Fa.arrow-down-a-z',
                    on: {
                        click: function() {
                            this.header.grid.sort(this.columnConfig.valueField, 'ASC');
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                },{
                    name    : 'btn-sort-desc',
                    caption : kijs.getText('Absteigend sortieren'),
                    iconMap: 'kijs.iconMap.Fa.arrow-down-z-a',
                    on: {
                        click: function() {
                            this.header.grid.sort(this.columnConfig.valueField, 'DESC');
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                },{
                    name    : 'btn-columns',
                    caption : kijs.getText('Spalten') + '...',
                    iconMap: 'kijs.iconMap.Fa.table-columns',
                    on: {
                        click: function() {
                            (new kijs.gui.grid.ColumnWindow({parent: this})).show();
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                },{
                    name    : 'btn-filters',
                    caption : kijs.getText('Filter') + '...',
                    iconMap: 'kijs.iconMap.Fa.filter',
                    on: {
                        click: function() {
                            this.parent.grid.filter.visible = !this.parent.grid.filter.visible;
                            this._menuButtonEl.menu.close();
                        },
                        context: this
                    }
                }
            ]
        });

        // DOM für Schieber
        this._splitterDom = new kijs.gui.Dom({
            cls:'kijs-splitter',
            on: {
                mouseDown: this.#onSplitterMouseDown,
                context: this
            }
        });

        // DOM für Schieber overlay
        this._overlayDom = new kijs.gui.Dom({cls:'kijs-splitter-overlay'});

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columnConfig: true,
            
            overflowTooltipDisable: true,
            
            sort: { target: 'sort' },

            helpIcon: { target: 'helpIcon' },
            helpIconChar: { target: 'iconChar', context: this._helpIconEl },
            helpIconCls: { target: 'iconCls', context: this._helpIconEl },
            helpIconColor: { target: 'iconColor', context: this._helpIconEl },
            helpIconMap: { target: 'iconMap', context: this._helpIconEl },
            helpText: { target: 'helpText' }
        });
        
        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._captionDom.html; }
    set caption(val) { this.setCaption(val); }

    get columnConfig() { return this._columnConfig; }
    set columnConfig(val) { this._columnConfig = val; }

    get header() { return this.parent; }

    get helpIcon() { return this._helpIconEl; }
    /**
     * Icon zuweisen
     * @param {kijs.gui.Icon|Object} val     Icon als icon-Config oder kijs.gui.Icon Element
     */
    set helpIcon(val) {
        if (kijs.isEmpty(val)) {

            // Icon zurücksetzen?
            this._helpIconEl.iconChar = null;
            this._helpIconEl.iconCls = null;
            this._helpIconEl.iconColor = null;

        } else if (val instanceof kijs.gui.Icon) {

            // kijs.gui.Icon Instanz
            this._helpIconEl.destruct();
            this._helpIconEl = val;
            if (this.isRendered) {
                this.render();
            }

        } else if (kijs.isObject(val)) {

            // Config Objekt
            this._helpIconEl.applyConfig(val);
            if (this.isRendered) {
                this._helpIconEl.render();
            }

        } else {
            throw new kijs.Error(`config "helpIcon" is not valid.`);
        }
    }

    get helpIconChar() { return this._helpIconEl.iconChar; }
    set helpIconChar(val) { this._helpIconEl.iconChar = val; }

    get helpIconCls() { return this._helpIconEl.iconCls; }
    set helpIconCls(val) { this._helpIconEl.iconCls = val; }

    get helpIconColor() { return this._helpIconEl.iconColor; }
    set helpIconColor(val) { this._helpIconEl.iconColor = val; }

    get helpIconMap() { return this._helpIconEl.iconMap; }
    set helpIconMap(val) { this._helpIconEl.iconMap = val; }

    get helpText() { return this._helpIconEl.tooltip.html; }
    set helpText(val) {
        this._helpIconEl.tooltip.html = val;
        this._helpIconEl.visible = !kijs.isEmpty(this._helpIconEl.tooltip.html);
    }

    get index() {
        if (this.header) {
            return this.header.cells.indexOf(this);
        }
        return null;
    }
    
    get overflowTooltipDisable() { return this.overflowTooltipDisable; }
    set overflowTooltipDisable(val) {
        this._overflowTooltipDisable = !!val;
        if (this.isRendered) {
            this._updateHeaderToolTip();
        }
    }
    
    get sort() { return this._sort; }
    set sort(val) {
        if (val === 'DESC') {
            this._sortDom.html = String.fromCodePoint(0xf0d7); // caret-down
            this._sort = val;

        } else if (val === 'ASC') {
            this._sortDom.html = String.fromCodePoint(0xf0d8); // caret-up
            this._sort = val;

        } else {
            this._sortDom.html = '';
            this._sort = null;
        }
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Setzt das caption der Zelle.
     * @param {String} caption
     * @param {Boolean} [updateColumnConfig=true] true, falls kein change-event ausgelöst werden soll.
     * @returns {undefined}
     */
    setCaption(caption, updateColumnConfig=true) {
        // HTML aktualisieren
        this._captionDom.html = caption;

        if (updateColumnConfig) {
            this._columnConfig.caption = caption;
        }

        if (this.isRendered) {
            this.render();
        }
    }

    /**
     * Lädt das value von der dataRow
     * @returns {undefined}
     */
    loadFromColumnConfig() {
        // Caption
        let c = this._columnConfig.caption;
        this.setCaption(c, false);

        // Tooltip
        if (this._columnConfig.tooltip) {
            this.helpText = this._columnConfig.tooltip;
        } else {
            this.helpText = '';
        }

        this._menuButtonEl.menu.down('btn-filters').visible = !!this.parent.grid.filterable;
        this._menuButtonEl.menu.down('btn-sort-asc').visible = !!this._columnConfig.sortable;
        this._menuButtonEl.menu.down('btn-sort-desc').visible = !!this._columnConfig.sortable;
    }

    // Overwrite
    render(superCall) {
        super.render(true);

        // container
        this._captionContainerDom.renderTo(this._dom.node);

        // caption dom
        this._captionDom.renderTo(this._captionContainerDom.node);

        // sort dom
        this._sortDom.renderTo(this._captionContainerDom.node);

        // Help icon rendern (kijs.gui.Icon)
        this._helpIconEl.renderTo(this._dom.node);

        // dropdown
        this._menuButtonEl.renderTo(this._dom.node);

        // Splitter
        this._splitterDom.renderTo(this._dom.node);

        // Breite
        this._dom.width = this._columnConfig.width;

        // sichtbar?
        this.visible = this._columnConfig.visible;

        // Caption als Tooltip anzeigen, wenn nicht genung Platz im Spaltenkopf
        kijs.defer(this._updateHeaderToolTip, 50, this);
        this._updateHeaderToolTip();
        
        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._captionDom.unrender();
        this._captionContainerDom.unrender();
        this._helpIconEl.unrender();
        this._menuButtonEl.unrender();
        this._splitterDom.unrender();

        super.unrender(true);
    }
    
    
    // PROTECTED
    /**
     * Aktualisiert die Overlay-Position aufgrund der Mauszeigerposition
     * @param {Number} xAbs     Mausposition clientX
     * @param {Number} yAbs     Mausposition clientY
     * @returns {undefined}
     */
    _updateOverlayPosition(xAbs, yAbs) {
        // Berechnet aus der absoluten Position bezogen zum Browserrand,
        // die relative Position bezogen zum übergeordneten DOM-Node
        const parentPos = kijs.Dom.getAbsolutePos(this.parent.grid.dom.node);
        const newPos = {
            x: xAbs - parentPos.x,
            y: yAbs - parentPos.x
        };

        this._overlayDom.left = newPos.x;
    }
    
    
    // Caption als Tooltip anzeigen, wenn nicht genung Platz im Spaltenkopf
    _updateHeaderToolTip() {
        if (!this.isRendered) {
            return;
        }
        if (!this._overflowTooltipDisable && this._captionContainerDom.width > 0) {
            if (this._captionDom.width >= this._captionContainerDom.width) {
                this._captionDom.tooltip = this.caption;
            } else {
                this._captionDom.tooltip = null;
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onSplitterMouseDown(e) {
        if (!this._columnConfig.resizable) {
            return;
        }
        this._splitterMove = true;

        this._initialPos = e.nodeEvent.clientX;

        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.clientX, e.nodeEvent.clientY);

        // Overlay rendern
        this._overlayDom.render();
        this.parent.grid.dom.node.appendChild(this._overlayDom.node);

        // mousemove und mouseup Listeners auf das document setzen
        kijs.Dom.addEventListener('mousemove', document, this.#onSplitterMouseMove, this);
        kijs.Dom.addEventListener('mouseup', document, this.#onSplitterMouseUp, this);
    }

    #onSplitterMouseMove(e) {
        // Overlay Positionieren
        this._updateOverlayPosition(e.nodeEvent.clientX, e.nodeEvent.clientY);
    }

    #onSplitterMouseUp(e) {
        // Beim ersten Auslösen des Listeners, gleich wieder entfernen
        kijs.Dom.removeEventListener('mousemove', document, this);
        kijs.Dom.removeEventListener('mouseup', document, this);

        // Overlay wieder ausblenden
        this._overlayDom.unrender();

        // Differenz zur vorherigen Position ermitteln
        let offset = e.nodeEvent.clientX - this._initialPos;

        if (this._columnConfig.resizable) {
            this._columnConfig.width = Math.max(this._columnConfig.width + offset, 40);
        }

        this._splitterMove = false;
    }

    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        this._captionDom.destruct();
        this._captionContainerDom.destruct();
        this._helpIconEl.destruct();
        this._menuButtonEl.destruct();
        this._splitterDom.destruct();

        // Variablen (Objekte/Arrays) leeren
        this._captionDom = null;
        this._helpIconEl = null;
        this._menuButtonEl = null;
        this._splitterDom = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this, HTMLElement */

// --------------------------------------------------------------
// kijs.gui.grid.ColumnWindow
// --------------------------------------------------------------
kijs.gui.grid.ColumnWindow = class kijs_gui_grid_ColumnWindow extends kijs.gui.Window {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._dom.clsAdd('kijs-columnwindow');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            caption: kijs.getText('Spalten'),
            iconMap: 'kijs.iconMap.Fa.table-columns',
            closable: true,
            maximizable: false,
            scrollableY: 'auto',
            resizable: false,
            modal: true,
            width: 200,

            innerStyle: {
                padding: '10px'
            },

            footerElements:[
                {
                    xtype: 'kijs.gui.Button',
                    caption: kijs.getText('OK'),
                    style: { flex: 1 },
                    isDefault: true,
                    on: {
                        click: this.#onOkClick,
                        context: this
                    }
                },{
                    xtype: 'kijs.gui.Button',
                    caption: kijs.getText('Abbrechen'),
                    isDefault: false,
                    on: {
                        click: this.#onCancelClick,
                        context: this
                    }
                }
            ]
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {

        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get grid() { return this.parent.header.grid; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    show() {
        let data = [];
        let values = [];
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            data.push({valueField: columnConfig.valueField, caption: columnConfig.caption });
            if (columnConfig.visible) {
                values.push(columnConfig.valueField);
            }
        }, this);

        this.add({
            xtype: 'kijs.gui.field.CheckboxGroup',
            name: 'fields',
            labelHide: true,
            valueField: 'valueField',
            captionField: 'caption',
            data: data,
            value: values,
            sortable: true
        });

        this.down('fields').on('ddOver', this.#onDdOver, this);
        this.down('fields').on('change', this.#onCheckChange, this);

        // anzeigen
        super.show();
    }


    // PRIVATE
    // LISTENERS
    #onCheckChange(e) {
        let unchecked = kijs.Array.diff(e.oldValue, e.value);

        kijs.Array.each(unchecked, function(valueField) {
            let columnConfig = this.grid.getColumnConfigByValueField(valueField);

            // uncheck verhindern, hacken wieder setzen
            if (!columnConfig.hideable) {
                kijs.defer(function() {
                    let flds = this.down('fields').value;
                    flds.push(valueField);
                    this.down('fields').value = flds;
                },20, this);
            }

        }, this);
    }
    
    #onDdOver(e) {
        const vF = e.sourceElement ? e.sourceElement.dataRow.valueField : null;

        // columnConfig Suchen und prüfen ob sortierbar
        let columnConfig = this.grid.getColumnConfigByValueField(vF);
        let allowDd = columnConfig ? columnConfig.sortable : false;

        return allowDd;
    }
    
    #onOkClick() {
        let flds = this.down('fields').value;
        
        // Sichtbarkeit übernehmen
        kijs.Array.each(this.grid.columnConfigs, function(columnConfig) {
            columnConfig.visible = kijs.Array.contains(flds, columnConfig.valueField);
        }, this);
        
        // Sortierung übernehmen
        let elements = this.down('fields').elements;
        for (let i=0; i<elements.length; i++) {
            let vF = elements[i].dataRow.valueField;

            // columnConfig Suchen und Position schreiben
            let columnConfig = this.grid.getColumnConfigByValueField(vF);
            if (columnConfig) {
                columnConfig.position = i;
            }
        }

        // Fenster schliessen
        this.destruct();
    }
    
    #onCancelClick(e) {
        // Fenster schliessen
        this.destruct();
    }
    


    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrender
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Basisklasse auch entladen
        super.destruct(true);
    }
    
};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid.column (namespace)
// --------------------------------------------------------------
kijs.gui.grid.columnConfig = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column (Abstract)
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.ColumnConfig = class kijs_gui_grid_columnConfig_ColumnConfig extends kijs.Observable {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // check if abstract
        if (kijs.isObject(config)) {
            throw new kijs.Error('do not create a instance of kijs.gui.grid.columnConfig.ColumnConfig directly');
        }

        this._caption = '';
        this._visible = true;
        this._hideable = true;
        this._position = null;
        this._resizable = true;
        this._sortable = true;
        this._tooltip = '';
        this._valueField = '';
        this._displayField = '';
        this._width = 100;

        // xtypes
        this._cellXtype = null;
        this._filterXtype = null;
        this._headerCellXtype = null;
        this._editorXtype = null;

        // Editable?
        this._editable = false;
        this._clicksToEdit = 2;

        // Configs
        this._cellConfig = null;
        this._filterConfig = null;
        this._editorConfig = null;
        this._defaultConfig = {};

        // grid
        this._grid = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        this._configMap = {
            grid: true,
            cellXtype: true,
            filterXtype: true,
            headerCellXtype: true,
            editorXtype: true,

            caption: { target: 'caption' },
            editable: true,
            clicksToEdit: true,
            visible: true,
            hideable: true,
            position: true,
            resizable: true,
            sortable: true,
            tooltip: true,
            valueField: true,
            displayField: true,
            width: true,

            cellConfig: { target: 'cellConfig' },
            filterConfig: { target: 'filterConfig' },
            editorConfig: { target: 'editorConfig' }
        };

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (this._cellConfig === null) {
            this.cellConfig = this._cellXtype;
        }
        if (this.filterConfig === null) {
            this.filterConfig = this._filterXtype;
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get caption() { return this._caption; }
    set caption(val) {
        this._caption = val;
        this.raiseEvent('change', {columnConfig: this, caption: val});
    }

    get cellConfig() {
        let cCnf =  this._cellConfig ? kijs.Object.clone(this._cellConfig) : {};
        cCnf.columnConfig = this;
        if (!cCnf.xtype) {
            cCnf.xtype = this._cellXtype;
        }
        return cCnf;
    }
    set cellConfig(val) {
        if (kijs.isString(val)) {
            this._cellConfig = {
                xtype: val
            };
        } else if (kijs.isObject(val)) {
            this._cellConfig = val;
        }
    }

    get clicksToEdit() { return this._clicksToEdit; }
    set clicksToEdit(val) { this._clicksToEdit = val === 1 ? 1 : 2; }

    get displayField() { return this._displayField ? this._displayField : this._valueField; }
    set displayField(val) { this._displayField = val; }

    get editable() { return this._editable; }
    set editable(val) {
        this._editable = !!val;
        this.raiseEvent('change', {columnConfig: this, editable: !!val});
    }

    get editorConfig() { return this._editorConfig; }
    set editorConfig(val) {
        this._editorConfig = kijs.isObject(val) ? val : null;
    }

    get editorXtype() { return this._editorXtype; }
    set editorXtype(val) {
        this._editorXtype = kijs.isString(val) ? val : null;
    }

    get filterConfig() {
        let cCnf =  this._filterConfig || {xtype: this._filterXtype};
        cCnf.columnConfig = this;
        return cCnf;
    }
    set filterConfig(val) {
        if (kijs.isString(val)) {
            this._filterConfig = {
                xtype: val
            };
        } else if (kijs.isObject(val)) {
            this._filterConfig = val;
            if (!this._filterConfig.xtype) {
                this._filterConfig.xtype = this._filterXtype;
            }
            this._filterConfig.columnConfig = this;
        }
    }

    get grid() { return this._grid; }
    set grid(val) { this._grid = val; }

    get hideable() { return this._hideable; }
    set hideable(val) {
        this._hideable = !!val;
        this.raiseEvent('change', {columnConfig: this, hideable: !!val});
    }

    get position() {
        if (!kijs.isEmpty(this._position)) {
            return this._position;
        } else if (this._grid) {
            return this._grid.columnConfigs.indexOf(this);
        }
        return false;
    }
    set position(val) {
        if (val !== this.position) {
            this.raiseEvent('change', {columnConfig: this, position: this.position});
        }
    }

    get resizable() { return this._resizable; }
    set resizable(val) {
        this._resizable = !!val;
        this.raiseEvent('change', {columnConfig: this, resizable: !!val});
    }

    get sortable() { return this._sortable; }
    set sortable(val) {
        this._sortable = !!val;
        this.raiseEvent('change', {columnConfig: this, sortable: !!val});
    }

    get tooltip() { return this._tooltip };
    set tooltip(val) {
        this._tooltip = val;
        this.raiseEvent('change', {columnConfig: this, tooltip: val});
    }

    get valueField() { return this._valueField ? this._valueField : this._displayField; }
    set valueField(val) { this._valueField = val; }

    get visible() { return this._visible; }
    set visible(val) {
        if (!val && !this.hideable) {
            return;
        }
        if (val !== this._visible) {
            this._visible = !!val;
            this.raiseEvent('change', {columnConfig: this, visible: !!val});
        }
    }

    get width() { return this._width; }
    set width(val) {
        if (!kijs.isNumeric(val)) {
            throw new kijs.Error('invalid width value for columnConfig');
        }
        this._width = val;
        this.raiseEvent('change', {columnConfig: this, width: val});
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Wendet die Konfigurations-Eigenschaften an
     * @param {Object} config
     * @param {Boolean} [preventEvents=false]   // Das Auslösen des afterResize-Event verhindern?
     * @returns {undefined}
     */
    applyConfig(config={}, preventEvents=false) {
        // evtl. afterResize-Event deaktivieren
        const prevAfterRes = this._preventAfterResize;
        if (preventEvents) {
            this._preventAfterResize = true;
        }

        // Config zuweisen
        kijs.Object.assignConfig(this, config, this._configMap);

        // Evtl. afterResize-Event wieder zulassen
        if (preventEvents) {
            this._preventAfterResize = prevAfterRes;
        }
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Text = class kijs_gui_grid_columnConfig_Text extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Text';
        this._filterXtype = 'kijs.gui.grid.filter.Text';
        this._editorXtype = 'kijs.gui.field.Text';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // Keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Date = class kijs_gui_grid_columnConfig_Date extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Date';
        this._filterXtype = 'kijs.gui.grid.filter.Date';

        // Editor
        this._editorXtype = 'kijs.gui.field.Date';

        this._hasTime = false;
        this._format = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            hasTime: true,
            format: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (!this._format) {
            if (this._hasTime) {
                this._format = 'd.m.Y H:i';
            } else {
                this._format = 'd.m.Y';
            }
        }

        this.cellConfig = {
            hasTime: this._hasTime,
            format: this._format
        };
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Number = class kijs_gui_grid_columnConfig_Number extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Number';
        this._filterXtype = 'kijs.gui.grid.filter.Number';
        this._editorXtype = 'kijs.gui.field.Number';

        this._decimalPrecision = null;
        this._decimalSeparator = '.';
        this._thousandsSeparator = '\'';

        this._numberStyles = [];

        this._unitBefore = '';
        this._unitAfter = '';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            decimalPrecision: true,
            decimalSeparator: true,
            thousandsSeparator: true,
            numberStyles: true,
            unitBefore: true,
            unitAfter: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this.cellConfig = {
            decimalPrecision: this._decimalPrecision,
            decimalSeparator: this._decimalSeparator,
            thousandsSeparator: this._thousandsSeparator,
            numberStyles: this._numberStyles,
            unitBefore: this._unitBefore,
            unitAfter: this._unitAfter
        };
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    /**
     * Gibt die Argumente für den Celleditor zurück
     * @returns {Object}
     */
    get editorConfig() {
        let editorConfig = super.editorConfig;

        if (this._editorXtype === 'kijs.gui.field.Number') {
            if (!kijs.isObject(editorConfig)) {
                editorConfig = {};
            }
            // config für Nummerfeld übernehmen
            if (this._decimalPrecision !== null && !kijs.isDefined(editorConfig.decimalPrecision)) {
                editorConfig.decimalPrecision = this._decimalPrecision;
            }
            if (this._decimalSeparator !== null && !kijs.isDefined(editorConfig.decimalSeparator)) {
                editorConfig.decimalSeparator = this._decimalSeparator;
            }
            if (this._thousandsSeparator !== null && !kijs.isDefined(editorConfig.thousandsSeparator)) {
                editorConfig.thousandsSeparator = this._thousandsSeparator;
            }
            
        }
        return editorConfig;
    }
    set editorConfig(val) {
        super.editorConfig = val;
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.column.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Checkbox = class kijs_gui_grid_columnConfig_Checkbox extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Checkbox';
        this._filterXtype = 'kijs.gui.grid.filter.Checkbox';

        this._editorXtype = null;

        this._disabled = false;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            disabled: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this.cellConfig = {
            disabled: this._disabled
        };
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.columnConfig.Column
// --------------------------------------------------------------
kijs.gui.grid.columnConfig.Icon = class kijs_gui_grid_columnConfig_Icon extends kijs.gui.grid.columnConfig.ColumnConfig {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // default xtype
        this._cellXtype = 'kijs.gui.grid.cell.Icon';
        this._filterXtype = 'kijs.gui.grid.filter.Icon';
        this._iconCharField = null;
        this._iconClsField = null;
        this._iconMapField = null;
        this._iconColorField = null;
        this._tooltipField = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {

        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            iconCharField:  true,
            iconClsField:  true,
            iconMapField:  true,
            iconColorField: true,
            tooltipField: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get displayField() { return super.displayField ? super.displayField : this._iconCharField; }
    set displayField(val) { this.iconCharField = val; }
    
    get iconCharField() { return this._iconCharField ? this._iconCharField : super.displayField; }
    set iconCharField(val) { this._iconCharField = val; }

    get iconClsField() { return this._iconClsField; }
    set iconClsField(val) { this._iconClsField = val; }

    get iconColorField() { return this._iconColorField; }
    set iconColorField(val) { this._iconColorField = val; }

    get iconMapField() { return this._iconMapField; }
    set iconMapField(val) { this._iconMapField = val; }

    get tooltipField() { return this._tooltipField; }
    set tooltipField(val) { this._tooltipField = val; }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid.cell (namespace)
// --------------------------------------------------------------
kijs.gui.grid.cell = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Cell (Abstract)
// --------------------------------------------------------------
kijs.gui.grid.cell.Cell = class kijs_gui_grid_cell_Cell extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // DOM type
        this._dom.nodeTagName = 'td';

        this._initialValue = null;
        this._columnConfig = null;
        this._cellEditor = null;
        this._cellEditorValue = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            htmlDisplayType: 'code'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columnConfig: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this._dom.on('dblClick', this.#onDblClick, this);
        this._dom.on('click', this.#onClick, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get cellIndex() { return this.row.grid.columnConfigs.indexOf(this._columnConfig); }
    
    get columnConfig() { return this._columnConfig; }
    set columnConfig(val) { this._columnConfig = val; }

    get isDirty() { return kijs.toString(this._initialValue) !== kijs.toString(this.value); }
    set isDirty(val) {
        if (val === false) {
            this._initialValue = kijs.toString(this.value);
            this._dom.clsRemove('kijs-grid-cell-dirty');
        } else {
            this._initialValue = null;
            this._dom.clsAdd('kijs-grid-cell-dirty');
        }
    }

    get initialValue() { return this._initialValue; }

    get row() { return this.parent; }

    get rowIndex() { return this.row.rowIndex; }
    
    get value() { return this._dom.html; }
    set value(val) { this.setValue(val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    /**
     * Lädt das value von der dataRow
     * @returns {undefined}
     */
    loadFromDataRow() {
        let dF = this._columnConfig.displayField;
        if (this.row && this.row.dataRow && kijs.isDefined(this.row.dataRow[dF])) {
            this.setValue(this.row.dataRow[dF], true, false, false);
        }
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        // breite
        this._dom.width = this._columnConfig.width;

        // sichtbar?
        this.visible = this._columnConfig.visible;

        // Editable-Zeilen: Klasse hinzufügen
        if (this._columnConfig.editable) {
            this._dom.clsAdd('kijs-grid-cell-editable');
        } else {
            this._dom.clsRemove('kijs-grid-cell-editable');
        }

        // Dirty-Zeilen: Klasse hinzufügen
        if (this.isDirty) {
            this._dom.clsAdd('kijs-grid-cell-dirty');
        } else {
            this._dom.clsRemove('kijs-grid-cell-dirty');
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    /**
     * Setzt den Wert auf den Standardwert zurück
     * @param {Boolean} [silent=false] true, falls kein change-event ausgelöst werden soll.
     * @returns {undefined}
     */
    resetValue(silent=false) {
        this.setValue(this.initialValue, silent);
    }

    /**
     * Setzt das Display-Value der Zelle.
     * @param {String} value
     * @param {Boolean} [silent=false] true, falls kein change-event ausgelöst werden soll.
     * @param {Boolean} [markDirty=true] false, falls der Eintrag nicht als geändert markiert werden soll.
     * @param {Boolean} [updateDataRow=true] false, falls die dataRow nicht aktualisiert werden soll.
     * @returns {undefined}
     */
    setValue(value, silent=false, markDirty=true, updateDataRow=true) {
        let changed = kijs.toString(value) !== kijs.toString(this._dom.html);

        // HTML aktualisieren
        this._setDomHtml(value);

        // dataRow aktualisieren
        if (updateDataRow) {
            this._writeDisplayValueToRow(value);
        }

        if (!markDirty) {
            this.isDirty = false;
        }

        // change event bei cell, row und grid aufrufen.
        if (!silent && changed) {
            this.raiseEvent('change', {value: value, valueDisplay: value});
            this.row.raiseEvent('change', {value: value, valueDisplay: value, cell: this});
            this.row.grid.raiseEvent('change', {value: value, valueDisplay: value, row: this.row, cell: this});
        }

        if (this.isRendered) {
            this.render();
        }
    }

    startCellEdit() {
        if (this._columnConfig.editorXtype) {
            // editor starten
            let editor = kijs.getObjectFromString(this._columnConfig.editorXtype);

            if (!editor) {
                throw new kijs.Error('invalid xtype for cell editor');
            }

            let eArgs = this._getEditorArgs();
            if (kijs.isObject(this._columnConfig.editorConfig)) {
                eArgs = Object.assign(eArgs, this._columnConfig.editorConfig);
            }

            // value speichern, um Änderungen nachzuverfolgen
            this._cellEditorValue = eArgs.value;

            this._cellEditor = new editor(eArgs);

            // Nach dem rendern den focus aufs Feld legen, damit beim blur der Editor wieder geschlossen wird.
            this._cellEditor.on('afterRender', function() {
                kijs.defer(function() {
                    this._cellEditor.focus(false, true);
                }, 100, this);
            }, this);

            // Inhalt Löschen und Textfeld in dom rendern
            kijs.Dom.removeAllChildNodes(this._dom.node);
            this._cellEditor.renderTo(this._dom.node);

            this.dom.clsAdd('kijs-celledit');

            // Event auf dem Grid aufrufen
            this.row.grid.raiseEvent('startCellEdit', {cell: this});

            // falls bei einer anderen cell der edit gestartet wird, diesen hier beenden
            this.row.grid.once('startCellEdit', function(e) {
                if (e.cell !== this) {
                    this.stopCellEdit();
                }
            }, this);
        }
    }

    stopCellEdit(cancelEdit=false) {
        if (this._cellEditor) {

            // value lesen und Editor schliessen
            let val = this._cellEditor.value,
                valDsp = this._cellEditor.valueDisplay,
                valDspHtml = this._cellEditor.valueDisplayHtml;

            this._cellEditor.unrender();
            this._cellEditor = null;

            this.dom.clsRemove('kijs-celledit');

            if (cancelEdit) {
                this.setValue(this.value, true, false, false);

            } else {

                // in Row setzen
                let dtRw = this.row.dataRow;

                if (kijs.isObject(dtRw)) {
                    dtRw[this._columnConfig.valueField] = val;

                    // falls der Wert eines abweichenden Displayfield gespeichert werden soll.
                    if (this._columnConfig.displayField !== this._columnConfig.valueField) {
                        dtRw[this._columnConfig.displayField] = this.htmlDisplayType === 'html' ? valDspHtml : valDsp;
                    }
                }

                // Cell-Value setzen
                // wird mit silent aufgerufen, damit der Event separat aufgerufen und valueDisplay mitgegeben werden kann.
                if (this.htmlDisplayType === 'html') {
                    this.setValue(valDspHtml, true, true, false);
                } else {
                    this.setValue(valDsp, true, true, false);
                }

                // Event auf dem Grid aufrufen
                this.row.grid.raiseEvent('stopCellEdit', {cell: this});

                // Änderung: Event aufrufen
                if (kijs.toString(val) !== kijs.toString(this._cellEditorValue)) {
                    this.raiseEvent('change', {value: val, valueDisplay: valDsp});
                    this.row.raiseEvent('change', {value: val, valueDisplay: valDsp, cell: this});
                    this.row.grid.raiseEvent('change', {value: val, valueDisplay: valDsp, row: this.row, cell: this});
                }
                this._cellEditorValue = null;
            }
        }
    }
    
    // overwrite
    unrender(superCall) {

        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        if (this._cellEditor) {
            this._cellEditor.unrender();
            this._cellEditor = null;
        }

        super.unrender(true);
    }


    // PROTECTED
    /**
     * Argumente, welche dem Editor beim Instanzieren übergeben werden.
     * @returns {Object}
     */
    _getEditorArgs() {
        return {
            labelHide: true,
            value: this.row.dataRow[this._columnConfig.valueField],
            parent: this,
            on: {
                blur: this.#onFieldBlur,
                keyDown: this.#onFieldKeyDown,
                click: function(e) { e.nodeEvent.stopPropagation(); }, // click event stoppen, damit row focus nicht nimmt.
                context: this
            }
        };
    }

    /**
     * Setzt das HTML im DOM. Kann in abgeleiteter Klasse überschrieben werden,
     * falls ein anderer Wert angezeigt werden soll als das Value.
     * @param {String} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        this._dom.html = value;
    }

    /**
     * Schreibt das value zurück in die DataRow
     * @param {String} value
     * @returns {undefined}
     */
    _writeDisplayValueToRow(value) {
        let vF = this._columnConfig.displayField;
        if (this.row) {
            this.row.dataRow[vF] = value;
        }
    }

    
    // PRIVATE
    // LISTENERS
    #onClick() {
        if (this._columnConfig.editable && !this._cellEditor && this._columnConfig.clicksToEdit === 1) {
            this.startCellEdit();
        }
    }

    #onDblClick() {
        if (this._columnConfig.editable && !this._cellEditor && this._columnConfig.clicksToEdit === 2) {
            this.startCellEdit();
        }
    }

    #onFieldBlur() {
        kijs.defer(function() {
            this.stopCellEdit();
        }, 200, this);
    }

    #onFieldKeyDown(e) {
        // keyDown event stoppen, damit grid keyDown nicht nimmt.
        e.nodeEvent.stopPropagation();

        // Mit Tab-Taste ins nächste editierbare Feld springen.
        if (e.nodeEvent.key === 'Tab' && e.nodeEvent.ctrlKey === false) {
            this.stopCellEdit();
            this.row.grid.startCellEdit(this, e.nodeEvent.shiftKey === true);

        } else if (e.nodeEvent.key === 'Enter') {
            this.stopCellEdit();
            this.row.grid.startCellEdit([this.rowIndex+1, this.cellIndex]);

        } else if (e.nodeEvent.key === 'Escape') {
            this.stopCellEdit(true);
            this.row.focus();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {

            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Text
// --------------------------------------------------------------
kijs.gui.grid.cell.Text = class kijs_gui_grid_cell_Text extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {

        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }


};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Date
// --------------------------------------------------------------
kijs.gui.grid.cell.Date = class kijs_gui_grid_cell_Date extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._hasTime = false;
        this._format = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            hasTime: true,
            format: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        if (!this._format) {
            if (this._hasTime) {
                this._format = 'd.m.Y H:i';
            } else {
                this._format = 'd.m.Y';
            }
        }
    }


    // PROTECTED
    // Overwrite
    _getEditorArgs() {
        let eArgs = super._getEditorArgs();

        eArgs.hasTime = this._hasTime;
        eArgs.displayFormat = this._format;

        return eArgs;
    }

    /**
     * Zahl rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        let date = kijs.Date.create(value);

        if (kijs.isDate(date)) {
            this._dom.html = kijs.Date.format(date, this._format);
        } else {
            this._dom.html = value;
        }
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Number
// --------------------------------------------------------------
kijs.gui.grid.cell.Number = class kijs_gui_grid_cell_Number extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // value
        this._numValue = null;

        // Nummer-Einstellungen
        this._decimalPrecision = null;
        this._decimalSeparator = '.';
        this._thousandsSeparator = '\'';

        this._numberStyles = [];
        this._unitBefore = '';
        this._unitAfter = '';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-grid-cell-number'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            decimalPrecision: true,
            decimalSeparator: true,
            thousandsSeparator: true,
            numberStyles: {target: 'numberStyles'},
            unitBefore: true,
            unitAfter: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTER/SETTER
    // --------------------------------------------------------------
    get numberStyles() { return this._numberStyles; }
    set numberStyles(val) {
        if (!kijs.isArray(val)) {
            val = [val];
        }
        this._numberStyles = val;
    }

    get value() { return this._numValue; }
    set value(val) { super.value = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    setValue(value, silent=false, markDirty=true, updateDataRow=true) {
        let num = parseFloat(value);
        if (kijs.isNumber(num)) {
            this._numValue = num;
        } else {
            this._numValue = value;
        }

        super.setValue(this._numValue, silent, markDirty, updateDataRow);
    }


    // PROTECTED
    // Overwrite
    _getEditorArgs() {
        let eArgs = super._getEditorArgs();

        eArgs.allowDecimals = this._decimalPrecision > 0;
        eArgs.alwaysDisplayDecimals = this._decimalPrecision > 0;
        eArgs.decimalPrecision = this._decimalPrecision;
        eArgs.decimalSeparator = this._decimalSeparator;
        eArgs.thousandsSeparator = this._thousandsSeparator;

        return eArgs;
    }
    
    /**
     * Gibt den Style für eine Nummer zurück
     * @param {Number} number
     * @returns {Object}
     */
    _getNumberStyle(number) {
        let style = {};

        kijs.Array.each(this._numberStyles, function(numberStyle) {
            let from = kijs.isNumber(numberStyle.from) ? numberStyle.from : Number.MIN_SAFE_INTEGER,
                to = kijs.isNumber(numberStyle.to) ? numberStyle.to : Number.MAX_SAFE_INTEGER;

            if (number >= from && number <= to) {
                for (let key in numberStyle) {
                    if (key !== 'from' && key !== 'to') {
                        style[key] = numberStyle[key];
                    }
                }
            }
        }, this);

        return style;
    }

    /**
     * Zahl rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        let num = parseFloat(value);

        if (kijs.isNumber(num)) {
            this._dom.html = this._unitBefore + kijs.Number.format(num, this._decimalPrecision, this._decimalSeparator, this._thousandsSeparator) + this._unitAfter;

            // styles anwenden
            let numberStyle = this._getNumberStyle(num);
            for (let styleKey in numberStyle) {
                this._dom.style[styleKey] = numberStyle[styleKey];
            }

        } else if (value) {
            this._dom.html = this._unitBefore + kijs.toString(value) + this._unitAfter;

        } else {
            this._dom.html = value;
        }
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Checkbox
// --------------------------------------------------------------
kijs.gui.grid.cell.Checkbox = class kijs_gui_grid_cell_Checkbox extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // value
        this._checked = false;
        this._disabled = false;

        // class
        this._dom.clsAdd('kijs-grid-cell-checkbox');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Events
        this._dom.on('click', this.#onClick, this);
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    // Overwrite
    get value() { return this._checked; }
    set value(val) { this.setValue(val); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(val, callFromParent);
        this._disabled = !!val;
    }

    /**
     * Setzt das value der Zelle.
     * @param {String} value
     * @param {Boolean} [silent=false] true, falls kein change-event ausgelöst werden soll.
     * @param {Boolean} [markDirty=true] false, falls der Eintrag nicht als geändert markiert werden soll.
     * @param {Boolean} [updateDataRow=true] false, falls die dataRow nicht aktualisiert werden soll.
     * @returns {undefined}
     */
    setValue(value, silent=false, markDirty=true, updateDataRow=true) {
        value = (value === true || value === 1 || value === '1');
        this._checked = value;
        return super.setValue(value, silent, markDirty, updateDataRow);
    }


    // PROTECTED
    /**
     * icon rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        if (value === true || value === 1 || value === '1') {
            this._dom.html = String.fromCharCode(0xf046); // fa-check-square-o
        } else {
            this._dom.html = String.fromCharCode(0xf096); // fa-square-o
        }
    }

    
    // PRIVATE
    // LISTENERS
    #onClick() {
        if (this._disabled) {
            return;
        }

        // value invertieren
        this.setValue(!this._checked);
    }

    /**
     * overwrite
     * prevent edit
     */
    #onDblClick() {
        return;
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {

            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }
    
};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.cell.Icon
// --------------------------------------------------------------
kijs.gui.grid.cell.Icon = class kijs_gui_grid_cell_Icon extends kijs.gui.grid.cell.Cell {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._iconCls = null;
        this._icon = null;
        this._originalIcon = null;
        this._iconColor = null;

        //this._dom.nodeTagName = 'span';
        this._dom.clsAdd('kijs-icon');

        // class
        this.dom.clsAdd('kijs-grid-cell-icon');

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            iconChar: true,   // Alias für html
            iconCls: { target: 'iconCls' },
            iconColor: { target: 'iconColor' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get icon() { return this._icon; }

    set iconCls(val) { this._addIconCls(val); }
    get iconCls() { return this._iconCls; }

    set iconColor(val) { this._dom.style.color = val; this._iconColor = val; }
    get iconColor() { return this._iconColor; }

    set isDirty(val) {}
    get isDirty() { return false; }
    
    get originalIcon() { return this._originalIcon; }
    
    

    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // Overwrite
    loadFromDataRow() {
        super.loadFromDataRow();

        if (this.row && this.row.dataRow) {

            // icon Farbe
            if (this.columnConfig.iconColorField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconColorField])) {
               this._iconColor = this.row.dataRow[this.columnConfig.iconColorField];
               this._dom.style.color = this._iconColor;
            }

            // iconMap
            if (this.columnConfig.iconMapField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconMapField])) {
                let value = this.row.dataRow[this.columnConfig.iconMapField];
                this._setDomHtml(value);
            }

            // iconChar
            if (this.columnConfig.iconCharField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconCharField])) {
                let value = this.row.dataRow[this.columnConfig.iconCharField];
                this._setDomHtml(value);
            }

            // CSS-Klasse hinzufügen
            if (this.columnConfig.iconClsField && kijs.isDefined(this.row.dataRow[this.columnConfig.iconClsField])) {
                let cls = this.row.dataRow[this.columnConfig.iconClsField];
                this._addIconCls(cls);
            }

            // Tooltip hinzufügen
            if (this.columnConfig.tooltipField && kijs.isDefined(this.row.dataRow[this.columnConfig.tooltipField])) {
                let tooltip = this.row.dataRow[this.columnConfig.tooltipField];
                this._dom.tooltip = kijs.String.nl2br(kijs.String.htmlspecialchars(tooltip));
            }
        }
    }


    // PROTECTED
    /**
     * Icon Klasse hinzufügen
     * @param val
     * @private
     */
    _addIconCls(val) {
        if (!kijs.isString(val) && val) {
            throw new kijs.Error(`config "iconCls" is not a string`);
        }
        if (this._iconCls) {
            this._dom.clsRemove(this._iconCls);
        }
        this._iconCls = val;
        if (this._iconCls) {
            this._dom.clsAdd(this._iconCls);
        }
    }
    
    /**
     * Icon rendern
     * @param {String|Number} value
     * @returns {undefined}
     */
    _setDomHtml(value) {
        this._originalIcon = value;

        if (kijs.isString(value) && value.substr(0,2) === '&#') {
            value = kijs.String.htmlentities_decode(value).codePointAt(0);
        }

        if (kijs.isString(value) && !isNaN(parseInt(value))) {
            value = parseInt(value);
        }

        if (kijs.isString(value) && value.substr(0, 4) === 'kijs') {
            let iconMap = kijs.getObjectFromString(value);
            if (kijs.isInteger(iconMap.char)) {
                value = iconMap.char;
            }
            if (kijs.isDefined(iconMap.cls)) {
                this._addIconCls(iconMap.cls);
            }
        }

        if (!kijs.isNumber(value)) {
            value = null;
        }

        this._icon = value;
        this._dom.html = kijs.isInteger(value) ? String.fromCodePoint(value) : '';
    }

};
/* global kijs */

// --------------------------------------------------------------
// kijs.gui.grid.filter (namespace)
// --------------------------------------------------------------
kijs.gui.grid.filter = {};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Filter (Abstract)
// --------------------------------------------------------------
kijs.gui.grid.filter.Filter = class kijs_gui_grid_filter_Filter extends kijs.gui.Element {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // DOM type
        this._dom.nodeTagName = 'td';
        this._columnConfig;
        this._filter = {};

        this._checkboxFilterGroup = null;

        this._searchContainer = new kijs.gui.Dom();
        this._removeFilterIcon = new kijs.gui.Dom({
            cls: 'kijs-grid-filter-reset'
        });

        this._menuButton = new kijs.gui.Button({
            parent: this,
            icon2Map: 'kijs.iconMap.Fa.filter', // fa-filter
            menuElements: []
        });


        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            columnConfig: true,
            checkboxFilterValues: { target: 'checkboxFilterValues' }
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get checkboxFilterValues() { return this._checkboxFilterGroup ? this._checkboxFilterGroup.value : []; }
    set checkboxFilterValues(val) {
        // convert data to array
        if (!kijs.isArray(val)) {
            val = [val];
        }
        let data = [];
        kijs.Array.each(val, (arrVal) => {
            if (kijs.isString(arrVal)) {
                data.push({caption: arrVal, value: arrVal});
            } else if (kijs.isObject(arrVal) && kijs.isDefined(arrVal.caption) && kijs.isDefined(arrVal.value)) {
                data.push(arrVal);
            }
        });

        // checkboxgruppe
        if (this._checkboxFilterGroup === null) {
            this._checkboxFilterGroup = new kijs.gui.field.CheckboxGroup({
                cls: 'kijs-filter-checkboxgroup',
                disableFlex: false,
                on: {
                    change: this._applyToGrid,
                    context: this
                }
            });
        }

        // Daten hinzufügen
        this._checkboxFilterGroup.data = data;
    }
    
    get columnConfig() { return this._columnConfig; }
    
    get filter() {
        let flt = {
            type: '',
            valueField: this._columnConfig.valueField
        };
        if (this._checkboxFilterGroup) {
            flt.checkboxFilter = this.checkboxFilterValues;
        }
        return flt;
    }
    
    get isFiltered() { return !!(this.checkboxFilterValues.length > 0); }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    hasFocus() {
        return !!this._menuButton.menu.isRendered;
    }
    
    // Overwrite
    render(superCall) {
        super.render(true);

        this._searchContainer.renderTo(this._dom.node);
        this._removeFilterIcon.renderTo(this._dom.node);

        this._menuButton.menu.removeAll({
            preventRender: true,
            preventDestruct: true
        });
        this._menuButton.menu.add(this._getMenuButtons());
        this._menuButton.renderTo(this._removeFilterIcon.node);

        // breite
        this._dom.width = this._columnConfig.width;

        // sichtbar?
        this.visible = this._columnConfig.visible;

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    reset() {
        // Filter zurücksetzen
        if (this._checkboxFilterGroup !== null) {
            this._checkboxFilterGroup.checkedAll = false;
        }

        // muss in abgeleiteter Klasse überschrieben werden
        this._applyToGrid();
    }

    // overwrite
    unrender(superCall) {
        // Event auslösen.
        if (!superCall) {
            this.raiseEvent('unrender');
        }

        this._searchContainer.unrender();
        this._removeFilterIcon.unrender();

        super.unrender(true);
    }
    
    
    // PROTECTED
    // wendet den Filter auf das grid an.
    _applyToGrid(forceReload=false) {
        this.raiseEvent('filter', {filter: this.filter, forceReload: forceReload});
    }

    _getCheckboxMenuButtons() {
        return this._checkboxFilterGroup !== null ? ['-', this._checkboxFilterGroup] : [];
    }

    _getDefaultMenuButtons() {
        return [
            {
                caption : kijs.getText('Filter löschen'),
                iconMap: 'kijs.iconMap.Fa.filter-circle-xmark',
                on: {
                    click: function() {
                        this.reset();
                        this._menuButton.menu.close();
                    },
                    context: this
                }
            },{
                caption : kijs.getText('Alle Filter löschen'),
                iconMap: 'kijs.iconMap.Fa.filter-circle-xmark',
                on: {
                    click: function() {
                        this.parent.reset();
                        this._menuButton.menu.close();
                    },
                    context: this
                }
            }
        ];
    }

    _getMenuButtons() {
        return kijs.Array.concat(this._getDefaultMenuButtons(), this._getCheckboxMenuButtons());
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        this._searchContainer.destruct();
        this._removeFilterIcon.destruct();

        // Variablen (Objekte/Arrays) leeren
        this._searchContainer = null;
        this._removeFilterIcon = null;

        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Text
// --------------------------------------------------------------
kijs.gui.grid.filter.Text = class kijs_gui_grid_filter_Text extends kijs.gui.grid.filter.Filter {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // compare types
        this._compareTypes = {
            equal: kijs.getText('Ist gleich...'),
            unequal: kijs.getText('Ist nicht gleich...'),
            begin: kijs.getText('Beginnt mit...'),
            end: kijs.getText('Endet mit...'),
            part: kijs.getText('Enthält...'),
            notpart: kijs.getText('Enthält nicht...')
        };

        this._applyFilter = true;
        this._compare = 'begin'; // full, part
        this._searchField = new kijs.gui.field.Text({
            labelHide: true,
            on: {
                change: function() {
                    if (this._applyFilter) {
                        this._applyToGrid();
                    }
                    this._applyFilter = true;
                },
                keyDown: this.#onKeyDown,
                context: this
            }
        });

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            placeholder: kijs.getText('Suche') + '...'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            placeholder: {target: 'placeholder'},
            compare: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'text',
            search: this._searchField.value,
            compare: this._compare
        });
    }

    get isFiltered() { return super.isFiltered || this._searchField.value !== ''; }

    get placeholder() { return this._searchField.placeholder; }
    set placeholder(val) { this._searchField.placeholder = val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    hasFocus() {
        if (super.hasFocus() || this._searchField.hasFocus) {
            return true;
        }

        return false;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        this._searchField.renderTo(this._searchContainer.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }

    reset() {
        this._searchField.value = '';
        super.reset();
    }


    // PROTECTED
    // overwrite
    _getMenuButtons() {
        let compareButtons = [];

        if (this._compare !== false && this._compareTypes) {
            compareButtons.push('-');

            for (const compareType in this._compareTypes) {
                compareButtons.push({
                    name: 'btn_compare_' + compareType,
                    caption : this._compareTypes[compareType],
                    iconMap: this._compare === compareType ? 'kijs.iconMap.Fa.square-check' : 'kijs.iconMap.Fa.square',
                    on: {
                        click: this.#onCompareBtnClick,
                        context: this
                    }
                });
            }
        }

        return kijs.Array.concat(this._getDefaultMenuButtons(),
            compareButtons,
            this._getCheckboxMenuButtons()
        );
    }


    // PRIVATE
    // LISTENERS
    #onCompareBtnClick(e) {
        this._menuButton.menu.close();

        if (e.element.name && e.element.name.substring(0, 'btn_compare_'.length) === 'btn_compare_') {
            this._compare = e.element.name.substring('btn_compare_'.length);
        }

        kijs.Array.each(e.element.parent.elements, function(element) {
            if (element.name === e.element.name) {
                element.iconMap = 'kijs.iconMap.Fa.square-check';

            } else if (element.name && element.name.substr(0, 'btn_compare_'.length) === 'btn_compare_') {
                element.iconMap = 'kijs.iconMap.Fa.square';
            }
        });
    }

    #onKeyDown(e) {
        e.nodeEvent.stopPropagation();
        if (e.nodeEvent.key === 'Enter') {
            e.nodeEvent.preventDefault();
            this._applyToGrid(true);
            this._applyFilter = false;
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen
        if (this._searchField) {
            this._searchField.destruct();
        }

        // Variablen (Objekte/Arrays) leeren
        this._searchField = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Number
// --------------------------------------------------------------
kijs.gui.grid.filter.Number = class kijs_gui_grid_filter_Number extends kijs.gui.grid.filter.Text {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // compare types
        this._compareTypes = {
            equal: kijs.getText('Ist gleich...'),
            unequal: kijs.getText('Ist nicht gleich...'),
            smaller: kijs.getText('Kleiner als...'),
            bigger: kijs.getText('Grösser als...')
        };

        this._compare = 'equal';

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            placeholder: kijs.getText('Filtern') + '...'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            compare: true
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'number',
            search: this._searchField.value,
            compare: this._compare
        });
    }

    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren

        // Basisklasse entladen
        super.destruct(true);
    }

};/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Date
// --------------------------------------------------------------
kijs.gui.grid.filter.Date = class kijs_gui_grid_filter_Date extends kijs.gui.grid.filter.Number {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'date'
        });
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        
        // Basisklasse entladen
        super.destruct(true);
    }

};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Checkbox
// --------------------------------------------------------------
kijs.gui.grid.filter.Checkbox = class kijs_gui_grid_filter_Checkbox extends kijs.gui.grid.filter.Filter {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._checkedType = '';
        this._searchContainer.clsAdd('kijs-icon');
        this._compare = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }
    


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'checkbox',
            checkbox: this._compare
        });
    }

    get isFiltered() { return super.isFiltered || this._compare !== null; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // PROTECTED
    _applyToGrid() {
        if (this._compare === 'checked') {
            this._searchContainer.html = String.fromCharCode(kijs.iconMap.Fa['square-check'].char);
        } else if (this._compare === 'unchecked') {
            this._searchContainer.html = String.fromCharCode(kijs.iconMap.Fa['square'].char);
        } else {
            this._searchContainer.html = '';
        }

        super._applyToGrid();
    }

    // overwrite
    _getMenuButtons() {
        return kijs.Array.concat(this._getDefaultMenuButtons(), ['-',{
            name: 'btn_compare_checked',
            caption : kijs.getText('Alle angewählten'),
            iconMap: 'kijs.iconMap.Fa.square-check', //  fa-square-o
            on: {
                click: this.#onFilterChange,
                context: this
            }
        },{
            caption : kijs.getText('Alle nicht angewählten'),
            name: 'btn_compare_unchecked',
            iconMap: 'kijs.iconMap.Fa.square-check', // fa-square-o
            on: {
                click: this.#onFilterChange,
                context: this
            }
        }]);
    }


    // PRIVATE
    // LISTENERS
    #onFilterChange(e) {
        if (e.element.name === 'btn_compare_checked') {
            this._compare = 'checked';
        } else if (e.element.name === 'btn_compare_unchecked') {
            this._compare = 'unchecked';
        }

        kijs.Array.each(e.element.parent.elements, function(element) {
            if (element.name === e.element.name) {
                element.iconMap = 'kijs.iconMap.Fa.square-check';
            } else if (kijs.Array.contains(['btn_compare_checked', 'btn_compare_unchecked'], element.name)) {
                element.iconMap = 'kijs.iconMap.Fa.square';
            }
        });

        this._applyToGrid();
    }
    
    
    
    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        
        // Variablen (Objekte/Arrays) leeren
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
/* global kijs, this */

// --------------------------------------------------------------
// kijs.gui.grid.filter.Icon
// --------------------------------------------------------------
kijs.gui.grid.filter.Icon = class kijs_gui_grid_filter_Icon extends kijs.gui.grid.filter.Filter {

    
    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._compare = 'begin'; // full, part
        this._searchField = new kijs.gui.field.Text({disabled: true});
        this._checkboxGroup = null;

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            // keine
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            // keine
        });

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        this.parent.grid.on('afterLoad', this.#onAfterLoad, this);
    }
    
    

    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get filter() {
        return Object.assign(super.filter, {
            type: 'icon',
            icons: this._checkboxGroup ? this._checkboxGroup.value : null
        });
    }

    get isFiltered() { return this._checkboxGroup ? this._checkboxGroup.value ? true : false : false; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    render(superCall) {
        super.render(true);

        this._searchField.renderTo(this._searchContainer.node);

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }
    
    reset() {
        if (this._checkboxGroup) {
            this._checkboxGroup.checkedAll = true;
        }
        super.reset();
    }


    // PROTECTED
    _checkIcons() {
        let icons = [];
        let iconsCheck = [];
        let dataCnt = this._checkboxGroup ? this._checkboxGroup.data.length : 0;

        if (dataCnt <= this.columnConfig.iconsCnt) {

            // Alle Zeilen und Zellen vom Grid durchsuchen
            kijs.Array.each(this.parent.grid.rows, function(row) {
                    kijs.Array.each(row.cells, function(cell) {

                        // Überprüfen ob Zelle mit dem iconCharField übereinstimmt
                        if (cell.columnConfig.iconCharField === this.columnConfig.iconCharField){
                            let contains = false;

                            // Überprüfen ob Icon schon in einem der Arrays ist
                            if (icons.length > 0) {
                                kijs.Array.each(icons, function(value){
                                        if (value.id === cell.originalIcon && value.icon === cell.icon && value.color === cell.iconColor && value.caption === cell.caption){
                                            contains = true;
                                        }
                                }, this);
                            }
                            if (this._checkboxGroup && !contains){
                                kijs.Array.each(this._checkboxGroup.data, function(data){
                                    if (data.id === cell.originalIcon && data.icon === cell.icon && data.color === cell.iconColor  && data.caption === cell.caption){
                                        contains = true;
                                    }
                                }, this);
                            }

                            // Icon dem Filter hinzufügen
                            if (!contains){
                                icons.push({id:cell.originalIcon, icon: cell.icon, color: cell.iconColor, caption: cell.caption});
                                iconsCheck.push(cell.originalIcon);
                            }
                        }
                    }, this);
            }, this);
        }
        return [icons, iconsCheck, dataCnt];
    }


    // PRIVATE
    // LISTENERS
    #onAfterLoad(e) {;
        let checkIcons = this._checkIcons();
        let icons = checkIcons[0];
        let iconsCheck = checkIcons[1];
        let dataCnt = checkIcons[2];

        // CheckboxGroup erstellen
        if (this._checkboxGroup === null && dataCnt + icons.length <= this.columnConfig.iconsCnt) {
            this._checkboxGroup = new kijs.gui.field.CheckboxGroup ({
                name: 'icons',
                valueField: 'id',
                iconCharField: 'icon',
                iconColorField: 'color',
                captionField: 'caption',
                data: icons,
                cls: 'kijs-filter-icon-checkboxgroup',
                checkedAll: true,
                on: {
                    change: this.#onFilterChange,
                    context: this
                }
            });
            this._menuButton.menu.add(['-', this._checkboxGroup]);

        } else if (this._checkboxGroup && icons.length > 0 ) {

            // Daten hinzufügen
            if (dataCnt + icons.length <= this.columnConfig.iconsCnt){
                this._checkboxGroup.addData(icons);
                this._checkboxGroup.checkedValues = iconsCheck;

            // CheckboxGroup entfernen
            } else {
                this._menuButton.menu.remove(['-', this._checkboxGroup]);
                this._checkboxGroup = null;
            }
        }
    }

    #onFilterChange() {
       this._applyToGrid();
    }

    #onKeyDown(e) {
        e.nodeEvent.stopPropagation();
        if (e.nodeEvent.key === 'Enter') {
            e.nodeEvent.preventDefault();
            this._applyToGrid();
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }
        
        // Elemente/DOM-Objekte entladen
        if (this._searchField) {
            this._searchField.destruct();
        }
        if (this._checkboxGroup) {
            this._checkboxGroup.destruct();
        }
        
        // Variablen (Objekte/Arrays) leeren
        this._searchField = null;
        this._checkboxGroup = null;
        
        // Basisklasse entladen
        super.destruct(true);
    }
    
};
(function(){function o(n){var i=e;n&&(e[n]||(e[n]={}),i=e[n]);if(!i.define||!i.define.packaged)t.original=i.define,i.define=t,i.define.packaged=!0;if(!i.require||!i.require.packaged)r.original=i.require,i.require=r,i.require.packaged=!0}var ACE_NAMESPACE = "ace",e=function(){return this}();!e&&typeof window!="undefined"&&(e=window);if(!ACE_NAMESPACE&&typeof requirejs!="undefined")return;var t=function(e,n,r){if(typeof e!="string"){t.original?t.original.apply(this,arguments):(console.error("dropping module because define wasn't a string."),console.trace());return}arguments.length==2&&(r=n),t.modules[e]||(t.payloads[e]=r,t.modules[e]=null)};t.modules={},t.payloads={};var n=function(e,t,n){if(typeof t=="string"){var i=s(e,t);if(i!=undefined)return n&&n(),i}else if(Object.prototype.toString.call(t)==="[object Array]"){var o=[];for(var u=0,a=t.length;u<a;++u){var f=s(e,t[u]);if(f==undefined&&r.original)return;o.push(f)}return n&&n.apply(null,o)||!0}},r=function(e,t){var i=n("",e,t);return i==undefined&&r.original?r.original.apply(this,arguments):i},i=function(e,t){if(t.indexOf("!")!==-1){var n=t.split("!");return i(e,n[0])+"!"+i(e,n[1])}if(t.charAt(0)=="."){var r=e.split("/").slice(0,-1).join("/");t=r+"/"+t;while(t.indexOf(".")!==-1&&s!=t){var s=t;t=t.replace(/\/\.\//,"/").replace(/[^\/]+\/\.\.\//,"")}}return t},s=function(e,r){r=i(e,r);var s=t.modules[r];if(!s){s=t.payloads[r];if(typeof s=="function"){var o={},u={id:r,uri:"",exports:o,packaged:!0},a=function(e,t){return n(r,e,t)},f=s(a,o,u);o=f||u.exports,t.modules[r]=o,delete t.payloads[r]}s=t.modules[r]=o||s}return s};o(ACE_NAMESPACE)})(),ace.define("ace/lib/es6-shim",["require","exports","module"],function(e,t,n){function r(e,t,n){Object.defineProperty(e,t,{value:n,enumerable:!1,writable:!0,configurable:!0})}String.prototype.startsWith||r(String.prototype,"startsWith",function(e,t){return t=t||0,this.lastIndexOf(e,t)===t}),String.prototype.endsWith||r(String.prototype,"endsWith",function(e,t){var n=this;if(t===undefined||t>n.length)t=n.length;t-=e.length;var r=n.indexOf(e,t);return r!==-1&&r===t}),String.prototype.repeat||r(String.prototype,"repeat",function(e){var t="",n=this;while(e>0){e&1&&(t+=n);if(e>>=1)n+=n}return t}),String.prototype.includes||r(String.prototype,"includes",function(e,t){return this.indexOf(e,t)!=-1}),Object.assign||(Object.assign=function(e){if(e===undefined||e===null)throw new TypeError("Cannot convert undefined or null to object");var t=Object(e);for(var n=1;n<arguments.length;n++){var r=arguments[n];r!==undefined&&r!==null&&Object.keys(r).forEach(function(e){t[e]=r[e]})}return t}),Object.values||(Object.values=function(e){return Object.keys(e).map(function(t){return e[t]})}),Array.prototype.find||r(Array.prototype,"find",function(e){var t=this.length,n=arguments[1];for(var r=0;r<t;r++){var i=this[r];if(e.call(n,i,r,this))return i}}),Array.prototype.findIndex||r(Array.prototype,"findIndex",function(e){var t=this.length,n=arguments[1];for(var r=0;r<t;r++){var i=this[r];if(e.call(n,i,r,this))return r}}),Array.prototype.includes||r(Array.prototype,"includes",function(e,t){return this.indexOf(e,t)!=-1}),Array.prototype.fill||r(Array.prototype,"fill",function(e){var t=this,n=t.length>>>0,r=arguments[1],i=r>>0,s=i<0?Math.max(n+i,0):Math.min(i,n),o=arguments[2],u=o===undefined?n:o>>0,a=u<0?Math.max(n+u,0):Math.min(u,n);while(s<a)t[s]=e,s++;return t}),Array.of||r(Array,"of",function(){return Array.prototype.slice.call(arguments)})}),ace.define("ace/lib/fixoldbrowsers",["require","exports","module","ace/lib/es6-shim"],function(e,t,n){"use strict";e("./es6-shim")}),ace.define("ace/lib/lang",["require","exports","module"],function(e,t,n){"use strict";t.last=function(e){return e[e.length-1]},t.stringReverse=function(e){return e.split("").reverse().join("")},t.stringRepeat=function(e,t){var n="";while(t>0){t&1&&(n+=e);if(t>>=1)e+=e}return n};var r=/^\s\s*/,i=/\s\s*$/;t.stringTrimLeft=function(e){return e.replace(r,"")},t.stringTrimRight=function(e){return e.replace(i,"")},t.copyObject=function(e){var t={};for(var n in e)t[n]=e[n];return t},t.copyArray=function(e){var t=[];for(var n=0,r=e.length;n<r;n++)e[n]&&typeof e[n]=="object"?t[n]=this.copyObject(e[n]):t[n]=e[n];return t},t.deepCopy=function s(e){if(typeof e!="object"||!e)return e;var t;if(Array.isArray(e)){t=[];for(var n=0;n<e.length;n++)t[n]=s(e[n]);return t}if(Object.prototype.toString.call(e)!=="[object Object]")return e;t={};for(var n in e)t[n]=s(e[n]);return t},t.arrayToMap=function(e){var t={};for(var n=0;n<e.length;n++)t[e[n]]=1;return t},t.createMap=function(e){var t=Object.create(null);for(var n in e)t[n]=e[n];return t},t.arrayRemove=function(e,t){for(var n=0;n<=e.length;n++)t===e[n]&&e.splice(n,1)},t.escapeRegExp=function(e){return e.replace(/([.*+?^${}()|[\]\/\\])/g,"\\$1")},t.escapeHTML=function(e){return(""+e).replace(/&/g,"&#38;").replace(/"/g,"&#34;").replace(/'/g,"&#39;").replace(/</g,"&#60;")},t.getMatchOffsets=function(e,t){var n=[];return e.replace(t,function(e){n.push({offset:arguments[arguments.length-2],length:e.length})}),n},t.deferredCall=function(e){var t=null,n=function(){t=null,e()},r=function(e){return r.cancel(),t=setTimeout(n,e||0),r};return r.schedule=r,r.call=function(){return this.cancel(),e(),r},r.cancel=function(){return clearTimeout(t),t=null,r},r.isPending=function(){return t},r},t.delayedCall=function(e,t){var n=null,r=function(){n=null,e()},i=function(e){n==null&&(n=setTimeout(r,e||t))};return i.delay=function(e){n&&clearTimeout(n),n=setTimeout(r,e||t)},i.schedule=i,i.call=function(){this.cancel(),e()},i.cancel=function(){n&&clearTimeout(n),n=null},i.isPending=function(){return n},i}}),ace.define("ace/lib/useragent",["require","exports","module"],function(e,t,n){"use strict";t.OS={LINUX:"LINUX",MAC:"MAC",WINDOWS:"WINDOWS"},t.getOS=function(){return t.isMac?t.OS.MAC:t.isLinux?t.OS.LINUX:t.OS.WINDOWS};var r=typeof navigator=="object"?navigator:{},i=(/mac|win|linux/i.exec(r.platform)||["other"])[0].toLowerCase(),s=r.userAgent||"",o=r.appName||"";t.isWin=i=="win",t.isMac=i=="mac",t.isLinux=i=="linux",t.isIE=o=="Microsoft Internet Explorer"||o.indexOf("MSAppHost")>=0?parseFloat((s.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]):parseFloat((s.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/)||[])[1]),t.isOldIE=t.isIE&&t.isIE<9,t.isGecko=t.isMozilla=s.match(/ Gecko\/\d+/),t.isOpera=typeof opera=="object"&&Object.prototype.toString.call(window.opera)=="[object Opera]",t.isWebKit=parseFloat(s.split("WebKit/")[1])||undefined,t.isChrome=parseFloat(s.split(" Chrome/")[1])||undefined,t.isEdge=parseFloat(s.split(" Edge/")[1])||undefined,t.isAIR=s.indexOf("AdobeAIR")>=0,t.isAndroid=s.indexOf("Android")>=0,t.isChromeOS=s.indexOf(" CrOS ")>=0,t.isIOS=/iPad|iPhone|iPod/.test(s)&&!window.MSStream,t.isIOS&&(t.isMac=!0),t.isMobile=t.isIOS||t.isAndroid}),ace.define("ace/lib/dom",["require","exports","module","ace/lib/useragent"],function(e,t,n){"use strict";function u(){var e=o;o=null,e&&e.forEach(function(e){a(e[0],e[1])})}function a(e,n,r){if(typeof document=="undefined")return;if(o)if(r)u();else if(r===!1)return o.push([e,n]);if(s)return;var i=r;if(!r||!r.getRootNode)i=document;else{i=r.getRootNode();if(!i||i==r)i=document}var a=i.ownerDocument||i;if(n&&t.hasCssString(n,i))return null;n&&(e+="\n/*# sourceURL=ace/css/"+n+" */");var f=t.createElement("style");f.appendChild(a.createTextNode(e)),n&&(f.id=n),i==a&&(i=t.getDocumentHead(a)),i.insertBefore(f,i.firstChild)}var r=e("./useragent"),i="http://www.w3.org/1999/xhtml";t.buildDom=function l(e,t,n){if(typeof e=="string"&&e){var r=document.createTextNode(e);return t&&t.appendChild(r),r}if(!Array.isArray(e))return e&&e.appendChild&&t&&t.appendChild(e),e;if(typeof e[0]!="string"||!e[0]){var i=[];for(var s=0;s<e.length;s++){var o=l(e[s],t,n);o&&i.push(o)}return i}var u=document.createElement(e[0]),a=e[1],f=1;a&&typeof a=="object"&&!Array.isArray(a)&&(f=2);for(var s=f;s<e.length;s++)l(e[s],u,n);return f==2&&Object.keys(a).forEach(function(e){var t=a[e];e==="class"?u.className=Array.isArray(t)?t.join(" "):t:typeof t=="function"||e=="value"||e[0]=="$"?u[e]=t:e==="ref"?n&&(n[t]=u):e==="style"?typeof t=="string"&&(u.style.cssText=t):t!=null&&u.setAttribute(e,t)}),t&&t.appendChild(u),u},t.getDocumentHead=function(e){return e||(e=document),e.head||e.getElementsByTagName("head")[0]||e.documentElement},t.createElement=function(e,t){return document.createElementNS?document.createElementNS(t||i,e):document.createElement(e)},t.removeChildren=function(e){e.innerHTML=""},t.createTextNode=function(e,t){var n=t?t.ownerDocument:document;return n.createTextNode(e)},t.createFragment=function(e){var t=e?e.ownerDocument:document;return t.createDocumentFragment()},t.hasCssClass=function(e,t){var n=(e.className+"").split(/\s+/g);return n.indexOf(t)!==-1},t.addCssClass=function(e,n){t.hasCssClass(e,n)||(e.className+=" "+n)},t.removeCssClass=function(e,t){var n=e.className.split(/\s+/g);for(;;){var r=n.indexOf(t);if(r==-1)break;n.splice(r,1)}e.className=n.join(" ")},t.toggleCssClass=function(e,t){var n=e.className.split(/\s+/g),r=!0;for(;;){var i=n.indexOf(t);if(i==-1)break;r=!1,n.splice(i,1)}return r&&n.push(t),e.className=n.join(" "),r},t.setCssClass=function(e,n,r){r?t.addCssClass(e,n):t.removeCssClass(e,n)},t.hasCssString=function(e,t){var n=0,r;t=t||document;if(r=t.querySelectorAll("style"))while(n<r.length)if(r[n++].id===e)return!0},t.removeElementById=function(e,t){t=t||document,t.getElementById(e)&&t.getElementById(e).remove()};var s,o=[];t.useStrictCSP=function(e){s=e,e==0?u():o||(o=[])},t.importCssString=a,t.importCssStylsheet=function(e,n){t.buildDom(["link",{rel:"stylesheet",href:e}],t.getDocumentHead(n))},t.scrollbarWidth=function(e){var n=t.createElement("ace_inner");n.style.width="100%",n.style.minWidth="0px",n.style.height="200px",n.style.display="block";var r=t.createElement("ace_outer"),i=r.style;i.position="absolute",i.left="-10000px",i.overflow="hidden",i.width="200px",i.minWidth="0px",i.height="150px",i.display="block",r.appendChild(n);var s=e&&e.documentElement||document&&document.documentElement;if(!s)return 0;s.appendChild(r);var o=n.offsetWidth;i.overflow="scroll";var u=n.offsetWidth;return o===u&&(u=r.clientWidth),s.removeChild(r),o-u},t.computedStyle=function(e,t){return window.getComputedStyle(e,"")||{}},t.setStyle=function(e,t,n){e[t]!==n&&(e[t]=n)},t.HAS_CSS_ANIMATION=!1,t.HAS_CSS_TRANSFORMS=!1,t.HI_DPI=r.isWin?typeof window!="undefined"&&window.devicePixelRatio>=1.5:!0,r.isChromeOS&&(t.HI_DPI=!1);if(typeof document!="undefined"){var f=document.createElement("div");t.HI_DPI&&f.style.transform!==undefined&&(t.HAS_CSS_TRANSFORMS=!0),!r.isEdge&&typeof f.style.animationName!="undefined"&&(t.HAS_CSS_ANIMATION=!0),f=null}t.HAS_CSS_TRANSFORMS?t.translate=function(e,t,n){e.style.transform="translate("+Math.round(t)+"px, "+Math.round(n)+"px)"}:t.translate=function(e,t,n){e.style.top=Math.round(n)+"px",e.style.left=Math.round(t)+"px"}}),ace.define("ace/lib/net",["require","exports","module","ace/lib/dom"],function(e,t,n){"use strict";var r=e("./dom");t.get=function(e,t){var n=new XMLHttpRequest;n.open("GET",e,!0),n.onreadystatechange=function(){n.readyState===4&&t(n.responseText)},n.send(null)},t.loadScript=function(e,t){var n=r.getDocumentHead(),i=document.createElement("script");i.src=e,n.appendChild(i),i.onload=i.onreadystatechange=function(e,n){if(n||!i.readyState||i.readyState=="loaded"||i.readyState=="complete")i=i.onload=i.onreadystatechange=null,n||t()}},t.qualifyURL=function(e){var t=document.createElement("a");return t.href=e,t.href}}),ace.define("ace/lib/oop",["require","exports","module"],function(e,t,n){"use strict";t.inherits=function(e,t){e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}})},t.mixin=function(e,t){for(var n in t)e[n]=t[n];return e},t.implement=function(e,n){t.mixin(e,n)}}),ace.define("ace/lib/event_emitter",["require","exports","module"],function(e,t,n){"use strict";var r={},i=function(){this.propagationStopped=!0},s=function(){this.defaultPrevented=!0};r._emit=r._dispatchEvent=function(e,t){this._eventRegistry||(this._eventRegistry={}),this._defaultHandlers||(this._defaultHandlers={});var n=this._eventRegistry[e]||[],r=this._defaultHandlers[e];if(!n.length&&!r)return;if(typeof t!="object"||!t)t={};t.type||(t.type=e),t.stopPropagation||(t.stopPropagation=i),t.preventDefault||(t.preventDefault=s),n=n.slice();for(var o=0;o<n.length;o++){n[o](t,this);if(t.propagationStopped)break}if(r&&!t.defaultPrevented)return r(t,this)},r._signal=function(e,t){var n=(this._eventRegistry||{})[e];if(!n)return;n=n.slice();for(var r=0;r<n.length;r++)n[r](t,this)},r.once=function(e,t){var n=this;this.on(e,function r(){n.off(e,r),t.apply(null,arguments)});if(!t)return new Promise(function(e){t=e})},r.setDefaultHandler=function(e,t){var n=this._defaultHandlers;n||(n=this._defaultHandlers={_disabled_:{}});if(n[e]){var r=n[e],i=n._disabled_[e];i||(n._disabled_[e]=i=[]),i.push(r);var s=i.indexOf(t);s!=-1&&i.splice(s,1)}n[e]=t},r.removeDefaultHandler=function(e,t){var n=this._defaultHandlers;if(!n)return;var r=n._disabled_[e];if(n[e]==t)r&&this.setDefaultHandler(e,r.pop());else if(r){var i=r.indexOf(t);i!=-1&&r.splice(i,1)}},r.on=r.addEventListener=function(e,t,n){this._eventRegistry=this._eventRegistry||{};var r=this._eventRegistry[e];return r||(r=this._eventRegistry[e]=[]),r.indexOf(t)==-1&&r[n?"unshift":"push"](t),t},r.off=r.removeListener=r.removeEventListener=function(e,t){this._eventRegistry=this._eventRegistry||{};var n=this._eventRegistry[e];if(!n)return;var r=n.indexOf(t);r!==-1&&n.splice(r,1)},r.removeAllListeners=function(e){e||(this._eventRegistry=this._defaultHandlers=undefined),this._eventRegistry&&(this._eventRegistry[e]=undefined),this._defaultHandlers&&(this._defaultHandlers[e]=undefined)},t.EventEmitter=r}),ace.define("ace/lib/app_config",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){"no use strict";function o(e){typeof console!="undefined"&&console.warn&&console.warn.apply(console,arguments)}function u(e,t){var n=new Error(e);n.data=t,typeof console=="object"&&console.error&&console.error(n),setTimeout(function(){throw n})}var r=e("./oop"),i=e("./event_emitter").EventEmitter,s={setOptions:function(e){Object.keys(e).forEach(function(t){this.setOption(t,e[t])},this)},getOptions:function(e){var t={};if(!e){var n=this.$options;e=Object.keys(n).filter(function(e){return!n[e].hidden})}else Array.isArray(e)||(t=e,e=Object.keys(t));return e.forEach(function(e){t[e]=this.getOption(e)},this),t},setOption:function(e,t){if(this["$"+e]===t)return;var n=this.$options[e];if(!n)return o('misspelled option "'+e+'"');if(n.forwardTo)return this[n.forwardTo]&&this[n.forwardTo].setOption(e,t);n.handlesSet||(this["$"+e]=t),n&&n.set&&n.set.call(this,t)},getOption:function(e){var t=this.$options[e];return t?t.forwardTo?this[t.forwardTo]&&this[t.forwardTo].getOption(e):t&&t.get?t.get.call(this):this["$"+e]:o('misspelled option "'+e+'"')}},a=function(){function e(){this.$defaultOptions={}}return e.prototype.defineOptions=function(e,t,n){return e.$options||(this.$defaultOptions[t]=e.$options={}),Object.keys(n).forEach(function(t){var r=n[t];typeof r=="string"&&(r={forwardTo:r}),r.name||(r.name=t),e.$options[r.name]=r,"initialValue"in r&&(e["$"+r.name]=r.initialValue)}),r.implement(e,s),this},e.prototype.resetOptions=function(e){Object.keys(e.$options).forEach(function(t){var n=e.$options[t];"value"in n&&e.setOption(t,n.value)})},e.prototype.setDefaultValue=function(e,t,n){if(!e){for(e in this.$defaultOptions)if(this.$defaultOptions[e][t])break;if(!this.$defaultOptions[e][t])return!1}var r=this.$defaultOptions[e]||(this.$defaultOptions[e]={});r[t]&&(r.forwardTo?this.setDefaultValue(r.forwardTo,t,n):r[t].value=n)},e.prototype.setDefaultValues=function(e,t){Object.keys(t).forEach(function(n){this.setDefaultValue(e,n,t[n])},this)},e}();a.prototype.warn=o,a.prototype.reportError=u,r.implement(a.prototype,i),t.AppConfig=a}),ace.define("ace/theme/textmate.css",["require","exports","module"],function(e,t,n){n.exports='.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n'}),ace.define("ace/theme/textmate",["require","exports","module","ace/theme/textmate.css","ace/lib/dom"],function(e,t,n){"use strict";t.isDark=!1,t.cssClass="ace-tm",t.cssText=e("./textmate.css"),t.$id="ace/theme/textmate";var r=e("../lib/dom");r.importCssString(t.cssText,t.cssClass,!1)}),ace.define("ace/config",["require","exports","module","ace/lib/lang","ace/lib/net","ace/lib/dom","ace/lib/app_config","ace/theme/textmate"],function(e,t,n){"no use strict";var r=e("./lib/lang"),i=e("./lib/net"),s=e("./lib/dom"),o=e("./lib/app_config").AppConfig;n.exports=t=new o;var u={packaged:!1,workerPath:null,modePath:null,themePath:null,basePath:"",suffix:".js",$moduleUrls:{},loadWorkerFromBlob:!0,sharedPopups:!1,useStrictCSP:null};t.get=function(e){if(!u.hasOwnProperty(e))throw new Error("Unknown config key: "+e);return u[e]},t.set=function(e,t){if(u.hasOwnProperty(e))u[e]=t;else if(this.setDefaultValue("",e,t)==0)throw new Error("Unknown config key: "+e);e=="useStrictCSP"&&s.useStrictCSP(t)},t.all=function(){return r.copyObject(u)},t.$modes={},t.moduleUrl=function(e,t){if(u.$moduleUrls[e])return u.$moduleUrls[e];var n=e.split("/");t=t||n[n.length-2]||"";var r=t=="snippets"?"/":"-",i=n[n.length-1];if(t=="worker"&&r=="-"){var s=new RegExp("^"+t+"[\\-_]|[\\-_]"+t+"$","g");i=i.replace(s,"")}(!i||i==t)&&n.length>1&&(i=n[n.length-2]);var o=u[t+"Path"];return o==null?o=u.basePath:r=="/"&&(t=r=""),o&&o.slice(-1)!="/"&&(o+="/"),o+t+r+i+this.get("suffix")},t.setModuleUrl=function(e,t){return u.$moduleUrls[e]=t};var a=function(t,n){return t==="ace/theme/textmate"||t==="./theme/textmate"?n(null,e("./theme/textmate")):console.error("loader is not configured")};t.setLoader=function(e){a=e},t.dynamicModules=Object.create(null),t.$loading={},t.loadModule=function(n,r){var s,o;Array.isArray(n)&&(o=n[0],n=n[1]);var u=function(e){if(e&&!t.$loading[n])return r&&r(e);t.$loading[n]||(t.$loading[n]=[]),t.$loading[n].push(r);if(t.$loading[n].length>1)return;var s=function(){a(n,function(e,r){t._emit("load.module",{name:n,module:r});var i=t.$loading[n];t.$loading[n]=null,i.forEach(function(e){e&&e(r)})})};if(!t.get("packaged"))return s();i.loadScript(t.moduleUrl(n,o),s),f()};if(t.dynamicModules[n])t.dynamicModules[n]().then(function(e){e.default?u(e.default):u(e)});else{try{s=e(n)}catch(l){}u(s)}},t.setModuleLoader=function(e,n){t.dynamicModules[e]=n};var f=function(){!u.basePath&&!u.workerPath&&!u.modePath&&!u.themePath&&!Object.keys(u.$moduleUrls).length&&(console.error("Unable to infer path to ace from script src,","use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes","or with webpack use ace/webpack-resolver"),f=function(){})};t.version="1.18.0"}),ace.define("ace/loader_build",["require","exports","module","ace/lib/fixoldbrowsers","ace/config"],function(e,t,n){"use strict";function s(t){if(!i||!i.document)return;r.set("packaged",t||e.packaged||n.packaged||i.define&&define.packaged);var s={},u="",a=document.currentScript||document._currentScript,f=a&&a.ownerDocument||document;a&&a.src&&(u=a.src.split(/[?#]/)[0].split("/").slice(0,-1).join("/")||"");var l=f.getElementsByTagName("script");for(var c=0;c<l.length;c++){var h=l[c],p=h.src||h.getAttribute("src");if(!p)continue;var d=h.attributes;for(var v=0,m=d.length;v<m;v++){var g=d[v];g.name.indexOf("data-ace-")===0&&(s[o(g.name.replace(/^data-ace-/,""))]=g.value)}var y=p.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);y&&(u=y[1])}u&&(s.base=s.base||u,s.packaged=!0),s.basePath=s.base,s.workerPath=s.workerPath||s.base,s.modePath=s.modePath||s.base,s.themePath=s.themePath||s.base,delete s.base;for(var b in s)typeof s[b]!="undefined"&&r.set(b,s[b])}function o(e){return e.replace(/-(.)/g,function(e,t){return t.toUpperCase()})}e("./lib/fixoldbrowsers");var r=e("./config");r.setLoader(function(t,n){e([t],function(e){n(null,e)})});var i=function(){return this||typeof window!="undefined"&&window}();n.exports=function(t){r.init=s,t.require=e,typeof define=="function"&&(t.define=define)}}),ace.define("ace/range",["require","exports","module"],function(e,t,n){"use strict";var r=function(e,t){return e.row-t.row||e.column-t.column},i=function(){function e(e,t,n,r){this.start={row:e,column:t},this.end={row:n,column:r}}return e.prototype.isEqual=function(e){return this.start.row===e.start.row&&this.end.row===e.end.row&&this.start.column===e.start.column&&this.end.column===e.end.column},e.prototype.toString=function(){return"Range: ["+this.start.row+"/"+this.start.column+"] -> ["+this.end.row+"/"+this.end.column+"]"},e.prototype.contains=function(e,t){return this.compare(e,t)==0},e.prototype.compareRange=function(e){var t,n=e.end,r=e.start;return t=this.compare(n.row,n.column),t==1?(t=this.compare(r.row,r.column),t==1?2:t==0?1:0):t==-1?-2:(t=this.compare(r.row,r.column),t==-1?-1:t==1?42:0)},e.prototype.comparePoint=function(e){return this.compare(e.row,e.column)},e.prototype.containsRange=function(e){return this.comparePoint(e.start)==0&&this.comparePoint(e.end)==0},e.prototype.intersects=function(e){var t=this.compareRange(e);return t==-1||t==0||t==1},e.prototype.isEnd=function(e,t){return this.end.row==e&&this.end.column==t},e.prototype.isStart=function(e,t){return this.start.row==e&&this.start.column==t},e.prototype.setStart=function(e,t){typeof e=="object"?(this.start.column=e.column,this.start.row=e.row):(this.start.row=e,this.start.column=t)},e.prototype.setEnd=function(e,t){typeof e=="object"?(this.end.column=e.column,this.end.row=e.row):(this.end.row=e,this.end.column=t)},e.prototype.inside=function(e,t){return this.compare(e,t)==0?this.isEnd(e,t)||this.isStart(e,t)?!1:!0:!1},e.prototype.insideStart=function(e,t){return this.compare(e,t)==0?this.isEnd(e,t)?!1:!0:!1},e.prototype.insideEnd=function(e,t){return this.compare(e,t)==0?this.isStart(e,t)?!1:!0:!1},e.prototype.compare=function(e,t){return!this.isMultiLine()&&e===this.start.row?t<this.start.column?-1:t>this.end.column?1:0:e<this.start.row?-1:e>this.end.row?1:this.start.row===e?t>=this.start.column?0:-1:this.end.row===e?t<=this.end.column?0:1:0},e.prototype.compareStart=function(e,t){return this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},e.prototype.compareEnd=function(e,t){return this.end.row==e&&this.end.column==t?1:this.compare(e,t)},e.prototype.compareInside=function(e,t){return this.end.row==e&&this.end.column==t?1:this.start.row==e&&this.start.column==t?-1:this.compare(e,t)},e.prototype.clipRows=function(t,n){if(this.end.row>n)var r={row:n+1,column:0};else if(this.end.row<t)var r={row:t,column:0};if(this.start.row>n)var i={row:n+1,column:0};else if(this.start.row<t)var i={row:t,column:0};return e.fromPoints(i||this.start,r||this.end)},e.prototype.extend=function(t,n){var r=this.compare(t,n);if(r==0)return this;if(r==-1)var i={row:t,column:n};else var s={row:t,column:n};return e.fromPoints(i||this.start,s||this.end)},e.prototype.isEmpty=function(){return this.start.row===this.end.row&&this.start.column===this.end.column},e.prototype.isMultiLine=function(){return this.start.row!==this.end.row},e.prototype.clone=function(){return e.fromPoints(this.start,this.end)},e.prototype.collapseRows=function(){return this.end.column==0?new e(this.start.row,0,Math.max(this.start.row,this.end.row-1),0):new e(this.start.row,0,this.end.row,0)},e.prototype.toScreenRange=function(t){var n=t.documentToScreenPosition(this.start),r=t.documentToScreenPosition(this.end);return new e(n.row,n.column,r.row,r.column)},e.prototype.moveBy=function(e,t){this.start.row+=e,this.start.column+=t,this.end.row+=e,this.end.column+=t},e}();i.fromPoints=function(e,t){return new i(e.row,e.column,t.row,t.column)},i.comparePoints=r,i.comparePoints=function(e,t){return e.row-t.row||e.column-t.column},t.Range=i}),ace.define("ace/lib/keys",["require","exports","module","ace/lib/oop"],function(e,t,n){"use strict";var r=e("./oop"),i=function(){var e={MODIFIER_KEYS:{16:"Shift",17:"Ctrl",18:"Alt",224:"Meta",91:"MetaLeft",92:"MetaRight",93:"ContextMenu"},KEY_MODS:{ctrl:1,alt:2,option:2,shift:4,"super":8,meta:8,command:8,cmd:8,control:1},FUNCTION_KEYS:{8:"Backspace",9:"Tab",13:"Return",19:"Pause",27:"Esc",32:"Space",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"Left",38:"Up",39:"Right",40:"Down",44:"Print",45:"Insert",46:"Delete",96:"Numpad0",97:"Numpad1",98:"Numpad2",99:"Numpad3",100:"Numpad4",101:"Numpad5",102:"Numpad6",103:"Numpad7",104:"Numpad8",105:"Numpad9","-13":"NumpadEnter",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"Numlock",145:"Scrolllock"},PRINTABLE_KEYS:{32:" ",48:"0",49:"1",50:"2",51:"3",52:"4",53:"5",54:"6",55:"7",56:"8",57:"9",59:";",61:"=",65:"a",66:"b",67:"c",68:"d",69:"e",70:"f",71:"g",72:"h",73:"i",74:"j",75:"k",76:"l",77:"m",78:"n",79:"o",80:"p",81:"q",82:"r",83:"s",84:"t",85:"u",86:"v",87:"w",88:"x",89:"y",90:"z",107:"+",109:"-",110:".",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'",111:"/",106:"*"}};e.PRINTABLE_KEYS[173]="-";var t,n;for(n in e.FUNCTION_KEYS)t=e.FUNCTION_KEYS[n].toLowerCase(),e[t]=parseInt(n,10);for(n in e.PRINTABLE_KEYS)t=e.PRINTABLE_KEYS[n].toLowerCase(),e[t]=parseInt(n,10);return r.mixin(e,e.MODIFIER_KEYS),r.mixin(e,e.PRINTABLE_KEYS),r.mixin(e,e.FUNCTION_KEYS),e.enter=e["return"],e.escape=e.esc,e.del=e["delete"],function(){var t=["cmd","ctrl","alt","shift"];for(var n=Math.pow(2,t.length);n--;)e.KEY_MODS[n]=t.filter(function(t){return n&e.KEY_MODS[t]}).join("-")+"-"}(),e.KEY_MODS[0]="",e.KEY_MODS[-1]="input-",e}();r.mixin(t,i),t.keyCodeToString=function(e){var t=i[e];return typeof t!="string"&&(t=String.fromCharCode(e)),t.toLowerCase()}}),ace.define("ace/lib/event",["require","exports","module","ace/lib/keys","ace/lib/useragent"],function(e,t,n){"use strict";function a(){u=!1;try{document.createComment("").addEventListener("test",function(){},{get passive(){u={passive:!1}}})}catch(e){}}function f(){return u==undefined&&a(),u}function l(e,t,n){this.elem=e,this.type=t,this.callback=n}function d(e,t,n){var u=p(t);if(!i.isMac&&s){t.getModifierState&&(t.getModifierState("OS")||t.getModifierState("Win"))&&(u|=8);if(s.altGr){if((3&u)==3)return;s.altGr=0}if(n===18||n===17){var a="location"in t?t.location:t.keyLocation;if(n===17&&a===1)s[n]==1&&(o=t.timeStamp);else if(n===18&&u===3&&a===2){var f=t.timeStamp-o;f<50&&(s.altGr=!0)}}}n in r.MODIFIER_KEYS&&(n=-1);if(!u&&n===13){var a="location"in t?t.location:t.keyLocation;if(a===3){e(t,u,-n);if(t.defaultPrevented)return}}if(i.isChromeOS&&u&8){e(t,u,n);if(t.defaultPrevented)return;u&=-9}return!!u||n in r.FUNCTION_KEYS||n in r.PRINTABLE_KEYS?e(t,u,n):!1}function v(){s=Object.create(null)}var r=e("./keys"),i=e("./useragent"),s=null,o=0,u;l.prototype.destroy=function(){h(this.elem,this.type,this.callback),this.elem=this.type=this.callback=undefined};var c=t.addListener=function(e,t,n,r){e.addEventListener(t,n,f()),r&&r.$toDestroy.push(new l(e,t,n))},h=t.removeListener=function(e,t,n){e.removeEventListener(t,n,f())};t.stopEvent=function(e){return t.stopPropagation(e),t.preventDefault(e),!1},t.stopPropagation=function(e){e.stopPropagation&&e.stopPropagation()},t.preventDefault=function(e){e.preventDefault&&e.preventDefault()},t.getButton=function(e){return e.type=="dblclick"?0:e.type=="contextmenu"||i.isMac&&e.ctrlKey&&!e.altKey&&!e.shiftKey?2:e.button},t.capture=function(e,t,n){function i(e){t&&t(e),n&&n(e),h(r,"mousemove",t),h(r,"mouseup",i),h(r,"dragstart",i)}var r=e&&e.ownerDocument||document;return c(r,"mousemove",t),c(r,"mouseup",i),c(r,"dragstart",i),i},t.addMouseWheelListener=function(e,t,n){c(e,"wheel",function(e){var n=.15,r=e.deltaX||0,i=e.deltaY||0;switch(e.deltaMode){case e.DOM_DELTA_PIXEL:e.wheelX=r*n,e.wheelY=i*n;break;case e.DOM_DELTA_LINE:var s=15;e.wheelX=r*s,e.wheelY=i*s;break;case e.DOM_DELTA_PAGE:var o=150;e.wheelX=r*o,e.wheelY=i*o}t(e)},n)},t.addMultiMouseDownListener=function(e,n,r,s,o){function p(e){t.getButton(e)!==0?u=0:e.detail>1?(u++,u>4&&(u=1)):u=1;if(i.isIE){var o=Math.abs(e.clientX-a)>5||Math.abs(e.clientY-f)>5;if(!l||o)u=1;l&&clearTimeout(l),l=setTimeout(function(){l=null},n[u-1]||600),u==1&&(a=e.clientX,f=e.clientY)}e._clicks=u,r[s]("mousedown",e);if(u>4)u=0;else if(u>1)return r[s](h[u],e)}var u=0,a,f,l,h={2:"dblclick",3:"tripleclick",4:"quadclick"};Array.isArray(e)||(e=[e]),e.forEach(function(e){c(e,"mousedown",p,o)})};var p=function(e){return 0|(e.ctrlKey?1:0)|(e.altKey?2:0)|(e.shiftKey?4:0)|(e.metaKey?8:0)};t.getModifierString=function(e){return r.KEY_MODS[p(e)]},t.addCommandKeyListener=function(e,n,r){if(i.isOldGecko||i.isOpera&&!("KeyboardEvent"in window)){var o=null;c(e,"keydown",function(e){o=e.keyCode},r),c(e,"keypress",function(e){return d(n,e,o)},r)}else{var u=null;c(e,"keydown",function(e){s[e.keyCode]=(s[e.keyCode]||0)+1;var t=d(n,e,e.keyCode);return u=e.defaultPrevented,t},r),c(e,"keypress",function(e){u&&(e.ctrlKey||e.altKey||e.shiftKey||e.metaKey)&&(t.stopEvent(e),u=null)},r),c(e,"keyup",function(e){s[e.keyCode]=null},r),s||(v(),c(window,"focus",v))}};if(typeof window=="object"&&window.postMessage&&!i.isOldIE){var m=1;t.nextTick=function(e,n){n=n||window;var r="zero-timeout-message-"+m++,i=function(s){s.data==r&&(t.stopPropagation(s),h(n,"message",i),e())};c(n,"message",i),n.postMessage(r,"*")}}t.$idleBlocked=!1,t.onIdle=function(e,n){return setTimeout(function r(){t.$idleBlocked?setTimeout(r,100):e()},n)},t.$idleBlockId=null,t.blockIdle=function(e){t.$idleBlockId&&clearTimeout(t.$idleBlockId),t.$idleBlocked=!0,t.$idleBlockId=setTimeout(function(){t.$idleBlocked=!1},e||100)},t.nextFrame=typeof window=="object"&&(window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame||window.oRequestAnimationFrame),t.nextFrame?t.nextFrame=t.nextFrame.bind(window):t.nextFrame=function(e){setTimeout(e,17)}}),ace.define("ace/clipboard",["require","exports","module"],function(e,t,n){"use strict";var r;n.exports={lineMode:!1,pasteCancelled:function(){return r&&r>Date.now()-50?!0:r=!1},cancel:function(){r=Date.now()}}}),ace.define("ace/keyboard/textinput",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/lib/dom","ace/lib/lang","ace/clipboard","ace/lib/keys"],function(e,t,n){"use strict";var r=e("../lib/event"),i=e("../lib/useragent"),s=e("../lib/dom"),o=e("../lib/lang"),u=e("../clipboard"),a=i.isChrome<18,f=i.isIE,l=i.isChrome>63,c=400,h=e("../lib/keys"),p=h.KEY_MODS,d=i.isIOS,v=d?/\s/:/\n/,m=i.isMobile,g=function(e,t){function D(e){(!n||!n.parentNode)&&document.removeEventListener("selectionchange",D);if(b)return;if(n.selectionStart!==n.selectionEnd)return;var r=n.selectionStart-N,i=C-N;r>0?r=Math.max(r-i,1):r===0&&i&&(r=-1);var s=Math.abs(r),o=r>0?h.right:h.left;for(var u=0;u<s;u++)t.onCommandKey({},0,o)}function V(){x=!0,n.blur(),n.focus(),x=!1}function J(e){e.keyCode==27&&n.value.length<n.selectionStart&&(b||(T=n.value),N=C=-1,O()),$()}function Q(){clearTimeout(K),K=setTimeout(function(){E&&(n.style.cssText=E,E=""),t.renderer.$isMousePressed=!1,t.renderer.$keepTextAreaAtCursor&&t.renderer.$moveTextAreaToCursor()},0)}function Y(e,t,n){var r=null,i=!1;n.addEventListener("keydown",function(e){r&&clearTimeout(r),i=!0},!0),n.addEventListener("keyup",function(e){r=setTimeout(function(){i=!1},100)},!0);var s=function(e){if(document.activeElement!==n)return;if(i||b||t.$mouseHandler.isMousePressed)return;if(g)return;var r=n.selectionStart,s=n.selectionEnd,o=null,u=0;if(r==0)o=h.up;else if(r==1)o=h.home;else if(s>C&&T[s]=="\n")o=h.end;else if(r<N&&T[r-1]==" ")o=h.left,u=p.option;else if(r<N||r==N&&C!=N&&r==s)o=h.left;else if(s>C&&T.slice(0,s).split("\n").length>2)o=h.down;else if(s>C&&T[s-1]==" ")o=h.right,u=p.option;else if(s>C||s==C&&C!=N&&r==s)o=h.right;r!==s&&(u|=p.shift);if(o){var a=t.onCommandKey({},u,o);if(!a&&t.commands){o=h.keyCodeToString(o);var f=t.commands.findKeyCommand(u,o);f&&t.execCommand(f)}N=r,C=s,O("")}};document.addEventListener("selectionchange",s),t.on("destroy",function(){document.removeEventListener("selectionchange",s)})}var n=s.createElement("textarea");n.className="ace_text-input",n.setAttribute("wrap","off"),n.setAttribute("autocorrect","off"),n.setAttribute("autocapitalize","off"),n.setAttribute("spellcheck",!1),n.style.opacity="0",e.insertBefore(n,e.firstChild);var g=!1,y=!1,b=!1,w=!1,E="";m||(n.style.fontSize="1px");var S=!1,x=!1,T="",N=0,C=0,k=0;try{var L=document.activeElement===n}catch(A){}this.setAriaOptions=function(e){e.activeDescendant?(n.setAttribute("aria-haspopup","true"),n.setAttribute("aria-autocomplete",e.inline?"both":"list"),n.setAttribute("aria-activedescendant",e.activeDescendant)):(n.setAttribute("aria-haspopup","false"),n.setAttribute("aria-autocomplete","both"),n.removeAttribute("aria-activedescendant")),e.role&&n.setAttribute("role",e.role)},this.setAriaOptions({role:"textbox"}),r.addListener(n,"blur",function(e){if(x)return;t.onBlur(e),L=!1,m&&!d&&document.removeEventListener("selectionchange",D)},t),r.addListener(n,"focus",function(e){if(x)return;L=!0;if(i.isEdge)try{if(!document.hasFocus())return}catch(e){}t.onFocus(e),i.isEdge?setTimeout(O):O(),m&&!d&&document.addEventListener("selectionchange",D)},t),this.$focusScroll=!1,this.focus=function(){if(E||l||this.$focusScroll=="browser")return n.focus({preventScroll:!0});var e=n.style.top;n.style.position="fixed",n.style.top="0px";try{var t=n.getBoundingClientRect().top!=0}catch(r){return}var i=[];if(t){var s=n.parentElement;while(s&&s.nodeType==1)i.push(s),s.setAttribute("ace_nocontext",!0),!s.parentElement&&s.getRootNode?s=s.getRootNode().host:s=s.parentElement}n.focus({preventScroll:!0}),t&&i.forEach(function(e){e.removeAttribute("ace_nocontext")}),setTimeout(function(){n.style.position="",n.style.top=="0px"&&(n.style.top=e)},0)},this.blur=function(){n.blur()},this.isFocused=function(){return L},t.on("beforeEndOperation",function(){var e=t.curOp,r=e&&e.command&&e.command.name;if(r=="insertstring")return;var i=r&&(e.docChanged||e.selectionChanged);b&&i&&(T=n.value="",X()),O()});var O=d?function(e){if(!L||g&&!e||w)return;e||(e="");var r="\n ab"+e+"cde fg\n";r!=n.value&&(n.value=T=r);var i=4,s=4+(e.length||(t.selection.isEmpty()?0:1));(N!=i||C!=s)&&n.setSelectionRange(i,s),N=i,C=s}:function(){if(b||w)return;if(!L&&!H)return;b=!0;var e=0,r=0,i="";if(t.session){var s=t.selection,o=s.getRange(),u=s.cursor.row;e=o.start.column,r=o.end.column,i=t.session.getLine(u);if(o.start.row!=u){var a=t.session.getLine(u-1);e=o.start.row<u-1?0:e,r+=a.length+1,i=a+"\n"+i}else if(o.end.row!=u){var f=t.session.getLine(u+1);r=o.end.row>u+1?f.length:r,r+=i.length+1,i=i+"\n"+f}else m&&u>0&&(i="\n"+i,r+=1,e+=1);i.length>c&&(e<c&&r<c?i=i.slice(0,c):(i="\n",e==r?e=r=0:(e=0,r=1)))}var l=i+"\n\n";l!=T&&(n.value=T=l,N=C=l.length),H&&(N=n.selectionStart,C=n.selectionEnd);if(C!=r||N!=e||n.selectionEnd!=C)try{n.setSelectionRange(e,r),N=e,C=r}catch(h){}b=!1};this.resetSelection=O,L&&t.onFocus();var M=function(e){return e.selectionStart===0&&e.selectionEnd>=T.length&&e.value===T&&T&&e.selectionEnd!==C},_=function(e){if(b)return;g?g=!1:M(n)?(t.selectAll(),O()):m&&n.selectionStart!=N&&O()},P=null;this.setInputHandler=function(e){P=e},this.getInputHandler=function(){return P};var H=!1,B=function(e,r){H&&(H=!1);if(y)return O(),e&&t.onPaste(e),y=!1,"";var s=n.selectionStart,o=n.selectionEnd,u=N,a=T.length-C,f=e,l=e.length-s,c=e.length-o,h=0;while(u>0&&T[h]==e[h])h++,u--;f=f.slice(h),h=1;while(a>0&&T.length-h>N-1&&T[T.length-h]==e[e.length-h])h++,a--;l-=h-1,c-=h-1;var p=f.length-h+1;p<0&&(u=-p,p=0),f=f.slice(0,p);if(!r&&!f&&!l&&!u&&!a&&!c)return"";w=!0;var d=!1;return i.isAndroid&&f==". "&&(f="  ",d=!0),f&&!u&&!a&&!l&&!c||S?t.onTextInput(f):t.onTextInput(f,{extendLeft:u,extendRight:a,restoreStart:l,restoreEnd:c}),w=!1,T=e,N=s,C=o,k=c,d?"\n":f},j=function(e){if(b)return W();if(e&&e.inputType){if(e.inputType=="historyUndo")return t.execCommand("undo");if(e.inputType=="historyRedo")return t.execCommand("redo")}var r=n.value,i=B(r,!0);(r.length>c+100||v.test(i)||m&&N<1&&N==C)&&O()},F=function(e,t,n){var r=e.clipboardData||window.clipboardData;if(!r||a)return;var i=f||n?"Text":"text/plain";try{return t?r.setData(i,t)!==!1:r.getData(i)}catch(e){if(!n)return F(e,t,!0)}},I=function(e,i){var s=t.getCopyText();if(!s)return r.preventDefault(e);F(e,s)?(d&&(O(s),g=s,setTimeout(function(){g=!1},10)),i?t.onCut():t.onCopy(),r.preventDefault(e)):(g=!0,n.value=s,n.select(),setTimeout(function(){g=!1,O(),i?t.onCut():t.onCopy()}))},q=function(e){I(e,!0)},R=function(e){I(e,!1)},U=function(e){var s=F(e);if(u.pasteCancelled())return;typeof s=="string"?(s&&t.onPaste(s,e),i.isIE&&setTimeout(O),r.preventDefault(e)):(n.value="",y=!0)};r.addCommandKeyListener(n,t.onCommandKey.bind(t),t),r.addListener(n,"select",_,t),r.addListener(n,"input",j,t),r.addListener(n,"cut",q,t),r.addListener(n,"copy",R,t),r.addListener(n,"paste",U,t),(!("oncut"in n)||!("oncopy"in n)||!("onpaste"in n))&&r.addListener(e,"keydown",function(e){if(i.isMac&&!e.metaKey||!e.ctrlKey)return;switch(e.keyCode){case 67:R(e);break;case 86:U(e);break;case 88:q(e)}},t);var z=function(e){if(b||!t.onCompositionStart||t.$readOnly)return;b={};if(S)return;e.data&&(b.useTextareaForIME=!1),setTimeout(W,0),t._signal("compositionStart"),t.on("mousedown",V);var r=t.getSelectionRange();r.end.row=r.start.row,r.end.column=r.start.column,b.markerRange=r,b.selectionStart=N,t.onCompositionStart(b),b.useTextareaForIME?(T=n.value="",N=0,C=0):(n.msGetInputContext&&(b.context=n.msGetInputContext()),n.getInputContext&&(b.context=n.getInputContext()))},W=function(){if(!b||!t.onCompositionUpdate||t.$readOnly)return;if(S)return V();if(b.useTextareaForIME)t.onCompositionUpdate(n.value);else{var e=n.value;B(e),b.markerRange&&(b.context&&(b.markerRange.start.column=b.selectionStart=b.context.compositionStartOffset),b.markerRange.end.column=b.markerRange.start.column+C-b.selectionStart+k)}},X=function(e){if(!t.onCompositionEnd||t.$readOnly)return;b=!1,t.onCompositionEnd(),t.off("mousedown",V),e&&j()},$=o.delayedCall(W,50).schedule.bind(null,null);r.addListener(n,"compositionstart",z,t),r.addListener(n,"compositionupdate",W,t),r.addListener(n,"keyup",J,t),r.addListener(n,"keydown",$,t),r.addListener(n,"compositionend",X,t),this.getElement=function(){return n},this.setCommandMode=function(e){S=e,n.readOnly=!1},this.setReadOnly=function(e){S||(n.readOnly=e)},this.setCopyWithEmptySelection=function(e){},this.onContextMenu=function(e){H=!0,O(),t._emit("nativecontextmenu",{target:t,domEvent:e}),this.moveToMouse(e,!0)},this.moveToMouse=function(e,o){E||(E=n.style.cssText),n.style.cssText=(o?"z-index:100000;":"")+(i.isIE?"opacity:0.1;":"")+"text-indent: -"+(N+C)*t.renderer.characterWidth*.5+"px;";var u=t.container.getBoundingClientRect(),a=s.computedStyle(t.container),f=u.top+(parseInt(a.borderTopWidth)||0),l=u.left+(parseInt(u.borderLeftWidth)||0),c=u.bottom-f-n.clientHeight-2,h=function(e){s.translate(n,e.clientX-l-2,Math.min(e.clientY-f-2,c))};h(e);if(e.type!="mousedown")return;t.renderer.$isMousePressed=!0,clearTimeout(K),i.isWin&&r.capture(t.container,h,Q)},this.onContextMenuClose=Q;var K,G=function(e){t.textInput.onContextMenu(e),Q()};r.addListener(n,"mouseup",G,t),r.addListener(n,"mousedown",function(e){e.preventDefault(),Q()},t),r.addListener(t.renderer.scroller,"contextmenu",G,t),r.addListener(n,"contextmenu",G,t),d&&Y(e,t,n),this.destroy=function(){n.parentElement&&n.parentElement.removeChild(n)}};t.TextInput=g,t.$setUserAgentForTests=function(e,t){m=e,d=t}}),ace.define("ace/mouse/default_handlers",["require","exports","module","ace/lib/useragent"],function(e,t,n){"use strict";function u(e,t,n,r){return Math.sqrt(Math.pow(n-e,2)+Math.pow(r-t,2))}function a(e,t){if(e.start.row==e.end.row)var n=2*t.column-e.start.column-e.end.column;else if(e.start.row==e.end.row-1&&!e.start.column&&!e.end.column)var n=t.column-4;else var n=2*t.row-e.start.row-e.end.row;return n<0?{cursor:e.start,anchor:e.end}:{cursor:e.end,anchor:e.start}}var r=e("../lib/useragent"),i=0,s=550,o=function(){function e(e){e.$clickSelection=null;var t=e.editor;t.setDefaultHandler("mousedown",this.onMouseDown.bind(e)),t.setDefaultHandler("dblclick",this.onDoubleClick.bind(e)),t.setDefaultHandler("tripleclick",this.onTripleClick.bind(e)),t.setDefaultHandler("quadclick",this.onQuadClick.bind(e)),t.setDefaultHandler("mousewheel",this.onMouseWheel.bind(e));var n=["select","startSelect","selectEnd","selectAllEnd","selectByWordsEnd","selectByLinesEnd","dragWait","dragWaitEnd","focusWait"];n.forEach(function(t){e[t]=this[t]},this),e.selectByLines=this.extendSelectionBy.bind(e,"getLineRange"),e.selectByWords=this.extendSelectionBy.bind(e,"getWordRange")}return e.prototype.onMouseDown=function(e){var t=e.inSelection(),n=e.getDocumentPosition();this.mousedownEvent=e;var i=this.editor,s=e.getButton();if(s!==0){var o=i.getSelectionRange(),u=o.isEmpty();(u||s==1)&&i.selection.moveToPosition(n),s==2&&(i.textInput.onContextMenu(e.domEvent),r.isMozilla||e.preventDefault());return}this.mousedownEvent.time=Date.now();if(t&&!i.isFocused()){i.focus();if(this.$focusTimeout&&!this.$clickSelection&&!i.inMultiSelectMode){this.setState("focusWait"),this.captureMouse(e);return}}return this.captureMouse(e),this.startSelect(n,e.domEvent._clicks>1),e.preventDefault()},e.prototype.startSelect=function(e,t){e=e||this.editor.renderer.screenToTextCoordinates(this.x,this.y);var n=this.editor;if(!this.mousedownEvent)return;this.mousedownEvent.getShiftKey()?n.selection.selectToPosition(e):t||n.selection.moveToPosition(e),t||this.select(),n.setStyle("ace_selecting"),this.setState("select")},e.prototype.select=function(){var e,t=this.editor,n=t.renderer.screenToTextCoordinates(this.x,this.y);if(this.$clickSelection){var r=this.$clickSelection.comparePoint(n);if(r==-1)e=this.$clickSelection.end;else if(r==1)e=this.$clickSelection.start;else{var i=a(this.$clickSelection,n);n=i.cursor,e=i.anchor}t.selection.setSelectionAnchor(e.row,e.column)}t.selection.selectToPosition(n),t.renderer.scrollCursorIntoView()},e.prototype.extendSelectionBy=function(e){var t,n=this.editor,r=n.renderer.screenToTextCoordinates(this.x,this.y),i=n.selection[e](r.row,r.column);if(this.$clickSelection){var s=this.$clickSelection.comparePoint(i.start),o=this.$clickSelection.comparePoint(i.end);if(s==-1&&o<=0){t=this.$clickSelection.end;if(i.end.row!=r.row||i.end.column!=r.column)r=i.start}else if(o==1&&s>=0){t=this.$clickSelection.start;if(i.start.row!=r.row||i.start.column!=r.column)r=i.end}else if(s==-1&&o==1)r=i.end,t=i.start;else{var u=a(this.$clickSelection,r);r=u.cursor,t=u.anchor}n.selection.setSelectionAnchor(t.row,t.column)}n.selection.selectToPosition(r),n.renderer.scrollCursorIntoView()},e.prototype.selectByLinesEnd=function(){this.$clickSelection=null,this.editor.unsetStyle("ace_selecting")},e.prototype.focusWait=function(){var e=u(this.mousedownEvent.x,this.mousedownEvent.y,this.x,this.y),t=Date.now();(e>i||t-this.mousedownEvent.time>this.$focusTimeout)&&this.startSelect(this.mousedownEvent.getDocumentPosition())},e.prototype.onDoubleClick=function(e){var t=e.getDocumentPosition(),n=this.editor,r=n.session,i=r.getBracketRange(t);i?(i.isEmpty()&&(i.start.column--,i.end.column++),this.setState("select")):(i=n.selection.getWordRange(t.row,t.column),this.setState("selectByWords")),this.$clickSelection=i,this.select()},e.prototype.onTripleClick=function(e){var t=e.getDocumentPosition(),n=this.editor;this.setState("selectByLines");var r=n.getSelectionRange();r.isMultiLine()&&r.contains(t.row,t.column)?(this.$clickSelection=n.selection.getLineRange(r.start.row),this.$clickSelection.end=n.selection.getLineRange(r.end.row).end):this.$clickSelection=n.selection.getLineRange(t.row),this.select()},e.prototype.onQuadClick=function(e){var t=this.editor;t.selectAll(),this.$clickSelection=t.getSelectionRange(),this.setState("selectAll")},e.prototype.onMouseWheel=function(e){if(e.getAccelKey())return;e.getShiftKey()&&e.wheelY&&!e.wheelX&&(e.wheelX=e.wheelY,e.wheelY=0);var t=this.editor;this.$lastScroll||(this.$lastScroll={t:0,vx:0,vy:0,allowed:0});var n=this.$lastScroll,r=e.domEvent.timeStamp,i=r-n.t,o=i?e.wheelX/i:n.vx,u=i?e.wheelY/i:n.vy;i<s&&(o=(o+n.vx)/2,u=(u+n.vy)/2);var a=Math.abs(o/u),f=!1;a>=1&&t.renderer.isScrollableBy(e.wheelX*e.speed,0)&&(f=!0),a<=1&&t.renderer.isScrollableBy(0,e.wheelY*e.speed)&&(f=!0);if(f)n.allowed=r;else if(r-n.allowed<s){var l=Math.abs(o)<=1.5*Math.abs(n.vx)&&Math.abs(u)<=1.5*Math.abs(n.vy);l?(f=!0,n.allowed=r):n.allowed=0}n.t=r,n.vx=o,n.vy=u;if(f)return t.renderer.scrollBy(e.wheelX*e.speed,e.wheelY*e.speed),e.stop()},e}();o.prototype.selectEnd=o.prototype.selectByLinesEnd,o.prototype.selectAllEnd=o.prototype.selectByLinesEnd,o.prototype.selectByWordsEnd=o.prototype.selectByLinesEnd,t.DefaultHandlers=o}),ace.define("ace/tooltip",["require","exports","module","ace/lib/dom","ace/range"],function(e,t,n){"use strict";var r=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}if(typeof n!="function"&&n!==null)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");e(t,n),t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),i=this&&this.__values||function(e){var t=typeof Symbol=="function"&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},s=e("./lib/dom"),o=e("./range").Range,u="ace_tooltip",a=function(){function e(e){this.isOpen=!1,this.$element=null,this.$parentNode=e}return e.prototype.$init=function(){return this.$element=s.createElement("div"),this.$element.className=u,this.$element.style.display="none",this.$parentNode.appendChild(this.$element),this.$element},e.prototype.getElement=function(){return this.$element||this.$init()},e.prototype.setText=function(e){this.getElement().textContent=e},e.prototype.setHtml=function(e){this.getElement().innerHTML=e},e.prototype.setPosition=function(e,t){this.getElement().style.left=e+"px",this.getElement().style.top=t+"px"},e.prototype.setClassName=function(e){s.addCssClass(this.getElement(),e)},e.prototype.setTheme=function(e){this.$element.className=u+" "+(e.isDark?"ace_dark ":"")+(e.cssClass||"")},e.prototype.show=function(e,t,n){e!=null&&this.setText(e),t!=null&&n!=null&&this.setPosition(t,n),this.isOpen||(this.getElement().style.display="block",this.isOpen=!0)},e.prototype.hide=function(){this.isOpen&&(this.getElement().style.display="none",this.getElement().className=u,this.isOpen=!1)},e.prototype.getHeight=function(){return this.getElement().offsetHeight},e.prototype.getWidth=function(){return this.getElement().offsetWidth},e.prototype.destroy=function(){this.isOpen=!1,this.$element&&this.$element.parentNode&&this.$element.parentNode.removeChild(this.$element)},e}(),f=function(){function e(){this.popups=[]}return e.prototype.addPopup=function(e){this.popups.push(e),this.updatePopups()},e.prototype.removePopup=function(e){var t=this.popups.indexOf(e);t!==-1&&(this.popups.splice(t,1),this.updatePopups())},e.prototype.updatePopups=function(){var e,t,n,r;this.popups.sort(function(e,t){return t.priority-e.priority});var s=[];try{for(var o=i(this.popups),u=o.next();!u.done;u=o.next()){var a=u.value,f=!0;try{for(var l=(n=void 0,i(s)),c=l.next();!c.done;c=l.next()){var h=c.value;if(this.doPopupsOverlap(h,a)){f=!1;break}}}catch(p){n={error:p}}finally{try{c&&!c.done&&(r=l.return)&&r.call(l)}finally{if(n)throw n.error}}f?s.push(a):a.hide()}}catch(d){e={error:d}}finally{try{u&&!u.done&&(t=o.return)&&t.call(o)}finally{if(e)throw e.error}}},e.prototype.doPopupsOverlap=function(e,t){var n=e.getElement().getBoundingClientRect(),r=t.getElement().getBoundingClientRect();return n.left<r.right&&n.right>r.left&&n.top<r.bottom&&n.bottom>r.top},e}(),l=new f;t.popupManager=l,t.Tooltip=a;var c=function(e){function t(){var t=e.call(this,document.body)||this;t.timeout=undefined,t.lastT=0,t.idleTime=350,t.lastEvent=undefined,t.onMouseOut=t.onMouseOut.bind(t),t.onMouseMove=t.onMouseMove.bind(t),t.waitForHover=t.waitForHover.bind(t),t.hide=t.hide.bind(t);var n=t.getElement();return n.style.whiteSpace="pre-wrap",n.style.pointerEvents="auto",n.addEventListener("mouseout",t.onMouseOut),n.tabIndex=-1,n.addEventListener("blur",function(){document.activeElement!=n&&this.hide()}.bind(t)),t}return r(t,e),t.prototype.addToEditor=function(e){e.on("mousemove",this.onMouseMove),e.on("mousedown",this.hide),e.renderer.getMouseEventTarget().addEventListener("mouseout",this.onMouseOut,!0)},t.prototype.removeFromEditor=function(e){e.off("mousemove",this.onMouseMove),e.off("mousedown",this.hide),e.renderer.getMouseEventTarget().removeEventListener("mouseout",this.onMouseOut,!0),this.timeout&&(clearTimeout(this.timeout),this.timeout=null)},t.prototype.onMouseMove=function(e,t){this.lastEvent=e,this.lastT=Date.now();var n=t.$mouseHandler.isMousePressed;if(this.isOpen){var r=this.lastEvent&&this.lastEvent.getDocumentPosition();(!this.range||!this.range.contains(r.row,r.column)||n||this.isOutsideOfText(this.lastEvent))&&this.hide()}if(this.timeout||n)return;this.lastEvent=e,this.timeout=setTimeout(this.waitForHover,this.idleTime)},t.prototype.waitForHover=function(){this.timeout&&clearTimeout(this.timeout);var e=Date.now()-this.lastT;if(this.idleTime-e>10){this.timeout=setTimeout(this.waitForHover,this.idleTime-e);return}this.timeout=null,this.lastEvent&&!this.isOutsideOfText(this.lastEvent)&&this.$gatherData(this.lastEvent,this.lastEvent.editor)},t.prototype.isOutsideOfText=function(e){var t=e.editor,n=e.getDocumentPosition(),r=t.session.getLine(n.row);if(n.column==r.length){var i=t.renderer.pixelToScreenCoordinates(e.clientX,e.clientY),s=t.session.documentToScreenPosition(n.row,n.column);if(s.column!=i.column||s.row!=i.row)return!0}return!1},t.prototype.setDataProvider=function(e){this.$gatherData=e},t.prototype.showForRange=function(e,t,n,r){if(r&&r!=this.lastEvent)return;if(this.isOpen&&document.activeElement==this.getElement())return;var i=e.renderer;this.isOpen||(l.addPopup(this),this.$registerCloseEvents(),this.setTheme(i.theme)),this.isOpen=!0,this.addMarker(t,e.session),this.range=o.fromPoints(t.start,t.end);var s=this.getElement();s.innerHTML="",s.appendChild(n),s.style.display="block";var u=i.textToScreenCoordinates(t.start.row,t.start.column),a=e.getCursorPosition(),f=s.clientHeight,c=i.scroller.getBoundingClientRect(),h=!0;this.row>a.row?h=!0:this.row<a.row&&(h=!1),u.pageY-f+i.lineHeight<c.top?h=!0:u.pageY+f>c.bottom&&(h=!1),h?u.pageY+=i.lineHeight:u.pageY-=f,s.style.maxWidth=c.width-(u.pageX-c.left)+"px",this.setPosition(u.pageX,u.pageY)},t.prototype.addMarker=function(e,t){this.marker&&this.$markerSession.removeMarker(this.marker),this.$markerSession=t,this.marker=t&&t.addMarker(e,"ace_highlight-marker","text")},t.prototype.hide=function(e){if(!e&&document.activeElement==this.getElement())return;if(e&&e.target&&e.type!="keydown"&&this.$element.contains(e.target))return;this.lastEvent=null,this.timeout&&clearTimeout(this.timeout),this.timeout=null,this.addMarker(null),this.isOpen&&(this.$removeCloseEvents(),this.getElement().style.display="none",this.isOpen=!1,l.removePopup(this))},t.prototype.$registerCloseEvents=function(){window.addEventListener("keydown",this.hide,!0),window.addEventListener("mousewheel",this.hide,!0),window.addEventListener("mousedown",this.hide,!0)},t.prototype.$removeCloseEvents=function(){window.removeEventListener("keydown",this.hide,!0),window.removeEventListener("mousewheel",this.hide,!0),window.removeEventListener("mousedown",this.hide,!0)},t.prototype.onMouseOut=function(e){this.timeout&&(clearTimeout(this.timeout),this.timeout=null),this.lastEvent=null;if(!this.isOpen)return;if(!e.relatedTarget||e.relatedTarget==this.getElement())return;if(e&&e.currentTarget.contains(e.relatedTarget))return;e.relatedTarget.classList.contains("ace_content")||this.hide()},t}(a);t.HoverTooltip=c}),ace.define("ace/mouse/default_gutter_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/tooltip"],function(e,t,n){"use strict";function a(e){function h(){var i=a.getDocumentPosition().row,s=n.$annotations[i],o;s?o={text:Array.from(s.text),type:Array.from(s.type)}:o={text:[],type:[]};var u=n.session.getFoldLine(i);if(u&&n.$showFoldedAnnotations){var f={error:[],warning:[],info:[]},h;for(var m=i+1;m<=u.end.row;m++){if(!n.$annotations[m])continue;for(var g=0;g<n.$annotations[m].text.length;g++){var y=n.$annotations[m].type[g];f[y].push(n.$annotations[m].text[g]);if(y==="error"){h="error_fold";continue}if(y==="warning"){h="warning_fold";continue}}}if(h==="error_fold"||h==="warning_fold"){var b="".concat(d(f)," in folded code.");o.text.push(b),o.type.push(h)}}if(o.text.length===0)return p();var w=t.session.getLength();if(i==w){var E=t.renderer.pixelToScreenCoordinates(0,a.y).row,S=a.$pos;if(E>t.session.documentToScreenRow(S.row,S.column))return p()}var x={error:[],warning:[],info:[]},T=n.$useSvgGutterIcons?"ace_icon_svg":"ace_icon";for(var m=0;m<o.text.length;m++){var N="<span class='ace_".concat(o.type[m]," ").concat(T,"' aria-label='").concat(c[o.type[m].replace("_fold","")].singular,"' role=img> </span> ").concat(o.text[m]);x[o.type[m].replace("_fold","")].push(N)}l=[].concat(x.error,x.warning,x.info).join("<br>"),r.setHtml(l),r.setClassName("ace_gutter-tooltip"),r.$element.setAttribute("aria-live","polite"),r.isOpen||r.setTheme(t.renderer.theme),r.show(),t._signal("showGutterTooltip",r),t.on("mousewheel",p);if(e.$tooltipFollowsMouse)v(a);else{var C=n.$lines.cells[i].element.querySelector("[class*=ace_icon]"),k=C.getBoundingClientRect(),L=r.getElement().style;L.left=k.right+"px",L.top=k.bottom+"px"}}function p(){u&&(u=clearTimeout(u)),l&&(r.hide(),l=null,t._signal("hideGutterTooltip",r),t.off("mousewheel",p))}function d(e){var t,n,r=[],s=["error","warning","info"];try{for(var o=i(s),u=o.next();!u.done;u=o.next()){var a=u.value;if(!e[a].length)continue;var f=e[a].length===1?c[a].singular:c[a].plural;r.push("".concat(e[a].length," ").concat(f))}}catch(l){t={error:l}}finally{try{u&&!u.done&&(n=o.return)&&n.call(o)}finally{if(t)throw t.error}}return r.join(", ")}function v(e){r.setPosition(e.x,e.y)}var t=e.editor,n=t.renderer.$gutterLayer,r=new f(t.container);e.editor.setDefaultHandler("guttermousedown",function(r){if(!t.isFocused()||r.getButton()!=0)return;var i=n.getRegion(r);if(i=="foldWidgets")return;var s=r.getDocumentPosition().row,o=t.session.selection;if(r.getShiftKey())o.selectTo(s,0);else{if(r.domEvent.detail==2)return t.selectAll(),r.preventDefault();e.$clickSelection=t.selection.getLineRange(s)}return e.setState("selectByLines"),e.captureMouse(r),r.preventDefault()});var u,a,l,c={error:{singular:"error",plural:"errors"},warning:{singular:"warning",plural:"warnings"},info:{singular:"information message",plural:"information messages"}};e.editor.setDefaultHandler("guttermousemove",function(t){var n=t.domEvent.target||t.domEvent.srcElement;if(s.hasCssClass(n,"ace_fold-widget"))return p();l&&e.$tooltipFollowsMouse&&v(t),a=t;if(u)return;u=setTimeout(function(){u=null,a&&!e.isMousePressed?h():p()},50)}),o.addListener(t.renderer.$gutter,"mouseout",function(e){a=null;if(!l||u)return;u=setTimeout(function(){u=null,p()},50)},t),t.on("changeSession",p)}var r=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}if(typeof n!="function"&&n!==null)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");e(t,n),t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),i=this&&this.__values||function(e){var t=typeof Symbol=="function"&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},s=e("../lib/dom"),o=e("../lib/event"),u=e("../tooltip").Tooltip,f=function(e){function t(){return e!==null&&e.apply(this,arguments)||this}return r(t,e),t.prototype.setPosition=function(e,t){var n=window.innerWidth||document.documentElement.clientWidth,r=window.innerHeight||document.documentElement.clientHeight,i=this.getWidth(),s=this.getHeight();e+=15,t+=15,e+i>n&&(e-=e+i-n),t+s>r&&(t-=20+s),u.prototype.setPosition.call(this,e,t)},t}(u);t.GutterHandler=a}),ace.define("ace/mouse/mouse_event",["require","exports","module","ace/lib/event","ace/lib/useragent"],function(e,t,n){"use strict";var r=e("../lib/event"),i=e("../lib/useragent"),s=function(){function e(e,t){this.domEvent=e,this.editor=t,this.x=this.clientX=e.clientX,this.y=this.clientY=e.clientY,this.$pos=null,this.$inSelection=null,this.propagationStopped=!1,this.defaultPrevented=!1,this.getAccelKey=i.isMac?function(){return this.domEvent.metaKey}:function(){return this.domEvent.ctrlKey}}return e.prototype.stopPropagation=function(){r.stopPropagation(this.domEvent),this.propagationStopped=!0},e.prototype.preventDefault=function(){r.preventDefault(this.domEvent),this.defaultPrevented=!0},e.prototype.stop=function(){this.stopPropagation(),this.preventDefault()},e.prototype.getDocumentPosition=function(){return this.$pos?this.$pos:(this.$pos=this.editor.renderer.screenToTextCoordinates(this.clientX,this.clientY),this.$pos)},e.prototype.inSelection=function(){if(this.$inSelection!==null)return this.$inSelection;var e=this.editor,t=e.getSelectionRange();if(t.isEmpty())this.$inSelection=!1;else{var n=this.getDocumentPosition();this.$inSelection=t.contains(n.row,n.column)}return this.$inSelection},e.prototype.getButton=function(){return r.getButton(this.domEvent)},e.prototype.getShiftKey=function(){return this.domEvent.shiftKey},e}();t.MouseEvent=s}),ace.define("ace/mouse/dragdrop_handler",["require","exports","module","ace/lib/dom","ace/lib/event","ace/lib/useragent"],function(e,t,n){"use strict";function f(e){function T(e,n){var r=Date.now(),i=!n||e.row!=n.row,s=!n||e.column!=n.column;if(!S||i||s)t.moveCursorToPosition(e),S=r,x={x:p,y:d};else{var o=l(x.x,x.y,p,d);o>a?S=null:r-S>=u&&(t.renderer.scrollCursorIntoView(),S=null)}}function N(e,n){var r=Date.now(),i=t.renderer.layerConfig.lineHeight,s=t.renderer.layerConfig.characterWidth,u=t.renderer.scroller.getBoundingClientRect(),a={x:{left:p-u.left,right:u.right-p},y:{top:d-u.top,bottom:u.bottom-d}},f=Math.min(a.x.left,a.x.right),l=Math.min(a.y.top,a.y.bottom),c={row:e.row,column:e.column};f/s<=2&&(c.column+=a.x.left<a.x.right?-3:2),l/i<=1&&(c.row+=a.y.top<a.y.bottom?-1:1);var h=e.row!=c.row,v=e.column!=c.column,m=!n||e.row!=n.row;h||v&&!m?E?r-E>=o&&t.renderer.scrollCursorIntoView(c):E=r:E=null}function C(){var e=g;g=t.renderer.screenToTextCoordinates(p,d),T(g,e),N(g,e)}function k(){m=t.selection.toOrientedRange(),h=t.session.addMarker(m,"ace_selection",t.getSelectionStyle()),t.clearSelection(),t.isFocused()&&t.renderer.$cursorLayer.setBlinking(!1),clearInterval(v),C(),v=setInterval(C,20),y=0,i.addListener(document,"mousemove",O)}function L(){clearInterval(v),t.session.removeMarker(h),h=null,t.selection.fromOrientedRange(m),t.isFocused()&&!w&&t.$resetCursorStyle(),m=null,g=null,y=0,E=null,S=null,i.removeListener(document,"mousemove",O)}function O(){A==null&&(A=setTimeout(function(){A!=null&&h&&L()},20))}function M(e){var t=e.types;return!t||Array.prototype.some.call(t,function(e){return e=="text/plain"||e=="Text"})}function _(e){var t=["copy","copymove","all","uninitialized"],n=["move","copymove","linkmove","all","uninitialized"],r=s.isMac?e.altKey:e.ctrlKey,i="uninitialized";try{i=e.dataTransfer.effectAllowed.toLowerCase()}catch(e){}var o="none";return r&&t.indexOf(i)>=0?o="copy":n.indexOf(i)>=0?o="move":t.indexOf(i)>=0&&(o="copy"),o}var t=e.editor,n=r.createElement("div");n.style.cssText="top:-100px;position:absolute;z-index:2147483647;opacity:0.5",n.textContent="\u00a0";var f=["dragWait","dragWaitEnd","startDrag","dragReadyEnd","onMouseDrag"];f.forEach(function(t){e[t]=this[t]},this),t.on("mousedown",this.onMouseDown.bind(e));var c=t.container,h,p,d,v,m,g,y=0,b,w,E,S,x;this.onDragStart=function(e){if(this.cancelDrag||!c.draggable){var r=this;return setTimeout(function(){r.startSelect(),r.captureMouse(e)},0),e.preventDefault()}m=t.getSelectionRange();var i=e.dataTransfer;i.effectAllowed=t.getReadOnly()?"copy":"copyMove",t.container.appendChild(n),i.setDragImage&&i.setDragImage(n,0,0),setTimeout(function(){t.container.removeChild(n)}),i.clearData(),i.setData("Text",t.session.getTextRange()),w=!0,this.setState("drag")},this.onDragEnd=function(e){c.draggable=!1,w=!1,this.setState(null);if(!t.getReadOnly()){var n=e.dataTransfer.dropEffect;!b&&n=="move"&&t.session.remove(t.getSelectionRange()),t.$resetCursorStyle()}this.editor.unsetStyle("ace_dragging"),this.editor.renderer.setCursorStyle("")},this.onDragEnter=function(e){if(t.getReadOnly()||!M(e.dataTransfer))return;return p=e.clientX,d=e.clientY,h||k(),y++,e.dataTransfer.dropEffect=b=_(e),i.preventDefault(e)},this.onDragOver=function(e){if(t.getReadOnly()||!M(e.dataTransfer))return;return p=e.clientX,d=e.clientY,h||(k(),y++),A!==null&&(A=null),e.dataTransfer.dropEffect=b=_(e),i.preventDefault(e)},this.onDragLeave=function(e){y--;if(y<=0&&h)return L(),b=null,i.preventDefault(e)},this.onDrop=function(e){if(!g)return;var n=e.dataTransfer;if(w)switch(b){case"move":m.contains(g.row,g.column)?m={start:g,end:g}:m=t.moveText(m,g);break;case"copy":m=t.moveText(m,g,!0)}else{var r=n.getData("Text");m={start:g,end:t.session.insert(g,r)},t.focus(),b=null}return L(),i.preventDefault(e)},i.addListener(c,"dragstart",this.onDragStart.bind(e),t),i.addListener(c,"dragend",this.onDragEnd.bind(e),t),i.addListener(c,"dragenter",this.onDragEnter.bind(e),t),i.addListener(c,"dragover",this.onDragOver.bind(e),t),i.addListener(c,"dragleave",this.onDragLeave.bind(e),t),i.addListener(c,"drop",this.onDrop.bind(e),t);var A=null}function l(e,t,n,r){return Math.sqrt(Math.pow(n-e,2)+Math.pow(r-t,2))}var r=e("../lib/dom"),i=e("../lib/event"),s=e("../lib/useragent"),o=200,u=200,a=5;(function(){this.dragWait=function(){var e=Date.now()-this.mousedownEvent.time;e>this.editor.getDragDelay()&&this.startDrag()},this.dragWaitEnd=function(){var e=this.editor.container;e.draggable=!1,this.startSelect(this.mousedownEvent.getDocumentPosition()),this.selectEnd()},this.dragReadyEnd=function(e){this.editor.$resetCursorStyle(),this.editor.unsetStyle("ace_dragging"),this.editor.renderer.setCursorStyle(""),this.dragWaitEnd()},this.startDrag=function(){this.cancelDrag=!1;var e=this.editor,t=e.container;t.draggable=!0,e.renderer.$cursorLayer.setBlinking(!1),e.setStyle("ace_dragging");var n=s.isWin?"default":"move";e.renderer.setCursorStyle(n),this.setState("dragReady")},this.onMouseDrag=function(e){var t=this.editor.container;if(s.isIE&&this.state=="dragReady"){var n=l(this.mousedownEvent.x,this.mousedownEvent.y,this.x,this.y);n>3&&t.dragDrop()}if(this.state==="dragWait"){var n=l(this.mousedownEvent.x,this.mousedownEvent.y,this.x,this.y);n>0&&(t.draggable=!1,this.startSelect(this.mousedownEvent.getDocumentPosition()))}},this.onMouseDown=function(e){if(!this.$dragEnabled)return;this.mousedownEvent=e;var t=this.editor,n=e.inSelection(),r=e.getButton(),i=e.domEvent.detail||1;if(i===1&&r===0&&n){if(e.editor.inMultiSelectMode&&(e.getAccelKey()||e.getShiftKey()))return;this.mousedownEvent.time=Date.now();var o=e.domEvent.target||e.domEvent.srcElement;"unselectable"in o&&(o.unselectable="on");if(t.getDragDelay()){if(s.isWebKit){this.cancelDrag=!0;var u=t.container;u.draggable=!0}this.setState("dragWait")}else this.startDrag();this.captureMouse(e,this.onMouseDrag.bind(this)),e.defaultPrevented=!0}}}).call(f.prototype),t.DragdropHandler=f}),ace.define("ace/mouse/touch_handler",["require","exports","module","ace/mouse/mouse_event","ace/lib/event","ace/lib/dom"],function(e,t,n){"use strict";var r=e("./mouse_event").MouseEvent,i=e("../lib/event"),s=e("../lib/dom");t.addTouchListeners=function(e,t){function b(){var e=window.navigator&&window.navigator.clipboard,r=!1,i=function(){var n=t.getCopyText(),i=t.session.getUndoManager().hasUndo();y.replaceChild(s.buildDom(r?["span",!n&&["span",{"class":"ace_mobile-button",action:"selectall"},"Select All"],n&&["span",{"class":"ace_mobile-button",action:"copy"},"Copy"],n&&["span",{"class":"ace_mobile-button",action:"cut"},"Cut"],e&&["span",{"class":"ace_mobile-button",action:"paste"},"Paste"],i&&["span",{"class":"ace_mobile-button",action:"undo"},"Undo"],["span",{"class":"ace_mobile-button",action:"find"},"Find"],["span",{"class":"ace_mobile-button",action:"openCommandPallete"},"Palette"]]:["span"]),y.firstChild)},o=function(n){var s=n.target.getAttribute("action");if(s=="more"||!r)return r=!r,i();if(s=="paste")e.readText().then(function(e){t.execCommand(s,e)});else if(s){if(s=="cut"||s=="copy")e?e.writeText(t.getCopyText()):document.execCommand("copy");t.execCommand(s)}y.firstChild.style.display="none",r=!1,s!="openCommandPallete"&&t.focus()};y=s.buildDom(["div",{"class":"ace_mobile-menu",ontouchstart:function(e){n="menu",e.stopPropagation(),e.preventDefault(),t.textInput.focus()},ontouchend:function(e){e.stopPropagation(),e.preventDefault(),o(e)},onclick:o},["span"],["span",{"class":"ace_mobile-button",action:"more"},"..."]],t.container)}function w(){y||b();var e=t.selection.cursor,n=t.renderer.textToScreenCoordinates(e.row,e.column),r=t.renderer.textToScreenCoordinates(0,0).pageX,i=t.renderer.scrollLeft,s=t.container.getBoundingClientRect();y.style.top=n.pageY-s.top-3+"px",n.pageX-s.left<s.width-70?(y.style.left="",y.style.right="10px"):(y.style.right="",y.style.left=r+i-s.left+"px"),y.style.display="",y.firstChild.style.display="none",t.on("input",E)}function E(e){y&&(y.style.display="none"),t.off("input",E)}function S(){l=null,clearTimeout(l);var e=t.selection.getRange(),r=e.contains(p.row,p.column);if(e.isEmpty()||!r)t.selection.moveToPosition(p),t.selection.selectWord();n="wait",w()}function x(){l=null,clearTimeout(l),t.selection.moveToPosition(p);var e=d>=2?t.selection.getLineRange(p.row):t.session.getBracketRange(p);e&&!e.isEmpty()?t.selection.setRange(e):t.selection.selectWord(),n="wait"}function T(){h+=60,c=setInterval(function(){h--<=0&&(clearInterval(c),c=null),Math.abs(v)<.01&&(v=0),Math.abs(m)<.01&&(m=0),h<20&&(v=.9*v),h<20&&(m=.9*m);var e=t.session.getScrollTop();t.renderer.scrollBy(10*v,10*m),e==t.session.getScrollTop()&&(h=0)},10)}var n="scroll",o,u,a,f,l,c,h=0,p,d=0,v=0,m=0,g,y;i.addListener(e,"contextmenu",function(e){if(!g)return;var n=t.textInput.getElement();n.focus()},t),i.addListener(e,"touchstart",function(e){var i=e.touches;if(l||i.length>1){clearTimeout(l),l=null,a=-1,n="zoom";return}g=t.$mouseHandler.isMousePressed=!0;var s=t.renderer.layerConfig.lineHeight,c=t.renderer.layerConfig.lineHeight,y=e.timeStamp;f=y;var b=i[0],w=b.clientX,E=b.clientY;Math.abs(o-w)+Math.abs(u-E)>s&&(a=-1),o=e.clientX=w,u=e.clientY=E,v=m=0;var T=new r(e,t);p=T.getDocumentPosition();if(y-a<500&&i.length==1&&!h)d++,e.preventDefault(),e.button=0,x();else{d=0;var N=t.selection.cursor,C=t.selection.isEmpty()?N:t.selection.anchor,k=t.renderer.$cursorLayer.getPixelPosition(N,!0),L=t.renderer.$cursorLayer.getPixelPosition(C,!0),A=t.renderer.scroller.getBoundingClientRect(),O=t.renderer.layerConfig.offset,M=t.renderer.scrollLeft,_=function(e,t){return e/=c,t=t/s-.75,e*e+t*t};if(e.clientX<A.left){n="zoom";return}var D=_(e.clientX-A.left-k.left+M,e.clientY-A.top-k.top+O),P=_(e.clientX-A.left-L.left+M,e.clientY-A.top-L.top+O);D<3.5&&P<3.5&&(n=D>P?"cursor":"anchor"),P<3.5?n="anchor":D<3.5?n="cursor":n="scroll",l=setTimeout(S,450)}a=y},t),i.addListener(e,"touchend",function(e){g=t.$mouseHandler.isMousePressed=!1,c&&clearInterval(c),n=="zoom"?(n="",h=0):l?(t.selection.moveToPosition(p),h=0,w()):n=="scroll"?(T(),E()):w(),clearTimeout(l),l=null},t),i.addListener(e,"touchmove",function(e){l&&(clearTimeout(l),l=null);var i=e.touches;if(i.length>1||n=="zoom")return;var s=i[0],a=o-s.clientX,c=u-s.clientY;if(n=="wait"){if(!(a*a+c*c>4))return e.preventDefault();n="cursor"}o=s.clientX,u=s.clientY,e.clientX=s.clientX,e.clientY=s.clientY;var h=e.timeStamp,p=h-f;f=h;if(n=="scroll"){var d=new r(e,t);d.speed=1,d.wheelX=a,d.wheelY=c,10*Math.abs(a)<Math.abs(c)&&(a=0),10*Math.abs(c)<Math.abs(a)&&(c=0),p!=0&&(v=a/p,m=c/p),t._emit("mousewheel",d),d.propagationStopped||(v=m=0)}else{var g=new r(e,t),y=g.getDocumentPosition();n=="cursor"?t.selection.moveCursorToPosition(y):n=="anchor"&&t.selection.setSelectionAnchor(y.row,y.column),t.renderer.scrollCursorIntoView(y),e.preventDefault()}},t)}}),ace.define("ace/mouse/mouse_handler",["require","exports","module","ace/lib/event","ace/lib/useragent","ace/mouse/default_handlers","ace/mouse/default_gutter_handler","ace/mouse/mouse_event","ace/mouse/dragdrop_handler","ace/mouse/touch_handler","ace/config"],function(e,t,n){"use strict";var r=e("../lib/event"),i=e("../lib/useragent"),s=e("./default_handlers").DefaultHandlers,o=e("./default_gutter_handler").GutterHandler,u=e("./mouse_event").MouseEvent,a=e("./dragdrop_handler").DragdropHandler,f=e("./touch_handler").addTouchListeners,l=e("../config"),c=function(){function e(e){var t=this;this.editor=e,new s(this),new o(this),new a(this);var n=function(t){var n=!document.hasFocus||!document.hasFocus()||!e.isFocused()&&document.activeElement==(e.textInput&&e.textInput.getElement());n&&window.focus(),e.focus(),setTimeout(function(){e.isFocused()||e.focus()})},u=e.renderer.getMouseEventTarget();r.addListener(u,"click",this.onMouseEvent.bind(this,"click"),e),r.addListener(u,"mousemove",this.onMouseMove.bind(this,"mousemove"),e),r.addMultiMouseDownListener([u,e.renderer.scrollBarV&&e.renderer.scrollBarV.inner,e.renderer.scrollBarH&&e.renderer.scrollBarH.inner,e.textInput&&e.textInput.getElement()].filter(Boolean),[400,300,250],this,"onMouseEvent",e),r.addMouseWheelListener(e.container,this.onMouseWheel.bind(this,"mousewheel"),e),f(e.container,e);var l=e.renderer.$gutter;r.addListener(l,"mousedown",this.onMouseEvent.bind(this,"guttermousedown"),e),r.addListener(l,"click",this.onMouseEvent.bind(this,"gutterclick"),e),r.addListener(l,"dblclick",this.onMouseEvent.bind(this,"gutterdblclick"),e),r.addListener(l,"mousemove",this.onMouseEvent.bind(this,"guttermousemove"),e),r.addListener(u,"mousedown",n,e),r.addListener(l,"mousedown",n,e),i.isIE&&e.renderer.scrollBarV&&(r.addListener(e.renderer.scrollBarV.element,"mousedown",n,e),r.addListener(e.renderer.scrollBarH.element,"mousedown",n,e)),e.on("mousemove",function(n){if(t.state||t.$dragDelay||!t.$dragEnabled)return;var r=e.renderer.screenToTextCoordinates(n.x,n.y),i=e.session.selection.getRange(),s=e.renderer;!i.isEmpty()&&i.insideStart(r.row,r.column)?s.setCursorStyle("default"):s.setCursorStyle("")},e)}return e.prototype.onMouseEvent=function(e,t){if(!this.editor.session)return;this.editor._emit(e,new u(t,this.editor))},e.prototype.onMouseMove=function(e,t){var n=this.editor._eventRegistry&&this.editor._eventRegistry.mousemove;if(!n||!n.length)return;this.editor._emit(e,new u(t,this.editor))},e.prototype.onMouseWheel=function(e,t){var n=new u(t,this.editor);n.speed=this.$scrollSpeed*2,n.wheelX=t.wheelX,n.wheelY=t.wheelY,this.editor._emit(e,n)},e.prototype.setState=function(e){this.state=e},e.prototype.captureMouse=function(e,t){this.x=e.x,this.y=e.y,this.isMousePressed=!0;var n=this.editor,s=this.editor.renderer;s.$isMousePressed=!0;var o=this,a=function(e){if(!e)return;if(i.isWebKit&&!e.which&&o.releaseMouse)return o.releaseMouse();o.x=e.clientX,o.y=e.clientY,t&&t(e),o.mouseEvent=new u(e,o.editor),o.$mouseMoved=!0},f=function(e){n.off("beforeEndOperation",c),clearInterval(h),n.session&&l(),o[o.state+"End"]&&o[o.state+"End"](e),o.state="",o.isMousePressed=s.$isMousePressed=!1,s.$keepTextAreaAtCursor&&s.$moveTextAreaToCursor(),o.$onCaptureMouseMove=o.releaseMouse=null,e&&o.onMouseEvent("mouseup",e),n.endOperation()},l=function(){o[o.state]&&o[o.state](),o.$mouseMoved=!1};if(i.isOldIE&&e.domEvent.type=="dblclick")return setTimeout(function(){f(e)});var c=function(e){if(!o.releaseMouse)return;n.curOp.command.name&&n.curOp.selectionChanged&&(o[o.state+"End"]&&o[o.state+"End"](),o.state="",o.releaseMouse())};n.on("beforeEndOperation",c),n.startOperation({command:{name:"mouse"}}),o.$onCaptureMouseMove=a,o.releaseMouse=r.capture(this.editor.container,a,f);var h=setInterval(l,20)},e.prototype.cancelContextMenu=function(){var e=function(t){if(t&&t.domEvent&&t.domEvent.type!="contextmenu")return;this.editor.off("nativecontextmenu",e),t&&t.domEvent&&r.stopEvent(t.domEvent)}.bind(this);setTimeout(e,10),this.editor.on("nativecontextmenu",e)},e.prototype.destroy=function(){this.releaseMouse&&this.releaseMouse()},e}();c.prototype.releaseMouse=null,l.defineOptions(c.prototype,"mouseHandler",{scrollSpeed:{initialValue:2},dragDelay:{initialValue:i.isMac?150:0},dragEnabled:{initialValue:!0},focusTimeout:{initialValue:0},tooltipFollowsMouse:{initialValue:!0}}),t.MouseHandler=c}),ace.define("ace/mouse/fold_handler",["require","exports","module","ace/lib/dom"],function(e,t,n){"use strict";var r=e("../lib/dom"),i=function(){function e(e){e.on("click",function(t){var n=t.getDocumentPosition(),i=e.session,s=i.getFoldAt(n.row,n.column,1);s&&(t.getAccelKey()?i.removeFold(s):i.expandFold(s),t.stop());var o=t.domEvent&&t.domEvent.target;o&&r.hasCssClass(o,"ace_inline_button")&&r.hasCssClass(o,"ace_toggle_wrap")&&(i.setOption("wrap",!i.getUseWrapMode()),e.renderer.scrollCursorIntoView())}),e.on("gutterclick",function(t){var n=e.renderer.$gutterLayer.getRegion(t);if(n=="foldWidgets"){var r=t.getDocumentPosition().row,i=e.session;i.foldWidgets&&i.foldWidgets[r]&&e.session.onFoldWidgetClick(r,t),e.isFocused()||e.focus(),t.stop()}}),e.on("gutterdblclick",function(t){var n=e.renderer.$gutterLayer.getRegion(t);if(n=="foldWidgets"){var r=t.getDocumentPosition().row,i=e.session,s=i.getParentFoldRangeData(r,!0),o=s.range||s.firstRange;if(o){r=o.start.row;var u=i.getFoldAt(r,i.getLine(r).length,1);u?i.removeFold(u):(i.addFold("...",o),e.renderer.scrollCursorIntoView({row:o.start.row,column:0}))}t.stop()}})}return e}();t.FoldHandler=i}),ace.define("ace/keyboard/keybinding",["require","exports","module","ace/lib/keys","ace/lib/event"],function(e,t,n){"use strict";var r=e("../lib/keys"),i=e("../lib/event"),s=function(){function e(e){this.$editor=e,this.$data={editor:e},this.$handlers=[],this.setDefaultHandler(e.commands)}return e.prototype.setDefaultHandler=function(e){this.removeKeyboardHandler(this.$defaultHandler),this.$defaultHandler=e,this.addKeyboardHandler(e,0)},e.prototype.setKeyboardHandler=function(e){var t=this.$handlers;if(t[t.length-1]==e)return;while(t[t.length-1]&&t[t.length-1]!=this.$defaultHandler)this.removeKeyboardHandler(t[t.length-1]);this.addKeyboardHandler(e,1)},e.prototype.addKeyboardHandler=function(e,t){if(!e)return;typeof e=="function"&&!e.handleKeyboard&&(e.handleKeyboard=e);var n=this.$handlers.indexOf(e);n!=-1&&this.$handlers.splice(n,1),t==undefined?this.$handlers.push(e):this.$handlers.splice(t,0,e),n==-1&&e.attach&&e.attach(this.$editor)},e.prototype.removeKeyboardHandler=function(e){var t=this.$handlers.indexOf(e);return t==-1?!1:(this.$handlers.splice(t,1),e.detach&&e.detach(this.$editor),!0)},e.prototype.getKeyboardHandler=function(){return this.$handlers[this.$handlers.length-1]},e.prototype.getStatusText=function(){var e=this.$data,t=e.editor;return this.$handlers.map(function(n){return n.getStatusText&&n.getStatusText(t,e)||""}).filter(Boolean).join(" ")},e.prototype.$callKeyboardHandlers=function(e,t,n,r){var s,o=!1,u=this.$editor.commands;for(var a=this.$handlers.length;a--;){s=this.$handlers[a].handleKeyboard(this.$data,e,t,n,r);if(!s||!s.command)continue;s.command=="null"?o=!0:o=u.exec(s.command,this.$editor,s.args,r),o&&r&&e!=-1&&s.passEvent!=1&&s.command.passEvent!=1&&i.stopEvent(r);if(o)break}return!o&&e==-1&&(s={command:"insertstring"},o=u.exec("insertstring",this.$editor,t)),o&&this.$editor._signal&&this.$editor._signal("keyboardActivity",s),o},e.prototype.onCommandKey=function(e,t,n){var i=r.keyCodeToString(n);return this.$callKeyboardHandlers(t,i,n,e)},e.prototype.onTextInput=function(e){return this.$callKeyboardHandlers(-1,e)},e}();t.KeyBinding=s}),ace.define("ace/lib/bidiutil",["require","exports","module"],function(e,t,n){"use strict";function F(e,t,n,r){var i=s?d:p,c=null,h=null,v=null,m=0,g=null,y=null,b=-1,w=null,E=null,T=[];if(!r)for(w=0,r=[];w<n;w++)r[w]=R(e[w]);o=s,u=!1,a=!1,f=!1,l=!1;for(E=0;E<n;E++){c=m,T[E]=h=q(e,r,T,E),m=i[c][h],g=m&240,m&=15,t[E]=v=i[m][5];if(g>0)if(g==16){for(w=b;w<E;w++)t[w]=1;b=-1}else b=-1;y=i[m][6];if(y)b==-1&&(b=E);else if(b>-1){for(w=b;w<E;w++)t[w]=v;b=-1}r[E]==S&&(t[E]=0),o|=v}if(l)for(w=0;w<n;w++)if(r[w]==x){t[w]=s;for(var C=w-1;C>=0;C--){if(r[C]!=N)break;t[C]=s}}}function I(e,t,n){if(o<e)return;if(e==1&&s==m&&!f){n.reverse();return}var r=n.length,i=0,u,a,l,c;while(i<r){if(t[i]>=e){u=i+1;while(u<r&&t[u]>=e)u++;for(a=i,l=u-1;a<l;a++,l--)c=n[a],n[a]=n[l],n[l]=c;i=u}i++}}function q(e,t,n,r){var i=t[r],o,c,h,p;switch(i){case g:case y:u=!1;case E:case w:return i;case b:return u?w:b;case T:return u=!0,a=!0,y;case N:return E;case C:if(r<1||r+1>=t.length||(o=n[r-1])!=b&&o!=w||(c=t[r+1])!=b&&c!=w)return E;return u&&(c=w),c==o?c:E;case k:o=r>0?n[r-1]:S;if(o==b&&r+1<t.length&&t[r+1]==b)return b;return E;case L:if(r>0&&n[r-1]==b)return b;if(u)return E;p=r+1,h=t.length;while(p<h&&t[p]==L)p++;if(p<h&&t[p]==b)return b;return E;case A:h=t.length,p=r+1;while(p<h&&t[p]==A)p++;if(p<h){var d=e[r],v=d>=1425&&d<=2303||d==64286;o=t[p];if(v&&(o==y||o==T))return y}if(r<1||(o=t[r-1])==S)return E;return n[r-1];case S:return u=!1,f=!0,s;case x:return l=!0,E;case O:case M:case D:case P:case _:u=!1;case H:return E}}function R(e){var t=e.charCodeAt(0),n=t>>8;return n==0?t>191?g:B[t]:n==5?/[\u0591-\u05f4]/.test(e)?y:g:n==6?/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(e)?A:/[\u0660-\u0669\u066b-\u066c]/.test(e)?w:t==1642?L:/[\u06f0-\u06f9]/.test(e)?b:T:n==32&&t<=8287?j[t&255]:n==254?t>=65136?T:E:E}function U(e){return e>="\u064b"&&e<="\u0655"}var r=["\u0621","\u0641"],i=["\u063a","\u064a"],s=0,o=0,u=!1,a=!1,f=!1,l=!1,c=!1,h=!1,p=[[0,3,0,1,0,0,0],[0,3,0,1,2,2,0],[0,3,0,17,2,0,1],[0,3,5,5,4,1,0],[0,3,21,21,4,0,1],[0,3,5,5,4,2,0]],d=[[2,0,1,1,0,1,0],[2,0,1,1,0,2,0],[2,0,2,1,3,2,0],[2,0,2,33,3,1,1]],v=0,m=1,g=0,y=1,b=2,w=3,E=4,S=5,x=6,T=7,N=8,C=9,k=10,L=11,A=12,O=13,M=14,_=15,D=16,P=17,H=18,B=[H,H,H,H,H,H,H,H,H,x,S,x,N,S,H,H,H,H,H,H,H,H,H,H,H,H,H,H,S,S,S,x,N,E,E,L,L,L,E,E,E,E,E,k,C,k,C,C,b,b,b,b,b,b,b,b,b,b,C,E,E,E,E,E,E,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,E,E,E,E,E,E,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,g,E,E,E,E,H,H,H,H,H,H,S,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,H,C,E,L,L,L,L,E,E,E,E,g,E,E,H,E,E,L,L,b,b,E,g,E,E,E,b,g,E,E,E,E,E],j=[N,N,N,N,N,N,N,N,N,N,N,H,H,H,g,y,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,N,S,O,M,_,D,P,C,L,L,L,L,L,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,C,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,E,N];t.L=g,t.R=y,t.EN=b,t.ON_R=3,t.AN=4,t.R_H=5,t.B=6,t.RLE=7,t.DOT="\u00b7",t.doBidiReorder=function(e,n,r){if(e.length<2)return{};var i=e.split(""),o=new Array(i.length),u=new Array(i.length),a=[];s=r?m:v,F(i,a,i.length,n);for(var f=0;f<o.length;o[f]=f,f++);I(2,a,o),I(1,a,o);for(var f=0;f<o.length-1;f++)n[f]===w?a[f]=t.AN:a[f]===y&&(n[f]>T&&n[f]<O||n[f]===E||n[f]===H)?a[f]=t.ON_R:f>0&&i[f-1]==="\u0644"&&/\u0622|\u0623|\u0625|\u0627/.test(i[f])&&(a[f-1]=a[f]=t.R_H,f++);i[i.length-1]===t.DOT&&(a[i.length-1]=t.B),i[0]==="\u202b"&&(a[0]=t.RLE);for(var f=0;f<o.length;f++)u[f]=a[o[f]];return{logicalFromVisual:o,bidiLevels:u}},t.hasBidiCharacters=function(e,t){var n=!1;for(var r=0;r<e.length;r++)t[r]=R(e.charAt(r)),!n&&(t[r]==y||t[r]==T||t[r]==w)&&(n=!0);return n},t.getVisualFromLogicalIdx=function(e,t){for(var n=0;n<t.logicalFromVisual.length;n++)if(t.logicalFromVisual[n]==e)return n;return 0}}),ace.define("ace/bidihandler",["require","exports","module","ace/lib/bidiutil","ace/lib/lang"],function(e,t,n){"use strict";var r=e("./lib/bidiutil"),i=e("./lib/lang"),s=/[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/,o=function(){function e(e){this.session=e,this.bidiMap={},this.currentRow=null,this.bidiUtil=r,this.charWidths=[],this.EOL="\u00ac",this.showInvisibles=!0,this.isRtlDir=!1,this.$isRtl=!1,this.line="",this.wrapIndent=0,this.EOF="\u00b6",this.RLE="\u202b",this.contentWidth=0,this.fontMetrics=null,this.rtlLineOffset=0,this.wrapOffset=0,this.isMoveLeftOperation=!1,this.seenBidi=s.test(e.getValue())}return e.prototype.isBidiRow=function(e,t,n){return this.seenBidi?(e!==this.currentRow&&(this.currentRow=e,this.updateRowLine(t,n),this.updateBidiMap()),this.bidiMap.bidiLevels):!1},e.prototype.onChange=function(e){this.seenBidi?this.currentRow=null:e.action=="insert"&&s.test(e.lines.join("\n"))&&(this.seenBidi=!0,this.currentRow=null)},e.prototype.getDocumentRow=function(){var e=0,t=this.session.$screenRowCache;if(t.length){var n=this.session.$getRowCacheIndex(t,this.currentRow);n>=0&&(e=this.session.$docRowCache[n])}return e},e.prototype.getSplitIndex=function(){var e=0,t=this.session.$screenRowCache;if(t.length){var n,r=this.session.$getRowCacheIndex(t,this.currentRow);while(this.currentRow-e>0){n=this.session.$getRowCacheIndex(t,this.currentRow-e-1);if(n!==r)break;r=n,e++}}else e=this.currentRow;return e},e.prototype.updateRowLine=function(e,t){e===undefined&&(e=this.getDocumentRow());var n=e===this.session.getLength()-1,s=n?this.EOF:this.EOL;this.wrapIndent=0,this.line=this.session.getLine(e),this.isRtlDir=this.$isRtl||this.line.charAt(0)===this.RLE;if(this.session.$useWrapMode){var o=this.session.$wrapData[e];o&&(t===undefined&&(t=this.getSplitIndex()),t>0&&o.length?(this.wrapIndent=o.indent,this.wrapOffset=this.wrapIndent*this.charWidths[r.L],this.line=t<o.length?this.line.substring(o[t-1],o[t]):this.line.substring(o[o.length-1])):this.line=this.line.substring(0,o[t]),t==o.length&&(this.line+=this.showInvisibles?s:r.DOT))}else this.line+=this.showInvisibles?s:r.DOT;var u=this.session,a=0,f;this.line=this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g,function(e,t){return e==="	"||u.isFullWidth(e.charCodeAt(0))?(f=e==="	"?u.getScreenTabSize(t+a):2,a+=f-1,i.stringRepeat(r.DOT,f)):e}),this.isRtlDir&&(this.fontMetrics.$main.textContent=this.line.charAt(this.line.length-1)==r.DOT?this.line.substr(0,this.line.length-1):this.line,this.rtlLineOffset=this.contentWidth-this.fontMetrics.$main.getBoundingClientRect().width)},e.prototype.updateBidiMap=function(){var e=[];r.hasBidiCharacters(this.line,e)||this.isRtlDir?this.bidiMap=r.doBidiReorder(this.line,e,this.isRtlDir):this.bidiMap={}},e.prototype.markAsDirty=function(){this.currentRow=null},e.prototype.updateCharacterWidths=function(e){if(this.characterWidth===e.$characterSize.width)return;this.fontMetrics=e;var t=this.characterWidth=e.$characterSize.width,n=e.$measureCharWidth("\u05d4");this.charWidths[r.L]=this.charWidths[r.EN]=this.charWidths[r.ON_R]=t,this.charWidths[r.R]=this.charWidths[r.AN]=n,this.charWidths[r.R_H]=n*.45,this.charWidths[r.B]=this.charWidths[r.RLE]=0,this.currentRow=null},e.prototype.setShowInvisibles=function(e){this.showInvisibles=e,this.currentRow=null},e.prototype.setEolChar=function(e){this.EOL=e},e.prototype.setContentWidth=function(e){this.contentWidth=e},e.prototype.isRtlLine=function(e){return this.$isRtl?!0:e!=undefined?this.session.getLine(e).charAt(0)==this.RLE:this.isRtlDir},e.prototype.setRtlDirection=function(e,t){var n=e.getCursorPosition();for(var r=e.selection.getSelectionAnchor().row;r<=n.row;r++)!t&&e.session.getLine(r).charAt(0)===e.session.$bidiHandler.RLE?e.session.doc.removeInLine(r,0,1):t&&e.session.getLine(r).charAt(0)!==e.session.$bidiHandler.RLE&&e.session.doc.insert({column:0,row:r},e.session.$bidiHandler.RLE)},e.prototype.getPosLeft=function(e){e-=this.wrapIndent;var t=this.line.charAt(0)===this.RLE?1:0,n=e>t?this.session.getOverwrite()?e:e-1:t,i=r.getVisualFromLogicalIdx(n,this.bidiMap),s=this.bidiMap.bidiLevels,o=0;!this.session.getOverwrite()&&e<=t&&s[i]%2!==0&&i++;for(var u=0;u<i;u++)o+=this.charWidths[s[u]];return!this.session.getOverwrite()&&e>t&&s[i]%2===0&&(o+=this.charWidths[s[i]]),this.wrapIndent&&(o+=this.isRtlDir?-1*this.wrapOffset:this.wrapOffset),this.isRtlDir&&(o+=this.rtlLineOffset),o},e.prototype.getSelections=function(e,t){var n=this.bidiMap,r=n.bidiLevels,i,s=[],o=0,u=Math.min(e,t)-this.wrapIndent,a=Math.max(e,t)-this.wrapIndent,f=!1,l=!1,c=0;this.wrapIndent&&(o+=this.isRtlDir?-1*this.wrapOffset:this.wrapOffset);for(var h,p=0;p<r.length;p++)h=n.logicalFromVisual[p],i=r[p],f=h>=u&&h<a,f&&!l?c=o:!f&&l&&s.push({left:c,width:o-c}),o+=this.charWidths[i],l=f;f&&p===r.length&&s.push({left:c,width:o-c});if(this.isRtlDir)for(var d=0;d<s.length;d++)s[d].left+=this.rtlLineOffset;return s},e.prototype.offsetToCol=function(e){this.isRtlDir&&(e-=this.rtlLineOffset);var t=0,e=Math.max(e,0),n=0,r=0,i=this.bidiMap.bidiLevels,s=this.charWidths[i[r]];this.wrapIndent&&(e-=this.isRtlDir?-1*this.wrapOffset:this.wrapOffset);while(e>n+s/2){n+=s;if(r===i.length-1){s=0;break}s=this.charWidths[i[++r]]}return r>0&&i[r-1]%2!==0&&i[r]%2===0?(e<n&&r--,t=this.bidiMap.logicalFromVisual[r]):r>0&&i[r-1]%2===0&&i[r]%2!==0?t=1+(e>n?this.bidiMap.logicalFromVisual[r]:this.bidiMap.logicalFromVisual[r-1]):this.isRtlDir&&r===i.length-1&&s===0&&i[r-1]%2===0||!this.isRtlDir&&r===0&&i[r]%2!==0?t=1+this.bidiMap.logicalFromVisual[r]:(r>0&&i[r-1]%2!==0&&s!==0&&r--,t=this.bidiMap.logicalFromVisual[r]),t===0&&this.isRtlDir&&t++,t+this.wrapIndent},e}();t.BidiHandler=o}),ace.define("ace/selection",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/range"],function(e,t,n){"use strict";var r=e("./lib/oop"),i=e("./lib/lang"),s=e("./lib/event_emitter").EventEmitter,o=e("./range").Range,u=function(e){this.session=e,this.doc=e.getDocument(),this.clearSelection(),this.cursor=this.lead=this.doc.createAnchor(0,0),this.anchor=this.doc.createAnchor(0,0),this.$silent=!1;var t=this;this.cursor.on("change",function(e){t.$cursorChanged=!0,t.$silent||t._emit("changeCursor"),!t.$isEmpty&&!t.$silent&&t._emit("changeSelection"),!t.$keepDesiredColumnOnChange&&e.old.column!=e.value.column&&(t.$desiredColumn=null)}),this.anchor.on("change",function(){t.$anchorChanged=!0,!t.$isEmpty&&!t.$silent&&t._emit("changeSelection")})};(function(){r.implement(this,s),this.isEmpty=function(){return this.$isEmpty||this.anchor.row==this.lead.row&&this.anchor.column==this.lead.column},this.isMultiLine=function(){return!this.$isEmpty&&this.anchor.row!=this.cursor.row},this.getCursor=function(){return this.lead.getPosition()},this.setAnchor=function(e,t){this.$isEmpty=!1,this.anchor.setPosition(e,t)},this.setSelectionAnchor=this.setAnchor,this.getAnchor=function(){return this.$isEmpty?this.getSelectionLead():this.anchor.getPosition()},this.getSelectionAnchor=this.getAnchor,this.getSelectionLead=function(){return this.lead.getPosition()},this.isBackwards=function(){var e=this.anchor,t=this.lead;return e.row>t.row||e.row==t.row&&e.column>t.column},this.getRange=function(){var e=this.anchor,t=this.lead;return this.$isEmpty?o.fromPoints(t,t):this.isBackwards()?o.fromPoints(t,e):o.fromPoints(e,t)},this.clearSelection=function(){this.$isEmpty||(this.$isEmpty=!0,this._emit("changeSelection"))},this.selectAll=function(){this.$setSelection(0,0,Number.MAX_VALUE,Number.MAX_VALUE)},this.setRange=this.setSelectionRange=function(e,t){var n=t?e.end:e.start,r=t?e.start:e.end;this.$setSelection(n.row,n.column,r.row,r.column)},this.$setSelection=function(e,t,n,r){if(this.$silent)return;var i=this.$isEmpty,s=this.inMultiSelectMode;this.$silent=!0,this.$cursorChanged=this.$anchorChanged=!1,this.anchor.setPosition(e,t),this.cursor.setPosition(n,r),this.$isEmpty=!o.comparePoints(this.anchor,this.cursor),this.$silent=!1,this.$cursorChanged&&this._emit("changeCursor"),(this.$cursorChanged||this.$anchorChanged||i!=this.$isEmpty||s)&&this._emit("changeSelection")},this.$moveSelection=function(e){var t=this.lead;this.$isEmpty&&this.setSelectionAnchor(t.row,t.column),e.call(this)},this.selectTo=function(e,t){this.$moveSelection(function(){this.moveCursorTo(e,t)})},this.selectToPosition=function(e){this.$moveSelection(function(){this.moveCursorToPosition(e)})},this.moveTo=function(e,t){this.clearSelection(),this.moveCursorTo(e,t)},this.moveToPosition=function(e){this.clearSelection(),this.moveCursorToPosition(e)},this.selectUp=function(){this.$moveSelection(this.moveCursorUp)},this.selectDown=function(){this.$moveSelection(this.moveCursorDown)},this.selectRight=function(){this.$moveSelection(this.moveCursorRight)},this.selectLeft=function(){this.$moveSelection(this.moveCursorLeft)},this.selectLineStart=function(){this.$moveSelection(this.moveCursorLineStart)},this.selectLineEnd=function(){this.$moveSelection(this.moveCursorLineEnd)},this.selectFileEnd=function(){this.$moveSelection(this.moveCursorFileEnd)},this.selectFileStart=function(){this.$moveSelection(this.moveCursorFileStart)},this.selectWordRight=function(){this.$moveSelection(this.moveCursorWordRight)},this.selectWordLeft=function(){this.$moveSelection(this.moveCursorWordLeft)},this.getWordRange=function(e,t){if(typeof t=="undefined"){var n=e||this.lead;e=n.row,t=n.column}return this.session.getWordRange(e,t)},this.selectWord=function(){this.setSelectionRange(this.getWordRange())},this.selectAWord=function(){var e=this.getCursor(),t=this.session.getAWordRange(e.row,e.column);this.setSelectionRange(t)},this.getLineRange=function(e,t){var n=typeof e=="number"?e:this.lead.row,r,i=this.session.getFoldLine(n);return i?(n=i.start.row,r=i.end.row):r=n,t===!0?new o(n,0,r,this.session.getLine(r).length):new o(n,0,r+1,0)},this.selectLine=function(){this.setSelectionRange(this.getLineRange())},this.moveCursorUp=function(){this.moveCursorBy(-1,0)},this.moveCursorDown=function(){this.moveCursorBy(1,0)},this.wouldMoveIntoSoftTab=function(e,t,n){var r=e.column,i=e.column+t;return n<0&&(r=e.column-t,i=e.column),this.session.isTabStop(e)&&this.doc.getLine(e.row).slice(r,i).split(" ").length-1==t},this.moveCursorLeft=function(){var e=this.lead.getPosition(),t;if(t=this.session.getFoldAt(e.row,e.column,-1))this.moveCursorTo(t.start.row,t.start.column);else if(e.column===0)e.row>0&&this.moveCursorTo(e.row-1,this.doc.getLine(e.row-1).length);else{var n=this.session.getTabSize();this.wouldMoveIntoSoftTab(e,n,-1)&&!this.session.getNavigateWithinSoftTabs()?this.moveCursorBy(0,-n):this.moveCursorBy(0,-1)}},this.moveCursorRight=function(){var e=this.lead.getPosition(),t;if(t=this.session.getFoldAt(e.row,e.column,1))this.moveCursorTo(t.end.row,t.end.column);else if(this.lead.column==this.doc.getLine(this.lead.row).length)this.lead.row<this.doc.getLength()-1&&this.moveCursorTo(this.lead.row+1,0);else{var n=this.session.getTabSize(),e=this.lead;this.wouldMoveIntoSoftTab(e,n,1)&&!this.session.getNavigateWithinSoftTabs()?this.moveCursorBy(0,n):this.moveCursorBy(0,1)}},this.moveCursorLineStart=function(){var e=this.lead.row,t=this.lead.column,n=this.session.documentToScreenRow(e,t),r=this.session.screenToDocumentPosition(n,0),i=this.session.getDisplayLine(e,null,r.row,r.column),s=i.match(/^\s*/);s[0].length!=t&&!this.session.$useEmacsStyleLineStart&&(r.column+=s[0].length),this.moveCursorToPosition(r)},this.moveCursorLineEnd=function(){var e=this.lead,t=this.session.getDocumentLastRowColumnPosition(e.row,e.column);if(this.lead.column==t.column){var n=this.session.getLine(t.row);if(t.column==n.length){var r=n.search(/\s+$/);r>0&&(t.column=r)}}this.moveCursorTo(t.row,t.column)},this.moveCursorFileEnd=function(){var e=this.doc.getLength()-1,t=this.doc.getLine(e).length;this.moveCursorTo(e,t)},this.moveCursorFileStart=function(){this.moveCursorTo(0,0)},this.moveCursorLongWordRight=function(){var e=this.lead.row,t=this.lead.column,n=this.doc.getLine(e),r=n.substring(t);this.session.nonTokenRe.lastIndex=0,this.session.tokenRe.lastIndex=0;var i=this.session.getFoldAt(e,t,1);if(i){this.moveCursorTo(i.end.row,i.end.column);return}this.session.nonTokenRe.exec(r)&&(t+=this.session.nonTokenRe.lastIndex,this.session.nonTokenRe.lastIndex=0,r=n.substring(t));if(t>=n.length){this.moveCursorTo(e,n.length),this.moveCursorRight(),e<this.doc.getLength()-1&&this.moveCursorWordRight();return}this.session.tokenRe.exec(r)&&(t+=this.session.tokenRe.lastIndex,this.session.tokenRe.lastIndex=0),this.moveCursorTo(e,t)},this.moveCursorLongWordLeft=function(){var e=this.lead.row,t=this.lead.column,n;if(n=this.session.getFoldAt(e,t,-1)){this.moveCursorTo(n.start.row,n.start.column);return}var r=this.session.getFoldStringAt(e,t,-1);r==null&&(r=this.doc.getLine(e).substring(0,t));var s=i.stringReverse(r);this.session.nonTokenRe.lastIndex=0,this.session.tokenRe.lastIndex=0,this.session.nonTokenRe.exec(s)&&(t-=this.session.nonTokenRe.lastIndex,s=s.slice(this.session.nonTokenRe.lastIndex),this.session.nonTokenRe.lastIndex=0);if(t<=0){this.moveCursorTo(e,0),this.moveCursorLeft(),e>0&&this.moveCursorWordLeft();return}this.session.tokenRe.exec(s)&&(t-=this.session.tokenRe.lastIndex,this.session.tokenRe.lastIndex=0),this.moveCursorTo(e,t)},this.$shortWordEndIndex=function(e){var t=0,n,r=/\s/,i=this.session.tokenRe;i.lastIndex=0;if(this.session.tokenRe.exec(e))t=this.session.tokenRe.lastIndex;else{while((n=e[t])&&r.test(n))t++;if(t<1){i.lastIndex=0;while((n=e[t])&&!i.test(n)){i.lastIndex=0,t++;if(r.test(n)){if(t>2){t--;break}while((n=e[t])&&r.test(n))t++;if(t>2)break}}}}return i.lastIndex=0,t},this.moveCursorShortWordRight=function(){var e=this.lead.row,t=this.lead.column,n=this.doc.getLine(e),r=n.substring(t),i=this.session.getFoldAt(e,t,1);if(i)return this.moveCursorTo(i.end.row,i.end.column);if(t==n.length){var s=this.doc.getLength();do e++,r=this.doc.getLine(e);while(e<s&&/^\s*$/.test(r));/^\s+/.test(r)||(r=""),t=0}var o=this.$shortWordEndIndex(r);this.moveCursorTo(e,t+o)},this.moveCursorShortWordLeft=function(){var e=this.lead.row,t=this.lead.column,n;if(n=this.session.getFoldAt(e,t,-1))return this.moveCursorTo(n.start.row,n.start.column);var r=this.session.getLine(e).substring(0,t);if(t===0){do e--,r=this.doc.getLine(e);while(e>0&&/^\s*$/.test(r));t=r.length,/\s+$/.test(r)||(r="")}var s=i.stringReverse(r),o=this.$shortWordEndIndex(s);return this.moveCursorTo(e,t-o)},this.moveCursorWordRight=function(){this.session.$selectLongWords?this.moveCursorLongWordRight():this.moveCursorShortWordRight()},this.moveCursorWordLeft=function(){this.session.$selectLongWords?this.moveCursorLongWordLeft():this.moveCursorShortWordLeft()},this.moveCursorBy=function(e,t){var n=this.session.documentToScreenPosition(this.lead.row,this.lead.column),r;t===0&&(e!==0&&(this.session.$bidiHandler.isBidiRow(n.row,this.lead.row)?(r=this.session.$bidiHandler.getPosLeft(n.column),n.column=Math.round(r/this.session.$bidiHandler.charWidths[0])):r=n.column*this.session.$bidiHandler.charWidths[0]),this.$desiredColumn?n.column=this.$desiredColumn:this.$desiredColumn=n.column);if(e!=0&&this.session.lineWidgets&&this.session.lineWidgets[this.lead.row]){var i=this.session.lineWidgets[this.lead.row];e<0?e-=i.rowsAbove||0:e>0&&(e+=i.rowCount-(i.rowsAbove||0))}var s=this.session.screenToDocumentPosition(n.row+e,n.column,r);e!==0&&t===0&&s.row===this.lead.row&&s.column===this.lead.column,this.moveCursorTo(s.row,s.column+t,t===0)},this.moveCursorToPosition=function(e){this.moveCursorTo(e.row,e.column)},this.moveCursorTo=function(e,t,n){var r=this.session.getFoldAt(e,t,1);r&&(e=r.start.row,t=r.start.column),this.$keepDesiredColumnOnChange=!0;var i=this.session.getLine(e);/[\uDC00-\uDFFF]/.test(i.charAt(t))&&i.charAt(t-1)&&(this.lead.row==e&&this.lead.column==t+1?t-=1:t+=1),this.lead.setPosition(e,t),this.$keepDesiredColumnOnChange=!1,n||(this.$desiredColumn=null)},this.moveCursorToScreen=function(e,t,n){var r=this.session.screenToDocumentPosition(e,t);this.moveCursorTo(r.row,r.column,n)},this.detach=function(){this.lead.detach(),this.anchor.detach()},this.fromOrientedRange=function(e){this.setSelectionRange(e,e.cursor==e.start),this.$desiredColumn=e.desiredColumn||this.$desiredColumn},this.toOrientedRange=function(e){var t=this.getRange();return e?(e.start.column=t.start.column,e.start.row=t.start.row,e.end.column=t.end.column,e.end.row=t.end.row):e=t,e.cursor=this.isBackwards()?e.start:e.end,e.desiredColumn=this.$desiredColumn,e},this.getRangeOfMovements=function(e){var t=this.getCursor();try{e(this);var n=this.getCursor();return o.fromPoints(t,n)}catch(r){return o.fromPoints(t,t)}finally{this.moveCursorToPosition(t)}},this.toJSON=function(){if(this.rangeCount)var e=this.ranges.map(function(e){var t=e.clone();return t.isBackwards=e.cursor==e.start,t});else{var e=this.getRange();e.isBackwards=this.isBackwards()}return e},this.fromJSON=function(e){if(e.start==undefined){if(this.rangeList&&e.length>1){this.toSingleRange(e[0]);for(var t=e.length;t--;){var n=o.fromPoints(e[t].start,e[t].end);e[t].isBackwards&&(n.cursor=n.start),this.addRange(n,!0)}return}e=e[0]}this.rangeList&&this.toSingleRange(e),this.setSelectionRange(e,e.isBackwards)},this.isEqual=function(e){if((e.length||this.rangeCount)&&e.length!=this.rangeCount)return!1;if(!e.length||!this.ranges)return this.getRange().isEqual(e);for(var t=this.ranges.length;t--;)if(!this.ranges[t].isEqual(e[t]))return!1;return!0}}).call(u.prototype),t.Selection=u}),ace.define("ace/tokenizer",["require","exports","module","ace/config"],function(e,t,n){"use strict";var r=e("./config"),i=2e3,s=function(){function e(e){this.states=e,this.regExps={},this.matchMappings={};for(var t in this.states){var n=this.states[t],r=[],i=0,s=this.matchMappings[t]={defaultToken:"text"},o="g",u=[];for(var a=0;a<n.length;a++){var f=n[a];f.defaultToken&&(s.defaultToken=f.defaultToken),f.caseInsensitive&&o.indexOf("i")===-1&&(o+="i"),f.unicode&&o.indexOf("u")===-1&&(o+="u");if(f.regex==null)continue;f.regex instanceof RegExp&&(f.regex=f.regex.toString().slice(1,-1));var l=f.regex,c=(new RegExp("(?:("+l+")|(.))")).exec("a").length-2;Array.isArray(f.token)?f.token.length==1||c==1?f.token=f.token[0]:c-1!=f.token.length?(this.reportError("number of classes and regexp groups doesn't match",{rule:f,groupCount:c-1}),f.token=f.token[0]):(f.tokenArray=f.token,f.token=null,f.onMatch=this.$arrayTokens):typeof f.token=="function"&&!f.onMatch&&(c>1?f.onMatch=this.$applyToken:f.onMatch=f.token),c>1&&(/\\\d/.test(f.regex)?l=f.regex.replace(/\\([0-9]+)/g,function(e,t){return"\\"+(parseInt(t,10)+i+1)}):(c=1,l=this.removeCapturingGroups(f.regex)),!f.splitRegex&&typeof f.token!="string"&&u.push(f)),s[i]=a,i+=c,r.push(l),f.onMatch||(f.onMatch=null)}r.length||(s[0]=0,r.push("$")),u.forEach(function(e){e.splitRegex=this.createSplitterRegexp(e.regex,o)},this),this.regExps[t]=new RegExp("("+r.join(")|(")+")|($)",o)}}return e.prototype.$setMaxTokenCount=function(e){i=e|0},e.prototype.$applyToken=function(e){var t=this.splitRegex.exec(e).slice(1),n=this.token.apply(this,t);if(typeof n=="string")return[{type:n,value:e}];var r=[];for(var i=0,s=n.length;i<s;i++)t[i]&&(r[r.length]={type:n[i],value:t[i]});return r},e.prototype.$arrayTokens=function(e){if(!e)return[];var t=this.splitRegex.exec(e);if(!t)return"text";var n=[],r=this.tokenArray;for(var i=0,s=r.length;i<s;i++)t[i+1]&&(n[n.length]={type:r[i],value:t[i+1]});return n},e.prototype.removeCapturingGroups=function(e){var t=e.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g,function(e,t){return t?"(?:":e});return t},e.prototype.createSplitterRegexp=function(e,t){if(e.indexOf("(?=")!=-1){var n=0,r=!1,i={};e.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g,function(e,t,s,o,u,a){return r?r=u!="]":u?r=!0:o?(n==i.stack&&(i.end=a+1,i.stack=-1),n--):s&&(n++,s.length!=1&&(i.stack=n,i.start=a)),e}),i.end!=null&&/^\)*$/.test(e.substr(i.end))&&(e=e.substring(0,i.start)+e.substr(i.end))}return e.charAt(0)!="^"&&(e="^"+e),e.charAt(e.length-1)!="$"&&(e+="$"),new RegExp(e,(t||"").replace("g",""))},e.prototype.getLineTokens=function(e,t){if(t&&typeof t!="string"){var n=t.slice(0);t=n[0],t==="#tmp"&&(n.shift(),t=n.shift())}else var n=[];var r=t||"start",s=this.states[r];s||(r="start",s=this.states[r]);var o=this.matchMappings[r],u=this.regExps[r];u.lastIndex=0;var a,f=[],l=0,c=0,h={type:null,value:""};while(a=u.exec(e)){var p=o.defaultToken,d=null,v=a[0],m=u.lastIndex;if(m-v.length>l){var g=e.substring(l,m-v.length);h.type==p?h.value+=g:(h.type&&f.push(h),h={type:p,value:g})}for(var y=0;y<a.length-2;y++){if(a[y+1]===undefined)continue;d=s[o[y]],d.onMatch?p=d.onMatch(v,r,n,e):p=d.token,d.next&&(typeof d.next=="string"?r=d.next:r=d.next(r,n),s=this.states[r],s||(this.reportError("state doesn't exist",r),r="start",s=this.states[r]),o=this.matchMappings[r],l=m,u=this.regExps[r],u.lastIndex=m),d.consumeLineEnd&&(l=m);break}if(v)if(typeof p=="string")!!d&&d.merge===!1||h.type!==p?(h.type&&f.push(h),h={type:p,value:v}):h.value+=v;else if(p){h.type&&f.push(h),h={type:null,value:""};for(var y=0;y<p.length;y++)f.push(p[y])}if(l==e.length)break;l=m;if(c++>i){c>2*e.length&&this.reportError("infinite loop with in ace tokenizer",{startState:t,line:e});while(l<e.length)h.type&&f.push(h),h={value:e.substring(l,l+=500),type:"overflow"};r="start",n=[];break}}return h.type&&f.push(h),n.length>1&&n[0]!==r&&n.unshift("#tmp",r),{tokens:f,state:n.length?n:r}},e}();s.prototype.reportError=r.reportError,t.Tokenizer=s}),ace.define("ace/mode/text_highlight_rules",["require","exports","module","ace/lib/lang"],function(e,t,n){"use strict";var r=e("../lib/lang"),i=function(){this.$rules={start:[{token:"empty_line",regex:"^$"},{defaultToken:"text"}]}};(function(){this.addRules=function(e,t){if(!t){for(var n in e)this.$rules[n]=e[n];return}for(var n in e){var r=e[n];for(var i=0;i<r.length;i++){var s=r[i];if(s.next||s.onMatch)typeof s.next=="string"&&s.next.indexOf(t)!==0&&(s.next=t+s.next),s.nextState&&s.nextState.indexOf(t)!==0&&(s.nextState=t+s.nextState)}this.$rules[t+n]=r}},this.getRules=function(){return this.$rules},this.embedRules=function(e,t,n,i,s){var o=typeof e=="function"?(new e).getRules():e;if(i)for(var u=0;u<i.length;u++)i[u]=t+i[u];else{i=[];for(var a in o)i.push(t+a)}this.addRules(o,t);if(n){var f=Array.prototype[s?"push":"unshift"];for(var u=0;u<i.length;u++)f.apply(this.$rules[i[u]],r.deepCopy(n))}this.$embeds||(this.$embeds=[]),this.$embeds.push(t)},this.getEmbeds=function(){return this.$embeds};var e=function(e,t){return(e!="start"||t.length)&&t.unshift(this.nextState,e),this.nextState},t=function(e,t){return t.shift(),t.shift()||"start"};this.normalizeRules=function(){function i(s){var o=r[s];o.processed=!0;for(var u=0;u<o.length;u++){var a=o[u],f=null;Array.isArray(a)&&(f=a,a={}),!a.regex&&a.start&&(a.regex=a.start,a.next||(a.next=[]),a.next.push({defaultToken:a.token},{token:a.token+".end",regex:a.end||a.start,next:"pop"}),a.token=a.token+".start",a.push=!0);var l=a.next||a.push;if(l&&Array.isArray(l)){var c=a.stateName;c||(c=a.token,typeof c!="string"&&(c=c[0]||""),r[c]&&(c+=n++)),r[c]=l,a.next=c,i(c)}else l=="pop"&&(a.next=t);a.push&&(a.nextState=a.next||a.push,a.next=e,delete a.push);if(a.rules)for(var h in a.rules)r[h]?r[h].push&&r[h].push.apply(r[h],a.rules[h]):r[h]=a.rules[h];var p=typeof a=="string"?a:a.include;p&&(p==="$self"&&(p="start"),Array.isArray(p)?f=p.map(function(e){return r[e]}):f=r[p]);if(f){var d=[u,1].concat(f);a.noEscape&&(d=d.filter(function(e){return!e.next})),o.splice.apply(o,d),u--}a.keywordMap&&(a.token=this.createKeywordMapper(a.keywordMap,a.defaultToken||"text",a.caseInsensitive),delete a.defaultToken)}}var n=0,r=this.$rules;Object.keys(r).forEach(i,this)},this.createKeywordMapper=function(e,t,n,r){var i=Object.create(null);return this.$keywordList=[],Object.keys(e).forEach(function(t){var s=e[t],o=s.split(r||"|");for(var u=o.length;u--;){var a=o[u];this.$keywordList.push(a),n&&(a=a.toLowerCase()),i[a]=t}},this),e=null,n?function(e){return i[e.toLowerCase()]||t}:function(e){return i[e]||t}},this.getKeywords=function(){return this.$keywords}}).call(i.prototype),t.TextHighlightRules=i}),ace.define("ace/mode/behaviour",["require","exports","module"],function(e,t,n){"use strict";var r=function(){this.$behaviours={}};(function(){this.add=function(e,t,n){switch(undefined){case this.$behaviours:this.$behaviours={};case this.$behaviours[e]:this.$behaviours[e]={}}this.$behaviours[e][t]=n},this.addBehaviours=function(e){for(var t in e)for(var n in e[t])this.add(t,n,e[t][n])},this.remove=function(e){this.$behaviours&&this.$behaviours[e]&&delete this.$behaviours[e]},this.inherit=function(e,t){if(typeof e=="function")var n=(new e).getBehaviours(t);else var n=e.getBehaviours(t);this.addBehaviours(n)},this.getBehaviours=function(e){if(!e)return this.$behaviours;var t={};for(var n=0;n<e.length;n++)this.$behaviours[e[n]]&&(t[e[n]]=this.$behaviours[e[n]]);return t}}).call(r.prototype),t.Behaviour=r}),ace.define("ace/token_iterator",["require","exports","module","ace/range"],function(e,t,n){"use strict";var r=e("./range").Range,i=function(){function e(e,t,n){this.$session=e,this.$row=t,this.$rowTokens=e.getTokens(t);var r=e.getTokenAt(t,n);this.$tokenIndex=r?r.index:-1}return e.prototype.stepBackward=function(){this.$tokenIndex-=1;while(this.$tokenIndex<0){this.$row-=1;if(this.$row<0)return this.$row=0,null;this.$rowTokens=this.$session.getTokens(this.$row),this.$tokenIndex=this.$rowTokens.length-1}return this.$rowTokens[this.$tokenIndex]},e.prototype.stepForward=function(){this.$tokenIndex+=1;var e;while(this.$tokenIndex>=this.$rowTokens.length){this.$row+=1,e||(e=this.$session.getLength());if(this.$row>=e)return this.$row=e-1,null;this.$rowTokens=this.$session.getTokens(this.$row),this.$tokenIndex=0}return this.$rowTokens[this.$tokenIndex]},e.prototype.getCurrentToken=function(){return this.$rowTokens[this.$tokenIndex]},e.prototype.getCurrentTokenRow=function(){return this.$row},e.prototype.getCurrentTokenColumn=function(){var e=this.$rowTokens,t=this.$tokenIndex,n=e[t].start;if(n!==undefined)return n;n=0;while(t>0)t-=1,n+=e[t].value.length;return n},e.prototype.getCurrentTokenPosition=function(){return{row:this.$row,column:this.getCurrentTokenColumn()}},e.prototype.getCurrentTokenRange=function(){var e=this.$rowTokens[this.$tokenIndex],t=this.getCurrentTokenColumn();return new r(this.$row,t,this.$row,t+e.value.length)},e}();t.TokenIterator=i}),ace.define("ace/mode/behaviour/cstyle",["require","exports","module","ace/lib/oop","ace/mode/behaviour","ace/token_iterator","ace/lib/lang"],function(e,t,n){"use strict";var r=e("../../lib/oop"),i=e("../behaviour").Behaviour,s=e("../../token_iterator").TokenIterator,o=e("../../lib/lang"),u=["text","paren.rparen","rparen","paren","punctuation.operator"],a=["text","paren.rparen","rparen","paren","punctuation.operator","comment"],f,l={},c={'"':'"',"'":"'"},h=function(e){var t=-1;e.multiSelect&&(t=e.selection.index,l.rangeCount!=e.multiSelect.rangeCount&&(l={rangeCount:e.multiSelect.rangeCount}));if(l[t])return f=l[t];f=l[t]={autoInsertedBrackets:0,autoInsertedRow:-1,autoInsertedLineEnd:"",maybeInsertedBrackets:0,maybeInsertedRow:-1,maybeInsertedLineStart:"",maybeInsertedLineEnd:""}},p=function(e,t,n,r){var i=e.end.row-e.start.row;return{text:n+t+r,selection:[0,e.start.column+1,i,e.end.column+(i?0:1)]}},d=function(e){this.add("braces","insertion",function(t,n,r,i,s){var u=r.getCursorPosition(),a=i.doc.getLine(u.row);if(s=="{"){h(r);var l=r.getSelectionRange(),c=i.doc.getTextRange(l);if(c!==""&&c!=="{"&&r.getWrapBehavioursEnabled())return p(l,c,"{","}");if(d.isSaneInsertion(r,i))return/[\]\}\)]/.test(a[u.column])||r.inMultiSelectMode||e&&e.braces?(d.recordAutoInsert(r,i,"}"),{text:"{}",selection:[1,1]}):(d.recordMaybeInsert(r,i,"{"),{text:"{",selection:[1,1]})}else if(s=="}"){h(r);var v=a.substring(u.column,u.column+1);if(v=="}"){var m=i.$findOpeningBracket("}",{column:u.column+1,row:u.row});if(m!==null&&d.isAutoInsertedClosing(u,a,s))return d.popAutoInsertedClosing(),{text:"",selection:[1,1]}}}else{if(s=="\n"||s=="\r\n"){h(r);var g="";d.isMaybeInsertedClosing(u,a)&&(g=o.stringRepeat("}",f.maybeInsertedBrackets),d.clearMaybeInsertedClosing());var v=a.substring(u.column,u.column+1);if(v==="}"){var y=i.findMatchingBracket({row:u.row,column:u.column+1},"}");if(!y)return null;var b=this.$getIndent(i.getLine(y.row))}else{if(!g){d.clearMaybeInsertedClosing();return}var b=this.$getIndent(a)}var w=b+i.getTabString();return{text:"\n"+w+"\n"+b+g,selection:[1,w.length,1,w.length]}}d.clearMaybeInsertedClosing()}}),this.add("braces","deletion",function(e,t,n,r,i){var s=r.doc.getTextRange(i);if(!i.isMultiLine()&&s=="{"){h(n);var o=r.doc.getLine(i.start.row),u=o.substring(i.end.column,i.end.column+1);if(u=="}")return i.end.column++,i;f.maybeInsertedBrackets--}}),this.add("parens","insertion",function(e,t,n,r,i){if(i=="("){h(n);var s=n.getSelectionRange(),o=r.doc.getTextRange(s);if(o!==""&&n.getWrapBehavioursEnabled())return p(s,o,"(",")");if(d.isSaneInsertion(n,r))return d.recordAutoInsert(n,r,")"),{text:"()",selection:[1,1]}}else if(i==")"){h(n);var u=n.getCursorPosition(),a=r.doc.getLine(u.row),f=a.substring(u.column,u.column+1);if(f==")"){var l=r.$findOpeningBracket(")",{column:u.column+1,row:u.row});if(l!==null&&d.isAutoInsertedClosing(u,a,i))return d.popAutoInsertedClosing(),{text:"",selection:[1,1]}}}}),this.add("parens","deletion",function(e,t,n,r,i){var s=r.doc.getTextRange(i);if(!i.isMultiLine()&&s=="("){h(n);var o=r.doc.getLine(i.start.row),u=o.substring(i.start.column+1,i.start.column+2);if(u==")")return i.end.column++,i}}),this.add("brackets","insertion",function(e,t,n,r,i){if(i=="["){h(n);var s=n.getSelectionRange(),o=r.doc.getTextRange(s);if(o!==""&&n.getWrapBehavioursEnabled())return p(s,o,"[","]");if(d.isSaneInsertion(n,r))return d.recordAutoInsert(n,r,"]"),{text:"[]",selection:[1,1]}}else if(i=="]"){h(n);var u=n.getCursorPosition(),a=r.doc.getLine(u.row),f=a.substring(u.column,u.column+1);if(f=="]"){var l=r.$findOpeningBracket("]",{column:u.column+1,row:u.row});if(l!==null&&d.isAutoInsertedClosing(u,a,i))return d.popAutoInsertedClosing(),{text:"",selection:[1,1]}}}}),this.add("brackets","deletion",function(e,t,n,r,i){var s=r.doc.getTextRange(i);if(!i.isMultiLine()&&s=="["){h(n);var o=r.doc.getLine(i.start.row),u=o.substring(i.start.column+1,i.start.column+2);if(u=="]")return i.end.column++,i}}),this.add("string_dquotes","insertion",function(e,t,n,r,i){var s=r.$mode.$quotes||c;if(i.length==1&&s[i]){if(this.lineCommentStart&&this.lineCommentStart.indexOf(i)!=-1)return;h(n);var o=i,u=n.getSelectionRange(),a=r.doc.getTextRange(u);if(a!==""&&(a.length!=1||!s[a])&&n.getWrapBehavioursEnabled())return p(u,a,o,o);if(!a){var f=n.getCursorPosition(),l=r.doc.getLine(f.row),d=l.substring(f.column-1,f.column),v=l.substring(f.column,f.column+1),m=r.getTokenAt(f.row,f.column),g=r.getTokenAt(f.row,f.column+1);if(d=="\\"&&m&&/escape/.test(m.type))return null;var y=m&&/string|escape/.test(m.type),b=!g||/string|escape/.test(g.type),w;if(v==o)w=y!==b,w&&/string\.end/.test(g.type)&&(w=!1);else{if(y&&!b)return null;if(y&&b)return null;var E=r.$mode.tokenRe;E.lastIndex=0;var S=E.test(d);E.lastIndex=0;var x=E.test(v),T=r.$mode.$pairQuotesAfter,N=T&&T[o]&&T[o].test(d);if(!N&&S||x)return null;if(v&&!/[\s;,.})\]\\]/.test(v))return null;var C=l[f.column-2];if(!(d!=o||C!=o&&!E.test(C)))return null;w=!0}return{text:w?o+o:"",selection:[1,1]}}}}),this.add("string_dquotes","deletion",function(e,t,n,r,i){var s=r.$mode.$quotes||c,o=r.doc.getTextRange(i);if(!i.isMultiLine()&&s.hasOwnProperty(o)){h(n);var u=r.doc.getLine(i.start.row),a=u.substring(i.start.column+1,i.start.column+2);if(a==o)return i.end.column++,i}})};d.isSaneInsertion=function(e,t){var n=e.getCursorPosition(),r=new s(t,n.row,n.column);if(!this.$matchTokenType(r.getCurrentToken()||"text",u)){if(/[)}\]]/.test(e.session.getLine(n.row)[n.column]))return!0;var i=new s(t,n.row,n.column+1);if(!this.$matchTokenType(i.getCurrentToken()||"text",u))return!1}return r.stepForward(),r.getCurrentTokenRow()!==n.row||this.$matchTokenType(r.getCurrentToken()||"text",a)},d.$matchTokenType=function(e,t){return t.indexOf(e.type||e)>-1},d.recordAutoInsert=function(e,t,n){var r=e.getCursorPosition(),i=t.doc.getLine(r.row);this.isAutoInsertedClosing(r,i,f.autoInsertedLineEnd[0])||(f.autoInsertedBrackets=0),f.autoInsertedRow=r.row,f.autoInsertedLineEnd=n+i.substr(r.column),f.autoInsertedBrackets++},d.recordMaybeInsert=function(e,t,n){var r=e.getCursorPosition(),i=t.doc.getLine(r.row);this.isMaybeInsertedClosing(r,i)||(f.maybeInsertedBrackets=0),f.maybeInsertedRow=r.row,f.maybeInsertedLineStart=i.substr(0,r.column)+n,f.maybeInsertedLineEnd=i.substr(r.column),f.maybeInsertedBrackets++},d.isAutoInsertedClosing=function(e,t,n){return f.autoInsertedBrackets>0&&e.row===f.autoInsertedRow&&n===f.autoInsertedLineEnd[0]&&t.substr(e.column)===f.autoInsertedLineEnd},d.isMaybeInsertedClosing=function(e,t){return f.maybeInsertedBrackets>0&&e.row===f.maybeInsertedRow&&t.substr(e.column)===f.maybeInsertedLineEnd&&t.substr(0,e.column)==f.maybeInsertedLineStart},d.popAutoInsertedClosing=function(){f.autoInsertedLineEnd=f.autoInsertedLineEnd.substr(1),f.autoInsertedBrackets--},d.clearMaybeInsertedClosing=function(){f&&(f.maybeInsertedBrackets=0,f.maybeInsertedRow=-1)},r.inherits(d,i),t.CstyleBehaviour=d}),ace.define("ace/unicode",["require","exports","module"],function(e,t,n){"use strict";var r=[48,9,8,25,5,0,2,25,48,0,11,0,5,0,6,22,2,30,2,457,5,11,15,4,8,0,2,0,18,116,2,1,3,3,9,0,2,2,2,0,2,19,2,82,2,138,2,4,3,155,12,37,3,0,8,38,10,44,2,0,2,1,2,1,2,0,9,26,6,2,30,10,7,61,2,9,5,101,2,7,3,9,2,18,3,0,17,58,3,100,15,53,5,0,6,45,211,57,3,18,2,5,3,11,3,9,2,1,7,6,2,2,2,7,3,1,3,21,2,6,2,0,4,3,3,8,3,1,3,3,9,0,5,1,2,4,3,11,16,2,2,5,5,1,3,21,2,6,2,1,2,1,2,1,3,0,2,4,5,1,3,2,4,0,8,3,2,0,8,15,12,2,2,8,2,2,2,21,2,6,2,1,2,4,3,9,2,2,2,2,3,0,16,3,3,9,18,2,2,7,3,1,3,21,2,6,2,1,2,4,3,8,3,1,3,2,9,1,5,1,2,4,3,9,2,0,17,1,2,5,4,2,2,3,4,1,2,0,2,1,4,1,4,2,4,11,5,4,4,2,2,3,3,0,7,0,15,9,18,2,2,7,2,2,2,22,2,9,2,4,4,7,2,2,2,3,8,1,2,1,7,3,3,9,19,1,2,7,2,2,2,22,2,9,2,4,3,8,2,2,2,3,8,1,8,0,2,3,3,9,19,1,2,7,2,2,2,22,2,15,4,7,2,2,2,3,10,0,9,3,3,9,11,5,3,1,2,17,4,23,2,8,2,0,3,6,4,0,5,5,2,0,2,7,19,1,14,57,6,14,2,9,40,1,2,0,3,1,2,0,3,0,7,3,2,6,2,2,2,0,2,0,3,1,2,12,2,2,3,4,2,0,2,5,3,9,3,1,35,0,24,1,7,9,12,0,2,0,2,0,5,9,2,35,5,19,2,5,5,7,2,35,10,0,58,73,7,77,3,37,11,42,2,0,4,328,2,3,3,6,2,0,2,3,3,40,2,3,3,32,2,3,3,6,2,0,2,3,3,14,2,56,2,3,3,66,5,0,33,15,17,84,13,619,3,16,2,25,6,74,22,12,2,6,12,20,12,19,13,12,2,2,2,1,13,51,3,29,4,0,5,1,3,9,34,2,3,9,7,87,9,42,6,69,11,28,4,11,5,11,11,39,3,4,12,43,5,25,7,10,38,27,5,62,2,28,3,10,7,9,14,0,89,75,5,9,18,8,13,42,4,11,71,55,9,9,4,48,83,2,2,30,14,230,23,280,3,5,3,37,3,5,3,7,2,0,2,0,2,0,2,30,3,52,2,6,2,0,4,2,2,6,4,3,3,5,5,12,6,2,2,6,67,1,20,0,29,0,14,0,17,4,60,12,5,0,4,11,18,0,5,0,3,9,2,0,4,4,7,0,2,0,2,0,2,3,2,10,3,3,6,4,5,0,53,1,2684,46,2,46,2,132,7,6,15,37,11,53,10,0,17,22,10,6,2,6,2,6,2,6,2,6,2,6,2,6,2,6,2,31,48,0,470,1,36,5,2,4,6,1,5,85,3,1,3,2,2,89,2,3,6,40,4,93,18,23,57,15,513,6581,75,20939,53,1164,68,45,3,268,4,27,21,31,3,13,13,1,2,24,9,69,11,1,38,8,3,102,3,1,111,44,25,51,13,68,12,9,7,23,4,0,5,45,3,35,13,28,4,64,15,10,39,54,10,13,3,9,7,22,4,1,5,66,25,2,227,42,2,1,3,9,7,11171,13,22,5,48,8453,301,3,61,3,105,39,6,13,4,6,11,2,12,2,4,2,0,2,1,2,1,2,107,34,362,19,63,3,53,41,11,5,15,17,6,13,1,25,2,33,4,2,134,20,9,8,25,5,0,2,25,12,88,4,5,3,5,3,5,3,2],i=0,s=[];for(var o=0;o<r.length;o+=2)s.push(i+=r[o]),r[o+1]&&s.push(45,i+=r[o+1]);t.wordChars=String.fromCharCode.apply(null,s)}),ace.define("ace/mode/text",["require","exports","module","ace/config","ace/tokenizer","ace/mode/text_highlight_rules","ace/mode/behaviour/cstyle","ace/unicode","ace/lib/lang","ace/token_iterator","ace/range"],function(e,t,n){"use strict";var r=e("../config"),i=e("../tokenizer").Tokenizer,s=e("./text_highlight_rules").TextHighlightRules,o=e("./behaviour/cstyle").CstyleBehaviour,u=e("../unicode"),a=e("../lib/lang"),f=e("../token_iterator").TokenIterator,l=e("../range").Range,c=function(){this.HighlightRules=s};(function(){this.$defaultBehaviour=new o,this.tokenRe=new RegExp("^["+u.wordChars+"\\$_]+","g"),this.nonTokenRe=new RegExp("^(?:[^"+u.wordChars+"\\$_]|\\s])+","g"),this.getTokenizer=function(){return this.$tokenizer||(this.$highlightRules=this.$highlightRules||new this.HighlightRules(this.$highlightRuleConfig),this.$tokenizer=new i(this.$highlightRules.getRules())),this.$tokenizer},this.lineCommentStart="",this.blockComment="",this.toggleCommentLines=function(e,t,n,r){function w(e){for(var t=n;t<=r;t++)e(i.getLine(t),t)}var i=t.doc,s=!0,o=!0,u=Infinity,f=t.getTabSize(),l=!1;if(!this.lineCommentStart){if(!this.blockComment)return!1;var c=this.blockComment.start,h=this.blockComment.end,p=new RegExp("^(\\s*)(?:"+a.escapeRegExp(c)+")"),d=new RegExp("(?:"+a.escapeRegExp(h)+")\\s*$"),v=function(e,t){if(g(e,t))return;if(!s||/\S/.test(e))i.insertInLine({row:t,column:e.length},h),i.insertInLine({row:t,column:u},c)},m=function(e,t){var n;(n=e.match(d))&&i.removeInLine(t,e.length-n[0].length,e.length),(n=e.match(p))&&i.removeInLine(t,n[1].length,n[0].length)},g=function(e,n){if(p.test(e))return!0;var r=t.getTokens(n);for(var i=0;i<r.length;i++)if(r[i].type==="comment")return!0}}else{if(Array.isArray(this.lineCommentStart))var p=this.lineCommentStart.map(a.escapeRegExp).join("|"),c=this.lineCommentStart[0];else var p=a.escapeRegExp(this.lineCommentStart),c=this.lineCommentStart;p=new RegExp("^(\\s*)(?:"+p+") ?"),l=t.getUseSoftTabs();var m=function(e,t){var n=e.match(p);if(!n)return;var r=n[1].length,s=n[0].length;!b(e,r,s)&&n[0][s-1]==" "&&s--,i.removeInLine(t,r,s)},y=c+" ",v=function(e,t){if(!s||/\S/.test(e))b(e,u,u)?i.insertInLine({row:t,column:u},y):i.insertInLine({row:t,column:u},c)},g=function(e,t){return p.test(e)},b=function(e,t,n){var r=0;while(t--&&e.charAt(t)==" ")r++;if(r%f!=0)return!1;var r=0;while(e.charAt(n++)==" ")r++;return f>2?r%f!=f-1:r%f==0}}var E=Infinity;w(function(e,t){var n=e.search(/\S/);n!==-1?(n<u&&(u=n),o&&!g(e,t)&&(o=!1)):E>e.length&&(E=e.length)}),u==Infinity&&(u=E,s=!1,o=!1),l&&u%f!=0&&(u=Math.floor(u/f)*f),w(o?m:v)},this.toggleBlockComment=function(e,t,n,r){var i=this.blockComment;if(!i)return;!i.start&&i[0]&&(i=i[0]);var s=new f(t,r.row,r.column),o=s.getCurrentToken(),u=t.selection,a=t.selection.toOrientedRange(),c,h;if(o&&/comment/.test(o.type)){var p,d;while(o&&/comment/.test(o.type)){var v=o.value.indexOf(i.start);if(v!=-1){var m=s.getCurrentTokenRow(),g=s.getCurrentTokenColumn()+v;p=new l(m,g,m,g+i.start.length);break}o=s.stepBackward()}var s=new f(t,r.row,r.column),o=s.getCurrentToken();while(o&&/comment/.test(o.type)){var v=o.value.indexOf(i.end);if(v!=-1){var m=s.getCurrentTokenRow(),g=s.getCurrentTokenColumn()+v;d=new l(m,g,m,g+i.end.length);break}o=s.stepForward()}d&&t.remove(d),p&&(t.remove(p),c=p.start.row,h=-i.start.length)}else h=i.start.length,c=n.start.row,t.insert(n.end,i.end),t.insert(n.start,i.start);a.start.row==c&&(a.start.column+=h),a.end.row==c&&(a.end.column+=h),t.selection.fromOrientedRange(a)},this.getNextLineIndent=function(e,t,n){return this.$getIndent(t)},this.checkOutdent=function(e,t,n){return!1},this.autoOutdent=function(e,t,n){},this.$getIndent=function(e){return e.match(/^\s*/)[0]},this.createWorker=function(e){return null},this.createModeDelegates=function(e){this.$embeds=[],this.$modes={};for(var t in e)if(e[t]){var n=e[t],i=n.prototype.$id,s=r.$modes[i];s||(r.$modes[i]=s=new n),r.$modes[t]||(r.$modes[t]=s),this.$embeds.push(t),this.$modes[t]=s}var o=["toggleBlockComment","toggleCommentLines","getNextLineIndent","checkOutdent","autoOutdent","transformAction","getCompletions"];for(var t=0;t<o.length;t++)(function(e){var n=o[t],r=e[n];e[o[t]]=function(){return this.$delegator(n,arguments,r)}})(this)},this.$delegator=function(e,t,n){var r=t[0]||"start";if(typeof r!="string"){if(Array.isArray(r[2])){var i=r[2][r[2].length-1],s=this.$modes[i];if(s)return s[e].apply(s,[r[1]].concat([].slice.call(t,1)))}r=r[0]||"start"}for(var o=0;o<this.$embeds.length;o++){if(!this.$modes[this.$embeds[o]])continue;var u=r.split(this.$embeds[o]);if(!u[0]&&u[1]){t[0]=u[1];var s=this.$modes[this.$embeds[o]];return s[e].apply(s,t)}}var a=n.apply(this,t);return n?a:undefined},this.transformAction=function(e,t,n,r,i){if(this.$behaviour){var s=this.$behaviour.getBehaviours();for(var o in s)if(s[o][t]){var u=s[o][t].apply(this,arguments);if(u)return u}}},this.getKeywords=function(e){if(!this.completionKeywords){var t=this.$tokenizer.rules,n=[];for(var r in t){var i=t[r];for(var s=0,o=i.length;s<o;s++)if(typeof i[s].token=="string")/keyword|support|storage/.test(i[s].token)&&n.push(i[s].regex);else if(typeof i[s].token=="object")for(var u=0,a=i[s].token.length;u<a;u++)if(/keyword|support|storage/.test(i[s].token[u])){var r=i[s].regex.match(/\(.+?\)/g)[u];n.push(r.substr(1,r.length-2))}}this.completionKeywords=n}return e?n.concat(this.$keywordList||[]):this.$keywordList},this.$createKeywordList=function(){return this.$highlightRules||this.getTokenizer(),this.$keywordList=this.$highlightRules.$keywordList||[]},this.getCompletions=function(e,t,n,r){var i=this.$keywordList||this.$createKeywordList();return i.map(function(e){return{name:e,value:e,score:0,meta:"keyword"}})},this.$id="ace/mode/text"}).call(c.prototype),t.Mode=c}),ace.define("ace/apply_delta",["require","exports","module"],function(e,t,n){"use strict";function r(e,t){throw console.log("Invalid Delta:",e),"Invalid Delta: "+t}function i(e,t){return t.row>=0&&t.row<e.length&&t.column>=0&&t.column<=e[t.row].length}function s(e,t){t.action!="insert"&&t.action!="remove"&&r(t,"delta.action must be 'insert' or 'remove'"),t.lines instanceof Array||r(t,"delta.lines must be an Array"),(!t.start||!t.end)&&r(t,"delta.start/end must be an present");var n=t.start;i(e,t.start)||r(t,"delta.start must be contained in document");var s=t.end;t.action=="remove"&&!i(e,s)&&r(t,"delta.end must contained in document for 'remove' actions");var o=s.row-n.row,u=s.column-(o==0?n.column:0);(o!=t.lines.length-1||t.lines[o].length!=u)&&r(t,"delta.range must match delta lines")}t.applyDelta=function(e,t,n){var r=t.start.row,i=t.start.column,s=e[r]||"";switch(t.action){case"insert":var o=t.lines;if(o.length===1)e[r]=s.substring(0,i)+t.lines[0]+s.substring(i);else{var u=[r,1].concat(t.lines);e.splice.apply(e,u),e[r]=s.substring(0,i)+e[r],e[r+t.lines.length-1]+=s.substring(i)}break;case"remove":var a=t.end.column,f=t.end.row;r===f?e[r]=s.substring(0,i)+s.substring(a):e.splice(r,f-r+1,s.substring(0,i)+e[f].substring(a))}}}),ace.define("ace/anchor",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){"use strict";function o(e,t,n){var r=n?e.column<=t.column:e.column<t.column;return e.row<t.row||e.row==t.row&&r}function u(e,t,n){var r=e.action=="insert",i=(r?1:-1)*(e.end.row-e.start.row),s=(r?1:-1)*(e.end.column-e.start.column),u=e.start,a=r?u:e.end;return o(t,u,n)?{row:t.row,column:t.column}:o(a,t,!n)?{row:t.row+i,column:t.column+(t.row==a.row?s:0)}:{row:u.row,column:u.column}}var r=e("./lib/oop"),i=e("./lib/event_emitter").EventEmitter,s=function(){function e(e,t,n){this.$onChange=this.onChange.bind(this),this.attach(e),typeof n=="undefined"?this.setPosition(t.row,t.column):this.setPosition(t,n)}return e.prototype.getPosition=function(){return this.$clipPositionToDocument(this.row,this.column)},e.prototype.getDocument=function(){return this.document},e.prototype.onChange=function(e){if(e.start.row==e.end.row&&e.start.row!=this.row)return;if(e.start.row>this.row)return;var t=u(e,{row:this.row,column:this.column},this.$insertRight);this.setPosition(t.row,t.column,!0)},e.prototype.setPosition=function(e,t,n){var r;n?r={row:e,column:t}:r=this.$clipPositionToDocument(e,t);if(this.row==r.row&&this.column==r.column)return;var i={row:this.row,column:this.column};this.row=r.row,this.column=r.column,this._signal("change",{old:i,value:r})},e.prototype.detach=function(){this.document.off("change",this.$onChange)},e.prototype.attach=function(e){this.document=e||this.document,this.document.on("change",this.$onChange)},e.prototype.$clipPositionToDocument=function(e,t){var n={};return e>=this.document.getLength()?(n.row=Math.max(0,this.document.getLength()-1),n.column=this.document.getLine(n.row).length):e<0?(n.row=0,n.column=0):(n.row=e,n.column=Math.min(this.document.getLine(n.row).length,Math.max(0,t))),t<0&&(n.column=0),n},e}();s.prototype.$insertRight=!1,r.implement(s.prototype,i),t.Anchor=s}),ace.define("ace/document",["require","exports","module","ace/lib/oop","ace/apply_delta","ace/lib/event_emitter","ace/range","ace/anchor"],function(e,t,n){"use strict";var r=e("./lib/oop"),i=e("./apply_delta").applyDelta,s=e("./lib/event_emitter").EventEmitter,o=e("./range").Range,u=e("./anchor").Anchor,a=function(){function e(e){this.$lines=[""],e.length===0?this.$lines=[""]:Array.isArray(e)?this.insertMergedLines({row:0,column:0},e):this.insert({row:0,column:0},e)}return e.prototype.setValue=function(e){var t=this.getLength()-1;this.remove(new o(0,0,t,this.getLine(t).length)),this.insert({row:0,column:0},e||"")},e.prototype.getValue=function(){return this.getAllLines().join(this.getNewLineCharacter())},e.prototype.createAnchor=function(e,t){return new u(this,e,t)},e.prototype.$detectNewLine=function(e){var t=e.match(/^.*?(\r\n|\r|\n)/m);this.$autoNewLine=t?t[1]:"\n",this._signal("changeNewLineMode")},e.prototype.getNewLineCharacter=function(){switch(this.$newLineMode){case"windows":return"\r\n";case"unix":return"\n";default:return this.$autoNewLine||"\n"}},e.prototype.setNewLineMode=function(e){if(this.$newLineMode===e)return;this.$newLineMode=e,this._signal("changeNewLineMode")},e.prototype.getNewLineMode=function(){return this.$newLineMode},e.prototype.isNewLine=function(e){return e=="\r\n"||e=="\r"||e=="\n"},e.prototype.getLine=function(e){return this.$lines[e]||""},e.prototype.getLines=function(e,t){return this.$lines.slice(e,t+1)},e.prototype.getAllLines=function(){return this.getLines(0,this.getLength())},e.prototype.getLength=function(){return this.$lines.length},e.prototype.getTextRange=function(e){return this.getLinesForRange(e).join(this.getNewLineCharacter())},e.prototype.getLinesForRange=function(e){var t;if(e.start.row===e.end.row)t=[this.getLine(e.start.row).substring(e.start.column,e.end.column)];else{t=this.getLines(e.start.row,e.end.row),t[0]=(t[0]||"").substring(e.start.column);var n=t.length-1;e.end.row-e.start.row==n&&(t[n]=t[n].substring(0,e.end.column))}return t},e.prototype.insertLines=function(e,t){return console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead."),this.insertFullLines(e,t)},e.prototype.removeLines=function(e,t){return console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead."),this.removeFullLines(e,t)},e.prototype.insertNewLine=function(e){return console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead."),this.insertMergedLines(e,["",""])},e.prototype.insert=function(e,t){return this.getLength()<=1&&this.$detectNewLine(t),this.insertMergedLines(e,this.$split(t))},e.prototype.insertInLine=function(e,t){var n=this.clippedPos(e.row,e.column),r=this.pos(e.row,e.column+t.length);return this.applyDelta({start:n,end:r,action:"insert",lines:[t]},!0),this.clonePos(r)},e.prototype.clippedPos=function(e,t){var n=this.getLength();e===undefined?e=n:e<0?e=0:e>=n&&(e=n-1,t=undefined);var r=this.getLine(e);return t==undefined&&(t=r.length),t=Math.min(Math.max(t,0),r.length),{row:e,column:t}},e.prototype.clonePos=function(e){return{row:e.row,column:e.column}},e.prototype.pos=function(e,t){return{row:e,column:t}},e.prototype.$clipPosition=function(e){var t=this.getLength();return e.row>=t?(e.row=Math.max(0,t-1),e.column=this.getLine(t-1).length):(e.row=Math.max(0,e.row),e.column=Math.min(Math.max(e.column,0),this.getLine(e.row).length)),e},e.prototype.insertFullLines=function(e,t){e=Math.min(Math.max(e,0),this.getLength());var n=0;e<this.getLength()?(t=t.concat([""]),n=0):(t=[""].concat(t),e--,n=this.$lines[e].length),this.insertMergedLines({row:e,column:n},t)},e.prototype.insertMergedLines=function(e,t){var n=this.clippedPos(e.row,e.column),r={row:n.row+t.length-1,column:(t.length==1?n.column:0)+t[t.length-1].length};return this.applyDelta({start:n,end:r,action:"insert",lines:t}),this.clonePos(r)},e.prototype.remove=function(e){var t=this.clippedPos(e.start.row,e.start.column),n=this.clippedPos(e.end.row,e.end.column);return this.applyDelta({start:t,end:n,action:"remove",lines:this.getLinesForRange({start:t,end:n})}),this.clonePos(t)},e.prototype.removeInLine=function(e,t,n){var r=this.clippedPos(e,t),i=this.clippedPos(e,n);return this.applyDelta({start:r,end:i,action:"remove",lines:this.getLinesForRange({start:r,end:i})},!0),this.clonePos(r)},e.prototype.removeFullLines=function(e,t){e=Math.min(Math.max(0,e),this.getLength()-1),t=Math.min(Math.max(0,t),this.getLength()-1);var n=t==this.getLength()-1&&e>0,r=t<this.getLength()-1,i=n?e-1:e,s=n?this.getLine(i).length:0,u=r?t+1:t,a=r?0:this.getLine(u).length,f=new o(i,s,u,a),l=this.$lines.slice(e,t+1);return this.applyDelta({start:f.start,end:f.end,action:"remove",lines:this.getLinesForRange(f)}),l},e.prototype.removeNewLine=function(e){e<this.getLength()-1&&e>=0&&this.applyDelta({start:this.pos(e,this.getLine(e).length),end:this.pos(e+1,0),action:"remove",lines:["",""]})},e.prototype.replace=function(e,t){e instanceof o||(e=o.fromPoints(e.start,e.end));if(t.length===0&&e.isEmpty())return e.start;if(t==this.getTextRange(e))return e.end;this.remove(e);var n;return t?n=this.insert(e.start,t):n=e.start,n},e.prototype.applyDeltas=function(e){for(var t=0;t<e.length;t++)this.applyDelta(e[t])},e.prototype.revertDeltas=function(e){for(var t=e.length-1;t>=0;t--)this.revertDelta(e[t])},e.prototype.applyDelta=function(e,t){var n=e.action=="insert";if(n?e.lines.length<=1&&!e.lines[0]:!o.comparePoints(e.start,e.end))return;n&&e.lines.length>2e4?this.$splitAndapplyLargeDelta(e,2e4):(i(this.$lines,e,t),this._signal("change",e))},e.prototype.$safeApplyDelta=function(e){var t=this.$lines.length;(e.action=="remove"&&e.start.row<t&&e.end.row<t||e.action=="insert"&&e.start.row<=t)&&this.applyDelta(e)},e.prototype.$splitAndapplyLargeDelta=function(e,t){var n=e.lines,r=n.length-t+1,i=e.start.row,s=e.start.column;for(var o=0,u=0;o<r;o=u){u+=t-1;var a=n.slice(o,u);a.push(""),this.applyDelta({start:this.pos(i+o,s),end:this.pos(i+u,s=0),action:e.action,lines:a},!0)}e.lines=n.slice(o),e.start.row=i+o,e.start.column=s,this.applyDelta(e,!0)},e.prototype.revertDelta=function(e){this.$safeApplyDelta({start:this.clonePos(e.start),end:this.clonePos(e.end),action:e.action=="insert"?"remove":"insert",lines:e.lines.slice()})},e.prototype.indexToPosition=function(e,t){var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length;for(var i=t||0,s=n.length;i<s;i++){e-=n[i].length+r;if(e<0)return{row:i,column:e+n[i].length+r}}return{row:s-1,column:e+n[s-1].length+r}},e.prototype.positionToIndex=function(e,t){var n=this.$lines||this.getAllLines(),r=this.getNewLineCharacter().length,i=0,s=Math.min(e.row,n.length);for(var o=t||0;o<s;++o)i+=n[o].length+r;return i+e.column},e}();a.prototype.$split="aaa".split(/a/).length===0?function(e){return e.replace(/\r\n|\r/g,"\n").split("\n")}:function(e){return e.split(/\r\n|\r|\n/)},a.prototype.$autoNewLine="",a.prototype.$newLineMode="auto",r.implement(a.prototype,s),t.Document=a}),ace.define("ace/background_tokenizer",["require","exports","module","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){"use strict";var r=e("./lib/oop"),i=e("./lib/event_emitter").EventEmitter,s=function(){function e(e,t){this.running=!1,this.lines=[],this.states=[],this.currentLine=0,this.tokenizer=e;var n=this;this.$worker=function(){if(!n.running)return;var e=new Date,t=n.currentLine,r=-1,i=n.doc,s=t;while(n.lines[t])t++;var o=i.getLength(),u=0;n.running=!1;while(t<o){n.$tokenizeRow(t),r=t;do t++;while(n.lines[t]);u++;if(u%5===0&&new Date-e>20){n.running=setTimeout(n.$worker,20);break}}n.currentLine=t,r==-1&&(r=t),s<=r&&n.fireUpdateEvent(s,r)}}return e.prototype.setTokenizer=function(e){this.tokenizer=e,this.lines=[],this.states=[],this.start(0)},e.prototype.setDocument=function(e){this.doc=e,this.lines=[],this.states=[],this.stop()},e.prototype.fireUpdateEvent=function(e,t){var n={first:e,last:t};this._signal("update",{data:n})},e.prototype.start=function(e){this.currentLine=Math.min(e||0,this.currentLine,this.doc.getLength()),this.lines.splice(this.currentLine,this.lines.length),this.states.splice(this.currentLine,this.states.length),this.stop(),this.running=setTimeout(this.$worker,700)},e.prototype.scheduleStart=function(){this.running||(this.running=setTimeout(this.$worker,700))},e.prototype.$updateOnChange=function(e){var t=e.start.row,n=e.end.row-t;if(n===0)this.lines[t]=null;else if(e.action=="remove")this.lines.splice(t,n+1,null),this.states.splice(t,n+1,null);else{var r=Array(n+1);r.unshift(t,1),this.lines.splice.apply(this.lines,r),this.states.splice.apply(this.states,r)}this.currentLine=Math.min(t,this.currentLine,this.doc.getLength()),this.stop()},e.prototype.stop=function(){this.running&&clearTimeout(this.running),this.running=!1},e.prototype.getTokens=function(e){return this.lines[e]||this.$tokenizeRow(e)},e.prototype.getState=function(e){return this.currentLine==e&&this.$tokenizeRow(e),this.states[e]||"start"},e.prototype.$tokenizeRow=function(e){var t=this.doc.getLine(e),n=this.states[e-1],r=this.tokenizer.getLineTokens(t,n,e);return this.states[e]+""!=r.state+""?(this.states[e]=r.state,this.lines[e+1]=null,this.currentLine>e+1&&(this.currentLine=e+1)):this.currentLine==e&&(this.currentLine=e+1),this.lines[e]=r.tokens},e.prototype.cleanup=function(){this.running=!1,this.lines=[],this.states=[],this.currentLine=0,this.removeAllListeners()},e}();r.implement(s.prototype,i),t.BackgroundTokenizer=s}),ace.define("ace/search_highlight",["require","exports","module","ace/lib/lang","ace/range"],function(e,t,n){"use strict";var r=e("./lib/lang"),i=e("./range").Range,s=function(){function e(e,t,n){n===void 0&&(n="text"),this.setRegexp(e),this.clazz=t,this.type=n}return e.prototype.setRegexp=function(e){if(this.regExp+""==e+"")return;this.regExp=e,this.cache=[]},e.prototype.update=function(e,t,n,s){if(!this.regExp)return;var o=s.firstRow,u=s.lastRow,a={};for(var f=o;f<=u;f++){var l=this.cache[f];l==null&&(l=r.getMatchOffsets(n.getLine(f),this.regExp),l.length>this.MAX_RANGES&&(l=l.slice(0,this.MAX_RANGES)),l=l.map(function(e){return new i(f,e.offset,f,e.offset+e.length)}),this.cache[f]=l.length?l:"");for(var c=l.length;c--;){var h=l[c].toScreenRange(n),p=h.toString();if(a[p])continue;a[p]=!0,t.drawSingleLineMarker(e,h,this.clazz,s)}}},e}();s.prototype.MAX_RANGES=500,t.SearchHighlight=s}),ace.define("ace/edit_session/fold_line",["require","exports","module","ace/range"],function(e,t,n){"use strict";var r=e("../range").Range,i=function(){function e(e,t){this.foldData=e,Array.isArray(t)?this.folds=t:t=this.folds=[t];var n=t[t.length-1];this.range=new r(t[0].start.row,t[0].start.column,n.end.row,n.end.column),this.start=this.range.start,this.end=this.range.end,this.folds.forEach(function(e){e.setFoldLine(this)},this)}return e.prototype.shiftRow=function(e){this.start.row+=e,this.end.row+=e,this.folds.forEach(function(t){t.start.row+=e,t.end.row+=e})},e.prototype.addFold=function(e){if(e.sameRow){if(e.start.row<this.startRow||e.endRow>this.endRow)throw new Error("Can't add a fold to this FoldLine as it has no connection");this.folds.push(e),this.folds.sort(function(e,t){return-e.range.compareEnd(t.start.row,t.start.column)}),this.range.compareEnd(e.start.row,e.start.column)>0?(this.end.row=e.end.row,this.end.column=e.end.column):this.range.compareStart(e.end.row,e.end.column)<0&&(this.start.row=e.start.row,this.start.column=e.start.column)}else if(e.start.row==this.end.row)this.folds.push(e),this.end.row=e.end.row,this.end.column=e.end.column;else{if(e.end.row!=this.start.row)throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");this.folds.unshift(e),this.start.row=e.start.row,this.start.column=e.start.column}e.foldLine=this},e.prototype.containsRow=function(e){return e>=this.start.row&&e<=this.end.row},e.prototype.walk=function(e,t,n){var r=0,i=this.folds,s,o,u,a=!0;t==null&&(t=this.end.row,n=this.end.column);for(var f=0;f<i.length;f++){s=i[f],o=s.range.compareStart(t,n);if(o==-1){e(null,t,n,r,a);return}u=e(null,s.start.row,s.start.column,r,a),u=!u&&e(s.placeholder,s.start.row,s.start.column,r);if(u||o===0)return;a=!s.sameRow,r=s.end.column}e(null,t,n,r,a)},e.prototype.getNextFoldTo=function(e,t){var n,r;for(var i=0;i<this.folds.length;i++){n=this.folds[i],r=n.range.compareEnd(e,t);if(r==-1)return{fold:n,kind:"after"};if(r===0)return{fold:n,kind:"inside"}}return null},e.prototype.addRemoveChars=function(e,t,n){var r=this.getNextFoldTo(e,t),i,s;if(r){i=r.fold;if(r.kind=="inside"&&i.start.column!=t&&i.start.row!=e)window.console&&window.console.log(e,t,i);else if(i.start.row==e){s=this.folds;var o=s.indexOf(i);o===0&&(this.start.column+=n);for(o;o<s.length;o++){i=s[o],i.start.column+=n;if(!i.sameRow)return;i.end.column+=n}this.end.column+=n}}},e.prototype.split=function(t,n){var r=this.getNextFoldTo(t,n);if(!r||r.kind=="inside")return null;var i=r.fold,s=this.folds,o=this.foldData,u=s.indexOf(i),a=s[u-1];this.end.row=a.end.row,this.end.column=a.end.column,s=s.splice(u,s.length-u);var f=new e(o,s);return o.splice(o.indexOf(this)+1,0,f),f},e.prototype.merge=function(e){var t=e.folds;for(var n=0;n<t.length;n++)this.addFold(t[n]);var r=this.foldData;r.splice(r.indexOf(e),1)},e.prototype.toString=function(){var e=[this.range.toString()+": ["];return this.folds.forEach(function(t){e.push("  "+t.toString())}),e.push("]"),e.join("\n")},e.prototype.idxToPosition=function(e){var t=0;for(var n=0;n<this.folds.length;n++){var r=this.folds[n];e-=r.start.column-t;if(e<0)return{row:r.start.row,column:r.start.column+e};e-=r.placeholder.length;if(e<0)return r.start;t=r.end.column}return{row:this.end.row,column:this.end.column+e}},e}();t.FoldLine=i}),ace.define("ace/range_list",["require","exports","module","ace/range"],function(e,t,n){"use strict";var r=e("./range").Range,i=r.comparePoints,s=function(){function e(){this.ranges=[],this.$bias=1}return e.prototype.pointIndex=function(e,t,n){var r=this.ranges;for(var s=n||0;s<r.length;s++){var o=r[s],u=i(e,o.end);if(u>0)continue;var a=i(e,o.start);return u===0?t&&a!==0?-s-2:s:a>0||a===0&&!t?s:-s-1}return-s-1},e.prototype.add=function(e){var t=!e.isEmpty(),n=this.pointIndex(e.start,t);n<0&&(n=-n-1);var r=this.pointIndex(e.end,t,n);return r<0?r=-r-1:r++,this.ranges.splice(n,r-n,e)},e.prototype.addList=function(e){var t=[];for(var n=e.length;n--;)t.push.apply(t,this.add(e[n]));return t},e.prototype.substractPoint=function(e){var t=this.pointIndex(e);if(t>=0)return this.ranges.splice(t,1)},e.prototype.merge=function(){var e=[],t=this.ranges;t=t.sort(function(e,t){return i(e.start,t.start)});var n=t[0],r;for(var s=1;s<t.length;s++){r=n,n=t[s];var o=i(r.end,n.start);if(o<0)continue;if(o==0&&!r.isEmpty()&&!n.isEmpty())continue;i(r.end,n.end)<0&&(r.end.row=n.end.row,r.end.column=n.end.column),t.splice(s,1),e.push(n),n=r,s--}return this.ranges=t,e},e.prototype.contains=function(e,t){return this.pointIndex({row:e,column:t})>=0},e.prototype.containsPoint=function(e){return this.pointIndex(e)>=0},e.prototype.rangeAtPoint=function(e){var t=this.pointIndex(e);if(t>=0)return this.ranges[t]},e.prototype.clipRows=function(e,t){var n=this.ranges;if(n[0].start.row>t||n[n.length-1].start.row<e)return[];var r=this.pointIndex({row:e,column:0});r<0&&(r=-r-1);var i=this.pointIndex({row:t,column:0},r);i<0&&(i=-i-1);var s=[];for(var o=r;o<i;o++)s.push(n[o]);return s},e.prototype.removeAll=function(){return this.ranges.splice(0,this.ranges.length)},e.prototype.attach=function(e){this.session&&this.detach(),this.session=e,this.onChange=this.$onChange.bind(this),this.session.on("change",this.onChange)},e.prototype.detach=function(){if(!this.session)return;this.session.removeListener("change",this.onChange),this.session=null},e.prototype.$onChange=function(e){var t=e.start,n=e.end,r=t.row,i=n.row,s=this.ranges;for(var o=0,u=s.length;o<u;o++){var a=s[o];if(a.end.row>=r)break}if(e.action=="insert"){var f=i-r,l=-t.column+n.column;for(;o<u;o++){var a=s[o];if(a.start.row>r)break;a.start.row==r&&a.start.column>=t.column&&(a.start.column==t.column&&this.$bias<=0||(a.start.column+=l,a.start.row+=f));if(a.end.row==r&&a.end.column>=t.column){if(a.end.column==t.column&&this.$bias<0)continue;a.end.column==t.column&&l>0&&o<u-1&&a.end.column>a.start.column&&a.end.column==s[o+1].start.column&&(a.end.column-=l),a.end.column+=l,a.end.row+=f}}}else{var f=r-i,l=t.column-n.column;for(;o<u;o++){var a=s[o];if(a.start.row>i)break;if(a.end.row<i&&(r<a.end.row||r==a.end.row&&t.column<a.end.column))a.end.row=r,a.end.column=t.column;else if(a.end.row==i)if(a.end.column<=n.column){if(f||a.end.column>t.column)a.end.column=t.column,a.end.row=t.row}else a.end.column+=l,a.end.row+=f;else a.end.row>i&&(a.end.row+=f);if(a.start.row<i&&(r<a.start.row||r==a.start.row&&t.column<a.start.column))a.start.row=r,a.start.column=t.column;else if(a.start.row==i)if(a.start.column<=n.column){if(f||a.start.column>t.column)a.start.column=t.column,a.start.row=t.row}else a.start.column+=l,a.start.row+=f;else a.start.row>i&&(a.start.row+=f)}}if(f!=0&&o<u)for(;o<u;o++){var a=s[o];a.start.row+=f,a.end.row+=f}},e}();s.prototype.comparePoints=i,t.RangeList=s}),ace.define("ace/edit_session/fold",["require","exports","module","ace/range_list"],function(e,t,n){"use strict";function o(e,t){e.row-=t.row,e.row==0&&(e.column-=t.column)}function u(e,t){o(e.start,t),o(e.end,t)}function a(e,t){e.row==0&&(e.column+=t.column),e.row+=t.row}function f(e,t){a(e.start,t),a(e.end,t)}var r=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}if(typeof n!="function"&&n!==null)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");e(t,n),t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),i=e("../range_list").RangeList,s=function(e){function t(t,n){var r=e.call(this)||this;return r.foldLine=null,r.placeholder=n,r.range=t,r.start=t.start,r.end=t.end,r.sameRow=t.start.row==t.end.row,r.subFolds=r.ranges=[],r}return r(t,e),t.prototype.toString=function(){return'"'+this.placeholder+'" '+this.range.toString()},t.prototype.setFoldLine=function(e){this.foldLine=e,this.subFolds.forEach(function(t){t.setFoldLine(e)})},t.prototype.clone=function(){var e=this.range.clone(),n=new t(e,this.placeholder);return this.subFolds.forEach(function(e){n.subFolds.push(e.clone())}),n.collapseChildren=this.collapseChildren,n},t.prototype.addSubFold=function(e){if(this.range.isEqual(e))return;u(e,this.start);var t=e.start.row,n=e.start.column;for(var r=0,i=-1;r<this.subFolds.length;r++){i=this.subFolds[r].range.compare(t,n);if(i!=1)break}var s=this.subFolds[r],o=0;if(i==0){if(s.range.containsRange(e))return s.addSubFold(e);o=1}var t=e.range.end.row,n=e.range.end.column;for(var a=r,i=-1;a<this.subFolds.length;a++){i=this.subFolds[a].range.compare(t,n);if(i!=1)break}i==0&&a++;var f=this.subFolds.splice(r,a-r,e),l=i==0?f.length-1:f.length;for(var c=o;c<l;c++)e.addSubFold(f[c]);return e.setFoldLine(this.foldLine),e},t.prototype.restoreRange=function(e){return f(e,this.start)},t}(i);t.Fold=s}),ace.define("ace/edit_session/folding",["require","exports","module","ace/range","ace/edit_session/fold_line","ace/edit_session/fold","ace/token_iterator"],function(e,t,n){"use strict";function u(){this.getFoldAt=function(e,t,n){var r=this.getFoldLine(e);if(!r)return null;var i=r.folds;for(var s=0;s<i.length;s++){var o=i[s].range;if(o.contains(e,t)){if(n==1&&o.isEnd(e,t)&&!o.isEmpty())continue;if(n==-1&&o.isStart(e,t)&&!o.isEmpty())continue;return i[s]}}},this.getFoldsInRange=function(e){var t=e.start,n=e.end,r=this.$foldData,i=[];t.column+=1,n.column-=1;for(var s=0;s<r.length;s++){var o=r[s].range.compareRange(e);if(o==2)continue;if(o==-2)break;var u=r[s].folds;for(var a=0;a<u.length;a++){var f=u[a];o=f.range.compareRange(e);if(o==-2)break;if(o==2)continue;if(o==42)break;i.push(f)}}return t.column-=1,n.column+=1,i},this.getFoldsInRangeList=function(e){if(Array.isArray(e)){var t=[];e.forEach(function(e){t=t.concat(this.getFoldsInRange(e))},this)}else var t=this.getFoldsInRange(e);return t},this.getAllFolds=function(){var e=[],t=this.$foldData;for(var n=0;n<t.length;n++)for(var r=0;r<t[n].folds.length;r++)e.push(t[n].folds[r]);return e},this.getFoldStringAt=function(e,t,n,r){r=r||this.getFoldLine(e);if(!r)return null;var i={end:{column:0}},s,o;for(var u=0;u<r.folds.length;u++){o=r.folds[u];var a=o.range.compareEnd(e,t);if(a==-1){s=this.getLine(o.start.row).substring(i.end.column,o.start.column);break}if(a===0)return null;i=o}return s||(s=this.getLine(o.start.row).substring(i.end.column)),n==-1?s.substring(0,t-i.end.column):n==1?s.substring(t-i.end.column):s},this.getFoldLine=function(e,t){var n=this.$foldData,r=0;t&&(r=n.indexOf(t)),r==-1&&(r=0);for(r;r<n.length;r++){var i=n[r];if(i.start.row<=e&&i.end.row>=e)return i;if(i.end.row>e)return null}return null},this.getNextFoldLine=function(e,t){var n=this.$foldData,r=0;t&&(r=n.indexOf(t)),r==-1&&(r=0);for(r;r<n.length;r++){var i=n[r];if(i.end.row>=e)return i}return null},this.getFoldedRowCount=function(e,t){var n=this.$foldData,r=t-e+1;for(var i=0;i<n.length;i++){var s=n[i],o=s.end.row,u=s.start.row;if(o>=t){u<t&&(u>=e?r-=t-u:r=0);break}o>=e&&(u>=e?r-=o-u:r-=o-e+1)}return r},this.$addFoldLine=function(e){return this.$foldData.push(e),this.$foldData.sort(function(e,t){return e.start.row-t.start.row}),e},this.addFold=function(e,t){var n=this.$foldData,r=!1,o;e instanceof s?o=e:(o=new s(t,e),o.collapseChildren=t.collapseChildren),this.$clipRangeToDocument(o.range);var u=o.start.row,a=o.start.column,f=o.end.row,l=o.end.column,c=this.getFoldAt(u,a,1),h=this.getFoldAt(f,l,-1);if(c&&h==c)return c.addSubFold(o);c&&!c.range.isStart(u,a)&&this.removeFold(c),h&&!h.range.isEnd(f,l)&&this.removeFold(h);var p=this.getFoldsInRange(o.range);p.length>0&&(this.removeFolds(p),o.collapseChildren||p.forEach(function(e){o.addSubFold(e)}));for(var d=0;d<n.length;d++){var v=n[d];if(f==v.start.row){v.addFold(o),r=!0;break}if(u==v.end.row){v.addFold(o),r=!0;if(!o.sameRow){var m=n[d+1];if(m&&m.start.row==f){v.merge(m);break}}break}if(f<=v.start.row)break}return r||(v=this.$addFoldLine(new i(this.$foldData,o))),this.$useWrapMode?this.$updateWrapData(v.start.row,v.start.row):this.$updateRowLengthCache(v.start.row,v.start.row),this.$modified=!0,this._signal("changeFold",{data:o,action:"add"}),o},this.addFolds=function(e){e.forEach(function(e){this.addFold(e)},this)},this.removeFold=function(e){var t=e.foldLine,n=t.start.row,r=t.end.row,i=this.$foldData,s=t.folds;if(s.length==1)i.splice(i.indexOf(t),1);else if(t.range.isEnd(e.end.row,e.end.column))s.pop(),t.end.row=s[s.length-1].end.row,t.end.column=s[s.length-1].end.column;else if(t.range.isStart(e.start.row,e.start.column))s.shift(),t.start.row=s[0].start.row,t.start.column=s[0].start.column;else if(e.sameRow)s.splice(s.indexOf(e),1);else{var o=t.split(e.start.row,e.start.column);s=o.folds,s.shift(),o.start.row=s[0].start.row,o.start.column=s[0].start.column}this.$updating||(this.$useWrapMode?this.$updateWrapData(n,r):this.$updateRowLengthCache(n,r)),this.$modified=!0,this._signal("changeFold",{data:e,action:"remove"})},this.removeFolds=function(e){var t=[];for(var n=0;n<e.length;n++)t.push(e[n]);t.forEach(function(e){this.removeFold(e)},this),this.$modified=!0},this.expandFold=function(e){this.removeFold(e),e.subFolds.forEach(function(t){e.restoreRange(t),this.addFold(t)},this),e.collapseChildren>0&&this.foldAll(e.start.row+1,e.end.row,e.collapseChildren-1),e.subFolds=[]},this.expandFolds=function(e){e.forEach(function(e){this.expandFold(e)},this)},this.unfold=function(e,t){var n,i;if(e==null)n=new r(0,0,this.getLength(),0),t==null&&(t=!0);else if(typeof e=="number")n=new r(e,0,e,this.getLine(e).length);else if("row"in e)n=r.fromPoints(e,e);else{if(Array.isArray(e))return i=[],e.forEach(function(e){i=i.concat(this.unfold(e))},this),i;n=e}i=this.getFoldsInRangeList(n);var s=i;while(i.length==1&&r.comparePoints(i[0].start,n.start)<0&&r.comparePoints(i[0].end,n.end)>0)this.expandFolds(i),i=this.getFoldsInRangeList(n);t!=0?this.removeFolds(i):this.expandFolds(i);if(s.length)return s},this.isRowFolded=function(e,t){return!!this.getFoldLine(e,t)},this.getRowFoldEnd=function(e,t){var n=this.getFoldLine(e,t);return n?n.end.row:e},this.getRowFoldStart=function(e,t){var n=this.getFoldLine(e,t);return n?n.start.row:e},this.getFoldDisplayLine=function(e,t,n,r,i){r==null&&(r=e.start.row),i==null&&(i=0),t==null&&(t=e.end.row),n==null&&(n=this.getLine(t).length);var s=this.doc,o="";return e.walk(function(e,t,n,u){if(t<r)return;if(t==r){if(n<i)return;u=Math.max(i,u)}e!=null?o+=e:o+=s.getLine(t).substring(u,n)},t,n),o},this.getDisplayLine=function(e,t,n,r){var i=this.getFoldLine(e);if(!i){var s;return s=this.doc.getLine(e),s.substring(r||0,t||s.length)}return this.getFoldDisplayLine(i,e,t,n,r)},this.$cloneFoldData=function(){var e=[];return e=this.$foldData.map(function(t){var n=t.folds.map(function(e){return e.clone()});return new i(e,n)}),e},this.toggleFold=function(e){var t=this.selection,n=t.getRange(),r,i;if(n.isEmpty()){var s=n.start;r=this.getFoldAt(s.row,s.column);if(r){this.expandFold(r);return}(i=this.findMatchingBracket(s))?n.comparePoint(i)==1?n.end=i:(n.start=i,n.start.column++,n.end.column--):(i=this.findMatchingBracket({row:s.row,column:s.column+1}))?(n.comparePoint(i)==1?n.end=i:n.start=i,n.start.column++):n=this.getCommentFoldRange(s.row,s.column)||n}else{var o=this.getFoldsInRange(n);if(e&&o.length){this.expandFolds(o);return}o.length==1&&(r=o[0])}r||(r=this.getFoldAt(n.start.row,n.start.column));if(r&&r.range.toString()==n.toString()){this.expandFold(r);return}var u="...";if(!n.isMultiLine()){u=this.getTextRange(n);if(u.length<4)return;u=u.trim().substring(0,2)+".."}this.addFold(u,n)},this.getCommentFoldRange=function(e,t,n){var i=new o(this,e,t),s=i.getCurrentToken(),u=s&&s.type;if(s&&/^comment|string/.test(u)){u=u.match(/comment|string/)[0],u=="comment"&&(u+="|doc-start");var a=new RegExp(u),f=new r;if(n!=1){do s=i.stepBackward();while(s&&a.test(s.type)&&!/^comment.end/.test(s.type));s=i.stepForward()}f.start.row=i.getCurrentTokenRow(),f.start.column=i.getCurrentTokenColumn()+(/^comment.start/.test(s.type)?s.value.length:2),i=new o(this,e,t);if(n!=-1){var l=-1;do{s=i.stepForward();if(l==-1){var c=this.getState(i.$row);a.test(c)||(l=i.$row)}else if(i.$row>l)break}while(s&&a.test(s.type)&&!/^comment.start/.test(s.type));s=i.stepBackward()}else s=i.getCurrentToken();return f.end.row=i.getCurrentTokenRow(),f.end.column=i.getCurrentTokenColumn(),/^comment.end/.test(s.type)||(f.end.column+=s.value.length-2),f}},this.foldAll=function(e,t,n,r){n==undefined&&(n=1e5);var i=this.foldWidgets;if(!i)return;t=t||this.getLength(),e=e||0;for(var s=e;s<t;s++){i[s]==null&&(i[s]=this.getFoldWidget(s));if(i[s]!="start")continue;if(r&&!r(s))continue;var o=this.getFoldWidgetRange(s);o&&o.isMultiLine()&&o.end.row<=t&&o.start.row>=e&&(s=o.end.row,o.collapseChildren=n,this.addFold("...",o))}},this.foldToLevel=function(e){this.foldAll();while(e-->0)this.unfold(null,!1)},this.foldAllComments=function(){var e=this;this.foldAll(null,null,null,function(t){var n=e.getTokens(t);for(var r=0;r<n.length;r++){var i=n[r];if(i.type=="text"&&/^\s+$/.test(i.value))continue;return/comment/.test(i.type)?!0:!1}})},this.$foldStyles={manual:1,markbegin:1,markbeginend:1},this.$foldStyle="markbegin",this.setFoldStyle=function(e){if(!this.$foldStyles[e])throw new Error("invalid fold style: "+e+"["+Object.keys(this.$foldStyles).join(", ")+"]");if(this.$foldStyle==e)return;this.$foldStyle=e,e=="manual"&&this.unfold();var t=this.$foldMode;this.$setFolding(null),this.$setFolding(t)},this.$setFolding=function(e){if(this.$foldMode==e)return;this.$foldMode=e,this.off("change",this.$updateFoldWidgets),this.off("tokenizerUpdate",this.$tokenizerUpdateFoldWidgets),this._signal("changeAnnotation");if(!e||this.$foldStyle=="manual"){this.foldWidgets=null;return}this.foldWidgets=[],this.getFoldWidget=e.getFoldWidget.bind(e,this,this.$foldStyle),this.getFoldWidgetRange=e.getFoldWidgetRange.bind(e,this,this.$foldStyle),this.$updateFoldWidgets=this.updateFoldWidgets.bind(this),this.$tokenizerUpdateFoldWidgets=this.tokenizerUpdateFoldWidgets.bind(this),this.on("change",this.$updateFoldWidgets),this.on("tokenizerUpdate",this.$tokenizerUpdateFoldWidgets)},this.getParentFoldRangeData=function(e,t){var n=this.foldWidgets;if(!n||t&&n[e])return{};var r=e-1,i;while(r>=0){var s=n[r];s==null&&(s=n[r]=this.getFoldWidget(r));if(s=="start"){var o=this.getFoldWidgetRange(r);i||(i=o);if(o&&o.end.row>=e)break}r--}return{range:r!==-1&&o,firstRange:i}},this.onFoldWidgetClick=function(e,t){t=t.domEvent;var n={children:t.shiftKey,all:t.ctrlKey||t.metaKey,siblings:t.altKey},r=this.$toggleFoldWidget(e,n);if(!r){var i=t.target||t.srcElement;i&&/ace_fold-widget/.test(i.className)&&(i.className+=" ace_invalid")}},this.$toggleFoldWidget=function(e,t){if(!this.getFoldWidget)return;var n=this.getFoldWidget(e),r=this.getLine(e),i=n==="end"?-1:1,s=this.getFoldAt(e,i===-1?0:r.length,i);if(s)return t.children||t.all?this.removeFold(s):this.expandFold(s),s;var o=this.getFoldWidgetRange(e,!0);if(o&&!o.isMultiLine()){s=this.getFoldAt(o.start.row,o.start.column,1);if(s&&o.isEqual(s.range))return this.removeFold(s),s}if(t.siblings){var u=this.getParentFoldRangeData(e);if(u.range)var a=u.range.start.row+1,f=u.range.end.row;this.foldAll(a,f,t.all?1e4:0)}else t.children?(f=o?o.end.row:this.getLength(),this.foldAll(e+1,f,t.all?1e4:0)):o&&(t.all&&(o.collapseChildren=1e4),this.addFold("...",o));return o},this.toggleFoldWidget=function(e){var t=this.selection.getCursor().row;t=this.getRowFoldStart(t);var n=this.$toggleFoldWidget(t,{});if(n)return;var r=this.getParentFoldRangeData(t,!0);n=r.range||r.firstRange;if(n){t=n.start.row;var i=this.getFoldAt(t,this.getLine(t).length,1);i?this.removeFold(i):this.addFold("...",n)}},this.updateFoldWidgets=function(e){var t=e.start.row,n=e.end.row-t;if(n===0)this.foldWidgets[t]=null;else if(e.action=="remove")this.foldWidgets.splice(t,n+1,null);else{var r=Array(n+1);r.unshift(t,1),this.foldWidgets.splice.apply(this.foldWidgets,r)}},this.tokenizerUpdateFoldWidgets=function(e){var t=e.data;t.first!=t.last&&this.foldWidgets.length>t.first&&this.foldWidgets.splice(t.first,this.foldWidgets.length)}}var r=e("../range").Range,i=e("./fold_line").FoldLine,s=e("./fold").Fold,o=e("../token_iterator").TokenIterator;t.Folding=u}),ace.define("ace/edit_session/bracket_match",["require","exports","module","ace/token_iterator","ace/range"],function(e,t,n){"use strict";function s(){this.findMatchingBracket=function(e,t){if(e.column==0)return null;var n=t||this.getLine(e.row).charAt(e.column-1);if(n=="")return null;var r=n.match(/([\(\[\{])|([\)\]\}])/);return r?r[1]?this.$findClosingBracket(r[1],e):this.$findOpeningBracket(r[2],e):null},this.getBracketRange=function(e){var t=this.getLine(e.row),n=!0,r,s=t.charAt(e.column-1),o=s&&s.match(/([\(\[\{])|([\)\]\}])/);o||(s=t.charAt(e.column),e={row:e.row,column:e.column+1},o=s&&s.match(/([\(\[\{])|([\)\]\}])/),n=!1);if(!o)return null;if(o[1]){var u=this.$findClosingBracket(o[1],e);if(!u)return null;r=i.fromPoints(e,u),n||(r.end.column++,r.start.column--),r.cursor=r.end}else{var u=this.$findOpeningBracket(o[2],e);if(!u)return null;r=i.fromPoints(u,e),n||(r.start.column++,r.end.column--),r.cursor=r.start}return r},this.getMatchingBracketRanges=function(e,t){var n=this.getLine(e.row),r=/([\(\[\{])|([\)\]\}])/,s=!t&&n.charAt(e.column-1),o=s&&s.match(r);o||(s=(t===undefined||t)&&n.charAt(e.column),e={row:e.row,column:e.column+1},o=s&&s.match(r));if(!o)return null;var u=new i(e.row,e.column-1,e.row,e.column),a=o[1]?this.$findClosingBracket(o[1],e):this.$findOpeningBracket(o[2],e);if(!a)return[u];var f=new i(a.row,a.column,a.row,a.column+1);return[u,f]},this.$brackets={")":"(","(":")","]":"[","[":"]","{":"}","}":"{","<":">",">":"<"},this.$findOpeningBracket=function(e,t,n){var i=this.$brackets[e],s=1,o=new r(this,t.row,t.column),u=o.getCurrentToken();u||(u=o.stepForward());if(!u)return;n||(n=new RegExp("(\\.?"+u.type.replace(".","\\.").replace("rparen",".paren").replace(/\b(?:end)\b/,"(?:start|begin|end)").replace(/-close\b/,"-(close|open)")+")+"));var a=t.column-o.getCurrentTokenColumn()-2,f=u.value;for(;;){while(a>=0){var l=f.charAt(a);if(l==i){s-=1;if(s==0)return{row:o.getCurrentTokenRow(),column:a+o.getCurrentTokenColumn()}}else l==e&&(s+=1);a-=1}do u=o.stepBackward();while(u&&!n.test(u.type));if(u==null)break;f=u.value,a=f.length-1}return null},this.$findClosingBracket=function(e,t,n){var i=this.$brackets[e],s=1,o=new r(this,t.row,t.column),u=o.getCurrentToken();u||(u=o.stepForward());if(!u)return;n||(n=new RegExp("(\\.?"+u.type.replace(".","\\.").replace("lparen",".paren").replace(/\b(?:start|begin)\b/,"(?:start|begin|end)").replace(/-open\b/,"-(close|open)")+")+"));var a=t.column-o.getCurrentTokenColumn();for(;;){var f=u.value,l=f.length;while(a<l){var c=f.charAt(a);if(c==i){s-=1;if(s==0)return{row:o.getCurrentTokenRow(),column:a+o.getCurrentTokenColumn()}}else c==e&&(s+=1);a+=1}do u=o.stepForward();while(u&&!n.test(u.type));if(u==null)break;a=0}return null},this.getMatchingTags=function(e){var t=new r(this,e.row,e.column),n=this.$findTagName(t);if(!n)return;var i=t.stepBackward();return i.value==="<"?this.$findClosingTag(t,n):this.$findOpeningTag(t,n)},this.$findTagName=function(e){var t=e.getCurrentToken(),n=!1,r=!1;if(t&&t.type.indexOf("tag-name")===-1)do r?t=e.stepBackward():t=e.stepForward(),t&&(t.value==="/>"?r=!0:t.type.indexOf("tag-name")!==-1&&(n=!0));while(t&&!n);return t},this.$findClosingTag=function(e,t){var n,r=t.value,s=t.value,o=0,u=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+1);t=e.stepForward();var a=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+t.value.length),f=!1;do{n=t,t=e.stepForward();if(t){if(t.value===">"&&!f){var l=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+1);f=!0}if(t.type.indexOf("tag-name")!==-1){r=t.value;if(s===r)if(n.value==="<")o++;else if(n.value==="</"){o--;if(o<0){e.stepBackward();var c=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+2);t=e.stepForward();var h=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+t.value.length);t=e.stepForward();if(!t||t.value!==">")return;var p=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+1)}}}else if(s===r&&t.value==="/>"){o--;if(o<0)var c=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+2),h=c,p=h,l=new i(a.end.row,a.end.column,a.end.row,a.end.column+1)}}}while(t&&o>=0);if(u&&l&&c&&p&&a&&h)return{openTag:new i(u.start.row,u.start.column,l.end.row,l.end.column),closeTag:new i(c.start.row,c.start.column,p.end.row,p.end.column),openTagName:a,closeTagName:h}},this.$findOpeningTag=function(e,t){var n=e.getCurrentToken(),r=t.value,s=0,o=e.getCurrentTokenRow(),u=e.getCurrentTokenColumn(),a=u+2,f=new i(o,u,o,a);e.stepForward();var l=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+t.value.length);t=e.stepForward();if(!t||t.value!==">")return;var c=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+1);e.stepBackward(),e.stepBackward();do{t=n,o=e.getCurrentTokenRow(),u=e.getCurrentTokenColumn(),a=u+t.value.length,n=e.stepBackward();if(t)if(t.type.indexOf("tag-name")!==-1){if(r===t.value)if(n.value==="<"){s++;if(s>0){var h=new i(o,u,o,a),p=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+1);do t=e.stepForward();while(t&&t.value!==">");var d=new i(e.getCurrentTokenRow(),e.getCurrentTokenColumn(),e.getCurrentTokenRow(),e.getCurrentTokenColumn()+1)}}else n.value==="</"&&s--}else if(t.value==="/>"){var v=0,m=n;while(m){if(m.type.indexOf("tag-name")!==-1&&m.value===r){s--;break}if(m.value==="<")break;m=e.stepBackward(),v++}for(var g=0;g<v;g++)e.stepForward()}}while(n&&s<=0);if(p&&d&&f&&c&&h&&l)return{openTag:new i(p.start.row,p.start.column,d.end.row,d.end.column),closeTag:new i(f.start.row,f.start.column,c.end.row,c.end.column),openTagName:h,closeTagName:l}}}var r=e("../token_iterator").TokenIterator,i=e("../range").Range;t.BracketMatch=s}),ace.define("ace/edit_session",["require","exports","module","ace/lib/oop","ace/lib/lang","ace/bidihandler","ace/config","ace/lib/event_emitter","ace/selection","ace/mode/text","ace/range","ace/document","ace/background_tokenizer","ace/search_highlight","ace/edit_session/folding","ace/edit_session/bracket_match"],function(e,t,n){"use strict";function x(e){return e<4352?!1:e>=4352&&e<=4447||e>=4515&&e<=4519||e>=4602&&e<=4607||e>=9001&&e<=9002||e>=11904&&e<=11929||e>=11931&&e<=12019||e>=12032&&e<=12245||e>=12272&&e<=12283||e>=12288&&e<=12350||e>=12353&&e<=12438||e>=12441&&e<=12543||e>=12549&&e<=12589||e>=12593&&e<=12686||e>=12688&&e<=12730||e>=12736&&e<=12771||e>=12784&&e<=12830||e>=12832&&e<=12871||e>=12880&&e<=13054||e>=13056&&e<=19903||e>=19968&&e<=42124||e>=42128&&e<=42182||e>=43360&&e<=43388||e>=44032&&e<=55203||e>=55216&&e<=55238||e>=55243&&e<=55291||e>=63744&&e<=64255||e>=65040&&e<=65049||e>=65072&&e<=65106||e>=65108&&e<=65126||e>=65128&&e<=65131||e>=65281&&e<=65376||e>=65504&&e<=65510}var r=e("./lib/oop"),i=e("./lib/lang"),s=e("./bidihandler").BidiHandler,o=e("./config"),u=e("./lib/event_emitter").EventEmitter,a=e("./selection").Selection,f=e("./mode/text").Mode,l=e("./range").Range,c=e("./document").Document,h=e("./background_tokenizer").BackgroundTokenizer,p=e("./search_highlight").SearchHighlight,d=function(){function e(t,n){this.$breakpoints=[],this.$decorations=[],this.$frontMarkers={},this.$backMarkers={},this.$markerId=1,this.$undoSelect=!0,this.$foldData=[],this.id="session"+ ++e.$uid,this.$foldData.toString=function(){return this.join("\n")},this.bgTokenizer=new h((new f).getTokenizer(),this);var r=this;this.bgTokenizer.on("update",function(e){r._signal("tokenizerUpdate",e)}),this.on("changeFold",this.onChangeFold.bind(this)),this.$onChange=this.onChange.bind(this);if(typeof t!="object"||!t.getLine)t=new c(t);this.setDocument(t),this.selection=new a(this),this.$bidiHandler=new s(this),o.resetOptions(this),this.setMode(n),o._signal("session",this),this.destroyed=!1}return e.prototype.setDocument=function(e){this.doc&&this.doc.off("change",this.$onChange),this.doc=e,e.on("change",this.$onChange,!0),this.bgTokenizer.setDocument(this.getDocument()),this.resetCaches()},e.prototype.getDocument=function(){return this.doc},e.prototype.$resetRowCache=function(e){if(!e){this.$docRowCache=[],this.$screenRowCache=[];return}var t=this.$docRowCache.length,n=this.$getRowCacheIndex(this.$docRowCache,e)+1;t>n&&(this.$docRowCache.splice(n,t),this.$screenRowCache.splice(n,t))},e.prototype.$getRowCacheIndex=function(e,t){var n=0,r=e.length-1;while(n<=r){var i=n+r>>1,s=e[i];if(t>s)n=i+1;else{if(!(t<s))return i;r=i-1}}return n-1},e.prototype.resetCaches=function(){this.$modified=!0,this.$wrapData=[],this.$rowLengthCache=[],this.$resetRowCache(0),this.destroyed||this.bgTokenizer.start(0)},e.prototype.onChangeFold=function(e){var t=e.data;this.$resetRowCache(t.start.row)},e.prototype.onChange=function(e){this.$modified=!0,this.$bidiHandler.onChange(e),this.$resetRowCache(e.start.row);var t=this.$updateInternalDataOnChange(e);!this.$fromUndo&&this.$undoManager&&(t&&t.length&&(this.$undoManager.add({action:"removeFolds",folds:t},this.mergeUndoDeltas),this.mergeUndoDeltas=!0),this.$undoManager.add(e,this.mergeUndoDeltas),this.mergeUndoDeltas=!0,this.$informUndoManager.schedule()),this.bgTokenizer.$updateOnChange(e),this._signal("change",e)},e.prototype.setValue=function(e){this.doc.setValue(e),this.selection.moveTo(0,0),this.$resetRowCache(0),this.setUndoManager(this.$undoManager),this.getUndoManager().reset()},e.prototype.toString=function(){return this.doc.getValue()},e.prototype.getSelection=function(){return this.selection},e.prototype.getState=function(e){return this.bgTokenizer.getState(e)},e.prototype.getTokens=function(e){return this.bgTokenizer.getTokens(e)},e.prototype.getTokenAt=function(e,t){var n=this.bgTokenizer.getTokens(e),r,i=0;if(t==null){var s=n.length-1;i=this.getLine(e).length}else for(var s=0;s<n.length;s++){i+=n[s].value.length;if(i>=t)break}return r=n[s],r?(r.index=s,r.start=i-r.value.length,r):null},e.prototype.setUndoManager=function(e){this.$undoManager=e,this.$informUndoManager&&this.$informUndoManager.cancel();if(e){var t=this;e.addSession(this),this.$syncInformUndoManager=function(){t.$informUndoManager.cancel(),t.mergeUndoDeltas=!1},this.$informUndoManager=i.delayedCall(this.$syncInformUndoManager)}else this.$syncInformUndoManager=function(){}},e.prototype.markUndoGroup=function(){this.$syncInformUndoManager&&this.$syncInformUndoManager()},e.prototype.getUndoManager=function(){return this.$undoManager||this.$defaultUndoManager},e.prototype.getTabString=function(){return this.getUseSoftTabs()?i.stringRepeat(" ",this.getTabSize()):"	"},e.prototype.setUseSoftTabs=function(e){this.setOption("useSoftTabs",e)},e.prototype.getUseSoftTabs=function(){return this.$useSoftTabs&&!this.$mode.$indentWithTabs},e.prototype.setTabSize=function(e){this.setOption("tabSize",e)},e.prototype.getTabSize=function(){return this.$tabSize},e.prototype.isTabStop=function(e){return this.$useSoftTabs&&e.column%this.$tabSize===0},e.prototype.setNavigateWithinSoftTabs=function(e){this.setOption("navigateWithinSoftTabs",e)},e.prototype.getNavigateWithinSoftTabs=function(){return this.$navigateWithinSoftTabs},e.prototype.setOverwrite=function(e){this.setOption("overwrite",e)},e.prototype.getOverwrite=function(){return this.$overwrite},e.prototype.toggleOverwrite=function(){this.setOverwrite(!this.$overwrite)},e.prototype.addGutterDecoration=function(e,t){this.$decorations[e]||(this.$decorations[e]=""),this.$decorations[e]+=" "+t,this._signal("changeBreakpoint",{})},e.prototype.removeGutterDecoration=function(e,t){this.$decorations[e]=(this.$decorations[e]||"").replace(" "+t,""),this._signal("changeBreakpoint",{})},e.prototype.getBreakpoints=function(){return this.$breakpoints},e.prototype.setBreakpoints=function(e){this.$breakpoints=[];for(var t=0;t<e.length;t++)this.$breakpoints[e[t]]="ace_breakpoint";this._signal("changeBreakpoint",{})},e.prototype.clearBreakpoints=function(){this.$breakpoints=[],this._signal("changeBreakpoint",{})},e.prototype.setBreakpoint=function(e,t){t===undefined&&(t="ace_breakpoint"),t?this.$breakpoints[e]=t:delete this.$breakpoints[e],this._signal("changeBreakpoint",{})},e.prototype.clearBreakpoint=function(e){delete this.$breakpoints[e],this._signal("changeBreakpoint",{})},e.prototype.addMarker=function(e,t,n,r){var i=this.$markerId++,s={range:e,type:n||"line",renderer:typeof n=="function"?n:null,clazz:t,inFront:!!r,id:i};return r?(this.$frontMarkers[i]=s,this._signal("changeFrontMarker")):(this.$backMarkers[i]=s,this._signal("changeBackMarker")),i},e.prototype.addDynamicMarker=function(e,t){if(!e.update)return;var n=this.$markerId++;return e.id=n,e.inFront=!!t,t?(this.$frontMarkers[n]=e,this._signal("changeFrontMarker")):(this.$backMarkers[n]=e,this._signal("changeBackMarker")),e},e.prototype.removeMarker=function(e){var t=this.$frontMarkers[e]||this.$backMarkers[e];if(!t)return;var n=t.inFront?this.$frontMarkers:this.$backMarkers;delete n[e],this._signal(t.inFront?"changeFrontMarker":"changeBackMarker")},e.prototype.getMarkers=function(e){return e?this.$frontMarkers:this.$backMarkers},e.prototype.highlight=function(e){if(!this.$searchHighlight){var t=new p(null,"ace_selected-word","text");this.$searchHighlight=this.addDynamicMarker(t)}this.$searchHighlight.setRegexp(e)},e.prototype.highlightLines=function(e,t,n,r){typeof t!="number"&&(n=t,t=e),n||(n="ace_step");var i=new l(e,0,t,Infinity);return i.id=this.addMarker(i,n,"fullLine",r),i},e.prototype.setAnnotations=function(e){this.$annotations=e,this._signal("changeAnnotation",{})},e.prototype.getAnnotations=function(){return this.$annotations||[]},e.prototype.clearAnnotations=function(){this.setAnnotations([])},e.prototype.$detectNewLine=function(e){var t=e.match(/^.*?(\r?\n)/m);t?this.$autoNewLine=t[1]:this.$autoNewLine="\n"},e.prototype.getWordRange=function(e,t){var n=this.getLine(e),r=!1;t>0&&(r=!!n.charAt(t-1).match(this.tokenRe)),r||(r=!!n.charAt(t).match(this.tokenRe));if(r)var i=this.tokenRe;else if(/^\s+$/.test(n.slice(t-1,t+1)))var i=/\s/;else var i=this.nonTokenRe;var s=t;if(s>0){do s--;while(s>=0&&n.charAt(s).match(i));s++}var o=t;while(o<n.length&&n.charAt(o).match(i))o++;return new l(e,s,e,o)},e.prototype.getAWordRange=function(e,t){var n=this.getWordRange(e,t),r=this.getLine(n.end.row);while(r.charAt(n.end.column).match(/[ \t]/))n.end.column+=1;return n},e.prototype.setNewLineMode=function(e){this.doc.setNewLineMode(e)},e.prototype.getNewLineMode=function(){return this.doc.getNewLineMode()},e.prototype.setUseWorker=function(e){this.setOption("useWorker",e)},e.prototype.getUseWorker=function(){return this.$useWorker},e.prototype.onReloadTokenizer=function(e){var t=e.data;this.bgTokenizer.start(t.first),this._signal("tokenizerUpdate",e)},e.prototype.setMode=function(e,t){if(e&&typeof e=="object"){if(e.getTokenizer)return this.$onChangeMode(e);var n=e,r=n.path}else r=e||"ace/mode/text";this.$modes["ace/mode/text"]||(this.$modes["ace/mode/text"]=new f);if(this.$modes[r]&&!n){this.$onChangeMode(this.$modes[r]),t&&t();return}this.$modeId=r,o.loadModule(["mode",r],function(e){if(this.$modeId!==r)return t&&t();this.$modes[r]&&!n?this.$onChangeMode(this.$modes[r]):e&&e.Mode&&(e=new e.Mode(n),n||(this.$modes[r]=e,e.$id=r),this.$onChangeMode(e)),t&&t()}.bind(this)),this.$mode||this.$onChangeMode(this.$modes["ace/mode/text"],!0)},e.prototype.$onChangeMode=function(e,t){t||(this.$modeId=e.$id);if(this.$mode===e)return;var n=this.$mode;this.$mode=e,this.$stopWorker(),this.$useWorker&&this.$startWorker();var r=e.getTokenizer();if(r.on!==undefined){var i=this.onReloadTokenizer.bind(this);r.on("update",i)}this.bgTokenizer.setTokenizer(r),this.bgTokenizer.setDocument(this.getDocument()),this.tokenRe=e.tokenRe,this.nonTokenRe=e.nonTokenRe,t||(e.attachToSession&&e.attachToSession(this),this.$options.wrapMethod.set.call(this,this.$wrapMethod),this.$setFolding(e.foldingRules),this.bgTokenizer.start(0),this._emit("changeMode",{oldMode:n,mode:e}))},e.prototype.$stopWorker=function(){this.$worker&&(this.$worker.terminate(),this.$worker=null)},e.prototype.$startWorker=function(){try{this.$worker=this.$mode.createWorker(this)}catch(e){o.warn("Could not load worker",e),this.$worker=null}},e.prototype.getMode=function(){return this.$mode},e.prototype.setScrollTop=function(e){if(this.$scrollTop===e||isNaN(e))return;this.$scrollTop=e,this._signal("changeScrollTop",e)},e.prototype.getScrollTop=function(){return this.$scrollTop},e.prototype.setScrollLeft=function(e){if(this.$scrollLeft===e||isNaN(e))return;this.$scrollLeft=e,this._signal("changeScrollLeft",e)},e.prototype.getScrollLeft=function(){return this.$scrollLeft},e.prototype.getScreenWidth=function(){return this.$computeWidth(),this.lineWidgets?Math.max(this.getLineWidgetMaxWidth(),this.screenWidth):this.screenWidth},e.prototype.getLineWidgetMaxWidth=function(){if(this.lineWidgetsWidth!=null)return this.lineWidgetsWidth;var e=0;return this.lineWidgets.forEach(function(t){t&&t.screenWidth>e&&(e=t.screenWidth)}),this.lineWidgetWidth=e},e.prototype.$computeWidth=function(e){if(this.$modified||e){this.$modified=!1;if(this.$useWrapMode)return this.screenWidth=this.$wrapLimit;var t=this.doc.getAllLines(),n=this.$rowLengthCache,r=0,i=0,s=this.$foldData[i],o=s?s.start.row:Infinity,u=t.length;for(var a=0;a<u;a++){if(a>o){a=s.end.row+1;if(a>=u)break;s=this.$foldData[i++],o=s?s.start.row:Infinity}n[a]==null&&(n[a]=this.$getStringScreenWidth(t[a])[0]),n[a]>r&&(r=n[a])}this.screenWidth=r}},e.prototype.getLine=function(e){return this.doc.getLine(e)},e.prototype.getLines=function(e,t){return this.doc.getLines(e,t)},e.prototype.getLength=function(){return this.doc.getLength()},e.prototype.getTextRange=function(e){return this.doc.getTextRange(e||this.selection.getRange())},e.prototype.insert=function(e,t){return this.doc.insert(e,t)},e.prototype.remove=function(e){return this.doc.remove(e)},e.prototype.removeFullLines=function(e,t){return this.doc.removeFullLines(e,t)},e.prototype.undoChanges=function(e,t){if(!e.length)return;this.$fromUndo=!0;for(var n=e.length-1;n!=-1;n--){var r=e[n];r.action=="insert"||r.action=="remove"?this.doc.revertDelta(r):r.folds&&this.addFolds(r.folds)}!t&&this.$undoSelect&&(e.selectionBefore?this.selection.fromJSON(e.selectionBefore):this.selection.setRange(this.$getUndoSelection(e,!0))),this.$fromUndo=!1},e.prototype.redoChanges=function(e,t){if(!e.length)return;this.$fromUndo=!0;for(var n=0;n<e.length;n++){var r=e[n];(r.action=="insert"||r.action=="remove")&&this.doc.$safeApplyDelta(r)}!t&&this.$undoSelect&&(e.selectionAfter?this.selection.fromJSON(e.selectionAfter):this.selection.setRange(this.$getUndoSelection(e,!1))),this.$fromUndo=!1},e.prototype.setUndoSelect=function(e){this.$undoSelect=e},e.prototype.$getUndoSelection=function(e,t){function n(e){return t?e.action!=="insert":e.action==="insert"}var r,i;for(var s=0;s<e.length;s++){var o=e[s];if(!o.start)continue;if(!r){n(o)?r=l.fromPoints(o.start,o.end):r=l.fromPoints(o.start,o.start);continue}n(o)?(i=o.start,r.compare(i.row,i.column)==-1&&r.setStart(i),i=o.end,r.compare(i.row,i.column)==1&&r.setEnd(i)):(i=o.start,r.compare(i.row,i.column)==-1&&(r=l.fromPoints(o.start,o.start)))}return r},e.prototype.replace=function(e,t){return this.doc.replace(e,t)},e.prototype.moveText=function(e,t,n){var r=this.getTextRange(e),i=this.getFoldsInRange(e),s=l.fromPoints(t,t);if(!n){this.remove(e);var o=e.start.row-e.end.row,u=o?-e.end.column:e.start.column-e.end.column;u&&(s.start.row==e.end.row&&s.start.column>e.end.column&&(s.start.column+=u),s.end.row==e.end.row&&s.end.column>e.end.column&&(s.end.column+=u)),o&&s.start.row>=e.end.row&&(s.start.row+=o,s.end.row+=o)}s.end=this.insert(s.start,r);if(i.length){var a=e.start,f=s.start,o=f.row-a.row,u=f.column-a.column;this.addFolds(i.map(function(e){return e=e.clone(),e.start.row==a.row&&(e.start.column+=u),e.end.row==a.row&&(e.end.column+=u),e.start.row+=o,e.end.row+=o,e}))}return s},e.prototype.indentRows=function(e,t,n){n=n.replace(/\t/g,this.getTabString());for(var r=e;r<=t;r++)this.doc.insertInLine({row:r,column:0},n)},e.prototype.outdentRows=function(e){var t=e.collapseRows(),n=new l(0,0,0,0),r=this.getTabSize();for(var i=t.start.row;i<=t.end.row;++i){var s=this.getLine(i);n.start.row=i,n.end.row=i;for(var o=0;o<r;++o)if(s.charAt(o)!=" ")break;o<r&&s.charAt(o)=="	"?(n.start.column=o,n.end.column=o+1):(n.start.column=0,n.end.column=o),this.remove(n)}},e.prototype.$moveLines=function(e,t,n){e=this.getRowFoldStart(e),t=this.getRowFoldEnd(t);if(n<0){var r=this.getRowFoldStart(e+n);if(r<0)return 0;var i=r-e}else if(n>0){var r=this.getRowFoldEnd(t+n);if(r>this.doc.getLength()-1)return 0;var i=r-t}else{e=this.$clipRowToDocument(e),t=this.$clipRowToDocument(t);var i=t-e+1}var s=new l(e,0,t,Number.MAX_VALUE),o=this.getFoldsInRange(s).map(function(e){return e=e.clone(),e.start.row+=i,e.end.row+=i,e}),u=n==0?this.doc.getLines(e,t):this.doc.removeFullLines(e,t);return this.doc.insertFullLines(e+i,u),o.length&&this.addFolds(o),i},e.prototype.moveLinesUp=function(e,t){return this.$moveLines(e,t,-1)},e.prototype.moveLinesDown=function(e,t){return this.$moveLines(e,t,1)},e.prototype.duplicateLines=function(e,t){return this.$moveLines(e,t,0)},e.prototype.$clipRowToDocument=function(e){return Math.max(0,Math.min(e,this.doc.getLength()-1))},e.prototype.$clipColumnToRow=function(e,t){return t<0?0:Math.min(this.doc.getLine(e).length,t)},e.prototype.$clipPositionToDocument=function(e,t){t=Math.max(0,t);if(e<0)e=0,t=0;else{var n=this.doc.getLength();e>=n?(e=n-1,t=this.doc.getLine(n-1).length):t=Math.min(this.doc.getLine(e).length,t)}return{row:e,column:t}},e.prototype.$clipRangeToDocument=function(e){e.start.row<0?(e.start.row=0,e.start.column=0):e.start.column=this.$clipColumnToRow(e.start.row,e.start.column);var t=this.doc.getLength()-1;return e.end.row>t?(e.end.row=t,e.end.column=this.doc.getLine(t).length):e.end.column=this.$clipColumnToRow(e.end.row,e.end.column),e},e.prototype.setUseWrapMode=function(e){if(e!=this.$useWrapMode){this.$useWrapMode=e,this.$modified=!0,this.$resetRowCache(0);if(e){var t=this.getLength();this.$wrapData=Array(t),this.$updateWrapData(0,t-1)}this._signal("changeWrapMode")}},e.prototype.getUseWrapMode=function(){return this.$useWrapMode},e.prototype.setWrapLimitRange=function(e,t){if(this.$wrapLimitRange.min!==e||this.$wrapLimitRange.max!==t)this.$wrapLimitRange={min:e,max:t},this.$modified=!0,this.$bidiHandler.markAsDirty(),this.$useWrapMode&&this._signal("changeWrapMode")},e.prototype.adjustWrapLimit=function(e,t){var n=this.$wrapLimitRange;n.max<0&&(n={min:t,max:t});var r=this.$constrainWrapLimit(e,n.min,n.max);return r!=this.$wrapLimit&&r>1?(this.$wrapLimit=r,this.$modified=!0,this.$useWrapMode&&(this.$updateWrapData(0,this.getLength()-1),this.$resetRowCache(0),this._signal("changeWrapLimit")),!0):!1},e.prototype.$constrainWrapLimit=function(e,t,n){return t&&(e=Math.max(t,e)),n&&(e=Math.min(n,e)),e},e.prototype.getWrapLimit=function(){return this.$wrapLimit},e.prototype.setWrapLimit=function(e){this.setWrapLimitRange(e,e)},e.prototype.getWrapLimitRange=function(){return{min:this.$wrapLimitRange.min,max:this.$wrapLimitRange.max}},e.prototype.$updateInternalDataOnChange=function(e){var t=this.$useWrapMode,n=e.action,r=e.start,i=e.end,s=r.row,o=i.row,u=o-s,a=null;this.$updating=!0;if(u!=0)if(n==="remove"){this[t?"$wrapData":"$rowLengthCache"].splice(s,u);var f=this.$foldData;a=this.getFoldsInRange(e),this.removeFolds(a);var l=this.getFoldLine(i.row),c=0;if(l){l.addRemoveChars(i.row,i.column,r.column-i.column),l.shiftRow(-u);var h=this.getFoldLine(s);h&&h!==l&&(h.merge(l),l=h),c=f.indexOf(l)+1}for(c;c<f.length;c++){var l=f[c];l.start.row>=i.row&&l.shiftRow(-u)}o=s}else{var p=Array(u);p.unshift(s,0);var d=t?this.$wrapData:this.$rowLengthCache;d.splice.apply(d,p);var f=this.$foldData,l=this.getFoldLine(s),c=0;if(l){var v=l.range.compareInside(r.row,r.column);v==0?(l=l.split(r.row,r.column),l&&(l.shiftRow(u),l.addRemoveChars(o,0,i.column-r.column))):v==-1&&(l.addRemoveChars(s,0,i.column-r.column),l.shiftRow(u)),c=f.indexOf(l)+1}for(c;c<f.length;c++){var l=f[c];l.start.row>=s&&l.shiftRow(u)}}else{u=Math.abs(e.start.column-e.end.column),n==="remove"&&(a=this.getFoldsInRange(e),this.removeFolds(a),u=-u);var l=this.getFoldLine(s);l&&l.addRemoveChars(s,r.column,u)}return t&&this.$wrapData.length!=this.doc.getLength()&&console.error("doc.getLength() and $wrapData.length have to be the same!"),this.$updating=!1,t?this.$updateWrapData(s,o):this.$updateRowLengthCache(s,o),a},e.prototype.$updateRowLengthCache=function(e,t,n){this.$rowLengthCache[e]=null,this.$rowLengthCache[t]=null},e.prototype.$updateWrapData=function(e,t){var n=this.doc.getAllLines(),r=this.getTabSize(),i=this.$wrapData,s=this.$wrapLimit,o,u,a=e;t=Math.min(t,n.length-1);while(a<=t)u=this.getFoldLine(a,u),u?(o=[],u.walk(function(e,t,r,i){var s;if(e!=null){s=this.$getDisplayTokens(e,o.length),s[0]=g;for(var u=1;u<s.length;u++)s[u]=y}else s=this.$getDisplayTokens(n[t].substring(i,r),o.length);o=o.concat(s)}.bind(this),u.end.row,n[u.end.row].length+1),i[u.start.row]=this.$computeWrapSplits(o,s,r),a=u.end.row+1):(o=this.$getDisplayTokens(n[a]),i[a]=this.$computeWrapSplits(o,s,r),a++)},e.prototype.$computeWrapSplits=function(e,t,n){function l(){var t=0;if(f===0)return t;if(a)for(var r=0;r<e.length;r++){var i=e[r];if(i==w)t+=1;else{if(i!=E){if(i==S)continue;break}t+=n}}return u&&a!==!1&&(t+=n),Math.min(t,f)}function c(t){var n=t-s;for(var i=s;i<t;i++){var u=e[i];if(u===12||u===2)n-=1}r.length||(h=l(),r.indent=h),o+=n,r.push(o),s=t}if(e.length==0)return[];var r=[],i=e.length,s=0,o=0,u=this.$wrapAsCode,a=this.$indentedSoftWrap,f=t<=Math.max(2*n,8)||a===!1?0:Math.floor(t/2),h=0;while(i-s>t-h){var p=s+t-h;if(e[p-1]>=w&&e[p]>=w){c(p);continue}if(e[p]==g||e[p]==y){for(p;p!=s-1;p--)if(e[p]==g)break;if(p>s){c(p);continue}p=s+t;for(p;p<e.length;p++)if(e[p]!=y)break;if(p==e.length)break;c(p);continue}var d=Math.max(p-(t-(t>>2)),s-1);while(p>d&&e[p]<g)p--;if(u){while(p>d&&e[p]<g)p--;while(p>d&&e[p]==b)p--}else while(p>d&&e[p]<w)p--;if(p>d){c(++p);continue}p=s+t,e[p]==m&&p--,c(p-h)}return r},e.prototype.$getDisplayTokens=function(e,t){var n=[],r;t=t||0;for(var i=0;i<e.length;i++){var s=e.charCodeAt(i);if(s==9){r=this.getScreenTabSize(n.length+t),n.push(E);for(var o=1;o<r;o++)n.push(S)}else s==32?n.push(w):s>39&&s<48||s>57&&s<64?n.push(b):s>=4352&&x(s)?n.push(v,m):n.push(v)}return n},e.prototype.$getStringScreenWidth=function(e,t,n){if(t==0)return[0,0];t==null&&(t=Infinity),n=n||0;var r,i;for(i=0;i<e.length;i++){r=e.charCodeAt(i),r==9?n+=this.getScreenTabSize(n):r>=4352&&x(r)?n+=2:n+=1;if(n>t)break}return[n,i]},e.prototype.getRowLength=function(e){var t=1;return this.lineWidgets&&(t+=this.lineWidgets[e]&&this.lineWidgets[e].rowCount||0),!this.$useWrapMode||!this.$wrapData[e]?t:this.$wrapData[e].length+t},e.prototype.getRowLineCount=function(e){return!this.$useWrapMode||!this.$wrapData[e]?1:this.$wrapData[e].length+1},e.prototype.getRowWrapIndent=function(e){if(this.$useWrapMode){var t=this.screenToDocumentPosition(e,Number.MAX_VALUE),n=this.$wrapData[t.row];return n.length&&n[0]<t.column?n.indent:0}return 0},e.prototype.getScreenLastRowColumn=function(e){var t=this.screenToDocumentPosition(e,Number.MAX_VALUE);return this.documentToScreenColumn(t.row,t.column)},e.prototype.getDocumentLastRowColumn=function(e,t){var n=this.documentToScreenRow(e,t);return this.getScreenLastRowColumn(n)},e.prototype.getDocumentLastRowColumnPosition=function(e,t){var n=this.documentToScreenRow(e,t);return this.screenToDocumentPosition(n,Number.MAX_VALUE/10)},e.prototype.getRowSplitData=function(e){return this.$useWrapMode?this.$wrapData[e]:undefined},e.prototype.getScreenTabSize=function(e){return this.$tabSize-(e%this.$tabSize|0)},e.prototype.screenToDocumentRow=function(e,t){return this.screenToDocumentPosition(e,t).row},e.prototype.screenToDocumentColumn=function(e,t){return this.screenToDocumentPosition(e,t).column},e.prototype.screenToDocumentPosition=function(e,t,n){if(e<0)return{row:0,column:0};var r,i=0,s=0,o,u=0,a=0,f=this.$screenRowCache,l=this.$getRowCacheIndex(f,e),c=f.length;if(c&&l>=0)var u=f[l],i=this.$docRowCache[l],h=e>f[c-1];else var h=!c;var p=this.getLength()-1,d=this.getNextFoldLine(i),v=d?d.start.row:Infinity;while(u<=e){a=this.getRowLength(i);if(u+a>e||i>=p)break;u+=a,i++,i>v&&(i=d.end.row+1,d=this.getNextFoldLine(i,d),v=d?d.start.row:Infinity),h&&(this.$docRowCache.push(i),this.$screenRowCache.push(u))}if(d&&d.start.row<=i)r=this.getFoldDisplayLine(d),i=d.start.row;else{if(u+a<=e||i>p)return{row:p,column:this.getLine(p).length};r=this.getLine(i),d=null}var m=0,g=Math.floor(e-u);if(this.$useWrapMode){var y=this.$wrapData[i];y&&(o=y[g],g>0&&y.length&&(m=y.indent,s=y[g-1]||y[y.length-1],r=r.substring(s)))}return n!==undefined&&this.$bidiHandler.isBidiRow(u+g,i,g)&&(t=this.$bidiHandler.offsetToCol(n)),s+=this.$getStringScreenWidth(r,t-m)[1],this.$useWrapMode&&s>=o&&(s=o-1),d?d.idxToPosition(s):{row:i,column:s}},e.prototype.documentToScreenPosition=function(e,t){if(typeof t=="undefined")var n=this.$clipPositionToDocument(e.row,e.column);else n=this.$clipPositionToDocument(e,t);e=n.row,t=n.column;var r=0,i=null,s=null;s=this.getFoldAt(e,t,1),s&&(e=s.start.row,t=s.start.column);var o,u=0,a=this.$docRowCache,f=this.$getRowCacheIndex(a,e),l=a.length;if(l&&f>=0)var u=a[f],r=this.$screenRowCache[f],c=e>a[l-1];else var c=!l;var h=this.getNextFoldLine(u),p=h?h.start.row:Infinity;while(u<e){if(u>=p){o=h.end.row+1;if(o>e)break;h=this.getNextFoldLine(o,h),p=h?h.start.row:Infinity}else o=u+1;r+=this.getRowLength(u),u=o,c&&(this.$docRowCache.push(u),this.$screenRowCache.push(r))}var d="";h&&u>=p?(d=this.getFoldDisplayLine(h,e,t),i=h.start.row):(d=this.getLine(e).substring(0,t),i=e);var v=0;if(this.$useWrapMode){var m=this.$wrapData[i];if(m){var g=0;while(d.length>=m[g])r++,g++;d=d.substring(m[g-1]||0,d.length),v=g>0?m.indent:0}}return this.lineWidgets&&this.lineWidgets[u]&&this.lineWidgets[u].rowsAbove&&(r+=this.lineWidgets[u].rowsAbove),{row:r,column:v+this.$getStringScreenWidth(d)[0]}},e.prototype.documentToScreenColumn=function(e,t){return this.documentToScreenPosition(e,t).column},e.prototype.documentToScreenRow=function(e,t){return this.documentToScreenPosition(e,t).row},e.prototype.getScreenLength=function(){var e=0,t=null;if(!this.$useWrapMode){e=this.getLength();var n=this.$foldData;for(var r=0;r<n.length;r++)t=n[r],e-=t.end.row-t.start.row}else{var i=this.$wrapData.length,s=0,r=0,t=this.$foldData[r++],o=t?t.start.row:Infinity;while(s<i){var u=this.$wrapData[s];e+=u?u.length+1:1,s++,s>o&&(s=t.end.row+1,t=this.$foldData[r++],o=t?t.start.row:Infinity)}}return this.lineWidgets&&(e+=this.$getWidgetScreenLength()),e},e.prototype.$setFontMetrics=function(e){if(!this.$enableVarChar)return;this.$getStringScreenWidth=function(t,n,r){if(n===0)return[0,0];n||(n=Infinity),r=r||0;var i,s;for(s=0;s<t.length;s++){i=t.charAt(s),i==="	"?r+=this.getScreenTabSize(r):r+=e.getCharacterWidth(i);if(r>n)break}return[r,s]}},e.prototype.destroy=function(){this.destroyed||(this.bgTokenizer.setDocument(null),this.bgTokenizer.cleanup(),this.destroyed=!0),this.$stopWorker(),this.removeAllListeners(),this.doc&&this.doc.off("change",this.$onChange),this.selection.detach()},e}();d.$uid=0,d.prototype.$modes=o.$modes,d.prototype.getValue=d.prototype.toString,d.prototype.$defaultUndoManager={undo:function(){},redo:function(){},hasUndo:function(){},hasRedo:function(){},reset:function(){},add:function(){},addSelection:function(){},startNewGroup:function(){},addSession:function(){}},d.prototype.$overwrite=!1,d.prototype.$mode=null,d.prototype.$modeId=null,d.prototype.$scrollTop=0,d.prototype.$scrollLeft=0,d.prototype.$wrapLimit=80,d.prototype.$useWrapMode=!1,d.prototype.$wrapLimitRange={min:null,max:null},d.prototype.lineWidgets=null,d.prototype.isFullWidth=x,r.implement(d.prototype,u);var v=1,m=2,g=3,y=4,b=9,w=10,E=11,S=12;e("./edit_session/folding").Folding.call(d.prototype),e("./edit_session/bracket_match").BracketMatch.call(d.prototype),o.defineOptions(d.prototype,"session",{wrap:{set:function(e){!e||e=="off"?e=!1:e=="free"?e=!0:e=="printMargin"?e=-1:typeof e=="string"&&(e=parseInt(e,10)||!1);if(this.$wrap==e)return;this.$wrap=e;if(!e)this.setUseWrapMode(!1);else{var t=typeof e=="number"?e:null;this.setWrapLimitRange(t,t),this.setUseWrapMode(!0)}},get:function(){return this.getUseWrapMode()?this.$wrap==-1?"printMargin":this.getWrapLimitRange().min?this.$wrap:"free":"off"},handlesSet:!0},wrapMethod:{set:function(e){e=e=="auto"?this.$mode.type!="text":e!="text",e!=this.$wrapAsCode&&(this.$wrapAsCode=e,this.$useWrapMode&&(this.$useWrapMode=!1,this.setUseWrapMode(!0)))},initialValue:"auto"},indentedSoftWrap:{set:function(){this.$useWrapMode&&(this.$useWrapMode=!1,this.setUseWrapMode(!0))},initialValue:!0},firstLineNumber:{set:function(){this._signal("changeBreakpoint")},initialValue:1},useWorker:{set:function(e){this.$useWorker=e,this.$stopWorker(),e&&this.$startWorker()},initialValue:!0},useSoftTabs:{initialValue:!0},tabSize:{set:function(e){e=parseInt(e),e>0&&this.$tabSize!==e&&(this.$modified=!0,this.$rowLengthCache=[],this.$tabSize=e,this._signal("changeTabSize"))},initialValue:4,handlesSet:!0},navigateWithinSoftTabs:{initialValue:!1},foldStyle:{set:function(e){this.setFoldStyle(e)},handlesSet:!0},overwrite:{set:function(e){this._signal("changeOverwrite")},initialValue:!1},newLineMode:{set:function(e){this.doc.setNewLineMode(e)},get:function(){return this.doc.getNewLineMode()},handlesSet:!0},mode:{set:function(e){this.setMode(e)},get:function(){return this.$modeId},handlesSet:!0}}),t.EditSession=d}),ace.define("ace/search",["require","exports","module","ace/lib/lang","ace/lib/oop","ace/range"],function(e,t,n){"use strict";function u(e,t){function n(e){return/\w/.test(e)||t.regExp?"\\b":""}return n(e[0])+e+n(e[e.length-1])}var r=e("./lib/lang"),i=e("./lib/oop"),s=e("./range").Range,o=function(){function e(){this.$options={}}return e.prototype.set=function(e){return i.mixin(this.$options,e),this},e.prototype.getOptions=function(){return r.copyObject(this.$options)},e.prototype.setOptions=function(e){this.$options=e},e.prototype.find=function(e){var t=this.$options,n=this.$matchIterator(e,t);if(!n)return!1;var r=null;return n.forEach(function(e,n,i,o){return r=new s(e,n,i,o),n==o&&t.start&&t.start.start&&t.skipCurrent!=0&&r.isEqual(t.start)?(r=null,!1):!0}),r},e.prototype.findAll=function(e){var t=this.$options;if(!t.needle)return[];this.$assembleRegExp(t);var n=t.range,i=n?e.getLines(n.start.row,n.end.row):e.doc.getAllLines(),o=[],u=t.re;if(t.$isMultiLine){var a=u.length,f=i.length-a,l;e:for(var c=u.offset||0;c<=f;c++){for(var h=0;h<a;h++)if(i[c+h].search(u[h])==-1)continue e;var p=i[c],d=i[c+a-1],v=p.length-p.match(u[0])[0].length,m=d.match(u[a-1])[0].length;if(l&&l.end.row===c&&l.end.column>v)continue;o.push(l=new s(c,v,c+a-1,m)),a>2&&(c=c+a-2)}}else for(var g=0;g<i.length;g++){var y=r.getMatchOffsets(i[g],u);for(var h=0;h<y.length;h++){var b=y[h];o.push(new s(g,b.offset,g,b.offset+b.length))}}if(n){var w=n.start.column,E=n.end.column,g=0,h=o.length-1;while(g<h&&o[g].start.column<w&&o[g].start.row==0)g++;var S=n.end.row-n.start.row;while(g<h&&o[h].end.column>E&&o[h].end.row==S)h--;o=o.slice(g,h+1);for(g=0,h=o.length;g<h;g++)o[g].start.row+=n.start.row,o[g].end.row+=n.start.row}return o},e.prototype.replace=function(e,t){var n=this.$options,r=this.$assembleRegExp(n);if(n.$isMultiLine)return t;if(!r)return;var i=r.exec(e);if(!i||i[0].length!=e.length)return null;t=e.replace(r,t);if(n.preserveCase){t=t.split("");for(var s=Math.min(e.length,e.length);s--;){var o=e[s];o&&o.toLowerCase()!=o?t[s]=t[s].toUpperCase():t[s]=t[s].toLowerCase()}t=t.join("")}return t},e.prototype.$assembleRegExp=function(e,t){if(e.needle instanceof RegExp)return e.re=e.needle;var n=e.needle;if(!e.needle)return e.re=!1;e.regExp||(n=r.escapeRegExp(n)),e.wholeWord&&(n=u(n,e));var i=e.caseSensitive?"gm":"gmi";e.$isMultiLine=!t&&/[\n\r]/.test(n);if(e.$isMultiLine)return e.re=this.$assembleMultilineRegExp(n,i);try{var s=new RegExp(n,i)}catch(o){s=!1}return e.re=s},e.prototype.$assembleMultilineRegExp=function(e,t){var n=e.replace(/\r\n|\r|\n/g,"$\n^").split("\n"),r=[];for(var i=0;i<n.length;i++)try{r.push(new RegExp(n[i],t))}catch(s){return!1}return r},e.prototype.$matchIterator=function(e,t){var n=this.$assembleRegExp(t);if(!n)return!1;var r=t.backwards==1,i=t.skipCurrent!=0,s=t.range,o=t.start;o||(o=s?s[r?"end":"start"]:e.selection.getRange()),o.start&&(o=o[i!=r?"end":"start"]);var u=s?s.start.row:0,a=s?s.end.row:e.getLength()-1;if(r)var f=function(e){var n=o.row;if(c(n,o.column,e))return;for(n--;n>=u;n--)if(c(n,Number.MAX_VALUE,e))return;if(t.wrap==0)return;for(n=a,u=o.row;n>=u;n--)if(c(n,Number.MAX_VALUE,e))return};else var f=function(e){var n=o.row;if(c(n,o.column,e))return;for(n+=1;n<=a;n++)if(c(n,0,e))return;if(t.wrap==0)return;for(n=u,a=o.row;n<=a;n++)if(c(n,0,e))return};if(t.$isMultiLine)var l=n.length,c=function(t,i,s){var o=r?t-l+1:t;if(o<0||o+l>e.getLength())return;var u=e.getLine(o),a=u.search(n[0]);if(!r&&a<i||a===-1)return;for(var f=1;f<l;f++){u=e.getLine(o+f);if(u.search(n[f])==-1)return}var c=u.match(n[l-1])[0].length;if(r&&c>i)return;if(s(o,a,o+l-1,c))return!0};else if(r)var c=function(t,r,i){var s=e.getLine(t),o=[],u,a=0;n.lastIndex=0;while(u=n.exec(s)){var f=u[0].length;a=u.index;if(!f){if(a>=s.length)break;n.lastIndex=a+=1}if(u.index+f>r)break;o.push(u.index,f)}for(var l=o.length-1;l>=0;l-=2){var c=o[l-1],f=o[l];if(i(t,c,t,c+f))return!0}};else var c=function(t,r,i){var s=e.getLine(t),o,u;n.lastIndex=r;while(u=n.exec(s)){var a=u[0].length;o=u.index;if(i(t,o,t,o+a))return!0;if(!a){n.lastIndex=o+=1;if(o>=s.length)return!1}}};return{forEach:f}},e}();t.Search=o}),ace.define("ace/keyboard/hash_handler",["require","exports","module","ace/lib/keys","ace/lib/useragent"],function(e,t,n){"use strict";function o(e,t){this.platform=t||(i.isMac?"mac":"win"),this.commands={},this.commandKeyBinding={},this.addCommands(e),this.$singleCommand=!0}function u(e,t){o.call(this,e,t),this.$singleCommand=!1}var r=e("../lib/keys"),i=e("../lib/useragent"),s=r.KEY_MODS;u.prototype=o.prototype,function(){function e(e){return typeof e=="object"&&e.bindKey&&e.bindKey.position||(e.isDefault?-100:0)}this.addCommand=function(e){this.commands[e.name]&&this.removeCommand(e),this.commands[e.name]=e,e.bindKey&&this._buildKeyHash(e)},this.removeCommand=function(e,t){var n=e&&(typeof e=="string"?e:e.name);e=this.commands[n],t||delete this.commands[n];var r=this.commandKeyBinding;for(var i in r){var s=r[i];if(s==e)delete r[i];else if(Array.isArray(s)){var o=s.indexOf(e);o!=-1&&(s.splice(o,1),s.length==1&&(r[i]=s[0]))}}},this.bindKey=function(e,t,n){typeof e=="object"&&e&&(n==undefined&&(n=e.position),e=e[this.platform]);if(!e)return;if(typeof t=="function")return this.addCommand({exec:t,bindKey:e,name:t.name||e});e.split("|").forEach(function(e){var r="";if(e.indexOf(" ")!=-1){var i=e.split(/\s+/);e=i.pop(),i.forEach(function(e){var t=this.parseKeys(e),n=s[t.hashId]+t.key;r+=(r?" ":"")+n,this._addCommandToBinding(r,"chainKeys")},this),r+=" "}var o=this.parseKeys(e),u=s[o.hashId]+o.key;this._addCommandToBinding(r+u,t,n)},this)},this._addCommandToBinding=function(t,n,r){var i=this.commandKeyBinding,s;if(!n)delete i[t];else if(!i[t]||this.$singleCommand)i[t]=n;else{Array.isArray(i[t])?(s=i[t].indexOf(n))!=-1&&i[t].splice(s,1):i[t]=[i[t]],typeof r!="number"&&(r=e(n));var o=i[t];for(s=0;s<o.length;s++){var u=o[s],a=e(u);if(a>r)break}o.splice(s,0,n)}},this.addCommands=function(e){e&&Object.keys(e).forEach(function(t){var n=e[t];if(!n)return;if(typeof n=="string")return this.bindKey(n,t);typeof n=="function"&&(n={exec:n});if(typeof n!="object")return;n.name||(n.name=t),this.addCommand(n)},this)},this.removeCommands=function(e){Object.keys(e).forEach(function(t){this.removeCommand(e[t])},this)},this.bindKeys=function(e){Object.keys(e).forEach(function(t){this.bindKey(t,e[t])},this)},this._buildKeyHash=function(e){this.bindKey(e.bindKey,e)},this.parseKeys=function(e){var t=e.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(e){return e}),n=t.pop(),i=r[n];if(r.FUNCTION_KEYS[i])n=r.FUNCTION_KEYS[i].toLowerCase();else{if(!t.length)return{key:n,hashId:-1};if(t.length==1&&t[0]=="shift")return{key:n.toUpperCase(),hashId:-1}}var s=0;for(var o=t.length;o--;){var u=r.KEY_MODS[t[o]];if(u==null)return typeof console!="undefined"&&console.error("invalid modifier "+t[o]+" in "+e),!1;s|=u}return{key:n,hashId:s}},this.findKeyCommand=function(t,n){var r=s[t]+n;return this.commandKeyBinding[r]},this.handleKeyboard=function(e,t,n,r){if(r<0)return;var i=s[t]+n,o=this.commandKeyBinding[i];e.$keyChain&&(e.$keyChain+=" "+i,o=this.commandKeyBinding[e.$keyChain]||o);if(o)if(o=="chainKeys"||o[o.length-1]=="chainKeys")return e.$keyChain=e.$keyChain||i,{command:"null"};if(e.$keyChain)if(!!t&&t!=4||n.length!=1){if(t==-1||r>0)e.$keyChain=""}else e.$keyChain=e.$keyChain.slice(0,-i.length-1);return{command:o}},this.getStatusText=function(e,t){return t.$keyChain||""}}.call(o.prototype),t.HashHandler=o,t.MultiHashHandler=u}),ace.define("ace/commands/command_manager",["require","exports","module","ace/lib/oop","ace/keyboard/hash_handler","ace/lib/event_emitter"],function(e,t,n){"use strict";var r=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}if(typeof n!="function"&&n!==null)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");e(t,n),t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),i=e("../lib/oop"),s=e("../keyboard/hash_handler").MultiHashHandler,o=e("../lib/event_emitter").EventEmitter,u=function(e){function t(t,n){var r=e.call(this,n,t)||this;return r.byName=r.commands,r.setDefaultHandler("exec",function(e){return e.args?e.command.exec(e.editor,e.args,e.event,!1):e.command.exec(e.editor,{},e.event,!0)}),r}return r(t,e),t.prototype.exec=function(e,t,n){if(Array.isArray(e)){for(var r=e.length;r--;)if(this.exec(e[r],t,n))return!0;return!1}typeof e=="string"&&(e=this.commands[e]);if(!e)return!1;if(t&&t.$readOnly&&!e.readOnly)return!1;if(this.$checkCommandState!=0&&e.isAvailable&&!e.isAvailable(t))return!1;var i={editor:t,command:e,args:n};return i.returnValue=this._emit("exec",i),this._signal("afterExec",i),i.returnValue===!1?!1:!0},t.prototype.toggleRecording=function(e){if(this.$inReplay)return;return e&&e._emit("changeStatus"),this.recording?(this.macro.pop(),this.off("exec",this.$addCommandToMacro),this.macro.length||(this.macro=this.oldMacro),this.recording=!1):(this.$addCommandToMacro||(this.$addCommandToMacro=function(e){this.macro.push([e.command,e.args])}.bind(this)),this.oldMacro=this.macro,this.macro=[],this.on("exec",this.$addCommandToMacro),this.recording=!0)},t.prototype.replay=function(e){if(this.$inReplay||!this.macro)return;if(this.recording)return this.toggleRecording(e);try{this.$inReplay=!0,this.macro.forEach(function(t){typeof t=="string"?this.exec(t,e):this.exec(t[0],e,t[1])},this)}finally{this.$inReplay=!1}},t.prototype.trimMacro=function(e){return e.map(function(e){return typeof e[0]!="string"&&(e[0]=e[0].name),e[1]||(e=e[0]),e})},t}(s);i.implement(u.prototype,o),t.CommandManager=u}),ace.define("ace/commands/default_commands",["require","exports","module","ace/lib/lang","ace/config","ace/range"],function(e,t,n){"use strict";function o(e,t){return{win:e,mac:t}}var r=e("../lib/lang"),i=e("../config"),s=e("../range").Range;t.commands=[{name:"showSettingsMenu",description:"Show settings menu",bindKey:o("Ctrl-,","Command-,"),exec:function(e){i.loadModule("ace/ext/settings_menu",function(t){t.init(e),e.showSettingsMenu()})},readOnly:!0},{name:"goToNextError",description:"Go to next error",bindKey:o("Alt-E","F4"),exec:function(e){i.loadModule("ace/ext/error_marker",function(t){t.showErrorMarker(e,1)})},scrollIntoView:"animate",readOnly:!0},{name:"goToPreviousError",description:"Go to previous error",bindKey:o("Alt-Shift-E","Shift-F4"),exec:function(e){i.loadModule("ace/ext/error_marker",function(t){t.showErrorMarker(e,-1)})},scrollIntoView:"animate",readOnly:!0},{name:"selectall",description:"Select all",bindKey:o("Ctrl-A","Command-A"),exec:function(e){e.selectAll()},readOnly:!0},{name:"centerselection",description:"Center selection",bindKey:o(null,"Ctrl-L"),exec:function(e){e.centerSelection()},readOnly:!0},{name:"gotoline",description:"Go to line...",bindKey:o("Ctrl-L","Command-L"),exec:function(e,t){typeof t=="number"&&!isNaN(t)&&e.gotoLine(t),e.prompt({$type:"gotoLine"})},readOnly:!0},{name:"fold",bindKey:o("Alt-L|Ctrl-F1","Command-Alt-L|Command-F1"),exec:function(e){e.session.toggleFold(!1)},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"unfold",bindKey:o("Alt-Shift-L|Ctrl-Shift-F1","Command-Alt-Shift-L|Command-Shift-F1"),exec:function(e){e.session.toggleFold(!0)},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"toggleFoldWidget",description:"Toggle fold widget",bindKey:o("F2","F2"),exec:function(e){e.session.toggleFoldWidget()},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"toggleParentFoldWidget",description:"Toggle parent fold widget",bindKey:o("Alt-F2","Alt-F2"),exec:function(e){e.session.toggleFoldWidget(!0)},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"foldall",description:"Fold all",bindKey:o(null,"Ctrl-Command-Option-0"),exec:function(e){e.session.foldAll()},scrollIntoView:"center",readOnly:!0},{name:"foldAllComments",description:"Fold all comments",bindKey:o(null,"Ctrl-Command-Option-0"),exec:function(e){e.session.foldAllComments()},scrollIntoView:"center",readOnly:!0},{name:"foldOther",description:"Fold other",bindKey:o("Alt-0","Command-Option-0"),exec:function(e){e.session.foldAll(),e.session.unfold(e.selection.getAllRanges())},scrollIntoView:"center",readOnly:!0},{name:"unfoldall",description:"Unfold all",bindKey:o("Alt-Shift-0","Command-Option-Shift-0"),exec:function(e){e.session.unfold()},scrollIntoView:"center",readOnly:!0},{name:"findnext",description:"Find next",bindKey:o("Ctrl-K","Command-G"),exec:function(e){e.findNext()},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"findprevious",description:"Find previous",bindKey:o("Ctrl-Shift-K","Command-Shift-G"),exec:function(e){e.findPrevious()},multiSelectAction:"forEach",scrollIntoView:"center",readOnly:!0},{name:"selectOrFindNext",description:"Select or find next",bindKey:o("Alt-K","Ctrl-G"),exec:function(e){e.selection.isEmpty()?e.selection.selectWord():e.findNext()},readOnly:!0},{name:"selectOrFindPrevious",description:"Select or find previous",bindKey:o("Alt-Shift-K","Ctrl-Shift-G"),exec:function(e){e.selection.isEmpty()?e.selection.selectWord():e.findPrevious()},readOnly:!0},{name:"find",description:"Find",bindKey:o("Ctrl-F","Command-F"),exec:function(e){i.loadModule("ace/ext/searchbox",function(t){t.Search(e)})},readOnly:!0},{name:"overwrite",description:"Overwrite",bindKey:"Insert",exec:function(e){e.toggleOverwrite()},readOnly:!0},{name:"selecttostart",description:"Select to start",bindKey:o("Ctrl-Shift-Home","Command-Shift-Home|Command-Shift-Up"),exec:function(e){e.getSelection().selectFileStart()},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"gotostart",description:"Go to start",bindKey:o("Ctrl-Home","Command-Home|Command-Up"),exec:function(e){e.navigateFileStart()},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"selectup",description:"Select up",bindKey:o("Shift-Up","Shift-Up|Ctrl-Shift-P"),exec:function(e){e.getSelection().selectUp()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"golineup",description:"Go line up",bindKey:o("Up","Up|Ctrl-P"),exec:function(e,t){e.navigateUp(t.times)},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selecttoend",description:"Select to end",bindKey:o("Ctrl-Shift-End","Command-Shift-End|Command-Shift-Down"),exec:function(e){e.getSelection().selectFileEnd()},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"gotoend",description:"Go to end",bindKey:o("Ctrl-End","Command-End|Command-Down"),exec:function(e){e.navigateFileEnd()},multiSelectAction:"forEach",readOnly:!0,scrollIntoView:"animate",aceCommandGroup:"fileJump"},{name:"selectdown",description:"Select down",bindKey:o("Shift-Down","Shift-Down|Ctrl-Shift-N"),exec:function(e){e.getSelection().selectDown()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"golinedown",description:"Go line down",bindKey:o("Down","Down|Ctrl-N"),exec:function(e,t){e.navigateDown(t.times)},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectwordleft",description:"Select word left",bindKey:o("Ctrl-Shift-Left","Option-Shift-Left"),exec:function(e){e.getSelection().selectWordLeft()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotowordleft",description:"Go to word left",bindKey:o("Ctrl-Left","Option-Left"),exec:function(e){e.navigateWordLeft()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selecttolinestart",description:"Select to line start",bindKey:o("Alt-Shift-Left","Command-Shift-Left|Ctrl-Shift-A"),exec:function(e){e.getSelection().selectLineStart()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotolinestart",description:"Go to line start",bindKey:o("Alt-Left|Home","Command-Left|Home|Ctrl-A"),exec:function(e){e.navigateLineStart()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectleft",description:"Select left",bindKey:o("Shift-Left","Shift-Left|Ctrl-Shift-B"),exec:function(e){e.getSelection().selectLeft()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotoleft",description:"Go to left",bindKey:o("Left","Left|Ctrl-B"),exec:function(e,t){e.navigateLeft(t.times)},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectwordright",description:"Select word right",bindKey:o("Ctrl-Shift-Right","Option-Shift-Right"),exec:function(e){e.getSelection().selectWordRight()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotowordright",description:"Go to word right",bindKey:o("Ctrl-Right","Option-Right"),exec:function(e){e.navigateWordRight()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selecttolineend",description:"Select to line end",bindKey:o("Alt-Shift-Right","Command-Shift-Right|Shift-End|Ctrl-Shift-E"),exec:function(e){e.getSelection().selectLineEnd()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotolineend",description:"Go to line end",bindKey:o("Alt-Right|End","Command-Right|End|Ctrl-E"),exec:function(e){e.navigateLineEnd()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectright",description:"Select right",bindKey:o("Shift-Right","Shift-Right"),exec:function(e){e.getSelection().selectRight()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"gotoright",description:"Go to right",bindKey:o("Right","Right|Ctrl-F"),exec:function(e,t){e.navigateRight(t.times)},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectpagedown",description:"Select page down",bindKey:"Shift-PageDown",exec:function(e){e.selectPageDown()},readOnly:!0},{name:"pagedown",description:"Page down",bindKey:o(null,"Option-PageDown"),exec:function(e){e.scrollPageDown()},readOnly:!0},{name:"gotopagedown",description:"Go to page down",bindKey:o("PageDown","PageDown|Ctrl-V"),exec:function(e){e.gotoPageDown()},readOnly:!0},{name:"selectpageup",description:"Select page up",bindKey:"Shift-PageUp",exec:function(e){e.selectPageUp()},readOnly:!0},{name:"pageup",description:"Page up",bindKey:o(null,"Option-PageUp"),exec:function(e){e.scrollPageUp()},readOnly:!0},{name:"gotopageup",description:"Go to page up",bindKey:"PageUp",exec:function(e){e.gotoPageUp()},readOnly:!0},{name:"scrollup",description:"Scroll up",bindKey:o("Ctrl-Up",null),exec:function(e){e.renderer.scrollBy(0,-2*e.renderer.layerConfig.lineHeight)},readOnly:!0},{name:"scrolldown",description:"Scroll down",bindKey:o("Ctrl-Down",null),exec:function(e){e.renderer.scrollBy(0,2*e.renderer.layerConfig.lineHeight)},readOnly:!0},{name:"selectlinestart",description:"Select line start",bindKey:"Shift-Home",exec:function(e){e.getSelection().selectLineStart()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"selectlineend",description:"Select line end",bindKey:"Shift-End",exec:function(e){e.getSelection().selectLineEnd()},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"togglerecording",description:"Toggle recording",bindKey:o("Ctrl-Alt-E","Command-Option-E"),exec:function(e){e.commands.toggleRecording(e)},readOnly:!0},{name:"replaymacro",description:"Replay macro",bindKey:o("Ctrl-Shift-E","Command-Shift-E"),exec:function(e){e.commands.replay(e)},readOnly:!0},{name:"jumptomatching",description:"Jump to matching",bindKey:o("Ctrl-\\|Ctrl-P","Command-\\"),exec:function(e){e.jumpToMatching()},multiSelectAction:"forEach",scrollIntoView:"animate",readOnly:!0},{name:"selecttomatching",description:"Select to matching",bindKey:o("Ctrl-Shift-\\|Ctrl-Shift-P","Command-Shift-\\"),exec:function(e){e.jumpToMatching(!0)},multiSelectAction:"forEach",scrollIntoView:"animate",readOnly:!0},{name:"expandToMatching",description:"Expand to matching",bindKey:o("Ctrl-Shift-M","Ctrl-Shift-M"),exec:function(e){e.jumpToMatching(!0,!0)},multiSelectAction:"forEach",scrollIntoView:"animate",readOnly:!0},{name:"passKeysToBrowser",description:"Pass keys to browser",bindKey:o(null,null),exec:function(){},passEvent:!0,readOnly:!0},{name:"copy",description:"Copy",exec:function(e){},readOnly:!0},{name:"cut",description:"Cut",exec:function(e){var t=e.$copyWithEmptySelection&&e.selection.isEmpty(),n=t?e.selection.getLineRange():e.selection.getRange();e._emit("cut",n),n.isEmpty()||e.session.remove(n),e.clearSelection()},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"paste",description:"Paste",exec:function(e,t){e.$handlePaste(t)},scrollIntoView:"cursor"},{name:"removeline",description:"Remove line",bindKey:o("Ctrl-D","Command-D"),exec:function(e){e.removeLines()},scrollIntoView:"cursor",multiSelectAction:"forEachLine"},{name:"duplicateSelection",description:"Duplicate selection",bindKey:o("Ctrl-Shift-D","Command-Shift-D"),exec:function(e){e.duplicateSelection()},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"sortlines",description:"Sort lines",bindKey:o("Ctrl-Alt-S","Command-Alt-S"),exec:function(e){e.sortLines()},scrollIntoView:"selection",multiSelectAction:"forEachLine"},{name:"togglecomment",description:"Toggle comment",bindKey:o("Ctrl-/","Command-/"),exec:function(e){e.toggleCommentLines()},multiSelectAction:"forEachLine",scrollIntoView:"selectionPart"},{name:"toggleBlockComment",description:"Toggle block comment",bindKey:o("Ctrl-Shift-/","Command-Shift-/"),exec:function(e){e.toggleBlockComment()},multiSelectAction:"forEach",scrollIntoView:"selectionPart"},{name:"modifyNumberUp",description:"Modify number up",bindKey:o("Ctrl-Shift-Up","Alt-Shift-Up"),exec:function(e){e.modifyNumber(1)},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"modifyNumberDown",description:"Modify number down",bindKey:o("Ctrl-Shift-Down","Alt-Shift-Down"),exec:function(e){e.modifyNumber(-1)},scrollIntoView:"cursor",multiSelectAction:"forEach"},{name:"replace",description:"Replace",bindKey:o("Ctrl-H","Command-Option-F"),exec:function(e){i.loadModule("ace/ext/searchbox",function(t){t.Search(e,!0)})}},{name:"undo",description:"Undo",bindKey:o("Ctrl-Z","Command-Z"),exec:function(e){e.undo()}},{name:"redo",description:"Redo",bindKey:o("Ctrl-Shift-Z|Ctrl-Y","Command-Shift-Z|Command-Y"),exec:function(e){e.redo()}},{name:"copylinesup",description:"Copy lines up",bindKey:o("Alt-Shift-Up","Command-Option-Up"),exec:function(e){e.copyLinesUp()},scrollIntoView:"cursor"},{name:"movelinesup",description:"Move lines up",bindKey:o("Alt-Up","Option-Up"),exec:function(e){e.moveLinesUp()},scrollIntoView:"cursor"},{name:"copylinesdown",description:"Copy lines down",bindKey:o("Alt-Shift-Down","Command-Option-Down"),exec:function(e){e.copyLinesDown()},scrollIntoView:"cursor"},{name:"movelinesdown",description:"Move lines down",bindKey:o("Alt-Down","Option-Down"),exec:function(e){e.moveLinesDown()},scrollIntoView:"cursor"},{name:"del",description:"Delete",bindKey:o("Delete","Delete|Ctrl-D|Shift-Delete"),exec:function(e){e.remove("right")},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"backspace",description:"Backspace",bindKey:o("Shift-Backspace|Backspace","Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),exec:function(e){e.remove("left")},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"cut_or_delete",description:"Cut or delete",bindKey:o("Shift-Delete",null),exec:function(e){if(!e.selection.isEmpty())return!1;e.remove("left")},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolinestart",description:"Remove to line start",bindKey:o("Alt-Backspace","Command-Backspace"),exec:function(e){e.removeToLineStart()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolineend",description:"Remove to line end",bindKey:o("Alt-Delete","Ctrl-K|Command-Delete"),exec:function(e){e.removeToLineEnd()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolinestarthard",description:"Remove to line start hard",bindKey:o("Ctrl-Shift-Backspace",null),exec:function(e){var t=e.selection.getRange();t.start.column=0,e.session.remove(t)},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removetolineendhard",description:"Remove to line end hard",bindKey:o("Ctrl-Shift-Delete",null),exec:function(e){var t=e.selection.getRange();t.end.column=Number.MAX_VALUE,e.session.remove(t)},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removewordleft",description:"Remove word left",bindKey:o("Ctrl-Backspace","Alt-Backspace|Ctrl-Alt-Backspace"),exec:function(e){e.removeWordLeft()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"removewordright",description:"Remove word right",bindKey:o("Ctrl-Delete","Alt-Delete"),exec:function(e){e.removeWordRight()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"outdent",description:"Outdent",bindKey:o("Shift-Tab","Shift-Tab"),exec:function(e){e.blockOutdent()},multiSelectAction:"forEach",scrollIntoView:"selectionPart"},{name:"indent",description:"Indent",bindKey:o("Tab","Tab"),exec:function(e){e.indent()},multiSelectAction:"forEach",scrollIntoView:"selectionPart"},{name:"blockoutdent",description:"Block outdent",bindKey:o("Ctrl-[","Ctrl-["),exec:function(e){e.blockOutdent()},multiSelectAction:"forEachLine",scrollIntoView:"selectionPart"},{name:"blockindent",description:"Block indent",bindKey:o("Ctrl-]","Ctrl-]"),exec:function(e){e.blockIndent()},multiSelectAction:"forEachLine",scrollIntoView:"selectionPart"},{name:"insertstring",description:"Insert string",exec:function(e,t){e.insert(t)},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"inserttext",description:"Insert text",exec:function(e,t){e.insert(r.stringRepeat(t.text||"",t.times||1))},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"splitline",description:"Split line",bindKey:o(null,"Ctrl-O"),exec:function(e){e.splitLine()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"transposeletters",description:"Transpose letters",bindKey:o("Alt-Shift-X","Ctrl-T"),exec:function(e){e.transposeLetters()},multiSelectAction:function(e){e.transposeSelections(1)},scrollIntoView:"cursor"},{name:"touppercase",description:"To uppercase",bindKey:o("Ctrl-U","Ctrl-U"),exec:function(e){e.toUpperCase()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"tolowercase",description:"To lowercase",bindKey:o("Ctrl-Shift-U","Ctrl-Shift-U"),exec:function(e){e.toLowerCase()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"autoindent",description:"Auto Indent",bindKey:o(null,null),exec:function(e){e.autoIndent()},multiSelectAction:"forEachLine",scrollIntoView:"animate"},{name:"expandtoline",description:"Expand to line",bindKey:o("Ctrl-Shift-L","Command-Shift-L"),exec:function(e){var t=e.selection.getRange();t.start.column=t.end.column=0,t.end.row++,e.selection.setRange(t,!1)},multiSelectAction:"forEach",scrollIntoView:"cursor",readOnly:!0},{name:"openlink",bindKey:o("Ctrl+F3","F3"),exec:function(e){e.openLink()}},{name:"joinlines",description:"Join lines",bindKey:o(null,null),exec:function(e){var t=e.selection.isBackwards(),n=t?e.selection.getSelectionLead():e.selection.getSelectionAnchor(),i=t?e.selection.getSelectionAnchor():e.selection.getSelectionLead(),o=e.session.doc.getLine(n.row).length,u=e.session.doc.getTextRange(e.selection.getRange()),a=u.replace(/\n\s*/," ").length,f=e.session.doc.getLine(n.row);for(var l=n.row+1;l<=i.row+1;l++){var c=r.stringTrimLeft(r.stringTrimRight(e.session.doc.getLine(l)));c.length!==0&&(c=" "+c),f+=c}i.row+1<e.session.doc.getLength()-1&&(f+=e.session.doc.getNewLineCharacter()),e.clearSelection(),e.session.doc.replace(new s(n.row,0,i.row+2,0),f),a>0?(e.selection.moveCursorTo(n.row,n.column),e.selection.selectTo(n.row,n.column+a)):(o=e.session.doc.getLine(n.row).length>o?o+1:o,e.selection.moveCursorTo(n.row,o))},multiSelectAction:"forEach",readOnly:!0},{name:"invertSelection",description:"Invert selection",bindKey:o(null,null),exec:function(e){var t=e.session.doc.getLength()-1,n=e.session.doc.getLine(t).length,r=e.selection.rangeList.ranges,i=[];r.length<1&&(r=[e.selection.getRange()]);for(var o=0;o<r.length;o++)o==r.length-1&&(r[o].end.row!==t||r[o].end.column!==n)&&i.push(new s(r[o].end.row,r[o].end.column,t,n)),o===0?(r[o].start.row!==0||r[o].start.column!==0)&&i.push(new s(0,0,r[o].start.row,r[o].start.column)):i.push(new s(r[o-1].end.row,r[o-1].end.column,r[o].start.row,r[o].start.column));e.exitMultiSelectMode(),e.clearSelection();for(var o=0;o<i.length;o++)e.selection.addRange(i[o],!1)},readOnly:!0,scrollIntoView:"none"},{name:"addLineAfter",description:"Add new line after the current line",exec:function(e){e.selection.clearSelection(),e.navigateLineEnd(),e.insert("\n")},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"addLineBefore",description:"Add new line before the current line",exec:function(e){e.selection.clearSelection();var t=e.getCursorPosition();e.selection.moveTo(t.row-1,Number.MAX_VALUE),e.insert("\n"),t.row===0&&e.navigateUp()},multiSelectAction:"forEach",scrollIntoView:"cursor"},{name:"openCommandPallete",description:"Open command palette",bindKey:o("F1","F1"),exec:function(e){e.prompt({$type:"commands"})},readOnly:!0},{name:"modeSelect",description:"Change language mode...",bindKey:o(null,null),exec:function(e){e.prompt({$type:"modes"})},readOnly:!0}];for(var u=1;u<9;u++)t.commands.push({name:"foldToLevel"+u,description:"Fold To Level "+u,level:u,exec:function(e){e.session.foldToLevel(this.level)},scrollIntoView:"center",readOnly:!0})}),ace.define("ace/line_widgets",["require","exports","module","ace/lib/dom"],function(e,t,n){"use strict";var r=e("./lib/dom"),i=function(){function e(e){this.session=e,this.session.widgetManager=this,this.session.getRowLength=this.getRowLength,this.session.$getWidgetScreenLength=this.$getWidgetScreenLength,this.updateOnChange=this.updateOnChange.bind(this),this.renderWidgets=this.renderWidgets.bind(this),this.measureWidgets=this.measureWidgets.bind(this),this.session._changedWidgets=[],this.$onChangeEditor=this.$onChangeEditor.bind(this),this.session.on("change",this.updateOnChange),this.session.on("changeFold",this.updateOnFold),this.session.on("changeEditor",this.$onChangeEditor)}return e.prototype.getRowLength=function(e){var t;return this.lineWidgets?t=this.lineWidgets[e]&&this.lineWidgets[e].rowCount||0:t=0,!this.$useWrapMode||!this.$wrapData[e]?1+t:this.$wrapData[e].length+1+t},e.prototype.$getWidgetScreenLength=function(){var e=0;return this.lineWidgets.forEach(function(t){t&&t.rowCount&&!t.hidden&&(e+=t.rowCount)}),e},e.prototype.$onChangeEditor=function(e){this.attach(e.editor)},e.prototype.attach=function(e){e&&e.widgetManager&&e.widgetManager!=this&&e.widgetManager.detach();if(this.editor==e)return;this.detach(),this.editor=e,e&&(e.widgetManager=this,e.renderer.on("beforeRender",this.measureWidgets),e.renderer.on("afterRender",this.renderWidgets))},e.prototype.detach=function(e){var t=this.editor;if(!t)return;this.editor=null,t.widgetManager=null,t.renderer.off("beforeRender",this.measureWidgets),t.renderer.off("afterRender",this.renderWidgets);var n=this.session.lineWidgets;n&&n.forEach(function(e){e&&e.el&&e.el.parentNode&&(e._inDocument=!1,e.el.parentNode.removeChild(e.el))})},e.prototype.updateOnFold=function(e,t){var n=t.lineWidgets;if(!n||!e.action)return;var r=e.data,i=r.start.row,s=r.end.row,o=e.action=="add";for(var u=i+1;u<s;u++)n[u]&&(n[u].hidden=o);n[s]&&(o?n[i]?n[s].hidden=o:n[i]=n[s]:(n[i]==n[s]&&(n[i]=undefined),n[s].hidden=o))},e.prototype.updateOnChange=function(e){var t=this.session.lineWidgets;if(!t)return;var n=e.start.row,r=e.end.row-n;if(r!==0)if(e.action=="remove"){var i=t.splice(n+1,r);!t[n]&&i[i.length-1]&&(t[n]=i.pop()),i.forEach(function(e){e&&this.removeLineWidget(e)},this),this.$updateRows()}else{var s=new Array(r);t[n]&&t[n].column!=null&&e.start.column>t[n].column&&n++,s.unshift(n,0),t.splice.apply(t,s),this.$updateRows()}},e.prototype.$updateRows=function(){var e=this.session.lineWidgets;if(!e)return;var t=!0;e.forEach(function(e,n){if(e){t=!1,e.row=n;while(e.$oldWidget)e.$oldWidget.row=n,e=e.$oldWidget}}),t&&(this.session.lineWidgets=null)},e.prototype.$registerLineWidget=function(e){this.session.lineWidgets||(this.session.lineWidgets=new Array(this.session.getLength()));var t=this.session.lineWidgets[e.row];return t&&(e.$oldWidget=t,t.el&&t.el.parentNode&&(t.el.parentNode.removeChild(t.el),t._inDocument=!1)),this.session.lineWidgets[e.row]=e,e},e.prototype.addLineWidget=function(e){this.$registerLineWidget(e),e.session=this.session;if(!this.editor)return e;var t=this.editor.renderer;e.html&&!e.el&&(e.el=r.createElement("div"),e.el.innerHTML=e.html),e.text&&!e.el&&(e.el=r.createElement("div"),e.el.textContent=e.text),e.el&&(r.addCssClass(e.el,"ace_lineWidgetContainer"),e.className&&r.addCssClass(e.el,e.className),e.el.style.position="absolute",e.el.style.zIndex=5,t.container.appendChild(e.el),e._inDocument=!0,e.coverGutter||(e.el.style.zIndex=3),e.pixelHeight==null&&(e.pixelHeight=e.el.offsetHeight)),e.rowCount==null&&(e.rowCount=e.pixelHeight/t.layerConfig.lineHeight);var n=this.session.getFoldAt(e.row,0);e.$fold=n;if(n){var i=this.session.lineWidgets;e.row==n.end.row&&!i[n.start.row]?i[n.start.row]=e:e.hidden=!0}return this.session._emit("changeFold",{data:{start:{row:e.row}}}),this.$updateRows(),this.renderWidgets(null,t),this.onWidgetChanged(e),e},e.prototype.removeLineWidget=function(e){e._inDocument=!1,e.session=null,e.el&&e.el.parentNode&&e.el.parentNode.removeChild(e.el);if(e.editor&&e.editor.destroy)try{e.editor.destroy()}catch(t){}if(this.session.lineWidgets){var n=this.session.lineWidgets[e.row];if(n==e)this.session.lineWidgets[e.row]=e.$oldWidget,e.$oldWidget&&this.onWidgetChanged(e.$oldWidget);else while(n){if(n.$oldWidget==e){n.$oldWidget=e.$oldWidget;break}n=n.$oldWidget}}this.session._emit("changeFold",{data:{start:{row:e.row}}}),this.$updateRows()},e.prototype.getWidgetsAtRow=function(e){var t=this.session.lineWidgets,n=t&&t[e],r=[];while(n)r.push(n),n=n.$oldWidget;return r},e.prototype.onWidgetChanged=function(e){this.session._changedWidgets.push(e),this.editor&&this.editor.renderer.updateFull()},e.prototype.measureWidgets=function(e,t){var n=this.session._changedWidgets,r=t.layerConfig;if(!n||!n.length)return;var i=Infinity;for(var s=0;s<n.length;s++){var o=n[s];if(!o||!o.el)continue;if(o.session!=this.session)continue;if(!o._inDocument){if(this.session.lineWidgets[o.row]!=o)continue;o._inDocument=!0,t.container.appendChild(o.el)}o.h=o.el.offsetHeight,o.fixedWidth||(o.w=o.el.offsetWidth,o.screenWidth=Math.ceil(o.w/r.characterWidth));var u=o.h/r.lineHeight;o.coverLine&&(u-=this.session.getRowLineCount(o.row),u<0&&(u=0)),o.rowCount!=u&&(o.rowCount=u,o.row<i&&(i=o.row))}i!=Infinity&&(this.session._emit("changeFold",{data:{start:{row:i}}}),this.session.lineWidgetWidth=null),this.session._changedWidgets=[]},e.prototype.renderWidgets=function(e,t){var n=t.layerConfig,r=this.session.lineWidgets;if(!r)return;var i=Math.min(this.firstRow,n.firstRow),s=Math.max(this.lastRow,n.lastRow,r.length);while(i>0&&!r[i])i--;this.firstRow=n.firstRow,this.lastRow=n.lastRow,t.$cursorLayer.config=n;for(var o=i;o<=s;o++){var u=r[o];if(!u||!u.el)continue;if(u.hidden){u.el.style.top=-100-(u.pixelHeight||0)+"px";continue}u._inDocument||(u._inDocument=!0,t.container.appendChild(u.el));var a=t.$cursorLayer.getPixelPosition({row:o,column:0},!0).top;u.coverLine||(a+=n.lineHeight*this.session.getRowLineCount(u.row)),u.el.style.top=a-n.offset+"px";var f=u.coverGutter?0:t.gutterWidth;u.fixedWidth||(f-=t.scrollLeft),u.el.style.left=f+"px",u.fullWidth&&u.screenWidth&&(u.el.style.minWidth=n.width+2*n.padding+"px"),u.fixedWidth?u.el.style.right=t.scrollBar.getWidth()+"px":u.el.style.right=""}},e}();t.LineWidgets=i}),ace.define("ace/editor",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/useragent","ace/keyboard/textinput","ace/mouse/mouse_handler","ace/mouse/fold_handler","ace/keyboard/keybinding","ace/edit_session","ace/search","ace/range","ace/lib/event_emitter","ace/commands/command_manager","ace/commands/default_commands","ace/config","ace/token_iterator","ace/line_widgets","ace/clipboard","ace/lib/keys"],function(e,t,n){"use strict";var r=this&&this.__values||function(e){var t=typeof Symbol=="function"&&Symbol.iterator,n=t&&e[t],r=0;if(n)return n.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&r>=e.length&&(e=void 0),{value:e&&e[r++],done:!e}}};throw new TypeError(t?"Object is not iterable.":"Symbol.iterator is not defined.")},i=e("./lib/oop"),s=e("./lib/dom"),o=e("./lib/lang"),u=e("./lib/useragent"),a=e("./keyboard/textinput").TextInput,f=e("./mouse/mouse_handler").MouseHandler,l=e("./mouse/fold_handler").FoldHandler,c=e("./keyboard/keybinding").KeyBinding,h=e("./edit_session").EditSession,p=e("./search").Search,d=e("./range").Range,v=e("./lib/event_emitter").EventEmitter,m=e("./commands/command_manager").CommandManager,g=e("./commands/default_commands").commands,y=e("./config"),b=e("./token_iterator").TokenIterator,w=e("./line_widgets").LineWidgets,E=e("./clipboard"),S=e("./lib/keys"),x=function(){function e(t,n,r){this.$toDestroy=[];var i=t.getContainerElement();this.container=i,this.renderer=t,this.id="editor"+ ++e.$uid,this.commands=new m(u.isMac?"mac":"win",g),typeof document=="object"&&(this.textInput=new a(t.getTextAreaContainer(),this),this.renderer.textarea=this.textInput.getElement(),this.$mouseHandler=new f(this),new l(this)),this.keyBinding=new c(this),this.$search=(new p).set({wrap:!0}),this.$historyTracker=this.$historyTracker.bind(this),this.commands.on("exec",this.$historyTracker),this.$initOperationListeners(),this._$emitInputEvent=o.delayedCall(function(){this._signal("input",{}),this.session&&!this.session.destroyed&&this.session.bgTokenizer.scheduleStart()}.bind(this)),this.on("change",function(e,t){t._$emitInputEvent.schedule(31)}),this.setSession(n||r&&r.session||new h("")),y.resetOptions(this),r&&this.setOptions(r),y._signal("editor",this)}return e.prototype.$initOperationListeners=function(){this.commands.on("exec",this.startOperation.bind(this),!0),this.commands.on("afterExec",this.endOperation.bind(this),!0),this.$opResetTimer=o.delayedCall(this.endOperation.bind(this,!0)),this.on("change",function(){this.curOp||(this.startOperation(),this.curOp.selectionBefore=this.$lastSel),this.curOp.docChanged=!0}.bind(this),!0),this.on("changeSelection",function(){this.curOp||(this.startOperation(),this.curOp.selectionBefore=this.$lastSel),this.curOp.selectionChanged=!0}.bind(this),!0)},e.prototype.startOperation=function(e){if(this.curOp){if(!e||this.curOp.command)return;this.prevOp=this.curOp}e||(this.previousCommand=null,e={}),this.$opResetTimer.schedule(),this.curOp=this.session.curOp={command:e.command||{},args:e.args,scrollTop:this.renderer.scrollTop},this.curOp.selectionBefore=this.selection.toJSON()},e.prototype.endOperation=function(e){if(this.curOp&&this.session){if(e&&e.returnValue===!1||!this.session)return this.curOp=null;if(e==1&&this.curOp.command&&this.curOp.command.name=="mouse")return;this._signal("beforeEndOperation");if(!this.curOp)return;var t=this.curOp.command,n=t&&t.scrollIntoView;if(n){switch(n){case"center-animate":n="animate";case"center":this.renderer.scrollCursorIntoView(null,.5);break;case"animate":case"cursor":this.renderer.scrollCursorIntoView();break;case"selectionPart":var r=this.selection.getRange(),i=this.renderer.layerConfig;(r.start.row>=i.lastRow||r.end.row<=i.firstRow)&&this.renderer.scrollSelectionIntoView(this.selection.anchor,this.selection.lead);break;default:}n=="animate"&&this.renderer.animateScrolling(this.curOp.scrollTop)}var s=this.selection.toJSON();this.curOp.selectionAfter=s,this.$lastSel=this.selection.toJSON(),this.session.getUndoManager().addSelection(s),this.prevOp=this.curOp,this.curOp=null}},e.prototype.$historyTracker=function(e){if(!this.$mergeUndoDeltas)return;var t=this.prevOp,n=this.$mergeableCommands,r=t.command&&e.command.name==t.command.name;if(e.command.name=="insertstring"){var i=e.args;this.mergeNextCommand===undefined&&(this.mergeNextCommand=!0),r=r&&this.mergeNextCommand&&(!/\s/.test(i)||/\s/.test(t.args)),this.mergeNextCommand=!0}else r=r&&n.indexOf(e.command.name)!==-1;this.$mergeUndoDeltas!="always"&&Date.now()-this.sequenceStartTime>2e3&&(r=!1),r?this.session.mergeUndoDeltas=!0:n.indexOf(e.command.name)!==-1&&(this.sequenceStartTime=Date.now())},e.prototype.setKeyboardHandler=function(e,t){if(e&&typeof e=="string"&&e!="ace"){this.$keybindingId=e;var n=this;y.loadModule(["keybinding",e],function(r){n.$keybindingId==e&&n.keyBinding.setKeyboardHandler(r&&r.handler),t&&t()})}else this.$keybindingId=null,this.keyBinding.setKeyboardHandler(e),t&&t()},e.prototype.getKeyboardHandler=function(){return this.keyBinding.getKeyboardHandler()},e.prototype.setSession=function(e){if(this.session==e)return;this.curOp&&this.endOperation(),this.curOp={};var t=this.session;if(t){this.session.off("change",this.$onDocumentChange),this.session.off("changeMode",this.$onChangeMode),this.session.off("tokenizerUpdate",this.$onTokenizerUpdate),this.session.off("changeTabSize",this.$onChangeTabSize),this.session.off("changeWrapLimit",this.$onChangeWrapLimit),this.session.off("changeWrapMode",this.$onChangeWrapMode),this.session.off("changeFold",this.$onChangeFold),this.session.off("changeFrontMarker",this.$onChangeFrontMarker),this.session.off("changeBackMarker",this.$onChangeBackMarker),this.session.off("changeBreakpoint",this.$onChangeBreakpoint),this.session.off("changeAnnotation",this.$onChangeAnnotation),this.session.off("changeOverwrite",this.$onCursorChange),this.session.off("changeScrollTop",this.$onScrollTopChange),this.session.off("changeScrollLeft",this.$onScrollLeftChange);var n=this.session.getSelection();n.off("changeCursor",this.$onCursorChange),n.off("changeSelection",this.$onSelectionChange)}this.session=e,e?(this.$onDocumentChange=this.onDocumentChange.bind(this),e.on("change",this.$onDocumentChange),this.renderer.setSession(e),this.$onChangeMode=this.onChangeMode.bind(this),e.on("changeMode",this.$onChangeMode),this.$onTokenizerUpdate=this.onTokenizerUpdate.bind(this),e.on("tokenizerUpdate",this.$onTokenizerUpdate),this.$onChangeTabSize=this.renderer.onChangeTabSize.bind(this.renderer),e.on("changeTabSize",this.$onChangeTabSize),this.$onChangeWrapLimit=this.onChangeWrapLimit.bind(this),e.on("changeWrapLimit",this.$onChangeWrapLimit),this.$onChangeWrapMode=this.onChangeWrapMode.bind(this),e.on("changeWrapMode",this.$onChangeWrapMode),this.$onChangeFold=this.onChangeFold.bind(this),e.on("changeFold",this.$onChangeFold),this.$onChangeFrontMarker=this.onChangeFrontMarker.bind(this),this.session.on("changeFrontMarker",this.$onChangeFrontMarker),this.$onChangeBackMarker=this.onChangeBackMarker.bind(this),this.session.on("changeBackMarker",this.$onChangeBackMarker),this.$onChangeBreakpoint=this.onChangeBreakpoint.bind(this),this.session.on("changeBreakpoint",this.$onChangeBreakpoint),this.$onChangeAnnotation=this.onChangeAnnotation.bind(this),this.session.on("changeAnnotation",this.$onChangeAnnotation),this.$onCursorChange=this.onCursorChange.bind(this),this.session.on("changeOverwrite",this.$onCursorChange),this.$onScrollTopChange=this.onScrollTopChange.bind(this),this.session.on("changeScrollTop",this.$onScrollTopChange),this.$onScrollLeftChange=this.onScrollLeftChange.bind(this),this.session.on("changeScrollLeft",this.$onScrollLeftChange),this.selection=e.getSelection(),this.selection.on("changeCursor",this.$onCursorChange),this.$onSelectionChange=this.onSelectionChange.bind(this),this.selection.on("changeSelection",this.$onSelectionChange),this.onChangeMode(),this.onCursorChange(),this.onScrollTopChange(),this.onScrollLeftChange(),this.onSelectionChange(),this.onChangeFrontMarker(),this.onChangeBackMarker(),this.onChangeBreakpoint(),this.onChangeAnnotation(),this.session.getUseWrapMode()&&this.renderer.adjustWrapLimit(),this.renderer.updateFull()):(this.selection=null,this.renderer.setSession(e)),this._signal("changeSession",{session:e,oldSession:t}),this.curOp=null,t&&t._signal("changeEditor",{oldEditor:this}),e&&e._signal("changeEditor",{editor:this}),e&&!e.destroyed&&e.bgTokenizer.scheduleStart()},e.prototype.getSession=function(){return this.session},e.prototype.setValue=function(e,t){return this.session.doc.setValue(e),t?t==1?this.navigateFileEnd():t==-1&&this.navigateFileStart():this.selectAll(),e},e.prototype.getValue=function(){return this.session.getValue()},e.prototype.getSelection=function(){return this.selection},e.prototype.resize=function(e){this.renderer.onResize(e)},e.prototype.setTheme=function(e,t){this.renderer.setTheme(e,t)},e.prototype.getTheme=function(){return this.renderer.getTheme()},e.prototype.setStyle=function(e){this.renderer.setStyle(e)},e.prototype.unsetStyle=function(e){this.renderer.unsetStyle(e)},e.prototype.getFontSize=function(){return this.getOption("fontSize")||s.computedStyle(this.container).fontSize},e.prototype.setFontSize=function(e){this.setOption("fontSize",e)},e.prototype.$highlightBrackets=function(){if(this.$highlightPending)return;var e=this;this.$highlightPending=!0,setTimeout(function(){e.$highlightPending=!1;var t=e.session;if(!t||t.destroyed)return;t.$bracketHighlight&&(t.$bracketHighlight.markerIds.forEach(function(e){t.removeMarker(e)}),t.$bracketHighlight=null);var n=e.getCursorPosition(),r=e.getKeyboardHandler(),i=r&&r.$getDirectionForHighlight&&r.$getDirectionForHighlight(e),s=t.getMatchingBracketRanges(n,i);if(!s){var o=new b(t,n.row,n.column),u=o.getCurrentToken();if(u&&/\b(?:tag-open|tag-name)/.test(u.type)){var a=t.getMatchingTags(n);a&&(s=[a.openTagName,a.closeTagName])}}!s&&t.$mode.getMatching&&(s=t.$mode.getMatching(e.session));if(!s){e.getHighlightIndentGuides()&&e.renderer.$textLayer.$highlightIndentGuide();return}var f="ace_bracket";Array.isArray(s)?s.length==1&&(f="ace_error_bracket"):s=[s],s.length==2&&(d.comparePoints(s[0].end,s[1].start)==0?s=[d.fromPoints(s[0].start,s[1].end)]:d.comparePoints(s[0].start,s[1].end)==0&&(s=[d.fromPoints(s[1].start,s[0].end)])),t.$bracketHighlight={ranges:s,markerIds:s.map(function(e){return t.addMarker(e,f,"text")})},e.getHighlightIndentGuides()&&e.renderer.$textLayer.$highlightIndentGuide()},50)},e.prototype.focus=function(){this.textInput.focus()},e.prototype.isFocused=function(){return this.textInput.isFocused()},e.prototype.blur=function(){this.textInput.blur()},e.prototype.onFocus=function(e){if(this.$isFocused)return;this.$isFocused=!0,this.renderer.showCursor(),this.renderer.visualizeFocus(),this._emit("focus",e)},e.prototype.onBlur=function(e){if(!this.$isFocused)return;this.$isFocused=!1,this.renderer.hideCursor(),this.renderer.visualizeBlur(),this._emit("blur",e)},e.prototype.$cursorChange=function(){this.renderer.updateCursor(),this.$highlightBrackets(),this.$updateHighlightActiveLine()},e.prototype.onDocumentChange=function(e){var t=this.session.$useWrapMode,n=e.start.row==e.end.row?e.end.row:Infinity;this.renderer.updateLines(e.start.row,n,t),this._signal("change",e),this.$cursorChange()},e.prototype.onTokenizerUpdate=function(e){var t=e.data;this.renderer.updateLines(t.first,t.last)},e.prototype.onScrollTopChange=function(){this.renderer.scrollToY(this.session.getScrollTop())},e.prototype.onScrollLeftChange=function(){this.renderer.scrollToX(this.session.getScrollLeft())},e.prototype.onCursorChange=function(){this.$cursorChange(),this._signal("changeSelection")},e.prototype.$updateHighlightActiveLine=function(){var e=this.getSession(),t;if(this.$highlightActiveLine){if(this.$selectionStyle!="line"||!this.selection.isMultiLine())t=this.getCursorPosition();this.renderer.theme&&this.renderer.theme.$selectionColorConflict&&!this.selection.isEmpty()&&(t=!1),this.renderer.$maxLines&&this.session.getLength()===1&&!(this.renderer.$minLines>1)&&(t=!1)}if(e.$highlightLineMarker&&!t)e.removeMarker(e.$highlightLineMarker.id),e.$highlightLineMarker=null;else if(!e.$highlightLineMarker&&t){var n=new d(t.row,t.column,t.row,Infinity);n.id=e.addMarker(n,"ace_active-line","screenLine"),e.$highlightLineMarker=n}else t&&(e.$highlightLineMarker.start.row=t.row,e.$highlightLineMarker.end.row=t.row,e.$highlightLineMarker.start.column=t.column,e._signal("changeBackMarker"))},e.prototype.onSelectionChange=function(e){var t=this.session;t.$selectionMarker&&t.removeMarker(t.$selectionMarker),t.$selectionMarker=null;if(!this.selection.isEmpty()){var n=this.selection.getRange(),r=this.getSelectionStyle();t.$selectionMarker=t.addMarker(n,"ace_selection",r)}else this.$updateHighlightActiveLine();var i=this.$highlightSelectedWord&&this.$getSelectionHighLightRegexp();this.session.highlight(i),this._signal("changeSelection")},e.prototype.$getSelectionHighLightRegexp=function(){var e=this.session,t=this.getSelectionRange();if(t.isEmpty()||t.isMultiLine())return;var n=t.start.column,r=t.end.column,i=e.getLine(t.start.row),s=i.substring(n,r);if(s.length>5e3||!/[\w\d]/.test(s))return;var o=this.$search.$assembleRegExp({wholeWord:!0,caseSensitive:!0,needle:s}),u=i.substring(n-1,r+1);if(!o.test(u))return;return o},e.prototype.onChangeFrontMarker=function(){this.renderer.updateFrontMarkers()},e.prototype.onChangeBackMarker=function(){this.renderer.updateBackMarkers()},e.prototype.onChangeBreakpoint=function(){this.renderer.updateBreakpoints()},e.prototype.onChangeAnnotation=function(){this.renderer.setAnnotations(this.session.getAnnotations())},e.prototype.onChangeMode=function(e){this.renderer.updateText(),this._emit("changeMode",e)},e.prototype.onChangeWrapLimit=function(){this.renderer.updateFull()},e.prototype.onChangeWrapMode=function(){this.renderer.onResize(!0)},e.prototype.onChangeFold=function(){this.$updateHighlightActiveLine(),this.renderer.updateFull()},e.prototype.getSelectedText=function(){return this.session.getTextRange(this.getSelectionRange())},e.prototype.getCopyText=function(){var e=this.getSelectedText(),t=this.session.doc.getNewLineCharacter(),n=!1;if(!e&&this.$copyWithEmptySelection){n=!0;var r=this.selection.getAllRanges();for(var i=0;i<r.length;i++){var s=r[i];if(i&&r[i-1].start.row==s.start.row)continue;e+=this.session.getLine(s.start.row)+t}}var o={text:e};return this._signal("copy",o),E.lineMode=n?o.text:!1,o.text},e.prototype.onCopy=function(){this.commands.exec("copy",this)},e.prototype.onCut=function(){this.commands.exec("cut",this)},e.prototype.onPaste=function(e,t){var n={text:e,event:t};this.commands.exec("paste",this,n)},e.prototype.$handlePaste=function(e){typeof e=="string"&&(e={text:e}),this._signal("paste",e);var t=e.text,n=t===E.lineMode,r=this.session;if(!this.inMultiSelectMode||this.inVirtualSelectionMode)n?r.insert({row:this.selection.lead.row,column:0},t):this.insert(t);else if(n)this.selection.rangeList.ranges.forEach(function(e){r.insert({row:e.start.row,column:0},t)});else{var i=t.split(/\r\n|\r|\n/),s=this.selection.rangeList.ranges,o=i.length==2&&(!i[0]||!i[1]);if(i.length!=s.length||o)return this.commands.exec("insertstring",this,t);for(var u=s.length;u--;){var a=s[u];a.isEmpty()||r.remove(a),r.insert(a.start,i[u])}}},e.prototype.execCommand=function(e,t){return this.commands.exec(e,this,t)},e.prototype.insert=function(e,t){var n=this.session,r=n.getMode(),i=this.getCursorPosition();if(this.getBehavioursEnabled()&&!t){var s=r.transformAction(n.getState(i.row),"insertion",this,n,e);s&&(e!==s.text&&(this.inVirtualSelectionMode||(this.session.mergeUndoDeltas=!1,this.mergeNextCommand=!1)),e=s.text)}e=="	"&&(e=this.session.getTabString());if(!this.selection.isEmpty()){var o=this.getSelectionRange();i=this.session.remove(o),this.clearSelection()}else if(this.session.getOverwrite()&&e.indexOf("\n")==-1){var o=new d.fromPoints(i,i);o.end.column+=e.length,this.session.remove(o)}if(e=="\n"||e=="\r\n"){var u=n.getLine(i.row);if(i.column>u.search(/\S|$/)){var a=u.substr(i.column).search(/\S|$/);n.doc.removeInLine(i.row,i.column,i.column+a)}}this.clearSelection();var f=i.column,l=n.getState(i.row),u=n.getLine(i.row),c=r.checkOutdent(l,u,e);n.insert(i,e),s&&s.selection&&(s.selection.length==2?this.selection.setSelectionRange(new d(i.row,f+s.selection[0],i.row,f+s.selection[1])):this.selection.setSelectionRange(new d(i.row+s.selection[0],s.selection[1],i.row+s.selection[2],s.selection[3])));if(this.$enableAutoIndent){if(n.getDocument().isNewLine(e)){var h=r.getNextLineIndent(l,u.slice(0,i.column),n.getTabString());n.insert({row:i.row+1,column:0},h)}c&&r.autoOutdent(l,n,i.row)}},e.prototype.autoIndent=function(){var e=this.session,t=e.getMode(),n,r;if(this.selection.isEmpty())n=0,r=e.doc.getLength()-1;else{var i=this.getSelectionRange();n=i.start.row,r=i.end.row}var s="",o="",u="",a,f,l,c=e.getTabString();for(var h=n;h<=r;h++)h>0&&(s=e.getState(h-1),o=e.getLine(h-1),u=t.getNextLineIndent(s,o,c)),a=e.getLine(h),f=t.$getIndent(a),u!==f&&(f.length>0&&(l=new d(h,0,h,f.length),e.remove(l)),u.length>0&&e.insert({row:h,column:0},u)),t.autoOutdent(s,e,h)},e.prototype.onTextInput=function(e,t){if(!t)return this.keyBinding.onTextInput(e);this.startOperation({command:{name:"insertstring"}});var n=this.applyComposition.bind(this,e,t);this.selection.rangeCount?this.forEachSelection(n):n(),this.endOperation()},e.prototype.applyComposition=function(e,t){if(t.extendLeft||t.extendRight){var n=this.selection.getRange();n.start.column-=t.extendLeft,n.end.column+=t.extendRight,n.start.column<0&&(n.start.row--,n.start.column+=this.session.getLine(n.start.row).length+1),this.selection.setRange(n),!e&&!n.isEmpty()&&this.remove()}(e||!this.selection.isEmpty())&&this.insert(e,!0);if(t.restoreStart||t.restoreEnd){var n=this.selection.getRange();n.start.column-=t.restoreStart,n.end.column-=t.restoreEnd,this.selection.setRange(n)}},e.prototype.onCommandKey=function(e,t,n){return this.keyBinding.onCommandKey(e,t,n)},e.prototype.setOverwrite=function(e){this.session.setOverwrite(e)},e.prototype.getOverwrite=function(){return this.session.getOverwrite()},e.prototype.toggleOverwrite=function(){this.session.toggleOverwrite()},e.prototype.setScrollSpeed=function(e){this.setOption("scrollSpeed",e)},e.prototype.getScrollSpeed=function(){return this.getOption("scrollSpeed")},e.prototype.setDragDelay=function(e){this.setOption("dragDelay",e)},e.prototype.getDragDelay=function(){return this.getOption("dragDelay")},e.prototype.setSelectionStyle=function(e){this.setOption("selectionStyle",e)},e.prototype.getSelectionStyle=function(){return this.getOption("selectionStyle")},e.prototype.setHighlightActiveLine=function(e){this.setOption("highlightActiveLine",e)},e.prototype.getHighlightActiveLine=function(){return this.getOption("highlightActiveLine")},e.prototype.setHighlightGutterLine=function(e){this.setOption("highlightGutterLine",e)},e.prototype.getHighlightGutterLine=function(){return this.getOption("highlightGutterLine")},e.prototype.setHighlightSelectedWord=function(e){this.setOption("highlightSelectedWord",e)},e.prototype.getHighlightSelectedWord=function(){return this.$highlightSelectedWord},e.prototype.setAnimatedScroll=function(e){this.renderer.setAnimatedScroll(e)},e.prototype.getAnimatedScroll=function(){return this.renderer.getAnimatedScroll()},e.prototype.setShowInvisibles=function(e){this.renderer.setShowInvisibles(e)},e.prototype.getShowInvisibles=function(){return this.renderer.getShowInvisibles()},e.prototype.setDisplayIndentGuides=function(e){this.renderer.setDisplayIndentGuides(e)},e.prototype.getDisplayIndentGuides=function(){return this.renderer.getDisplayIndentGuides()},e.prototype.setHighlightIndentGuides=function(e){this.renderer.setHighlightIndentGuides(e)},e.prototype.getHighlightIndentGuides=function(){return this.renderer.getHighlightIndentGuides()},e.prototype.setShowPrintMargin=function(e){this.renderer.setShowPrintMargin(e)},e.prototype.getShowPrintMargin=function(){return this.renderer.getShowPrintMargin()},e.prototype.setPrintMarginColumn=function(e){this.renderer.setPrintMarginColumn(e)},e.prototype.getPrintMarginColumn=function(){return this.renderer.getPrintMarginColumn()},e.prototype.setReadOnly=function(e){this.setOption("readOnly",e)},e.prototype.getReadOnly=function(){return this.getOption("readOnly")},e.prototype.setBehavioursEnabled=function(e){this.setOption("behavioursEnabled",e)},e.prototype.getBehavioursEnabled=function(){return this.getOption("behavioursEnabled")},e.prototype.setWrapBehavioursEnabled=function(e){this.setOption("wrapBehavioursEnabled",e)},e.prototype.getWrapBehavioursEnabled=function(){return this.getOption("wrapBehavioursEnabled")},e.prototype.setShowFoldWidgets=function(e){this.setOption("showFoldWidgets",e)},e.prototype.getShowFoldWidgets=function(){return this.getOption("showFoldWidgets")},e.prototype.setFadeFoldWidgets=function(e){this.setOption("fadeFoldWidgets",e)},e.prototype.getFadeFoldWidgets=function(){return this.getOption("fadeFoldWidgets")},e.prototype.remove=function(e){this.selection.isEmpty()&&(e=="left"?this.selection.selectLeft():this.selection.selectRight());var t=this.getSelectionRange();if(this.getBehavioursEnabled()){var n=this.session,r=n.getState(t.start.row),i=n.getMode().transformAction(r,"deletion",this,n,t);if(t.end.column===0){var s=n.getTextRange(t);if(s[s.length-1]=="\n"){var o=n.getLine(t.end.row);/^\s+$/.test(o)&&(t.end.column=o.length)}}i&&(t=i)}this.session.remove(t),this.clearSelection()},e.prototype.removeWordRight=function(){this.selection.isEmpty()&&this.selection.selectWordRight(),this.session.remove(this.getSelectionRange()),this.clearSelection()},e.prototype.removeWordLeft=function(){this.selection.isEmpty()&&this.selection.selectWordLeft(),this.session.remove(this.getSelectionRange()),this.clearSelection()},e.prototype.removeToLineStart=function(){this.selection.isEmpty()&&this.selection.selectLineStart(),this.selection.isEmpty()&&this.selection.selectLeft(),this.session.remove(this.getSelectionRange()),this.clearSelection()},e.prototype.removeToLineEnd=function(){this.selection.isEmpty()&&this.selection.selectLineEnd();var e=this.getSelectionRange();e.start.column==e.end.column&&e.start.row==e.end.row&&(e.end.column=0,e.end.row++),this.session.remove(e),this.clearSelection()},e.prototype.splitLine=function(){this.selection.isEmpty()||(this.session.remove(this.getSelectionRange()),this.clearSelection());var e=this.getCursorPosition();this.insert("\n"),this.moveCursorToPosition(e)},e.prototype.setGhostText=function(e,t){this.session.widgetManager||(this.session.widgetManager=new w(this.session),this.session.widgetManager.attach(this)),this.renderer.setGhostText(e,t)},e.prototype.removeGhostText=function(){if(!this.session.widgetManager)return;this.renderer.removeGhostText()},e.prototype.transposeLetters=function(){if(!this.selection.isEmpty())return;var e=this.getCursorPosition(),t=e.column;if(t===0)return;var n=this.session.getLine(e.row),r,i;t<n.length?(r=n.charAt(t)+n.charAt(t-1),i=new d(e.row,t-1,e.row,t+1)):(r=n.charAt(t-1)+n.charAt(t-2),i=new d(e.row,t-2,e.row,t)),this.session.replace(i,r),this.session.selection.moveToPosition(i.end)},e.prototype.toLowerCase=function(){var e=this.getSelectionRange();this.selection.isEmpty()&&this.selection.selectWord();var t=this.getSelectionRange(),n=this.session.getTextRange(t);this.session.replace(t,n.toLowerCase()),this.selection.setSelectionRange(e)},e.prototype.toUpperCase=function(){var e=this.getSelectionRange();this.selection.isEmpty()&&this.selection.selectWord();var t=this.getSelectionRange(),n=this.session.getTextRange(t);this.session.replace(t,n.toUpperCase()),this.selection.setSelectionRange(e)},e.prototype.indent=function(){var e=this.session,t=this.getSelectionRange();if(t.start.row<t.end.row){var n=this.$getSelectedRows();e.indentRows(n.first,n.last,"	");return}if(t.start.column<t.end.column){var r=e.getTextRange(t);if(!/^\s+$/.test(r)){var n=this.$getSelectedRows();e.indentRows(n.first,n.last,"	");return}}var i=e.getLine(t.start.row),s=t.start,u=e.getTabSize(),a=e.documentToScreenColumn(s.row,s.column);if(this.session.getUseSoftTabs())var f=u-a%u,l=o.stringRepeat(" ",f);else{var f=a%u;while(i[t.start.column-1]==" "&&f)t.start.column--,f--;this.selection.setSelectionRange(t),l="	"}return this.insert(l)},e.prototype.blockIndent=function(){var e=this.$getSelectedRows();this.session.indentRows(e.first,e.last,"	")},e.prototype.blockOutdent=function(){var e=this.session.getSelection();this.session.outdentRows(e.getRange())},e.prototype.sortLines=function(){var e=this.$getSelectedRows(),t=this.session,n=[];for(var r=e.first;r<=e.last;r++)n.push(t.getLine(r));n.sort(function(e,t){return e.toLowerCase()<t.toLowerCase()?-1:e.toLowerCase()>t.toLowerCase()?1:0});var i=new d(0,0,0,0);for(var r=e.first;r<=e.last;r++){var s=t.getLine(r);i.start.row=r,i.end.row=r,i.end.column=s.length,t.replace(i,n[r-e.first])}},e.prototype.toggleCommentLines=function(){var e=this.session.getState(this.getCursorPosition().row),t=this.$getSelectedRows();this.session.getMode().toggleCommentLines(e,this.session,t.first,t.last)},e.prototype.toggleBlockComment=function(){var e=this.getCursorPosition(),t=this.session.getState(e.row),n=this.getSelectionRange();this.session.getMode().toggleBlockComment(t,this.session,n,e)},e.prototype.getNumberAt=function(e,t){var n=/[\-]?[0-9]+(?:\.[0-9]+)?/g;n.lastIndex=0;var r=this.session.getLine(e);while(n.lastIndex<t){var i=n.exec(r);if(i.index<=t&&i.index+i[0].length>=t){var s={value:i[0],start:i.index,end:i.index+i[0].length};return s}}return null},e.prototype.modifyNumber=function(e){var t=this.selection.getCursor().row,n=this.selection.getCursor().column,r=new d(t,n-1,t,n),i=this.session.getTextRange(r);if(!isNaN(parseFloat(i))&&isFinite(i)){var s=this.getNumberAt(t,n);if(s){var o=s.value.indexOf(".")>=0?s.start+s.value.indexOf(".")+1:s.end,u=s.start+s.value.length-o,a=parseFloat(s.value);a*=Math.pow(10,u),o!==s.end&&n<o?e*=Math.pow(10,s.end-n-1):e*=Math.pow(10,s.end-n),a+=e,a/=Math.pow(10,u);var f=a.toFixed(u),l=new d(t,s.start,t,s.end);this.session.replace(l,f),this.moveCursorTo(t,Math.max(s.start+1,n+f.length-s.value.length))}}else this.toggleWord()},e.prototype.toggleWord=function(){var e=this.selection.getCursor().row,t=this.selection.getCursor().column;this.selection.selectWord();var n=this.getSelectedText(),r=this.selection.getWordRange().start.column,i=n.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g,"$1 ").split(/\s/),s=t-r-1;s<0&&(s=0);var u=0,a=0,f=this;n.match(/[A-Za-z0-9_]+/)&&i.forEach(function(t,i){a=u+t.length,s>=u&&s<=a&&(n=t,f.selection.clearSelection(),f.moveCursorTo(e,u+r),f.selection.selectTo(e,a+r)),u=a});var l=this.$toggleWordPairs,c;for(var h=0;h<l.length;h++){var p=l[h];for(var d=0;d<=1;d++){var v=+!d,m=n.match(new RegExp("^\\s?_?("+o.escapeRegExp(p[d])+")\\s?$","i"));if(m){var g=n.match(new RegExp("([_]|^|\\s)("+o.escapeRegExp(m[1])+")($|\\s)","g"));g&&(c=n.replace(new RegExp(o.escapeRegExp(p[d]),"i"),function(e){var t=p[v];return e.toUpperCase()==e?t=t.toUpperCase():e.charAt(0).toUpperCase()==e.charAt(0)&&(t=t.substr(0,0)+p[v].charAt(0).toUpperCase()+t.substr(1)),t}),this.insert(c),c="")}}}},e.prototype.findLinkAt=function(e,t){var n,i,s=this.session.getLine(e),o=s.split(/((?:https?|ftp):\/\/[\S]+)/),u=t;u<0&&(u=0);var a=0,f=0,l;try{for(var c=r(o),h=c.next();!h.done;h=c.next()){var p=h.value;f=a+p.length;if(u>=a&&u<=f&&p.match(/((?:https?|ftp):\/\/[\S]+)/)){l=p.replace(/[\s:.,'";}\]]+$/,"");break}a=f}}catch(d){n={error:d}}finally{try{h&&!h.done&&(i=c.return)&&i.call(c)}finally{if(n)throw n.error}}return l},e.prototype.openLink=function(){var e=this.selection.getCursor(),t=this.findLinkAt(e.row,e.column);return t&&window.open(t,"_blank"),t!=null},e.prototype.removeLines=function(){var e=this.$getSelectedRows();this.session.removeFullLines(e.first,e.last),this.clearSelection()},e.prototype.duplicateSelection=function(){var e=this.selection,t=this.session,n=e.getRange(),r=e.isBackwards();if(n.isEmpty()){var i=n.start.row;t.duplicateLines(i,i)}else{var s=r?n.start:n.end,o=t.insert(s,t.getTextRange(n),!1);n.start=s,n.end=o,e.setSelectionRange(n,r)}},e.prototype.moveLinesDown=function(){this.$moveLines(1,!1)},e.prototype.moveLinesUp=function(){this.$moveLines(-1,!1)},e.prototype.moveText=function(e,t,n){return this.session.moveText(e,t,n)},e.prototype.copyLinesUp=function(){this.$moveLines(-1,!0)},e.prototype.copyLinesDown=function(){this.$moveLines(1,!0)},e.prototype.$moveLines=function(e,t){var n,r,i=this.selection;if(!i.inMultiSelectMode||this.inVirtualSelectionMode){var s=i.toOrientedRange();n=this.$getSelectedRows(s),r=this.session.$moveLines(n.first,n.last,t?0:e),t&&e==-1&&(r=0),s.moveBy(r,0),i.fromOrientedRange(s)}else{var o=i.rangeList.ranges;i.rangeList.detach(this.session),this.inVirtualSelectionMode=!0;var u=0,a=0,f=o.length;for(var l=0;l<f;l++){var c=l;o[l].moveBy(u,0),n=this.$getSelectedRows(o[l]);var h=n.first,p=n.last;while(++l<f){a&&o[l].moveBy(a,0);var d=this.$getSelectedRows(o[l]);if(t&&d.first!=p)break;if(!t&&d.first>p+1)break;p=d.last}l--,u=this.session.$moveLines(h,p,t?0:e),t&&e==-1&&(c=l+1);while(c<=l)o[c].moveBy(u,0),c++;t||(u=0),a+=u}i.fromOrientedRange(i.ranges[0]),i.rangeList.attach(this.session),this.inVirtualSelectionMode=!1}},e.prototype.$getSelectedRows=function(e){return e=(e||this.getSelectionRange()).collapseRows(),{first:this.session.getRowFoldStart(e.start.row),last:this.session.getRowFoldEnd(e.end.row)}},e.prototype.onCompositionStart=function(e){this.renderer.showComposition(e)},e.prototype.onCompositionUpdate=function(e){this.renderer.setCompositionText(e)},e.prototype.onCompositionEnd=function(){this.renderer.hideComposition()},e.prototype.getFirstVisibleRow=function(){return this.renderer.getFirstVisibleRow()},e.prototype.getLastVisibleRow=function(){return this.renderer.getLastVisibleRow()},e.prototype.isRowVisible=function(e){return e>=this.getFirstVisibleRow()&&e<=this.getLastVisibleRow()},e.prototype.isRowFullyVisible=function(e){return e>=this.renderer.getFirstFullyVisibleRow()&&e<=this.renderer.getLastFullyVisibleRow()},e.prototype.$getVisibleRowCount=function(){return this.renderer.getScrollBottomRow()-this.renderer.getScrollTopRow()+1},e.prototype.$moveByPage=function(e,t){var n=this.renderer,r=this.renderer.layerConfig,i=e*Math.floor(r.height/r.lineHeight);t===!0?this.selection.$moveSelection(function(){this.moveCursorBy(i,0)}):t===!1&&(this.selection.moveCursorBy(i,0),this.selection.clearSelection());var s=n.scrollTop;n.scrollBy(0,i*r.lineHeight),t!=null&&n.scrollCursorIntoView(null,.5),n.animateScrolling(s)},e.prototype.selectPageDown=function(){this.$moveByPage(1,!0)},e.prototype.selectPageUp=function(){this.$moveByPage(-1,!0)},e.prototype.gotoPageDown=function(){this.$moveByPage(1,!1)},e.prototype.gotoPageUp=function(){this.$moveByPage(-1,!1)},e.prototype.scrollPageDown=function(){this.$moveByPage(1)},e.prototype.scrollPageUp=function(){this.$moveByPage(-1)},e.prototype.scrollToRow=function(e){this.renderer.scrollToRow(e)},e.prototype.scrollToLine=function(e,t,n,r){this.renderer.scrollToLine(e,t,n,r)},e.prototype.centerSelection=function(){var e=this.getSelectionRange(),t={row:Math.floor(e.start.row+(e.end.row-e.start.row)/2),column:Math.floor(e.start.column+(e.end.column-e.start.column)/2)};this.renderer.alignCursor(t,.5)},e.prototype.getCursorPosition=function(){return this.selection.getCursor()},e.prototype.getCursorPositionScreen=function(){return this.session.documentToScreenPosition(this.getCursorPosition())},e.prototype.getSelectionRange=function(){return this.selection.getRange()},e.prototype.selectAll=function(){this.selection.selectAll()},e.prototype.clearSelection=function(){this.selection.clearSelection()},e.prototype.moveCursorTo=function(e,t){this.selection.moveCursorTo(e,t)},e.prototype.moveCursorToPosition=function(e){this.selection.moveCursorToPosition(e)},e.prototype.jumpToMatching=function(e,t){var n=this.getCursorPosition(),r=new b(this.session,n.row,n.column),i=r.getCurrentToken(),s=0;i&&i.type.indexOf("tag-name")!==-1&&(i=r.stepBackward());var o=i||r.stepForward();if(!o)return;var u,a=!1,f={},l=n.column-o.start,c,h={")":"(","(":"(","]":"[","[":"[","{":"{","}":"{"};do{if(o.value.match(/[{}()\[\]]/g))for(;l<o.value.length&&!a;l++){if(!h[o.value[l]])continue;c=h[o.value[l]]+"."+o.type.replace("rparen","lparen"),isNaN(f[c])&&(f[c]=0);switch(o.value[l]){case"(":case"[":case"{":f[c]++;break;case")":case"]":case"}":f[c]--,f[c]===-1&&(u="bracket",a=!0)}}else o.type.indexOf("tag-name")!==-1&&(isNaN(f[o.value])&&(f[o.value]=0),i.value==="<"&&s>1?f[o.value]++:i.value==="</"&&f[o.value]--,f[o.value]===-1&&(u="tag",a=!0));a||(i=o,s++,o=r.stepForward(),l=0)}while(o&&!a);if(!u)return;var p,v;if(u==="bracket"){p=this.session.getBracketRange(n);if(!p){p=new d(r.getCurrentTokenRow(),r.getCurrentTokenColumn()+l-1,r.getCurrentTokenRow(),r.getCurrentTokenColumn()+l-1),v=p.start;if(t||v.row===n.row&&Math.abs(v.column-n.column)<2)p=this.session.getBracketRange(v)}}else if(u==="tag"){if(!o||o.type.indexOf("tag-name")===-1)return;p=new d(r.getCurrentTokenRow(),r.getCurrentTokenColumn()-2,r.getCurrentTokenRow(),r.getCurrentTokenColumn()-2);if(p.compare(n.row,n.column)===0){var m=this.session.getMatchingTags(n);m&&(m.openTag.contains(n.row,n.column)?(p=m.closeTag,v=p.start):(p=m.openTag,m.closeTag.start.row===n.row&&m.closeTag.start.column===n.column?v=p.end:v=p.start))}v=v||p.start}v=p&&p.cursor||v,v&&(e?p&&t?this.selection.setRange(p):p&&p.isEqual(this.getSelectionRange())?this.clearSelection():this.selection.selectTo(v.row,v.column):this.selection.moveTo(v.row,v.column))},e.prototype.gotoLine=function(e,t,n){this.selection.clearSelection(),this.session.unfold({row:e-1,column:t||0}),this.exitMultiSelectMode&&this.exitMultiSelectMode(),this.moveCursorTo(e-1,t||0),this.isRowFullyVisible(e-1)||this.scrollToLine(e-1,!0,n)},e.prototype.navigateTo=function(e,t){this.selection.moveTo(e,t)},e.prototype.navigateUp=function(e){if(this.selection.isMultiLine()&&!this.selection.isBackwards()){var t=this.selection.anchor.getPosition();return this.moveCursorToPosition(t)}this.selection.clearSelection(),this.selection.moveCursorBy(-e||-1,0)},e.prototype.navigateDown=function(e){if(this.selection.isMultiLine()&&this.selection.isBackwards()){var t=this.selection.anchor.getPosition();return this.moveCursorToPosition(t)}this.selection.clearSelection(),this.selection.moveCursorBy(e||1,0)},e.prototype.navigateLeft=function(e){if(!this.selection.isEmpty()){var t=this.getSelectionRange().start;this.moveCursorToPosition(t)}else{e=e||1;while(e--)this.selection.moveCursorLeft()}this.clearSelection()},e.prototype.navigateRight=function(e){if(!this.selection.isEmpty()){var t=this.getSelectionRange().end;this.moveCursorToPosition(t)}else{e=e||1;while(e--)this.selection.moveCursorRight()}this.clearSelection()},e.prototype.navigateLineStart=function(){this.selection.moveCursorLineStart(),this.clearSelection()},e.prototype.navigateLineEnd=function(){this.selection.moveCursorLineEnd(),this.clearSelection()},e.prototype.navigateFileEnd=function(){this.selection.moveCursorFileEnd(),this.clearSelection()},e.prototype.navigateFileStart=function(){this.selection.moveCursorFileStart(),this.clearSelection()},e.prototype.navigateWordRight=function(){this.selection.moveCursorWordRight(),this.clearSelection()},e.prototype.navigateWordLeft=function(){this.selection.moveCursorWordLeft(),this.clearSelection()},e.prototype.replace=function(e,t){t&&this.$search.set(t);var n=this.$search.find(this.session),r=0;return n?(this.$tryReplace(n,e)&&(r=1),this.selection.setSelectionRange(n),this.renderer.scrollSelectionIntoView(n.start,n.end),r):r},e.prototype.replaceAll=function(e,t){t&&this.$search.set(t);var n=this.$search.findAll(this.session),r=0;if(!n.length)return r;var i=this.getSelectionRange();this.selection.moveTo(0,0);for(var s=n.length-1;s>=0;--s)this.$tryReplace(n[s],e)&&r++;return this.selection.setSelectionRange(i),r},e.prototype.$tryReplace=function(e,t){var n=this.session.getTextRange(e);return t=this.$search.replace(n,t),t!==null?(e.end=this.session.replace(e,t),e):null},e.prototype.getLastSearchOptions=function(){return this.$search.getOptions()},e.prototype.find=function(e,t,n){t||(t={}),typeof e=="string"||e instanceof RegExp?t.needle=e:typeof e=="object"&&i.mixin(t,e);var r=this.selection.getRange();t.needle==null&&(e=this.session.getTextRange(r)||this.$search.$options.needle,e||(r=this.session.getWordRange(r.start.row,r.start.column),e=this.session.getTextRange(r)),this.$search.set({needle:e})),this.$search.set(t),t.start||this.$search.set({start:r});var s=this.$search.find(this.session);if(t.preventScroll)return s;if(s)return this.revealRange(s,n),s;t.backwards?r.start=r.end:r.end=r.start,this.selection.setRange(r)},e.prototype.findNext=function(e,t){this.find({skipCurrent:!0,backwards:!1},e,t)},e.prototype.findPrevious=function(e,t){this.find(e,{skipCurrent:!0,backwards:!0},t)},e.prototype.revealRange=function(e,t){this.session.unfold(e),this.selection.setSelectionRange(e);var n=this.renderer.scrollTop;this.renderer.scrollSelectionIntoView(e.start,e.end,.5),t!==!1&&this.renderer.animateScrolling(n)},e.prototype.undo=function(){this.session.getUndoManager().undo(this.session),this.renderer.scrollCursorIntoView(null,.5)},e.prototype.redo=function(){this.session.getUndoManager().redo(this.session),this.renderer.scrollCursorIntoView(null,.5)},e.prototype.destroy=function(){this.$toDestroy&&(this.$toDestroy.forEach(function(e){e.destroy()}),this.$toDestroy=null),this.$mouseHandler&&this.$mouseHandler.destroy(),this.renderer.destroy(),this._signal("destroy",this),this.session&&this.session.destroy(),this._$emitInputEvent&&this._$emitInputEvent.cancel(),this.removeAllListeners()},e.prototype.setAutoScrollEditorIntoView=function(e){if(!e)return;var t,n=this,r=!1;this.$scrollAnchor||(this.$scrollAnchor=document.createElement("div"));var i=this.$scrollAnchor;i.style.cssText="position:absolute",this.container.insertBefore(i,this.container.firstChild);var s=this.on("changeSelection",function(){r=!0}),o=this.renderer.on("beforeRender",function(){r&&(t=n.renderer.container.getBoundingClientRect())}),u=this.renderer.on("afterRender",function(){if(r&&t&&(n.isFocused()||n.searchBox&&n.searchBox.isFocused())){var e=n.renderer,s=e.$cursorLayer.$pixelPos,o=e.layerConfig,u=s.top-o.offset;s.top>=0&&u+t.top<0?r=!0:s.top<o.height&&s.top+t.top+o.lineHeight>window.innerHeight?r=!1:r=null,r!=null&&(i.style.top=u+"px",i.style.left=s.left+"px",i.style.height=o.lineHeight+"px",i.scrollIntoView(r)),r=t=null}});this.setAutoScrollEditorIntoView=function(e){if(e)return;delete this.setAutoScrollEditorIntoView,this.off("changeSelection",s),this.renderer.off("afterRender",u),this.renderer.off("beforeRender",o)}},e.prototype.$resetCursorStyle=function(){var e=this.$cursorStyle||"ace",t=this.renderer.$cursorLayer;if(!t)return;t.setSmoothBlinking(/smooth/.test(e)),t.isBlinking=!this.$readOnly&&e!="wide",s.setCssClass(t.element,"ace_slim-cursors",/slim/.test(e))},e.prototype.prompt=function(e,t,n){var r=this;y.loadModule("ace/ext/prompt",function(i){i.prompt(r,e,t,n)})},e}();x.$uid=0,x.prototype.curOp=null,x.prototype.prevOp={},x.prototype.$mergeableCommands=["backspace","del","insertstring"],x.prototype.$toggleWordPairs=[["first","last"],["true","false"],["yes","no"],["width","height"],["top","bottom"],["right","left"],["on","off"],["x","y"],["get","set"],["max","min"],["horizontal","vertical"],["show","hide"],["add","remove"],["up","down"],["before","after"],["even","odd"],["in","out"],["inside","outside"],["next","previous"],["increase","decrease"],["attach","detach"],["&&","||"],["==","!="]],i.implement(x.prototype,v),y.defineOptions(x.prototype,"editor",{selectionStyle:{set:function(e){this.onSelectionChange(),this._signal("changeSelectionStyle",{data:e})},initialValue:"line"},highlightActiveLine:{set:function(){this.$updateHighlightActiveLine()},initialValue:!0},highlightSelectedWord:{set:function(e){this.$onSelectionChange()},initialValue:!0},readOnly:{set:function(e){this.textInput.setReadOnly(e),this.$resetCursorStyle()},initialValue:!1},copyWithEmptySelection:{set:function(e){this.textInput.setCopyWithEmptySelection(e)},initialValue:!1},cursorStyle:{set:function(e){this.$resetCursorStyle()},values:["ace","slim","smooth","wide"],initialValue:"ace"},mergeUndoDeltas:{values:[!1,!0,"always"],initialValue:!0},behavioursEnabled:{initialValue:!0},wrapBehavioursEnabled:{initialValue:!0},enableAutoIndent:{initialValue:!0},autoScrollEditorIntoView:{set:function(e){this.setAutoScrollEditorIntoView(e)}},keyboardHandler:{set:function(e){this.setKeyboardHandler(e)},get:function(){return this.$keybindingId},handlesSet:!0},value:{set:function(e){this.session.setValue(e)},get:function(){return this.getValue()},handlesSet:!0,hidden:!0},session:{set:function(e){this.setSession(e)},get:function(){return this.session},handlesSet:!0,hidden:!0},showLineNumbers:{set:function(e){this.renderer.$gutterLayer.setShowLineNumbers(e),this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER),e&&this.$relativeLineNumbers?T.attach(this):T.detach(this)},initialValue:!0},relativeLineNumbers:{set:function(e){this.$showLineNumbers&&e?T.attach(this):T.detach(this)}},placeholder:{set:function(e){this.$updatePlaceholder||(this.$updatePlaceholder=function(){var e=this.session&&(this.renderer.$composition||this.getValue());if(e&&this.renderer.placeholderNode)this.renderer.off("afterRender",this.$updatePlaceholder),s.removeCssClass(this.container,"ace_hasPlaceholder"),this.renderer.placeholderNode.remove(),this.renderer.placeholderNode=null;else if(!e&&!this.renderer.placeholderNode){this.renderer.on("afterRender",this.$updatePlaceholder),s.addCssClass(this.container,"ace_hasPlaceholder");var t=s.createElement("div");t.className="ace_placeholder",t.textContent=this.$placeholder||"",this.renderer.placeholderNode=t,this.renderer.content.appendChild(this.renderer.placeholderNode)}else!e&&this.renderer.placeholderNode&&(this.renderer.placeholderNode.textContent=this.$placeholder||"")}.bind(this),this.on("input",this.$updatePlaceholder)),this.$updatePlaceholder()}},enableKeyboardAccessibility:{set:function(e){var t={name:"blurTextInput",description:"Set focus to the editor content div to allow tabbing through the page",bindKey:"Esc",exec:function(e){e.blur(),e.renderer.content.focus()},readOnly:!0},n=function(e){e.target==this.renderer.content&&e.keyCode===S.enter&&(e.stopPropagation(),e.preventDefault(),this.focus())},r="ace_keyboard-focus";e?(this.textInput.getElement().setAttribute("tabindex",-1),this.renderer.content.setAttribute("tabindex",0),this.renderer.content.classList.add(r),this.renderer.content.setAttribute("aria-label","Editor, press Enter key to start editing, press Escape key to exit"),this.renderer.content.addEventListener("keyup",n.bind(this)),this.commands.addCommand(t)):(this.textInput.getElement().setAttribute("tabindex",0),this.renderer.content.setAttribute("tabindex",-1),this.renderer.content.classList.remove(r),this.renderer.content.setAttribute("aria-label",""),this.renderer.content.removeEventListener("keyup",n.bind(this)),this.commands.removeCommand(t))},initialValue:!1},customScrollbar:"renderer",hScrollBarAlwaysVisible:"renderer",vScrollBarAlwaysVisible:"renderer",highlightGutterLine:"renderer",animatedScroll:"renderer",showInvisibles:"renderer",showPrintMargin:"renderer",printMarginColumn:"renderer",printMargin:"renderer",fadeFoldWidgets:"renderer",showFoldWidgets:"renderer",displayIndentGuides:"renderer",highlightIndentGuides:"renderer",showGutter:"renderer",fontSize:"renderer",fontFamily:"renderer",maxLines:"renderer",minLines:"renderer",scrollPastEnd:"renderer",fixedWidthGutter:"renderer",theme:"renderer",hasCssTransforms:"renderer",maxPixelHeight:"renderer",useTextareaForIME:"renderer",useResizeObserver:"renderer",useSvgGutterIcons:"renderer",showFoldedAnnotations:"renderer",scrollSpeed:"$mouseHandler",dragDelay:"$mouseHandler",dragEnabled:"$mouseHandler",focusTimeout:"$mouseHandler",tooltipFollowsMouse:"$mouseHandler",firstLineNumber:"session",overwrite:"session",newLineMode:"session",useWorker:"session",useSoftTabs:"session",navigateWithinSoftTabs:"session",tabSize:"session",wrap:"session",indentedSoftWrap:"session",foldStyle:"session",mode:"session"});var T={getText:function(e,t){return(Math.abs(e.selection.lead.row-t)||t+1+(t<9?"\u00b7":""))+""},getWidth:function(e,t,n){return Math.max(t.toString().length,(n.lastRow+1).toString().length,2)*n.characterWidth},update:function(e,t){t.renderer.$loop.schedule(t.renderer.CHANGE_GUTTER)},attach:function(e){e.renderer.$gutterLayer.$renderer=this,e.on("changeSelection",this.update),this.update(null,e)},detach:function(e){e.renderer.$gutterLayer.$renderer==this&&(e.renderer.$gutterLayer.$renderer=null),e.off("changeSelection",this.update),this.update(null,e)}};t.Editor=x}),ace.define("ace/undomanager",["require","exports","module","ace/range"],function(e,t,n){"use strict";function i(e,t){for(var n=t;n--;){var r=e[n];if(r&&!r[0].ignore){while(n<t-1){var i=d(e[n],e[n+1]);e[n]=i[0],e[n+1]=i[1],n++}return!0}}}function a(e){var t=e.action=="insert",n=e.start,r=e.end,i=(r.row-n.row)*(t?1:-1),s=(r.column-n.column)*(t?1:-1);t&&(r=n);for(var o in this.marks){var a=this.marks[o],f=u(a,n);if(f<0)continue;if(f===0&&t){if(a.bias!=1){a.bias==-1;continue}f=1}var l=t?f:u(a,r);if(l>0){a.row+=i,a.column+=a.row==r.row?s:0;continue}!t&&l<=0&&(a.row=n.row,a.column=n.column,l===0&&(a.bias=1))}}function f(e){return{row:e.row,column:e.column}}function l(e){return{start:f(e.start),end:f(e.end),action:e.action,lines:e.lines.slice()}}function c(e){e=e||this;if(Array.isArray(e))return e.map(c).join("\n");var t="";e.action?(t=e.action=="insert"?"+":"-",t+="["+e.lines+"]"):e.value&&(Array.isArray(e.value)?t=e.value.map(h).join("\n"):t=h(e.value)),e.start&&(t+=h(e));if(e.id||e.rev)t+="	("+(e.id||e.rev)+")";return t}function h(e){return e.start.row+":"+e.start.column+"=>"+e.end.row+":"+e.end.column}function p(e,t){var n=e.action=="insert",r=t.action=="insert";if(n&&r)if(o(t.start,e.end)>=0)m(t,e,-1);else{if(!(o(t.start,e.start)<=0))return null;m(e,t,1)}else if(n&&!r)if(o(t.start,e.end)>=0)m(t,e,-1);else{if(!(o(t.end,e.start)<=0))return null;m(e,t,-1)}else if(!n&&r)if(o(t.start,e.start)>=0)m(t,e,1);else{if(!(o(t.start,e.start)<=0))return null;m(e,t,1)}else if(!n&&!r)if(o(t.start,e.start)>=0)m(t,e,1);else{if(!(o(t.end,e.start)<=0))return null;m(e,t,-1)}return[t,e]}function d(e,t){for(var n=e.length;n--;)for(var r=0;r<t.length;r++)if(!p(e[n],t[r])){while(n<e.length){while(r--)p(t[r],e[n]);r=t.length,n++}return[e,t]}return e.selectionBefore=t.selectionBefore=e.selectionAfter=t.selectionAfter=null,[t,e]}function v(e,t){var n=e.action=="insert",r=t.action=="insert";if(n&&r)o(e.start,t.start)<0?m(t,e,1):m(e,t,1);else if(n&&!r)o(e.start,t.end)>=0?m(e,t,-1):o(e.start,t.start)<=0?m(t,e,1):(m(e,s.fromPoints(t.start,e.start),-1),m(t,e,1));else if(!n&&r)o(t.start,e.end)>=0?m(t,e,-1):o(t.start,e.start)<=0?m(e,t,1):(m(t,s.fromPoints(e.start,t.start),-1),m(e,t,1));else if(!n&&!r)if(o(t.start,e.end)>=0)m(t,e,-1);else{if(!(o(t.end,e.start)<=0)){var i,u;return o(e.start,t.start)<0&&(i=e,e=y(e,t.start)),o(e.end,t.end)>0&&(u=y(e,t.end)),g(t.end,e.start,e.end,-1),u&&!i&&(e.lines=u.lines,e.start=u.start,e.end=u.end,u=e),[t,i,u].filter(Boolean)}m(e,t,-1)}return[t,e]}function m(e,t,n){g(e.start,t.start,t.end,n),g(e.end,t.start,t.end,n)}function g(e,t,n,r){e.row==(r==1?t:n).row&&(e.column+=r*(n.column-t.column)),e.row+=r*(n.row-t.row)}function y(e,t){var n=e.lines,r=e.end;e.end=f(t);var i=e.end.row-e.start.row,s=n.splice(i,n.length),o=i?t.column:t.column-e.start.column;n.push(s[0].substring(0,o)),s[0]=s[0].substr(o);var u={start:f(t),end:r,lines:s,action:e.action};return u}function b(e,t){t=l(t);for(var n=e.length;n--;){var r=e[n];for(var i=0;i<r.length;i++){var s=r[i],o=v(s,t);t=o[0],o.length!=2&&(o[2]?(r.splice(i+1,1,o[1],o[2]),i++):o[1]||(r.splice(i,1),i--))}r.length||e.splice(n,1)}return e}function w(e,t){for(var n=0;n<t.length;n++){var r=t[n];for(var i=0;i<r.length;i++)b(e,r[i])}}var r=function(){function e(){this.$maxRev=0,this.$fromUndo=!1,this.$undoDepth=Infinity,this.reset()}return e.prototype.addSession=function(e){this.$session=e},e.prototype.add=function(e,t,n){if(this.$fromUndo)return;if(e==this.$lastDelta)return;this.$keepRedoStack||(this.$redoStack.length=0);if(t===!1||!this.lastDeltas){this.lastDeltas=[];var r=this.$undoStack.length;r>this.$undoDepth-1&&this.$undoStack.splice(0,r-this.$undoDepth+1),this.$undoStack.push(this.lastDeltas),e.id=this.$rev=++this.$maxRev}if(e.action=="remove"||e.action=="insert")this.$lastDelta=e;this.lastDeltas.push(e)},e.prototype.addSelection=function(e,t){this.selections.push({value:e,rev:t||this.$rev})},e.prototype.startNewGroup=function(){return this.lastDeltas=null,this.$rev},e.prototype.markIgnored=function(e,t){t==null&&(t=this.$rev+1);var n=this.$undoStack;for(var r=n.length;r--;){var i=n[r][0];if(i.id<=e)break;i.id<t&&(i.ignore=!0)}this.lastDeltas=null},e.prototype.getSelection=function(e,t){var n=this.selections;for(var r=n.length;r--;){var i=n[r];if(i.rev<e)return t&&(i=n[r+1]),i}},e.prototype.getRevision=function(){return this.$rev},e.prototype.getDeltas=function(e,t){t==null&&(t=this.$rev+1);var n=this.$undoStack,r=null,i=0;for(var s=n.length;s--;){var o=n[s][0];o.id<t&&!r&&(r=s+1);if(o.id<=e){i=s+1;break}}return n.slice(i,r)},e.prototype.getChangedRanges=function(e,t){t==null&&(t=this.$rev+1)},e.prototype.getChangedLines=function(e,t){t==null&&(t=this.$rev+1)},e.prototype.undo=function(e,t){this.lastDeltas=null;var n=this.$undoStack;if(!i(n,n.length))return;e||(e=this.$session),this.$redoStackBaseRev!==this.$rev&&this.$redoStack.length&&(this.$redoStack=[]),this.$fromUndo=!0;var r=n.pop(),s=null;return r&&(s=e.undoChanges(r,t),this.$redoStack.push(r),this.$syncRev()),this.$fromUndo=!1,s},e.prototype.redo=function(e,t){this.lastDeltas=null,e||(e=this.$session),this.$fromUndo=!0;if(this.$redoStackBaseRev!=this.$rev){var n=this.getDeltas(this.$redoStackBaseRev,this.$rev+1);w(this.$redoStack,n),this.$redoStackBaseRev=this.$rev,this.$redoStack.forEach(function(e){e[0].id=++this.$maxRev},this)}var r=this.$redoStack.pop(),i=null;return r&&(i=e.redoChanges(r,t),this.$undoStack.push(r),this.$syncRev()),this.$fromUndo=!1,i},e.prototype.$syncRev=function(){var e=this.$undoStack,t=e[e.length-1],n=t&&t[0].id||0;this.$redoStackBaseRev=n,this.$rev=n},e.prototype.reset=function(){this.lastDeltas=null,this.$lastDelta=null,this.$undoStack=[],this.$redoStack=[],this.$rev=0,this.mark=0,this.$redoStackBaseRev=this.$rev,this.selections=[]},e.prototype.canUndo=function(){return this.$undoStack.length>0},e.prototype.canRedo=function(){return this.$redoStack.length>0},e.prototype.bookmark=function(e){e==undefined&&(e=this.$rev),this.mark=e},e.prototype.isAtBookmark=function(){return this.$rev===this.mark},e.prototype.toJSON=function(){},e.prototype.fromJSON=function(){},e.prototype.$prettyPrint=function(e){return e?c(e):c(this.$undoStack)+"\n---\n"+c(this.$redoStack)},e}();r.prototype.hasUndo=r.prototype.canUndo,r.prototype.hasRedo=r.prototype.canRedo,r.prototype.isClean=r.prototype.isAtBookmark,r.prototype.markClean=r.prototype.bookmark;var s=e("./range").Range,o=s.comparePoints,u=s.comparePoints;t.UndoManager=r}),ace.define("ace/layer/lines",["require","exports","module","ace/lib/dom"],function(e,t,n){"use strict";var r=e("../lib/dom"),i=function(){function e(e,t){this.element=e,this.canvasHeight=t||5e5,this.element.style.height=this.canvasHeight*2+"px",this.cells=[],this.cellCache=[],this.$offsetCoefficient=0}return e.prototype.moveContainer=function(e){r.translate(this.element,0,-(e.firstRowScreen*e.lineHeight%this.canvasHeight)-e.offset*this.$offsetCoefficient)},e.prototype.pageChanged=function(e,t){return Math.floor(e.firstRowScreen*e.lineHeight/this.canvasHeight)!==Math.floor(t.firstRowScreen*t.lineHeight/this.canvasHeight)},e.prototype.computeLineTop=function(e,t,n){var r=t.firstRowScreen*t.lineHeight,i=Math.floor(r/this.canvasHeight),s=n.documentToScreenRow(e,0)*t.lineHeight;return s-i*this.canvasHeight},e.prototype.computeLineHeight=function(e,t,n){return t.lineHeight*n.getRowLineCount(e)},e.prototype.getLength=function(){return this.cells.length},e.prototype.get=function(e){return this.cells[e]},e.prototype.shift=function(){this.$cacheCell(this.cells.shift())},e.prototype.pop=function(){this.$cacheCell(this.cells.pop())},e.prototype.push=function(e){if(Array.isArray(e)){this.cells.push.apply(this.cells,e);var t=r.createFragment(this.element);for(var n=0;n<e.length;n++)t.appendChild(e[n].element);this.element.appendChild(t)}else this.cells.push(e),this.element.appendChild(e.element)},e.prototype.unshift=function(e){if(Array.isArray(e)){this.cells.unshift.apply(this.cells,e);var t=r.createFragment(this.element);for(var n=0;n<e.length;n++)t.appendChild(e[n].element);this.element.firstChild?this.element.insertBefore(t,this.element.firstChild):this.element.appendChild(t)}else this.cells.unshift(e),this.element.insertAdjacentElement("afterbegin",e.element)},e.prototype.last=function(){return this.cells.length?this.cells[this.cells.length-1]:null},e.prototype.$cacheCell=function(e){if(!e)return;e.element.remove(),this.cellCache.push(e)},e.prototype.createCell=function(e,t,n,i){var s=this.cellCache.pop();if(!s){var o=r.createElement("div");i&&i(o),this.element.appendChild(o),s={element:o,text:"",row:e}}return s.row=e,s},e}();t.Lines=i}),ace.define("ace/layer/gutter",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/lang","ace/lib/event_emitter","ace/layer/lines"],function(e,t,n){"use strict";function f(e){var t=document.createTextNode("");e.appendChild(t);var n=r.createElement("span");e.appendChild(n);var i=r.createElement("span");return e.appendChild(i),e}var r=e("../lib/dom"),i=e("../lib/oop"),s=e("../lib/lang"),o=e("../lib/event_emitter").EventEmitter,u=e("./lines").Lines,a=function(){function e(e){this.element=r.createElement("div"),this.element.className="ace_layer ace_gutter-layer",e.appendChild(this.element),this.setShowFoldWidgets(this.$showFoldWidgets),this.gutterWidth=0,this.$annotations=[],this.$updateAnnotations=this.$updateAnnotations.bind(this),this.$lines=new u(this.element),this.$lines.$offsetCoefficient=1}return e.prototype.setSession=function(e){this.session&&this.session.off("change",this.$updateAnnotations),this.session=e,e&&e.on("change",this.$updateAnnotations)},e.prototype.addGutterDecoration=function(e,t){window.console&&console.warn&&console.warn("deprecated use session.addGutterDecoration"),this.session.addGutterDecoration(e,t)},e.prototype.removeGutterDecoration=function(e,t){window.console&&console.warn&&console.warn("deprecated use session.removeGutterDecoration"),this.session.removeGutterDecoration(e,t)},e.prototype.setAnnotations=function(e){this.$annotations=[];for(var t=0;t<e.length;t++){var n=e[t],r=n.row,i=this.$annotations[r];i||(i=this.$annotations[r]={text:[],type:[]});var o=n.text,u=n.type;o=o?s.escapeHTML(o):n.html||"",i.text.indexOf(o)===-1&&(i.text.push(o),i.type.push(u));var a=n.className;a?i.className=a:u=="error"?i.className=" ace_error":u=="warning"&&i.className!=" ace_error"?i.className=" ace_warning":u=="info"&&!i.className&&(i.className=" ace_info")}},e.prototype.$updateAnnotations=function(e){if(!this.$annotations.length)return;var t=e.start.row,n=e.end.row-t;if(n!==0)if(e.action=="remove")this.$annotations.splice(t,n+1,null);else{var r=new Array(n+1);r.unshift(t,1),this.$annotations.splice.apply(this.$annotations,r)}},e.prototype.update=function(e){this.config=e;var t=this.session,n=e.firstRow,r=Math.min(e.lastRow+e.gutterOffset,t.getLength()-1);this.oldLastRow=r,this.config=e,this.$lines.moveContainer(e),this.$updateCursorRow();var i=t.getNextFoldLine(n),s=i?i.start.row:Infinity,o=null,u=-1,a=n;for(;;){a>s&&(a=i.end.row+1,i=t.getNextFoldLine(a,i),s=i?i.start.row:Infinity);if(a>r){while(this.$lines.getLength()>u+1)this.$lines.pop();break}o=this.$lines.get(++u),o?o.row=a:(o=this.$lines.createCell(a,e,this.session,f),this.$lines.push(o)),this.$renderCell(o,e,i,a),a++}this._signal("afterRender"),this.$updateGutterWidth(e)},e.prototype.$updateGutterWidth=function(e){var t=this.session,n=t.gutterRenderer||this.$renderer,r=t.$firstLineNumber,i=this.$lines.last()?this.$lines.last().text:"";if(this.$fixedWidth||t.$useWrapMode)i=t.getLength()+r-1;var s=n?n.getWidth(t,i,e):i.toString().length*e.characterWidth,o=this.$padding||this.$computePadding();s+=o.left+o.right,s!==this.gutterWidth&&!isNaN(s)&&(this.gutterWidth=s,this.element.parentNode.style.width=this.element.style.width=Math.ceil(this.gutterWidth)+"px",this._signal("changeGutterWidth",s))},e.prototype.$updateCursorRow=function(){if(!this.$highlightGutterLine)return;var e=this.session.selection.getCursor();if(this.$cursorRow===e.row)return;this.$cursorRow=e.row},e.prototype.updateLineHighlight=function(){if(!this.$highlightGutterLine)return;var e=this.session.selection.cursor.row;this.$cursorRow=e;if(this.$cursorCell&&this.$cursorCell.row==e)return;this.$cursorCell&&(this.$cursorCell.element.className=this.$cursorCell.element.className.replace("ace_gutter-active-line ",""));var t=this.$lines.cells;this.$cursorCell=null;for(var n=0;n<t.length;n++){var r=t[n];if(r.row>=this.$cursorRow){if(r.row>this.$cursorRow){var i=this.session.getFoldLine(this.$cursorRow);if(!(n>0&&i&&i.start.row==t[n-1].row))break;r=t[n-1]}r.element.className="ace_gutter-active-line "+r.element.className,this.$cursorCell=r;break}}},e.prototype.scrollLines=function(e){var t=this.config;this.config=e,this.$updateCursorRow();if(this.$lines.pageChanged(t,e))return this.update(e);this.$lines.moveContainer(e);var n=Math.min(e.lastRow+e.gutterOffset,this.session.getLength()-1),r=this.oldLastRow;this.oldLastRow=n;if(!t||r<e.firstRow)return this.update(e);if(n<t.firstRow)return this.update(e);if(t.firstRow<e.firstRow)for(var i=this.session.getFoldedRowCount(t.firstRow,e.firstRow-1);i>0;i--)this.$lines.shift();if(r>n)for(var i=this.session.getFoldedRowCount(n+1,r);i>0;i--)this.$lines.pop();e.firstRow<t.firstRow&&this.$lines.unshift(this.$renderLines(e,e.firstRow,t.firstRow-1)),n>r&&this.$lines.push(this.$renderLines(e,r+1,n)),this.updateLineHighlight(),this._signal("afterRender"),this.$updateGutterWidth(e)},e.prototype.$renderLines=function(e,t,n){var r=[],i=t,s=this.session.getNextFoldLine(i),o=s?s.start.row:Infinity;for(;;){i>o&&(i=s.end.row+1,s=this.session.getNextFoldLine(i,s),o=s?s.start.row:Infinity);if(i>n)break;var u=this.$lines.createCell(i,e,this.session,f);this.$renderCell(u,e,s,i),r.push(u),i++}return r},e.prototype.$renderCell=function(e,t,n,i){var s=e.element,o=this.session,u=s.childNodes[0],a=s.childNodes[1],f=s.childNodes[2],l=o.$firstLineNumber,c=o.$breakpoints,h=o.$decorations,p=o.gutterRenderer||this.$renderer,d=this.$showFoldWidgets&&o.foldWidgets,v=n?n.start.row:Number.MAX_VALUE,m=t.lineHeight+"px",g=this.$useSvgGutterIcons?"ace_gutter-cell_svg-icons ":"ace_gutter-cell ",y=this.$useSvgGutterIcons?"ace_icon_svg":"ace_icon";this.$highlightGutterLine&&(i==this.$cursorRow||n&&i<this.$cursorRow&&i>=v&&this.$cursorRow<=n.end.row)&&(g+="ace_gutter-active-line ",this.$cursorCell!=e&&(this.$cursorCell&&(this.$cursorCell.element.className=this.$cursorCell.element.className.replace("ace_gutter-active-line ","")),this.$cursorCell=e)),c[i]&&(g+=c[i]),h[i]&&(g+=h[i]),this.$annotations[i]&&i!==v&&(g+=this.$annotations[i].className),s.className!=g&&(s.className=g);if(d){var b=d[i];b==null&&(b=d[i]=o.getFoldWidget(i))}if(b){var g="ace_fold-widget ace_"+b;if(b=="start"&&i==v&&i<n.end.row){g+=" ace_closed";var w,E=!1;for(var S=i+1;S<=n.end.row;S++){if(!this.$annotations[S])continue;if(this.$annotations[S].className===" ace_error"){E=!0,w=" ace_error_fold";break}if(this.$annotations[S].className===" ace_warning"){E=!0,w=" ace_warning_fold";continue}}s.className+=w}else g+=" ace_open";a.className!=g&&(a.className=g),r.setStyle(a.style,"height",m),r.setStyle(a.style,"display","inline-block")}else a&&r.setStyle(a.style,"display","none");E&&this.$showFoldedAnnotations?(f.className=y,f.className+=w,r.setStyle(f.style,"height",m),r.setStyle(f.style,"display","block")):this.$annotations[i]?(f.className=y,this.$useSvgGutterIcons?f.className+=this.$annotations[i].className:s.classList.add(this.$annotations[i].className.replace(" ","")),r.setStyle(f.style,"height",m),r.setStyle(f.style,"display","block")):r.setStyle(f.style,"display","none");var x=(p?p.getText(o,i):i+l).toString();return x!==u.data&&(u.data=x),r.setStyle(e.element.style,"height",this.$lines.computeLineHeight(i,t,o)+"px"),r.setStyle(e.element.style,"top",this.$lines.computeLineTop(i,t,o)+"px"),e.text=x,e},e.prototype.setHighlightGutterLine=function(e){this.$highlightGutterLine=e},e.prototype.setShowLineNumbers=function(e){this.$renderer=!e&&{getWidth:function(){return 0},getText:function(){return""}}},e.prototype.getShowLineNumbers=function(){return this.$showLineNumbers},e.prototype.setShowFoldWidgets=function(e){e?r.addCssClass(this.element,"ace_folding-enabled"):r.removeCssClass(this.element,"ace_folding-enabled"),this.$showFoldWidgets=e,this.$padding=null},e.prototype.getShowFoldWidgets=function(){return this.$showFoldWidgets},e.prototype.$computePadding=function(){if(!this.element.firstChild)return{left:0,right:0};var e=r.computedStyle(this.element.firstChild);return this.$padding={},this.$padding.left=(parseInt(e.borderLeftWidth)||0)+(parseInt(e.paddingLeft)||0)+1,this.$padding.right=(parseInt(e.borderRightWidth)||0)+(parseInt(e.paddingRight)||0),this.$padding},e.prototype.getRegion=function(e){var t=this.$padding||this.$computePadding(),n=this.element.getBoundingClientRect();if(e.x<t.left+n.left)return"markers";if(this.$showFoldWidgets&&e.x>n.right-t.right)return"foldWidgets"},e}();a.prototype.$fixedWidth=!1,a.prototype.$highlightGutterLine=!0,a.prototype.$renderer="",a.prototype.$showLineNumbers=!0,a.prototype.$showFoldWidgets=!0,i.implement(a.prototype,o),t.Gutter=a}),ace.define("ace/layer/marker",["require","exports","module","ace/range","ace/lib/dom"],function(e,t,n){"use strict";function o(e,t,n,r){return(e?1:0)|(t?2:0)|(n?4:0)|(r?8:0)}var r=e("../range").Range,i=e("../lib/dom"),s=function(){function e(e){this.element=i.createElement("div"),this.element.className="ace_layer ace_marker-layer",e.appendChild(this.element)}return e.prototype.setPadding=function(e){this.$padding=e},e.prototype.setSession=function(e){this.session=e},e.prototype.setMarkers=function(e){this.markers=e},e.prototype.elt=function(e,t){var n=this.i!=-1&&this.element.childNodes[this.i];n?this.i++:(n=document.createElement("div"),this.element.appendChild(n),this.i=-1),n.style.cssText=t,n.className=e},e.prototype.update=function(e){if(!e)return;this.config=e,this.i=0;var t;for(var n in this.markers){var r=this.markers[n];if(!r.range){r.update(t,this,this.session,e);continue}var i=r.range.clipRows(e.firstRow,e.lastRow);if(i.isEmpty())continue;i=i.toScreenRange(this.session);if(r.renderer){var s=this.$getTop(i.start.row,e),o=this.$padding+i.start.column*e.characterWidth;r.renderer(t,i,o,s,e)}else r.type=="fullLine"?this.drawFullLineMarker(t,i,r.clazz,e):r.type=="screenLine"?this.drawScreenLineMarker(t,i,r.clazz,e):i.isMultiLine()?r.type=="text"?this.drawTextMarker(t,i,r.clazz,e):this.drawMultiLineMarker(t,i,r.clazz,e):this.drawSingleLineMarker(t,i,r.clazz+" ace_start"+" ace_br15",e)}if(this.i!=-1)while(this.i<this.element.childElementCount)this.element.removeChild(this.element.lastChild)},e.prototype.$getTop=function(e,t){return(e-t.firstRowScreen)*t.lineHeight},e.prototype.drawTextMarker=function(e,t,n,i,s){var u=this.session,a=t.start.row,f=t.end.row,l=a,c=0,h=0,p=u.getScreenLastRowColumn(l),d=new r(l,t.start.column,l,h);for(;l<=f;l++)d.start.row=d.end.row=l,d.start.column=l==a?t.start.column:u.getRowWrapIndent(l),d.end.column=p,c=h,h=p,p=l+1<f?u.getScreenLastRowColumn(l+1):l==f?0:t.end.column,this.drawSingleLineMarker(e,d,n+(l==a?" ace_start":"")+" ace_br"+o(l==a||l==a+1&&t.start.column,c<h,h>p,l==f),i,l==f?0:1,s)},e.prototype.drawMultiLineMarker=function(e,t,n,r,i){var s=this.$padding,o=r.lineHeight,u=this.$getTop(t.start.row,r),a=s+t.start.column*r.characterWidth;i=i||"";if(this.session.$bidiHandler.isBidiRow(t.start.row)){var f=t.clone();f.end.row=f.start.row,f.end.column=this.session.getLine(f.start.row).length,this.drawBidiSingleLineMarker(e,f,n+" ace_br1 ace_start",r,null,i)}else this.elt(n+" ace_br1 ace_start","height:"+o+"px;"+"right:0;"+"top:"+u+"px;left:"+a+"px;"+(i||""));if(this.session.$bidiHandler.isBidiRow(t.end.row)){var f=t.clone();f.start.row=f.end.row,f.start.column=0,this.drawBidiSingleLineMarker(e,f,n+" ace_br12",r,null,i)}else{u=this.$getTop(t.end.row,r);var l=t.end.column*r.characterWidth;this.elt(n+" ace_br12","height:"+o+"px;"+"width:"+l+"px;"+"top:"+u+"px;"+"left:"+s+"px;"+(i||""))}o=(t.end.row-t.start.row-1)*r.lineHeight;if(o<=0)return;u=this.$getTop(t.start.row+1,r);var c=(t.start.column?1:0)|(t.end.column?0:8);this.elt(n+(c?" ace_br"+c:""),"height:"+o+"px;"+"right:0;"+"top:"+u+"px;"+"left:"+s+"px;"+(i||""))},e.prototype.drawSingleLineMarker=function(e,t,n,r,i,s){if(this.session.$bidiHandler.isBidiRow(t.start.row))return this.drawBidiSingleLineMarker(e,t,n,r,i,s);var o=r.lineHeight,u=(t.end.column+(i||0)-t.start.column)*r.characterWidth,a=this.$getTop(t.start.row,r),f=this.$padding+t.start.column*r.characterWidth;this.elt(n,"height:"+o+"px;"+"width:"+u+"px;"+"top:"+a+"px;"+"left:"+f+"px;"+(s||""))},e.prototype.drawBidiSingleLineMarker=function(e,t,n,r,i,s){var o=r.lineHeight,u=this.$getTop(t.start.row,r),a=this.$padding,f=this.session.$bidiHandler.getSelections(t.start.column,t.end.column);f.forEach(function(e){this.elt(n,"height:"+o+"px;"+"width:"+(e.width+(i||0))+"px;"+"top:"+u+"px;"+"left:"+(a+e.left)+"px;"+(s||""))},this)},e.prototype.drawFullLineMarker=function(e,t,n,r,i){var s=this.$getTop(t.start.row,r),o=r.lineHeight;t.start.row!=t.end.row&&(o+=this.$getTop(t.end.row,r)-s),this.elt(n,"height:"+o+"px;"+"top:"+s+"px;"+"left:0;right:0;"+(i||""))},e.prototype.drawScreenLineMarker=function(e,t,n,r,i){var s=this.$getTop(t.start.row,r),o=r.lineHeight;this.elt(n,"height:"+o+"px;"+"top:"+s+"px;"+"left:0;right:0;"+(i||""))},e}();s.prototype.$padding=0,t.Marker=s}),ace.define("ace/layer/text",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/layer/lines","ace/lib/event_emitter"],function(e,t,n){"use strict";var r=e("../lib/oop"),i=e("../lib/dom"),s=e("../lib/lang"),o=e("./lines").Lines,u=e("../lib/event_emitter").EventEmitter,a=function(){function e(e){this.dom=i,this.element=this.dom.createElement("div"),this.element.className="ace_layer ace_text-layer",e.appendChild(this.element),this.$updateEolChar=this.$updateEolChar.bind(this),this.$lines=new o(this.element)}return e.prototype.$updateEolChar=function(){var e=this.session.doc,t=e.getNewLineCharacter()=="\n"&&e.getNewLineMode()!="windows",n=t?this.EOL_CHAR_LF:this.EOL_CHAR_CRLF;if(this.EOL_CHAR!=n)return this.EOL_CHAR=n,!0},e.prototype.setPadding=function(e){this.$padding=e,this.element.style.margin="0 "+e+"px"},e.prototype.getLineHeight=function(){return this.$fontMetrics.$characterSize.height||0},e.prototype.getCharacterWidth=function(){return this.$fontMetrics.$characterSize.width||0},e.prototype.$setFontMetrics=function(e){this.$fontMetrics=e,this.$fontMetrics.on("changeCharacterSize",function(e){this._signal("changeCharacterSize",e)}.bind(this)),this.$pollSizeChanges()},e.prototype.checkForSizeChanges=function(){this.$fontMetrics.checkForSizeChanges()},e.prototype.$pollSizeChanges=function(){return this.$pollSizeChangesTimer=this.$fontMetrics.$pollSizeChanges()},e.prototype.setSession=function(e){this.session=e,e&&this.$computeTabString()},e.prototype.setShowInvisibles=function(e){return this.showInvisibles==e?!1:(this.showInvisibles=e,typeof e=="string"?(this.showSpaces=/tab/i.test(e),this.showTabs=/space/i.test(e),this.showEOL=/eol/i.test(e)):this.showSpaces=this.showTabs=this.showEOL=e,this.$computeTabString(),!0)},e.prototype.setDisplayIndentGuides=function(e){return this.displayIndentGuides==e?!1:(this.displayIndentGuides=e,this.$computeTabString(),!0)},e.prototype.setHighlightIndentGuides=function(e){return this.$highlightIndentGuides===e?!1:(this.$highlightIndentGuides=e,e)},e.prototype.$computeTabString=function(){var e=this.session.getTabSize();this.tabSize=e;var t=this.$tabStrings=[0];for(var n=1;n<e+1;n++)if(this.showTabs){var r=this.dom.createElement("span");r.className="ace_invisible ace_invisible_tab",r.textContent=s.stringRepeat(this.TAB_CHAR,n),t.push(r)}else t.push(this.dom.createTextNode(s.stringRepeat(" ",n),this.element));if(this.displayIndentGuides){this.$indentGuideRe=/\s\S| \t|\t |\s$/;var i="ace_indent-guide",o=this.showSpaces?" ace_invisible ace_invisible_space":"",u=this.showSpaces?s.stringRepeat(this.SPACE_CHAR,this.tabSize):s.stringRepeat(" ",this.tabSize),a=this.showTabs?" ace_invisible ace_invisible_tab":"",f=this.showTabs?s.stringRepeat(this.TAB_CHAR,this.tabSize):u,r=this.dom.createElement("span");r.className=i+o,r.textContent=u,this.$tabStrings[" "]=r;var r=this.dom.createElement("span");r.className=i+a,r.textContent=f,this.$tabStrings["	"]=r}},e.prototype.updateLines=function(e,t,n){if(this.config.lastRow!=e.lastRow||this.config.firstRow!=e.firstRow)return this.update(e);this.config=e;var r=Math.max(t,e.firstRow),i=Math.min(n,e.lastRow),s=this.element.childNodes,o=0;for(var u=e.firstRow;u<r;u++){var a=this.session.getFoldLine(u);if(a){if(a.containsRow(r)){r=a.start.row;break}u=a.end.row}o++}var f=!1,u=r,a=this.session.getNextFoldLine(u),l=a?a.start.row:Infinity;for(;;){u>l&&(u=a.end.row+1,a=this.session.getNextFoldLine(u,a),l=a?a.start.row:Infinity);if(u>i)break;var c=s[o++];if(c){this.dom.removeChildren(c),this.$renderLine(c,u,u==l?a:!1),f&&(c.style.top=this.$lines.computeLineTop(u,e,this.session)+"px");var h=e.lineHeight*this.session.getRowLength(u)+"px";c.style.height!=h&&(f=!0,c.style.height=h)}u++}if(f)while(o<this.$lines.cells.length){var p=this.$lines.cells[o++];p.element.style.top=this.$lines.computeLineTop(p.row,e,this.session)+"px"}},e.prototype.scrollLines=function(e){var t=this.config;this.config=e;if(this.$lines.pageChanged(t,e))return this.update(e);this.$lines.moveContainer(e);var n=e.lastRow,r=t?t.lastRow:-1;if(!t||r<e.firstRow)return this.update(e);if(n<t.firstRow)return this.update(e);if(!t||t.lastRow<e.firstRow)return this.update(e);if(e.lastRow<t.firstRow)return this.update(e);if(t.firstRow<e.firstRow)for(var i=this.session.getFoldedRowCount(t.firstRow,e.firstRow-1);i>0;i--)this.$lines.shift();if(t.lastRow>e.lastRow)for(var i=this.session.getFoldedRowCount(e.lastRow+1,t.lastRow);i>0;i--)this.$lines.pop();e.firstRow<t.firstRow&&this.$lines.unshift(this.$renderLinesFragment(e,e.firstRow,t.firstRow-1)),e.lastRow>t.lastRow&&this.$lines.push(this.$renderLinesFragment(e,t.lastRow+1,e.lastRow)),this.$highlightIndentGuide()},e.prototype.$renderLinesFragment=function(e,t,n){var r=[],s=t,o=this.session.getNextFoldLine(s),u=o?o.start.row:Infinity;for(;;){s>u&&(s=o.end.row+1,o=this.session.getNextFoldLine(s,o),u=o?o.start.row:Infinity);if(s>n)break;var a=this.$lines.createCell(s,e,this.session),f=a.element;this.dom.removeChildren(f),i.setStyle(f.style,"height",this.$lines.computeLineHeight(s,e,this.session)+"px"),i.setStyle(f.style,"top",this.$lines.computeLineTop(s,e,this.session)+"px"),this.$renderLine(f,s,s==u?o:!1),this.$useLineGroups()?f.className="ace_line_group":f.className="ace_line",r.push(a),s++}return r},e.prototype.update=function(e){this.$lines.moveContainer(e),this.config=e;var t=e.firstRow,n=e.lastRow,r=this.$lines;while(r.getLength())r.pop();r.push(this.$renderLinesFragment(e,t,n))},e.prototype.$renderToken=function(e,t,n,r){var i=this,o=/(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g,u=this.dom.createFragment(this.element),a,f=0;while(a=o.exec(r)){var l=a[1],c=a[2],h=a[3],p=a[4],d=a[5];if(!i.showSpaces&&c)continue;var v=f!=a.index?r.slice(f,a.index):"";f=a.index+a[0].length,v&&u.appendChild(this.dom.createTextNode(v,this.element));if(l){var m=i.session.getScreenTabSize(t+a.index);u.appendChild(i.$tabStrings[m].cloneNode(!0)),t+=m-1}else if(c)if(i.showSpaces){var g=this.dom.createElement("span");g.className="ace_invisible ace_invisible_space",g.textContent=s.stringRepeat(i.SPACE_CHAR,c.length),u.appendChild(g)}else u.appendChild(this.com.createTextNode(c,this.element));else if(h){var g=this.dom.createElement("span");g.className="ace_invisible ace_invisible_space ace_invalid",g.textContent=s.stringRepeat(i.SPACE_CHAR,h.length),u.appendChild(g)}else if(p){t+=1;var g=this.dom.createElement("span");g.style.width=i.config.characterWidth*2+"px",g.className=i.showSpaces?"ace_cjk ace_invisible ace_invisible_space":"ace_cjk",g.textContent=i.showSpaces?i.SPACE_CHAR:p,u.appendChild(g)}else if(d){t+=1;var g=this.dom.createElement("span");g.style.width=i.config.characterWidth*2+"px",g.className="ace_cjk",g.textContent=d,u.appendChild(g)}}u.appendChild(this.dom.createTextNode(f?r.slice(f):r,this.element));if(!this.$textToken[n.type]){var y="ace_"+n.type.replace(/\./g," ace_"),g=this.dom.createElement("span");n.type=="fold"&&(g.style.width=n.value.length*this.config.characterWidth+"px"),g.className=y,g.appendChild(u),e.appendChild(g)}else e.appendChild(u);return t+r.length},e.prototype.renderIndentGuide=function(e,t,n){var r=t.search(this.$indentGuideRe);if(r<=0||r>=n)return t;if(t[0]==" "){r-=r%this.tabSize;var i=r/this.tabSize;for(var s=0;s<i;s++)e.appendChild(this.$tabStrings[" "].cloneNode(!0));return this.$highlightIndentGuide(),t.substr(r)}if(t[0]=="	"){for(var s=0;s<r;s++)e.appendChild(this.$tabStrings["	"].cloneNode(!0));return this.$highlightIndentGuide(),t.substr(r)}return this.$highlightIndentGuide(),t},e.prototype.$highlightIndentGuide=function(){if(!this.$highlightIndentGuides||!this.displayIndentGuides)return;this.$highlightIndentGuideMarker={indentLevel:undefined,start:undefined,end:undefined,dir:undefined};var e=this.session.doc.$lines;if(!e)return;var t=this.session.selection.getCursor(),n=/^\s*/.exec(this.session.doc.getLine(t.row))[0].length,r=Math.floor(n/this.tabSize);this.$highlightIndentGuideMarker={indentLevel:r,start:t.row};var i=this.session.$bracketHighlight;if(i){var s=this.session.$bracketHighlight.ranges;for(var o=0;o<s.length;o++)if(t.row!==s[o].start.row){this.$highlightIndentGuideMarker.end=s[o].start.row,t.row>s[o].start.row?this.$highlightIndentGuideMarker.dir=-1:this.$highlightIndentGuideMarker.dir=1;break}}if(!this.$highlightIndentGuideMarker.end&&e[t.row]!==""&&t.column===e[t.row].length){this.$highlightIndentGuideMarker.dir=1;for(var o=t.row+1;o<e.length;o++){var u=e[o],a=/^\s*/.exec(u)[0].length;if(u!==""){this.$highlightIndentGuideMarker.end=o;if(a<=n)break}}}this.$renderHighlightIndentGuide()},e.prototype.$clearActiveIndentGuide=function(){var e=this.$lines.cells;for(var t=0;t<e.length;t++){var n=e[t],r=n.element.childNodes;if(r.length>0)for(var i=0;i<r.length;i++)if(r[i].classList&&r[i].classList.contains("ace_indent-guide-active")){r[i].classList.remove("ace_indent-guide-active");break}}},e.prototype.$setIndentGuideActive=function(e,t){var n=this.session.doc.getLine(e.row);if(n!==""){var r=e.element.childNodes;if(r){var i=r[t-1];i&&i.classList&&i.classList.contains("ace_indent-guide")&&i.classList.add("ace_indent-guide-active")}}},e.prototype.$renderHighlightIndentGuide=function(){if(!this.$lines)return;var e=this.$lines.cells;this.$clearActiveIndentGuide();var t=this.$highlightIndentGuideMarker.indentLevel;if(t!==0)if(this.$highlightIndentGuideMarker.dir===1)for(var n=0;n<e.length;n++){var r=e[n];if(this.$highlightIndentGuideMarker.end&&r.row>=this.$highlightIndentGuideMarker.start+1){if(r.row>=this.$highlightIndentGuideMarker.end)break;this.$setIndentGuideActive(r,t)}}else for(var n=e.length-1;n>=0;n--){var r=e[n];if(this.$highlightIndentGuideMarker.end&&r.row<this.$highlightIndentGuideMarker.start){if(r.row<=this.$highlightIndentGuideMarker.end)break;this.$setIndentGuideActive(r,t)}}},e.prototype.$createLineElement=function(e){var t=this.dom.createElement("div");return t.className="ace_line",t.style.height=this.config.lineHeight+"px",t},e.prototype.$renderWrappedLine=function(e,t,n){var r=0,i=0,o=n[0],u=0,a=this.$createLineElement();e.appendChild(a);for(var f=0;f<t.length;f++){var l=t[f],c=l.value;if(f==0&&this.displayIndentGuides){r=c.length,c=this.renderIndentGuide(a,c,o);if(!c)continue;r-=c.length}if(r+c.length<o)u=this.$renderToken(a,u,l,c),r+=c.length;else{while(r+c.length>=o)u=this.$renderToken(a,u,l,c.substring(0,o-r)),c=c.substring(o-r),r=o,a=this.$createLineElement(),e.appendChild(a),a.appendChild(this.dom.createTextNode(s.stringRepeat("\u00a0",n.indent),this.element)),i++,u=0,o=n[i]||Number.MAX_VALUE;c.length!=0&&(r+=c.length,u=this.$renderToken(a,u,l,c))}}n[n.length-1]>this.MAX_LINE_LENGTH&&this.$renderOverflowMessage(a,u,null,"",!0)},e.prototype.$renderSimpleLine=function(e,t){var n=0;for(var r=0;r<t.length;r++){var i=t[r],s=i.value;if(r==0&&this.displayIndentGuides){s=this.renderIndentGuide(e,s);if(!s)continue}if(n+s.length>this.MAX_LINE_LENGTH)return this.$renderOverflowMessage(e,n,i,s);n=this.$renderToken(e,n,i,s)}},e.prototype.$renderOverflowMessage=function(e,t,n,r,i){n&&this.$renderToken(e,t,n,r.slice(0,this.MAX_LINE_LENGTH-t));var s=this.dom.createElement("span");s.className="ace_inline_button ace_keyword ace_toggle_wrap",s.textContent=i?"<hide>":"<click to see more...>",e.appendChild(s)},e.prototype.$renderLine=function(e,t,n){!n&&n!=0&&(n=this.session.getFoldLine(t));if(n)var r=this.$getFoldLineTokens(t,n);else var r=this.session.getTokens(t);var i=e;if(r.length){var s=this.session.getRowSplitData(t);if(s&&s.length){this.$renderWrappedLine(e,r,s);var i=e.lastChild}else{var i=e;this.$useLineGroups()&&(i=this.$createLineElement(),e.appendChild(i)),this.$renderSimpleLine(i,r)}}else this.$useLineGroups()&&(i=this.$createLineElement(),e.appendChild(i));if(this.showEOL&&i){n&&(t=n.end.row);var o=this.dom.createElement("span");o.className="ace_invisible ace_invisible_eol",o.textContent=t==this.session.getLength()-1?this.EOF_CHAR:this.EOL_CHAR,i.appendChild(o)}},e.prototype.$getFoldLineTokens=function(e,t){function i(e,t,n){var i=0,s=0;while(s+e[i].value.length<t){s+=e[i].value.length,i++;if(i==e.length)return}if(s!=t){var o=e[i].value.substring(t-s);o.length>n-t&&(o=o.substring(0,n-t)),r.push({type:e[i].type,value:o}),s=t+o.length,i+=1}while(s<n&&i<e.length){var o=e[i].value;o.length+s>n?r.push({type:e[i].type,value:o.substring(0,n-s)}):r.push(e[i]),s+=o.length,i+=1}}var n=this.session,r=[],s=n.getTokens(e);return t.walk(function(e,t,o,u,a){e!=null?r.push({type:"fold",value:e}):(a&&(s=n.getTokens(t)),s.length&&i(s,u,o))},t.end.row,this.session.getLine(t.end.row).length),r},e.prototype.$useLineGroups=function(){return this.session.getUseWrapMode()},e}();a.prototype.$textToken={text:!0,rparen:!0,lparen:!0},a.prototype.EOF_CHAR="\u00b6",a.prototype.EOL_CHAR_LF="\u00ac",a.prototype.EOL_CHAR_CRLF="\u00a4",a.prototype.EOL_CHAR=a.prototype.EOL_CHAR_LF,a.prototype.TAB_CHAR="\u2014",a.prototype.SPACE_CHAR="\u00b7",a.prototype.$padding=0,a.prototype.MAX_LINE_LENGTH=1e4,a.prototype.showInvisibles=!1,a.prototype.showSpaces=!1,a.prototype.showTabs=!1,a.prototype.showEOL=!1,a.prototype.displayIndentGuides=!0,a.prototype.$highlightIndentGuides=!0,a.prototype.$tabStrings=[],a.prototype.destroy={},a.prototype.onChangeTabSize=a.prototype.$computeTabString,r.implement(a.prototype,u),t.Text=a}),ace.define("ace/layer/cursor",["require","exports","module","ace/lib/dom"],function(e,t,n){"use strict";var r=e("../lib/dom"),i=function(){function e(e){this.element=r.createElement("div"),this.element.className="ace_layer ace_cursor-layer",e.appendChild(this.element),this.isVisible=!1,this.isBlinking=!0,this.blinkInterval=1e3,this.smoothBlinking=!1,this.cursors=[],this.cursor=this.addCursor(),r.addCssClass(this.element,"ace_hidden-cursors"),this.$updateCursors=this.$updateOpacity.bind(this)}return e.prototype.$updateOpacity=function(e){var t=this.cursors;for(var n=t.length;n--;)r.setStyle(t[n].style,"opacity",e?"":"0")},e.prototype.$startCssAnimation=function(){var e=this.cursors;for(var t=e.length;t--;)e[t].style.animationDuration=this.blinkInterval+"ms";this.$isAnimating=!0,setTimeout(function(){this.$isAnimating&&r.addCssClass(this.element,"ace_animate-blinking")}.bind(this))},e.prototype.$stopCssAnimation=function(){this.$isAnimating=!1,r.removeCssClass(this.element,"ace_animate-blinking")},e.prototype.setPadding=function(e){this.$padding=e},e.prototype.setSession=function(e){this.session=e},e.prototype.setBlinking=function(e){e!=this.isBlinking&&(this.isBlinking=e,this.restartTimer())},e.prototype.setBlinkInterval=function(e){e!=this.blinkInterval&&(this.blinkInterval=e,this.restartTimer())},e.prototype.setSmoothBlinking=function(e){e!=this.smoothBlinking&&(this.smoothBlinking=e,r.setCssClass(this.element,"ace_smooth-blinking",e),this.$updateCursors(!0),this.restartTimer())},e.prototype.addCursor=function(){var e=r.createElement("div");return e.className="ace_cursor",this.element.appendChild(e),this.cursors.push(e),e},e.prototype.removeCursor=function(){if(this.cursors.length>1){var e=this.cursors.pop();return e.parentNode.removeChild(e),e}},e.prototype.hideCursor=function(){this.isVisible=!1,r.addCssClass(this.element,"ace_hidden-cursors"),this.restartTimer()},e.prototype.showCursor=function(){this.isVisible=!0,r.removeCssClass(this.element,"ace_hidden-cursors"),this.restartTimer()},e.prototype.restartTimer=function(){var e=this.$updateCursors;clearInterval(this.intervalId),clearTimeout(this.timeoutId),this.$stopCssAnimation(),this.smoothBlinking&&(this.$isSmoothBlinking=!1,r.removeCssClass(this.element,"ace_smooth-blinking")),e(!0);if(!this.isBlinking||!this.blinkInterval||!this.isVisible){this.$stopCssAnimation();return}this.smoothBlinking&&(this.$isSmoothBlinking=!0,setTimeout(function(){this.$isSmoothBlinking&&r.addCssClass(this.element,"ace_smooth-blinking")}.bind(this)));if(r.HAS_CSS_ANIMATION)this.$startCssAnimation();else{var t=function(){this.timeoutId=setTimeout(function(){e(!1)},.6*this.blinkInterval)}.bind(this);this.intervalId=setInterval(function(){e(!0),t()},this.blinkInterval),t()}},e.prototype.getPixelPosition=function(e,t){if(!this.config||!this.session)return{left:0,top:0};e||(e=this.session.selection.getCursor());var n=this.session.documentToScreenPosition(e),r=this.$padding+(this.session.$bidiHandler.isBidiRow(n.row,e.row)?this.session.$bidiHandler.getPosLeft(n.column):n.column*this.config.characterWidth),i=(n.row-(t?this.config.firstRowScreen:0))*this.config.lineHeight;return{left:r,top:i}},e.prototype.isCursorInView=function(e,t){return e.top>=0&&e.top<t.maxHeight},e.prototype.update=function(e){this.config=e;var t=this.session.$selectionMarkers,n=0,i=0;if(t===undefined||t.length===0)t=[{cursor:null}];for(var n=0,s=t.length;n<s;n++){var o=this.getPixelPosition(t[n].cursor,!0);if((o.top>e.height+e.offset||o.top<0)&&n>1)continue;var u=this.cursors[i++]||this.addCursor(),a=u.style;this.drawCursor?this.drawCursor(u,o,e,t[n],this.session):this.isCursorInView(o,e)?(r.setStyle(a,"display","block"),r.translate(u,o.left,o.top),r.setStyle(a,"width",Math.round(e.characterWidth)+"px"),r.setStyle(a,"height",e.lineHeight+"px")):r.setStyle(a,"display","none")}while(this.cursors.length>i)this.removeCursor();var f=this.session.getOverwrite();this.$setOverwrite(f),this.$pixelPos=o,this.restartTimer()},e.prototype.$setOverwrite=function(e){e!=this.overwrite&&(this.overwrite=e,e?r.addCssClass(this.element,"ace_overwrite-cursors"):r.removeCssClass(this.element,"ace_overwrite-cursors"))},e.prototype.destroy=function(){clearInterval(this.intervalId),clearTimeout(this.timeoutId)},e}();i.prototype.$padding=0,i.prototype.drawCursor=null,t.Cursor=i}),ace.define("ace/scrollbar",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"],function(e,t,n){"use strict";var r=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}if(typeof n!="function"&&n!==null)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");e(t,n),t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),i=e("./lib/oop"),s=e("./lib/dom"),o=e("./lib/event"),u=e("./lib/event_emitter").EventEmitter,a=32768,f=function(){function e(e,t){this.element=s.createElement("div"),this.element.className="ace_scrollbar ace_scrollbar"+t,this.inner=s.createElement("div"),this.inner.className="ace_scrollbar-inner",this.inner.textContent="\u00a0",this.element.appendChild(this.inner),e.appendChild(this.element),this.setVisible(!1),this.skipEvent=!1,o.addListener(this.element,"scroll",this.onScroll.bind(this)),o.addListener(this.element,"mousedown",o.preventDefault)}return e.prototype.setVisible=function(e){this.element.style.display=e?"":"none",this.isVisible=e,this.coeff=1},e}();i.implement(f.prototype,u);var l=function(e){function t(t,n){var r=e.call(this,t,"-v")||this;return r.scrollTop=0,r.scrollHeight=0,n.$scrollbarWidth=r.width=s.scrollbarWidth(t.ownerDocument),r.inner.style.width=r.element.style.width=(r.width||15)+5+"px",r.$minWidth=0,r}return r(t,e),t.prototype.onScroll=function(){if(!this.skipEvent){this.scrollTop=this.element.scrollTop;if(this.coeff!=1){var e=this.element.clientHeight/this.scrollHeight;this.scrollTop=this.scrollTop*(1-e)/(this.coeff-e)}this._emit("scroll",{data:this.scrollTop})}this.skipEvent=!1},t.prototype.getWidth=function(){return Math.max(this.isVisible?this.width:0,this.$minWidth||0)},t.prototype.setHeight=function(e){this.element.style.height=e+"px"},t.prototype.setScrollHeight=function(e){this.scrollHeight=e,e>a?(this.coeff=a/e,e=a):this.coeff!=1&&(this.coeff=1),this.inner.style.height=e+"px"},t.prototype.setScrollTop=function(e){this.scrollTop!=e&&(this.skipEvent=!0,this.scrollTop=e,this.element.scrollTop=e*this.coeff)},t}(f);l.prototype.setInnerHeight=l.prototype.setScrollHeight;var c=function(e){function t(t,n){var r=e.call(this,t,"-h")||this;return r.scrollLeft=0,r.height=n.$scrollbarWidth,r.inner.style.height=r.element.style.height=(r.height||15)+5+"px",r}return r(t,e),t.prototype.onScroll=function(){this.skipEvent||(this.scrollLeft=this.element.scrollLeft,this._emit("scroll",{data:this.scrollLeft})),this.skipEvent=!1},t.prototype.getHeight=function(){return this.isVisible?this.height:0},t.prototype.setWidth=function(e){this.element.style.width=e+"px"},t.prototype.setInnerWidth=function(e){this.inner.style.width=e+"px"},t.prototype.setScrollWidth=function(e){this.inner.style.width=e+"px"},t.prototype.setScrollLeft=function(e){this.scrollLeft!=e&&(this.skipEvent=!0,this.scrollLeft=this.element.scrollLeft=e)},t}(f);t.ScrollBar=l,t.ScrollBarV=l,t.ScrollBarH=c,t.VScrollBar=l,t.HScrollBar=c}),ace.define("ace/scrollbar_custom",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/event","ace/lib/event_emitter"],function(e,t,n){"use strict";var r=this&&this.__extends||function(){var e=function(t,n){return e=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])},e(t,n)};return function(t,n){function r(){this.constructor=t}if(typeof n!="function"&&n!==null)throw new TypeError("Class extends value "+String(n)+" is not a constructor or null");e(t,n),t.prototype=n===null?Object.create(n):(r.prototype=n.prototype,new r)}}(),i=e("./lib/oop"),s=e("./lib/dom"),o=e("./lib/event"),u=e("./lib/event_emitter").EventEmitter;s.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}","ace_scrollbar.css",!1);var a=function(){function e(e,t){this.element=s.createElement("div"),this.element.className="ace_sb"+t,this.inner=s.createElement("div"),this.inner.className="",this.element.appendChild(this.inner),this.VScrollWidth=12,this.HScrollHeight=12,e.appendChild(this.element),this.setVisible(!1),this.skipEvent=!1,o.addMultiMouseDownListener(this.element,[500,300,300],this,"onMouseDown")}return e.prototype.setVisible=function(e){this.element.style.display=e?"":"none",this.isVisible=e,this.coeff=1},e}();i.implement(a.prototype,u);var f=function(e){function t(t,n){var r=e.call(this,t,"-v")||this;return r.scrollTop=0,r.scrollHeight=0,r.parent=t,r.width=r.VScrollWidth,r.renderer=n,r.inner.style.width=r.element.style.width=(r.width||15)+"px",r.$minWidth=0,r}return r(t,e),t.prototype.onMouseDown=function(e,t){if(e!=="mousedown")return;if(o.getButton(t)!==0||t.detail===2)return;if(t.target===this.inner){var n=this,r=t.clientY,i=function(e){r=e.clientY},s=function(){clearInterval(l)},u=t.clientY,a=this.thumbTop,f=function(){if(r===undefined)return;var e=n.scrollTopFromThumbTop(a+r-u);if(e===n.scrollTop)return;n._emit("scroll",{data:e})};o.capture(this.inner,i,s);var l=setInterval(f,20);return o.preventDefault(t)}var c=t.clientY-this.element.getBoundingClientRect().top-this.thumbHeight/2;return this._emit("scroll",{data:this.scrollTopFromThumbTop(c)}),o.preventDefault(t)},t.prototype.getHeight=function(){return this.height},t.prototype.scrollTopFromThumbTop=function(e){var t=e*(this.pageHeight-this.viewHeight)/(this.slideHeight-this.thumbHeight);return t>>=0,t<0?t=0:t>this.pageHeight-this.viewHeight&&(t=this.pageHeight-this.viewHeight),t},t.prototype.getWidth=function(){return Math.max(this.isVisible?this.width:0,this.$minWidth||0)},t.prototype.setHeight=function(e){this.height=Math.max(0,e),this.slideHeight=this.height,this.viewHeight=this.height,this.setScrollHeight(this.pageHeight,!0)},t.prototype.setScrollHeight=function(e,t){if(this.pageHeight===e&&!t)return;this.pageHeight=e,this.thumbHeight=this.slideHeight*this.viewHeight/this.pageHeight,this.thumbHeight>this.slideHeight&&(this.thumbHeight=this.slideHeight),this.thumbHeight<15&&(this.thumbHeight=15),this.inner.style.height=this.thumbHeight+"px",this.scrollTop>this.pageHeight-this.viewHeight&&(this.scrollTop=this.pageHeight-this.viewHeight,this.scrollTop<0&&(this.scrollTop=0),this._emit("scroll",{data:this.scrollTop}))},t.prototype.setScrollTop=function(e){this.scrollTop=e,e<0&&(e=0),this.thumbTop=e*(this.slideHeight-this.thumbHeight)/(this.pageHeight-this.viewHeight),this.inner.style.top=this.thumbTop+"px"},t}(a);f.prototype.setInnerHeight=f.prototype.setScrollHeight;var l=function(e){function t(t,n){var r=e.call(this,t,"-h")||this;return r.scrollLeft=0,r.scrollWidth=0,r.height=r.HScrollHeight,r.inner.style.height=r.element.style.height=(r.height||12)+"px",r.renderer=n,r}return r(t,e),t.prototype.onMouseDown=function(e,t){if(e!=="mousedown")return;if(o.getButton(t)!==0||t.detail===2)return;if(t.target===this.inner){var n=this,r=t.clientX,i=function(e){r=e.clientX},s=function(){clearInterval(l)},u=t.clientX,a=this.thumbLeft,f=function(){if(r===undefined)return;var e=n.scrollLeftFromThumbLeft(a+r-u);if(e===n.scrollLeft)return;n._emit("scroll",{data:e})};o.capture(this.inner,i,s);var l=setInterval(f,20);return o.preventDefault(t)}var c=t.clientX-this.element.getBoundingClientRect().left-this.thumbWidth/2;return this._emit("scroll",{data:this.scrollLeftFromThumbLeft(c)}),o.preventDefault(t)},t.prototype.getHeight=function(){return this.isVisible?this.height:0},t.prototype.scrollLeftFromThumbLeft=function(e){var t=e*(this.pageWidth-this.viewWidth)/(this.slideWidth-this.thumbWidth);return t>>=0,t<0?t=0:t>this.pageWidth-this.viewWidth&&(t=this.pageWidth-this.viewWidth),t},t.prototype.setWidth=function(e){this.width=Math.max(0,e),this.element.style.width=this.width+"px",this.slideWidth=this.width,this.viewWidth=this.width,this.setScrollWidth(this.pageWidth,!0)},t.prototype.setScrollWidth=function(e,t){if(this.pageWidth===e&&!t)return;this.pageWidth=e,this.thumbWidth=this.slideWidth*this.viewWidth/this.pageWidth,this.thumbWidth>this.slideWidth&&(this.thumbWidth=this.slideWidth),this.thumbWidth<15&&(this.thumbWidth=15),this.inner.style.width=this.thumbWidth+"px",this.scrollLeft>this.pageWidth-this.viewWidth&&(this.scrollLeft=this.pageWidth-this.viewWidth,this.scrollLeft<0&&(this.scrollLeft=0),this._emit("scroll",{data:this.scrollLeft}))},t.prototype.setScrollLeft=function(e){this.scrollLeft=e,e<0&&(e=0),this.thumbLeft=e*(this.slideWidth-this.thumbWidth)/(this.pageWidth-this.viewWidth),this.inner.style.left=this.thumbLeft+"px"},t}(a);l.prototype.setInnerWidth=l.prototype.setScrollWidth,t.ScrollBar=f,t.ScrollBarV=f,t.ScrollBarH=l,t.VScrollBar=f,t.HScrollBar=l}),ace.define("ace/renderloop",["require","exports","module","ace/lib/event"],function(e,t,n){"use strict";var r=e("./lib/event"),i=function(){function e(e,t){this.onRender=e,this.pending=!1,this.changes=0,this.$recursionLimit=2,this.window=t||window;var n=this;this._flush=function(e){n.pending=!1;var t=n.changes;t&&(r.blockIdle(100),n.changes=0,n.onRender(t));if(n.changes){if(n.$recursionLimit--<0)return;n.schedule()}else n.$recursionLimit=2}}return e.prototype.schedule=function(e){this.changes=this.changes|e,this.changes&&!this.pending&&(r.nextFrame(this._flush),this.pending=!0)},e.prototype.clear=function(e){var t=this.changes;return this.changes=0,t},e}();t.RenderLoop=i}),ace.define("ace/layer/font_metrics",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/lib/event","ace/lib/useragent","ace/lib/event_emitter"],function(e,t,n){var r=e("../lib/oop"),i=e("../lib/dom"),s=e("../lib/lang"),o=e("../lib/event"),u=e("../lib/useragent"),a=e("../lib/event_emitter").EventEmitter,f=512,l=typeof ResizeObserver=="function",c=200,h=function(){function e(e){this.el=i.createElement("div"),this.$setMeasureNodeStyles(this.el.style,!0),this.$main=i.createElement("div"),this.$setMeasureNodeStyles(this.$main.style),this.$measureNode=i.createElement("div"),this.$setMeasureNodeStyles(this.$measureNode.style),this.el.appendChild(this.$main),this.el.appendChild(this.$measureNode),e.appendChild(this.el),this.$measureNode.textContent=s.stringRepeat("X",f),this.$characterSize={width:0,height:0},l?this.$addObserver():this.checkForSizeChanges()}return e.prototype.$setMeasureNodeStyles=function(e,t){e.width=e.height="auto",e.left=e.top="0px",e.visibility="hidden",e.position="absolute",e.whiteSpace="pre",u.isIE<8?e["font-family"]="inherit":e.font="inherit",e.overflow=t?"hidden":"visible"},e.prototype.checkForSizeChanges=function(e){e===undefined&&(e=this.$measureSizes());if(e&&(this.$characterSize.width!==e.width||this.$characterSize.height!==e.height)){this.$measureNode.style.fontWeight="bold";var t=this.$measureSizes();this.$measureNode.style.fontWeight="",this.$characterSize=e,this.charSizes=Object.create(null),this.allowBoldFonts=t&&t.width===e.width&&t.height===e.height,this._emit("changeCharacterSize",{data:e})}},e.prototype.$addObserver=function(){var e=this;this.$observer=new window.ResizeObserver(function(t){e.checkForSizeChanges()}),this.$observer.observe(this.$measureNode)},e.prototype.$pollSizeChanges=function(){if(this.$pollSizeChangesTimer||this.$observer)return this.$pollSizeChangesTimer;var e=this;return this.$pollSizeChangesTimer=o.onIdle(function t(){e.checkForSizeChanges(),o.onIdle(t,500)},500)},e.prototype.setPolling=function(e){e?this.$pollSizeChanges():this.$pollSizeChangesTimer&&(clearInterval(this.$pollSizeChangesTimer),this.$pollSizeChangesTimer=0)},e.prototype.$measureSizes=function(e){var t={height:(e||this.$measureNode).clientHeight,width:(e||this.$measureNode).clientWidth/f};return t.width===0||t.height===0?null:t},e.prototype.$measureCharWidth=function(e){this.$main.textContent=s.stringRepeat(e,f);var t=this.$main.getBoundingClientRect();return t.width/f},e.prototype.getCharacterWidth=function(e){var t=this.charSizes[e];return t===undefined&&(t=this.charSizes[e]=this.$measureCharWidth(e)/this.$characterSize.width),t},e.prototype.destroy=function(){clearInterval(this.$pollSizeChangesTimer),this.$observer&&this.$observer.disconnect(),this.el&&this.el.parentNode&&this.el.parentNode.removeChild(this.el)},e.prototype.$getZoom=function(e){return!e||!e.parentElement?1:(window.getComputedStyle(e).zoom||1)*this.$getZoom(e.parentElement)},e.prototype.$initTransformMeasureNodes=function(){var e=function(e,t){return["div",{style:"position: absolute;top:"+e+"px;left:"+t+"px;"}]};this.els=i.buildDom([e(0,0),e(c,0),e(0,c),e(c,c)],this.el)},e.prototype.transformCoordinates=function(e,t){function r(e,t,n){var r=e[1]*t[0]-e[0]*t[1];return[(-t[1]*n[0]+t[0]*n[1])/r,(+e[1]*n[0]-e[0]*n[1])/r]}function i(e,t){return[e[0]-t[0],e[1]-t[1]]}function s(e,t){return[e[0]+t[0],e[1]+t[1]]}function o(e,t){return[e*t[0],e*t[1]]}function u(e){var t=e.getBoundingClientRect();return[t.left,t.top]}if(e){var n=this.$getZoom(this.el);e=o(1/n,e)}this.els||this.$initTransformMeasureNodes();var a=u(this.els[0]),f=u(this.els[1]),l=u(this.els[2]),h=u(this.els[3]),p=r(i(h,f),i(h,l),i(s(f,l),s(h,a))),d=o(1+p[0],i(f,a)),v=o(1+p[1],i(l,a));if(t){var m=t,g=p[0]*m[0]/c+p[1]*m[1]/c+1,y=s(o(m[0],d),o(m[1],v));return s(o(1/g/c,y),a)}var b=i(e,a),w=r(i(d,o(p[0],b)),i(v,o(p[1],b)),b);return o(c,w)},e}();h.prototype.$characterSize={width:0,height:0},r.implement(h.prototype,a),t.FontMetrics=h}),ace.define("ace/css/editor.css",["require","exports","module"],function(e,t,n){n.exports='\n.ace_br1 {border-top-left-radius    : 3px;}\n.ace_br2 {border-top-right-radius   : 3px;}\n.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}\n.ace_br4 {border-bottom-right-radius: 3px;}\n.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}\n.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}\n.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}\n.ace_br8 {border-bottom-left-radius : 3px;}\n.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}\n.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}\n.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}\n.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}\n.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}\n\n\n.ace_editor {\n    position: relative;\n    overflow: hidden;\n    padding: 0;\n    font: 12px/normal \'Monaco\', \'Menlo\', \'Ubuntu Mono\', \'Consolas\', \'Source Code Pro\', \'source-code-pro\', monospace;\n    direction: ltr;\n    text-align: left;\n    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n}\n\n.ace_scroller {\n    position: absolute;\n    overflow: hidden;\n    top: 0;\n    bottom: 0;\n    background-color: inherit;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    cursor: text;\n}\n\n.ace_content {\n    position: absolute;\n    box-sizing: border-box;\n    min-width: 100%;\n    contain: style size layout;\n    font-variant-ligatures: no-common-ligatures;\n}\n\n.ace_keyboard-focus:focus {\n    box-shadow: inset 0 0 0 2px #5E9ED6;\n    outline: none;\n}\n\n.ace_dragging .ace_scroller:before{\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    content: \'\';\n    background: rgba(250, 250, 250, 0.01);\n    z-index: 1000;\n}\n.ace_dragging.ace_dark .ace_scroller:before{\n    background: rgba(0, 0, 0, 0.01);\n}\n\n.ace_gutter {\n    position: absolute;\n    overflow : hidden;\n    width: auto;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    cursor: default;\n    z-index: 4;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    contain: style size layout;\n}\n\n.ace_gutter-active-line {\n    position: absolute;\n    left: 0;\n    right: 0;\n}\n\n.ace_scroller.ace_scroll-left:after {\n    content: "";\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;\n    pointer-events: none;\n}\n\n.ace_gutter-cell, .ace_gutter-cell_svg-icons {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    padding-left: 19px;\n    padding-right: 6px;\n    background-repeat: no-repeat;\n}\n\n.ace_gutter-cell_svg-icons .ace_icon_svg {\n    margin-left: -14px;\n    float: left;\n}\n\n.ace_gutter-cell .ace_icon {\n    margin-left: -18px;\n    float: left;\n}\n\n.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n\n.ace_gutter-cell.ace_info, .ace_icon.ace_info {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");\n    background-repeat: no-repeat;\n    background-position: 2px center;\n}\n.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");\n}\n\n.ace_icon_svg.ace_error {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: darkorange;\n}\n.ace_icon_svg.ace_info {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");\n    background-color: royalblue;\n}\n\n.ace_icon_svg.ace_error_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");\n    background-color: crimson;\n}\n.ace_icon_svg.ace_warning_fold {\n    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");\n    background-color: darkorange;\n}\n\n.ace_scrollbar {\n    contain: strict;\n    position: absolute;\n    right: 0;\n    bottom: 0;\n    z-index: 6;\n}\n\n.ace_scrollbar-inner {\n    position: absolute;\n    cursor: text;\n    left: 0;\n    top: 0;\n}\n\n.ace_scrollbar-v{\n    overflow-x: hidden;\n    overflow-y: scroll;\n    top: 0;\n}\n\n.ace_scrollbar-h {\n    overflow-x: scroll;\n    overflow-y: hidden;\n    left: 0;\n}\n\n.ace_print-margin {\n    position: absolute;\n    height: 100%;\n}\n\n.ace_text-input {\n    position: absolute;\n    z-index: 0;\n    width: 0.5em;\n    height: 1em;\n    opacity: 0;\n    background: transparent;\n    -moz-appearance: none;\n    appearance: none;\n    border: none;\n    resize: none;\n    outline: none;\n    overflow: hidden;\n    font: inherit;\n    padding: 0 1px;\n    margin: 0 -1px;\n    contain: strict;\n    -ms-user-select: text;\n    -moz-user-select: text;\n    -webkit-user-select: text;\n    user-select: text;\n    /*with `pre-line` chrome inserts &nbsp; instead of space*/\n    white-space: pre!important;\n}\n.ace_text-input.ace_composition {\n    background: transparent;\n    color: inherit;\n    z-index: 1000;\n    opacity: 1;\n}\n.ace_composition_placeholder { color: transparent }\n.ace_composition_marker { \n    border-bottom: 1px solid;\n    position: absolute;\n    border-radius: 0;\n    margin-top: 1px;\n}\n\n[ace_nocontext=true] {\n    transform: none!important;\n    filter: none!important;\n    clip-path: none!important;\n    mask : none!important;\n    contain: none!important;\n    perspective: none!important;\n    mix-blend-mode: initial!important;\n    z-index: auto;\n}\n\n.ace_layer {\n    z-index: 1;\n    position: absolute;\n    overflow: hidden;\n    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/\n    word-wrap: normal;\n    white-space: pre;\n    height: 100%;\n    width: 100%;\n    box-sizing: border-box;\n    /* setting pointer-events: auto; on node under the mouse, which changes\n        during scroll, will break mouse wheel scrolling in Safari */\n    pointer-events: none;\n}\n\n.ace_gutter-layer {\n    position: relative;\n    width: auto;\n    text-align: right;\n    pointer-events: auto;\n    height: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer {\n    font: inherit !important;\n    position: absolute;\n    height: 1000000px;\n    width: 1000000px;\n    contain: style size layout;\n}\n\n.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {\n    contain: style size layout;\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n}\n\n.ace_hidpi .ace_text-layer,\n.ace_hidpi .ace_gutter-layer,\n.ace_hidpi .ace_content,\n.ace_hidpi .ace_gutter {\n    contain: strict;\n}\n.ace_hidpi .ace_text-layer > .ace_line, \n.ace_hidpi .ace_text-layer > .ace_line_group {\n    contain: strict;\n}\n\n.ace_cjk {\n    display: inline-block;\n    text-align: center;\n}\n\n.ace_cursor-layer {\n    z-index: 4;\n}\n\n.ace_cursor {\n    z-index: 4;\n    position: absolute;\n    box-sizing: border-box;\n    border-left: 2px solid;\n    /* workaround for smooth cursor repaintng whole screen in chrome */\n    transform: translatez(0);\n}\n\n.ace_multiselect .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_slim-cursors .ace_cursor {\n    border-left-width: 1px;\n}\n\n.ace_overwrite-cursors .ace_cursor {\n    border-left-width: 0;\n    border-bottom: 1px solid;\n}\n\n.ace_hidden-cursors .ace_cursor {\n    opacity: 0.2;\n}\n\n.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {\n    opacity: 0;\n}\n\n.ace_smooth-blinking .ace_cursor {\n    transition: opacity 0.18s;\n}\n\n.ace_animate-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: step-end;\n    animation-name: blink-ace-animate;\n    animation-iteration-count: infinite;\n}\n\n.ace_animate-blinking.ace_smooth-blinking .ace_cursor {\n    animation-duration: 1000ms;\n    animation-timing-function: ease-in-out;\n    animation-name: blink-ace-animate-smooth;\n}\n    \n@keyframes blink-ace-animate {\n    from, to { opacity: 1; }\n    60% { opacity: 0; }\n}\n\n@keyframes blink-ace-animate-smooth {\n    from, to { opacity: 1; }\n    45% { opacity: 1; }\n    60% { opacity: 0; }\n    85% { opacity: 0; }\n}\n\n.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {\n    position: absolute;\n    z-index: 3;\n}\n\n.ace_marker-layer .ace_selection {\n    position: absolute;\n    z-index: 5;\n}\n\n.ace_marker-layer .ace_bracket {\n    position: absolute;\n    z-index: 6;\n}\n\n.ace_marker-layer .ace_error_bracket {\n    position: absolute;\n    border-bottom: 1px solid #DE5555;\n    border-radius: 0;\n}\n\n.ace_marker-layer .ace_active-line {\n    position: absolute;\n    z-index: 2;\n}\n\n.ace_marker-layer .ace_selected-word {\n    position: absolute;\n    z-index: 4;\n    box-sizing: border-box;\n}\n\n.ace_line .ace_fold {\n    box-sizing: border-box;\n\n    display: inline-block;\n    height: 11px;\n    margin-top: -2px;\n    vertical-align: middle;\n\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");\n    background-repeat: no-repeat, repeat-x;\n    background-position: center center, top left;\n    color: transparent;\n\n    border: 1px solid black;\n    border-radius: 2px;\n\n    cursor: pointer;\n    pointer-events: auto;\n}\n\n.ace_dark .ace_fold {\n}\n\n.ace_fold:hover{\n    background-image:\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),\n        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");\n}\n\n.ace_tooltip {\n    background-color: #f5f5f5;\n    border: 1px solid gray;\n    border-radius: 1px;\n    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n    color: black;\n    max-width: 100%;\n    padding: 3px 4px;\n    position: fixed;\n    z-index: 999999;\n    box-sizing: border-box;\n    cursor: default;\n    white-space: pre;\n    word-wrap: break-word;\n    line-height: normal;\n    font-style: normal;\n    font-weight: normal;\n    letter-spacing: normal;\n    pointer-events: none;\n}\n\n.ace_tooltip.ace_dark {\n    background-color: #636363;\n    color: #fff;\n}\n\n.ace_tooltip:focus {\n    outline: 1px solid #5E9ED6;\n}\n\n.ace_icon {\n    display: inline-block;\n    width: 18px;\n    vertical-align: top;\n}\n\n.ace_icon_svg {\n    display: inline-block;\n    width: 12px;\n    vertical-align: top;\n    -webkit-mask-repeat: no-repeat;\n    -webkit-mask-size: 12px;\n    -webkit-mask-position: center;\n}\n\n.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {\n    padding-right: 13px;\n}\n\n.ace_fold-widget {\n    box-sizing: border-box;\n\n    margin: 0 -12px 0 1px;\n    display: none;\n    width: 11px;\n    vertical-align: top;\n\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");\n    background-repeat: no-repeat;\n    background-position: center;\n\n    border-radius: 3px;\n    \n    border: 1px solid transparent;\n    cursor: pointer;\n}\n\n.ace_folding-enabled .ace_fold-widget {\n    display: inline-block;   \n}\n\n.ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");\n}\n\n.ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");\n}\n\n.ace_fold-widget:hover {\n    border: 1px solid rgba(0, 0, 0, 0.3);\n    background-color: rgba(255, 255, 255, 0.2);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);\n}\n\n.ace_fold-widget:active {\n    border: 1px solid rgba(0, 0, 0, 0.4);\n    background-color: rgba(0, 0, 0, 0.05);\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);\n}\n/**\n * Dark version for fold widgets\n */\n.ace_dark .ace_fold-widget {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");\n}\n.ace_dark .ace_fold-widget.ace_end {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget.ace_closed {\n    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");\n}\n.ace_dark .ace_fold-widget:hover {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n    background-color: rgba(255, 255, 255, 0.1);\n}\n.ace_dark .ace_fold-widget:active {\n    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);\n}\n\n.ace_inline_button {\n    border: 1px solid lightgray;\n    display: inline-block;\n    margin: -1px 8px;\n    padding: 0 5px;\n    pointer-events: auto;\n    cursor: pointer;\n}\n.ace_inline_button:hover {\n    border-color: gray;\n    background: rgba(200,200,200,0.2);\n    display: inline-block;\n    pointer-events: auto;\n}\n\n.ace_fold-widget.ace_invalid {\n    background-color: #FFB4B4;\n    border-color: #DE5555;\n}\n\n.ace_fade-fold-widgets .ace_fold-widget {\n    transition: opacity 0.4s ease 0.05s;\n    opacity: 0;\n}\n\n.ace_fade-fold-widgets:hover .ace_fold-widget {\n    transition: opacity 0.05s ease 0.05s;\n    opacity:1;\n}\n\n.ace_underline {\n    text-decoration: underline;\n}\n\n.ace_bold {\n    font-weight: bold;\n}\n\n.ace_nobold .ace_bold {\n    font-weight: normal;\n}\n\n.ace_italic {\n    font-style: italic;\n}\n\n\n.ace_error-marker {\n    background-color: rgba(255, 0, 0,0.2);\n    position: absolute;\n    z-index: 9;\n}\n\n.ace_highlight-marker {\n    background-color: rgba(255, 255, 0,0.2);\n    position: absolute;\n    z-index: 8;\n}\n\n.ace_mobile-menu {\n    position: absolute;\n    line-height: 1.5;\n    border-radius: 4px;\n    -ms-user-select: none;\n    -moz-user-select: none;\n    -webkit-user-select: none;\n    user-select: none;\n    background: white;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #dcdcdc;\n    color: black;\n}\n.ace_dark > .ace_mobile-menu {\n    background: #333;\n    color: #ccc;\n    box-shadow: 1px 3px 2px grey;\n    border: 1px solid #444;\n\n}\n.ace_mobile-button {\n    padding: 2px;\n    cursor: pointer;\n    overflow: hidden;\n}\n.ace_mobile-button:hover {\n    background-color: #eee;\n    opacity:1;\n}\n.ace_mobile-button:active {\n    background-color: #ddd;\n}\n\n.ace_placeholder {\n    font-family: arial;\n    transform: scale(0.9);\n    transform-origin: left;\n    white-space: pre;\n    opacity: 0.7;\n    margin: 0 10px;\n}\n\n.ace_ghost_text {\n    opacity: 0.5;\n    font-style: italic;\n    white-space: pre;\n}'}),ace.define("ace/layer/decorators",["require","exports","module","ace/lib/dom","ace/lib/oop","ace/lib/event_emitter"],function(e,t,n){"use strict";var r=e("../lib/dom"),i=e("../lib/oop"),s=e("../lib/event_emitter").EventEmitter,o=function(){function e(e,t){this.canvas=r.createElement("canvas"),this.renderer=t,this.pixelRatio=1,this.maxHeight=t.layerConfig.maxHeight,this.lineHeight=t.layerConfig.lineHeight,this.canvasHeight=e.parent.scrollHeight,this.heightRatio=this.canvasHeight/this.maxHeight,this.canvasWidth=e.width,this.minDecorationHeight=2*this.pixelRatio|0,this.halfMinDecorationHeight=this.minDecorationHeight/2|0,this.canvas.width=this.canvasWidth,this.canvas.height=this.canvasHeight,this.canvas.style.top="0px",this.canvas.style.right="0px",this.canvas.style.zIndex="7px",this.canvas.style.position="absolute",this.colors={},this.colors.dark={error:"rgba(255, 18, 18, 1)",warning:"rgba(18, 136, 18, 1)",info:"rgba(18, 18, 136, 1)"},this.colors.light={error:"rgb(255,51,51)",warning:"rgb(32,133,72)",info:"rgb(35,68,138)"},e.element.appendChild(this.canvas)}return e.prototype.$updateDecorators=function(e){function i(e,t){return e.priority<t.priority?-1:e.priority>t.priority?1:0}var t=this.renderer.theme.isDark===!0?this.colors.dark:this.colors.light;if(e){this.maxHeight=e.maxHeight,this.lineHeight=e.lineHeight,this.canvasHeight=e.height;var n=(e.lastRow+1)*this.lineHeight;n<this.canvasHeight?this.heightRatio=1:this.heightRatio=this.canvasHeight/this.maxHeight}var r=this.canvas.getContext("2d"),s=this.renderer.session.$annotations;r.clearRect(0,0,this.canvas.width,this.canvas.height);if(s){var o={info:1,warning:2,error:3};s.forEach(function(e){e.priority=o[e.type]||null}),s=s.sort(i);var u=this.renderer.session.$foldData;for(var a=0;a<s.length;a++){var f=s[a].row,l=this.compensateFoldRows(f,u),c=Math.round((f-l)*this.lineHeight*this.heightRatio),h=Math.round((f-l)*this.lineHeight*this.heightRatio),p=Math.round(((f-l)*this.lineHeight+this.lineHeight)*this.heightRatio),d=p-h;if(d<this.minDecorationHeight){var v=(h+p)/2|0;v<this.halfMinDecorationHeight?v=this.halfMinDecorationHeight:v+this.halfMinDecorationHeight>this.canvasHeight&&(v=this.canvasHeight-this.halfMinDecorationHeight),h=Math.round(v-this.halfMinDecorationHeight),p=Math.round(v+this.halfMinDecorationHeight)}r.fillStyle=t[s[a].type]||null,r.fillRect(0,c,this.canvasWidth,p-h)}}var m=this.renderer.session.selection.getCursor();if(m){var l=this.compensateFoldRows(m.row,u),c=Math.round((m.row-l)*this.lineHeight*this.heightRatio);r.fillStyle="rgba(0, 0, 0, 0.5)",r.fillRect(0,c,this.canvasWidth,2)}},e.prototype.compensateFoldRows=function(e,t){var n=0;if(t&&t.length>0)for(var r=0;r<t.length;r++)e>t[r].start.row&&e<t[r].end.row?n+=e-t[r].start.row:e>=t[r].end.row&&(n+=t[r].end.row-t[r].start.row);return n},e}();i.implement(o.prototype,s),t.Decorator=o}),ace.define("ace/virtual_renderer",["require","exports","module","ace/lib/oop","ace/lib/dom","ace/lib/lang","ace/config","ace/layer/gutter","ace/layer/marker","ace/layer/text","ace/layer/cursor","ace/scrollbar","ace/scrollbar","ace/scrollbar_custom","ace/scrollbar_custom","ace/renderloop","ace/layer/font_metrics","ace/lib/event_emitter","ace/css/editor.css","ace/layer/decorators","ace/lib/useragent"],function(e,t,n){"use strict";var r=e("./lib/oop"),i=e("./lib/dom"),s=e("./lib/lang"),o=e("./config"),u=e("./layer/gutter").Gutter,a=e("./layer/marker").Marker,f=e("./layer/text").Text,l=e("./layer/cursor").Cursor,c=e("./scrollbar").HScrollBar,h=e("./scrollbar").VScrollBar,p=e("./scrollbar_custom").HScrollBar,d=e("./scrollbar_custom").VScrollBar,v=e("./renderloop").RenderLoop,m=e("./layer/font_metrics").FontMetrics,g=e("./lib/event_emitter").EventEmitter,y=e("./css/editor.css"),b=e("./layer/decorators").Decorator,w=e("./lib/useragent");i.importCssString(y,"ace_editor.css",!1);var E=function(){function e(e,t){var n=this;this.container=e||i.createElement("div"),i.addCssClass(this.container,"ace_editor"),i.HI_DPI&&i.addCssClass(this.container,"ace_hidpi"),this.setTheme(t),o.get("useStrictCSP")==null&&o.set("useStrictCSP",!1),this.$gutter=i.createElement("div"),this.$gutter.className="ace_gutter",this.container.appendChild(this.$gutter),this.$gutter.setAttribute("aria-hidden",!0),this.scroller=i.createElement("div"),this.scroller.className="ace_scroller",this.container.appendChild(this.scroller),this.content=i.createElement("div"),this.content.className="ace_content",this.scroller.appendChild(this.content),this.$gutterLayer=new u(this.$gutter),this.$gutterLayer.on("changeGutterWidth",this.onGutterResize.bind(this)),this.$markerBack=new a(this.content);var r=this.$textLayer=new f(this.content);this.canvas=r.element,this.$markerFront=new a(this.content),this.$cursorLayer=new l(this.content),this.$horizScroll=!1,this.$vScroll=!1,this.scrollBar=this.scrollBarV=new h(this.container,this),this.scrollBarH=new c(this.container,this),this.scrollBarV.on("scroll",function(e){n.$scrollAnimation||n.session.setScrollTop(e.data-n.scrollMargin.top)}),this.scrollBarH.on("scroll",function(e){n.$scrollAnimation||n.session.setScrollLeft(e.data-n.scrollMargin.left)}),this.scrollTop=0,this.scrollLeft=0,this.cursorPos={row:0,column:0},this.$fontMetrics=new m(this.container),this.$textLayer.$setFontMetrics(this.$fontMetrics),this.$textLayer.on("changeCharacterSize",function(e){n.updateCharacterSize(),n.onResize(!0,n.gutterWidth,n.$size.width,n.$size.height),n._signal("changeCharacterSize",e)}),this.$size={width:0,height:0,scrollerHeight:0,scrollerWidth:0,$dirty:!0},this.layerConfig={width:1,padding:0,firstRow:0,firstRowScreen:0,lastRow:0,lineHeight:0,characterWidth:0,minHeight:1,maxHeight:1,offset:0,height:1,gutterOffset:1},this.scrollMargin={left:0,right:0,top:0,bottom:0,v:0,h:0},this.margin={left:0,right:0,top:0,bottom:0,v:0,h:0},this.$keepTextAreaAtCursor=!w.isIOS,this.$loop=new v(this.$renderChanges.bind(this),this.container.ownerDocument.defaultView),this.$loop.schedule(this.CHANGE_FULL),this.updateCharacterSize(),this.setPadding(4),this.$addResizeObserver(),o.resetOptions(this),o._signal("renderer",this)}return e.prototype.updateCharacterSize=function(){this.$textLayer.allowBoldFonts!=this.$allowBoldFonts&&(this.$allowBoldFonts=this.$textLayer.allowBoldFonts,this.setStyle("ace_nobold",!this.$allowBoldFonts)),this.layerConfig.characterWidth=this.characterWidth=this.$textLayer.getCharacterWidth(),this.layerConfig.lineHeight=this.lineHeight=this.$textLayer.getLineHeight(),this.$updatePrintMargin(),i.setStyle(this.scroller.style,"line-height",this.lineHeight+"px")},e.prototype.setSession=function(e){this.session&&this.session.doc.off("changeNewLineMode",this.onChangeNewLineMode),this.session=e,e&&this.scrollMargin.top&&e.getScrollTop()<=0&&e.setScrollTop(-this.scrollMargin.top),this.$cursorLayer.setSession(e),this.$markerBack.setSession(e),this.$markerFront.setSession(e),this.$gutterLayer.setSession(e),this.$textLayer.setSession(e);if(!e)return;this.$loop.schedule(this.CHANGE_FULL),this.session.$setFontMetrics(this.$fontMetrics),this.scrollBarH.scrollLeft=this.scrollBarV.scrollTop=null,this.onChangeNewLineMode=this.onChangeNewLineMode.bind(this),this.onChangeNewLineMode(),this.session.doc.on("changeNewLineMode",this.onChangeNewLineMode)},e.prototype.updateLines=function(e,t,n){t===undefined&&(t=Infinity),this.$changedLines?(this.$changedLines.firstRow>e&&(this.$changedLines.firstRow=e),this.$changedLines.lastRow<t&&(this.$changedLines.lastRow=t)):this.$changedLines={firstRow:e,lastRow:t};if(this.$changedLines.lastRow<this.layerConfig.firstRow){if(!n)return;this.$changedLines.lastRow=this.layerConfig.lastRow}if(this.$changedLines.firstRow>this.layerConfig.lastRow)return;this.$loop.schedule(this.CHANGE_LINES)},e.prototype.onChangeNewLineMode=function(){this.$loop.schedule(this.CHANGE_TEXT),this.$textLayer.$updateEolChar(),this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR)},e.prototype.onChangeTabSize=function(){this.$loop.schedule(this.CHANGE_TEXT|this.CHANGE_MARKER),this.$textLayer.onChangeTabSize()},e.prototype.updateText=function(){this.$loop.schedule(this.CHANGE_TEXT)},e.prototype.updateFull=function(e){e?this.$renderChanges(this.CHANGE_FULL,!0):this.$loop.schedule(this.CHANGE_FULL)},e.prototype.updateFontSize=function(){this.$textLayer.checkForSizeChanges()},e.prototype.$updateSizeAsync=function(){this.$loop.pending?this.$size.$dirty=!0:this.onResize()},e.prototype.onResize=function(e,t,n,r){if(this.resizing>2)return;this.resizing>0?this.resizing++:this.resizing=e?1:0;var i=this.container;r||(r=i.clientHeight||i.scrollHeight),n||(n=i.clientWidth||i.scrollWidth);var s=this.$updateCachedSize(e,t,n,r);this.$resizeTimer&&this.$resizeTimer.cancel();if(!this.$size.scrollerHeight||!n&&!r)return this.resizing=0;e&&(this.$gutterLayer.$padding=null),e?this.$renderChanges(s|this.$changes,!0):this.$loop.schedule(s|this.$changes),this.resizing&&(this.resizing=0),this.scrollBarH.scrollLeft=this.scrollBarV.scrollTop=null,this.$customScrollbar&&this.$updateCustomScrollbar(!0)},e.prototype.$updateCachedSize=function(e,t,n,r){r-=this.$extraHeight||0;var s=0,o=this.$size,u={width:o.width,height:o.height,scrollerHeight:o.scrollerHeight,scrollerWidth:o.scrollerWidth};r&&(e||o.height!=r)&&(o.height=r,s|=this.CHANGE_SIZE,o.scrollerHeight=o.height,this.$horizScroll&&(o.scrollerHeight-=this.scrollBarH.getHeight()),this.scrollBarV.setHeight(o.scrollerHeight),this.scrollBarV.element.style.bottom=this.scrollBarH.getHeight()+"px",s|=this.CHANGE_SCROLL);if(n&&(e||o.width!=n)){s|=this.CHANGE_SIZE,o.width=n,t==null&&(t=this.$showGutter?this.$gutter.offsetWidth:0),this.gutterWidth=t,i.setStyle(this.scrollBarH.element.style,"left",t+"px"),i.setStyle(this.scroller.style,"left",t+this.margin.left+"px"),o.scrollerWidth=Math.max(0,n-t-this.scrollBarV.getWidth()-this.margin.h),i.setStyle(this.$gutter.style,"left",this.margin.left+"px");var a=this.scrollBarV.getWidth()+"px";i.setStyle(this.scrollBarH.element.style,"right",a),i.setStyle(this.scroller.style,"right",a),i.setStyle(this.scroller.style,"bottom",this.scrollBarH.getHeight()),this.scrollBarH.setWidth(o.scrollerWidth);if(this.session&&this.session.getUseWrapMode()&&this.adjustWrapLimit()||e)s|=this.CHANGE_FULL}return o.$dirty=!n||!r,s&&this._signal("resize",u),s},e.prototype.onGutterResize=function(e){var t=this.$showGutter?e:0;t!=this.gutterWidth&&(this.$changes|=this.$updateCachedSize(!0,t,this.$size.width,this.$size.height)),this.session.getUseWrapMode()&&this.adjustWrapLimit()?this.$loop.schedule(this.CHANGE_FULL):this.$size.$dirty?this.$loop.schedule(this.CHANGE_FULL):this.$computeLayerConfig()},e.prototype.adjustWrapLimit=function(){var e=this.$size.scrollerWidth-this.$padding*2,t=Math.floor(e/this.characterWidth);return this.session.adjustWrapLimit(t,this.$showPrintMargin&&this.$printMarginColumn)},e.prototype.setAnimatedScroll=function(e){this.setOption("animatedScroll",e)},e.prototype.getAnimatedScroll=function(){return this.$animatedScroll},e.prototype.setShowInvisibles=function(e){this.setOption("showInvisibles",e),this.session.$bidiHandler.setShowInvisibles(e)},e.prototype.getShowInvisibles=function(){return this.getOption("showInvisibles")},e.prototype.getDisplayIndentGuide=function(){return this.getOption("displayIndentGuides")},e.prototype.setDisplayIndentGuides=function(e){this.setOption("displayIndentGuides",e)},e.prototype.getHighlightIndentGuides=function(){return this.getOption("highlightIndentGuides")},e.prototype.setHighlightIndentGuides=function(e){this.setOption("highlightIndentGuides",e)},e.prototype.setShowPrintMargin=function(e){this.setOption("showPrintMargin",e)},e.prototype.getShowPrintMargin=function(){return this.getOption("showPrintMargin")},e.prototype.setPrintMarginColumn=function(e){this.setOption("printMarginColumn",e)},e.prototype.getPrintMarginColumn=function(){return this.getOption("printMarginColumn")},e.prototype.getShowGutter=function(){return this.getOption("showGutter")},e.prototype.setShowGutter=function(e){return this.setOption("showGutter",e)},e.prototype.getFadeFoldWidgets=function(){return this.getOption("fadeFoldWidgets")},e.prototype.setFadeFoldWidgets=function(e){this.setOption("fadeFoldWidgets",e)},e.prototype.setHighlightGutterLine=function(e){this.setOption("highlightGutterLine",e)},e.prototype.getHighlightGutterLine=function(){return this.getOption("highlightGutterLine")},e.prototype.$updatePrintMargin=function(){if(!this.$showPrintMargin&&!this.$printMarginEl)return;if(!this.$printMarginEl){var e=i.createElement("div");e.className="ace_layer ace_print-margin-layer",this.$printMarginEl=i.createElement("div"),this.$printMarginEl.className="ace_print-margin",e.appendChild(this.$printMarginEl),this.content.insertBefore(e,this.content.firstChild)}var t=this.$printMarginEl.style;t.left=Math.round(this.characterWidth*this.$printMarginColumn+this.$padding)+"px",t.visibility=this.$showPrintMargin?"visible":"hidden",this.session&&this.session.$wrap==-1&&this.adjustWrapLimit()},e.prototype.getContainerElement=function(){return this.container},e.prototype.getMouseEventTarget=function(){return this.scroller},e.prototype.getTextAreaContainer=function(){return this.container},e.prototype.$moveTextAreaToCursor=function(){if(this.$isMousePressed)return;var e=this.textarea.style,t=this.$composition;if(!this.$keepTextAreaAtCursor&&!t){i.translate(this.textarea,-100,0);return}var n=this.$cursorLayer.$pixelPos;if(!n)return;t&&t.markerRange&&(n=this.$cursorLayer.getPixelPosition(t.markerRange.start,!0));var r=this.layerConfig,s=n.top,o=n.left;s-=r.offset;var u=t&&t.useTextareaForIME||w.isMobile?this.lineHeight:1;if(s<0||s>r.height-u){i.translate(this.textarea,0,0);return}var a=1,f=this.$size.height-u;if(!t)s+=this.lineHeight;else if(t.useTextareaForIME){var l=this.textarea.value;a=this.characterWidth*this.session.$getStringScreenWidth(l)[0]}else s+=this.lineHeight+2;o-=this.scrollLeft,o>this.$size.scrollerWidth-a&&(o=this.$size.scrollerWidth-a),o+=this.gutterWidth+this.margin.left,i.setStyle(e,"height",u+"px"),i.setStyle(e,"width",a+"px"),i.translate(this.textarea,Math.min(o,this.$size.scrollerWidth-a),Math.min(s,f))},e.prototype.getFirstVisibleRow=function(){return this.layerConfig.firstRow},e.prototype.getFirstFullyVisibleRow=function(){return this.layerConfig.firstRow+(this.layerConfig.offset===0?0:1)},e.prototype.getLastFullyVisibleRow=function(){var e=this.layerConfig,t=e.lastRow,n=this.session.documentToScreenRow(t,0)*e.lineHeight;return n-this.session.getScrollTop()>e.height-e.lineHeight?t-1:t},e.prototype.getLastVisibleRow=function(){return this.layerConfig.lastRow},e.prototype.setPadding=function(e){this.$padding=e,this.$textLayer.setPadding(e),this.$cursorLayer.setPadding(e),this.$markerFront.setPadding(e),this.$markerBack.setPadding(e),this.$loop.schedule(this.CHANGE_FULL),this.$updatePrintMargin()},e.prototype.setScrollMargin=function(e,t,n,r){var i=this.scrollMargin;i.top=e|0,i.bottom=t|0,i.right=r|0,i.left=n|0,i.v=i.top+i.bottom,i.h=i.left+i.right,i.top&&this.scrollTop<=0&&this.session&&this.session.setScrollTop(-i.top),this.updateFull()},e.prototype.setMargin=function(e,t,n,r){var i=this.margin;i.top=e|0,i.bottom=t|0,i.right=r|0,i.left=n|0,i.v=i.top+i.bottom,i.h=i.left+i.right,this.$updateCachedSize(!0,this.gutterWidth,this.$size.width,this.$size.height),this.updateFull()},e.prototype.getHScrollBarAlwaysVisible=function(){return this.$hScrollBarAlwaysVisible},e.prototype.setHScrollBarAlwaysVisible=function(e){this.setOption("hScrollBarAlwaysVisible",e)},e.prototype.getVScrollBarAlwaysVisible=function(){return this.$vScrollBarAlwaysVisible},e.prototype.setVScrollBarAlwaysVisible=function(e){this.setOption("vScrollBarAlwaysVisible",e)},e.prototype.$updateScrollBarV=function(){var e=this.layerConfig.maxHeight,t=this.$size.scrollerHeight;!this.$maxLines&&this.$scrollPastEnd&&(e-=(t-this.lineHeight)*this.$scrollPastEnd,this.scrollTop>e-t&&(e=this.scrollTop+t,this.scrollBarV.scrollTop=null)),this.scrollBarV.setScrollHeight(e+this.scrollMargin.v),this.scrollBarV.setScrollTop(this.scrollTop+this.scrollMargin.top)},e.prototype.$updateScrollBarH=function(){this.scrollBarH.setScrollWidth(this.layerConfig.width+2*this.$padding+this.scrollMargin.h),this.scrollBarH.setScrollLeft(this.scrollLeft+this.scrollMargin.left)},e.prototype.freeze=function(){this.$frozen=!0},e.prototype.unfreeze=function(){this.$frozen=!1},e.prototype.$renderChanges=function(e,t){this.$changes&&(e|=this.$changes,this.$changes=0);if(!this.session||!this.container.offsetWidth||this.$frozen||!e&&!t){this.$changes|=e;return}if(this.$size.$dirty)return this.$changes|=e,this.onResize(!0);this.lineHeight||this.$textLayer.checkForSizeChanges(),this._signal("beforeRender",e),this.session&&this.session.$bidiHandler&&this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);var n=this.layerConfig;if(e&this.CHANGE_FULL||e&this.CHANGE_SIZE||e&this.CHANGE_TEXT||e&this.CHANGE_LINES||e&this.CHANGE_SCROLL||e&this.CHANGE_H_SCROLL){e|=this.$computeLayerConfig()|this.$loop.clear();if(n.firstRow!=this.layerConfig.firstRow&&n.firstRowScreen==this.layerConfig.firstRowScreen){var r=this.scrollTop+(n.firstRow-Math.max(this.layerConfig.firstRow,0))*this.lineHeight;r>0&&(this.scrollTop=r,e|=this.CHANGE_SCROLL,e|=this.$computeLayerConfig()|this.$loop.clear())}n=this.layerConfig,this.$updateScrollBarV(),e&this.CHANGE_H_SCROLL&&this.$updateScrollBarH(),i.translate(this.content,-this.scrollLeft,-n.offset);var s=n.width+2*this.$padding+"px",o=n.minHeight+"px";i.setStyle(this.content.style,"width",s),i.setStyle(this.content.style,"height",o)}e&this.CHANGE_H_SCROLL&&(i.translate(this.content,-this.scrollLeft,-n.offset),this.scroller.className=this.scrollLeft<=0?"ace_scroller":"ace_scroller ace_scroll-left");if(e&this.CHANGE_FULL){this.$changedLines=null,this.$textLayer.update(n),this.$showGutter&&this.$gutterLayer.update(n),this.$customScrollbar&&this.$scrollDecorator.$updateDecorators(n),this.$markerBack.update(n),this.$markerFront.update(n),this.$cursorLayer.update(n),this.$moveTextAreaToCursor(),this._signal("afterRender",e);return}if(e&this.CHANGE_SCROLL){this.$changedLines=null,e&this.CHANGE_TEXT||e&this.CHANGE_LINES?this.$textLayer.update(n):this.$textLayer.scrollLines(n),this.$showGutter&&(e&this.CHANGE_GUTTER||e&this.CHANGE_LINES?this.$gutterLayer.update(n):this.$gutterLayer.scrollLines(n)),this.$customScrollbar&&this.$scrollDecorator.$updateDecorators(n),this.$markerBack.update(n),this.$markerFront.update(n),this.$cursorLayer.update(n),this.$moveTextAreaToCursor(),this._signal("afterRender",e);return}e&this.CHANGE_TEXT?(this.$changedLines=null,this.$textLayer.update(n),this.$showGutter&&this.$gutterLayer.update(n),this.$customScrollbar&&this.$scrollDecorator.$updateDecorators(n)):e&this.CHANGE_LINES?((this.$updateLines()||e&this.CHANGE_GUTTER&&this.$showGutter)&&this.$gutterLayer.update(n),this.$customScrollbar&&this.$scrollDecorator.$updateDecorators(n)):e&this.CHANGE_TEXT||e&this.CHANGE_GUTTER?(this.$showGutter&&this.$gutterLayer.update(n),this.$customScrollbar&&this.$scrollDecorator.$updateDecorators(n)):e&this.CHANGE_CURSOR&&(this.$highlightGutterLine&&this.$gutterLayer.updateLineHighlight(n),this.$customScrollbar&&this.$scrollDecorator.$updateDecorators(n)),e&this.CHANGE_CURSOR&&(this.$cursorLayer.update(n),this.$moveTextAreaToCursor()),e&(this.CHANGE_MARKER|this.CHANGE_MARKER_FRONT)&&this.$markerFront.update(n),e&(this.CHANGE_MARKER|this.CHANGE_MARKER_BACK)&&this.$markerBack.update(n),this._signal("afterRender",e)},e.prototype.$autosize=function(){var e=this.session.getScreenLength()*this.lineHeight,t=this.$maxLines*this.lineHeight,n=Math.min(t,Math.max((this.$minLines||1)*this.lineHeight,e))+this.scrollMargin.v+(this.$extraHeight||0);this.$horizScroll&&(n+=this.scrollBarH.getHeight()),this.$maxPixelHeight&&n>this.$maxPixelHeight&&(n=this.$maxPixelHeight);var r=n<=2*this.lineHeight,i=!r&&e>t;if(n!=this.desiredHeight||this.$size.height!=this.desiredHeight||i!=this.$vScroll){i!=this.$vScroll&&(this.$vScroll=i,this.scrollBarV.setVisible(i));var s=this.container.clientWidth;this.container.style.height=n+"px",this.$updateCachedSize(!0,this.$gutterWidth,s,n),this.desiredHeight=n,this._signal("autosize")}},e.prototype.$computeLayerConfig=function(){var e=this.session,t=this.$size,n=t.height<=2*this.lineHeight,r=this.session.getScreenLength(),i=r*this.lineHeight,s=this.$getLongestLine(),o=!n&&(this.$hScrollBarAlwaysVisible||t.scrollerWidth-s-2*this.$padding<0),u=this.$horizScroll!==o;u&&(this.$horizScroll=o,this.scrollBarH.setVisible(o));var a=this.$vScroll;this.$maxLines&&this.lineHeight>1&&this.$autosize();var f=t.scrollerHeight+this.lineHeight,l=!this.$maxLines&&this.$scrollPastEnd?(t.scrollerHeight-this.lineHeight)*this.$scrollPastEnd:0;i+=l;var c=this.scrollMargin;this.session.setScrollTop(Math.max(-c.top,Math.min(this.scrollTop,i-t.scrollerHeight+c.bottom))),this.session.setScrollLeft(Math.max(-c.left,Math.min(this.scrollLeft,s+2*this.$padding-t.scrollerWidth+c.right)));var h=!n&&(this.$vScrollBarAlwaysVisible||t.scrollerHeight-i+l<0||this.scrollTop>c.top),p=a!==h;p&&(this.$vScroll=h,this.scrollBarV.setVisible(h));var d=this.scrollTop%this.lineHeight,v=Math.ceil(f/this.lineHeight)-1,m=Math.max(0,Math.round((this.scrollTop-d)/this.lineHeight)),g=m+v,y,b,w=this.lineHeight;m=e.screenToDocumentRow(m,0);var E=e.getFoldLine(m);E&&(m=E.start.row),y=e.documentToScreenRow(m,0),b=e.getRowLength(m)*w,g=Math.min(e.screenToDocumentRow(g,0),e.getLength()-1),f=t.scrollerHeight+e.getRowLength(g)*w+b,d=this.scrollTop-y*w;var S=0;if(this.layerConfig.width!=s||u)S=this.CHANGE_H_SCROLL;if(u||p)S|=this.$updateCachedSize(!0,this.gutterWidth,t.width,t.height),this._signal("scrollbarVisibilityChanged"),p&&(s=this.$getLongestLine());return this.layerConfig={width:s,padding:this.$padding,firstRow:m,firstRowScreen:y,lastRow:g,lineHeight:w,characterWidth:this.characterWidth,minHeight:f,maxHeight:i,offset:d,gutterOffset:w?Math.max(0,Math.ceil((d+t.height-t.scrollerHeight)/w)):0,height:this.$size.scrollerHeight},this.session.$bidiHandler&&this.session.$bidiHandler.setContentWidth(s-this.$padding),S},e.prototype.$updateLines=function(){if(!this.$changedLines)return;var e=this.$changedLines.firstRow,t=this.$changedLines.lastRow;this.$changedLines=null;var n=this.layerConfig;if(e>n.lastRow+1)return;if(t<n.firstRow)return;if(t===Infinity){this.$showGutter&&this.$gutterLayer.update(n),this.$textLayer.update(n);return}return this.$textLayer.updateLines(n,e,t),!0},e.prototype.$getLongestLine=function(){var e=this.session.getScreenWidth();return this.showInvisibles&&!this.session.$useWrapMode&&(e+=1),this.$textLayer&&e>this.$textLayer.MAX_LINE_LENGTH&&(e=this.$textLayer.MAX_LINE_LENGTH+30),Math.max(this.$size.scrollerWidth-2*this.$padding,Math.round(e*this.characterWidth))},e.prototype.updateFrontMarkers=function(){this.$markerFront.setMarkers(this.session.getMarkers(!0)),this.$loop.schedule(this.CHANGE_MARKER_FRONT)},e.prototype.updateBackMarkers=function(){this.$markerBack.setMarkers(this.session.getMarkers()),this.$loop.schedule(this.CHANGE_MARKER_BACK)},e.prototype.addGutterDecoration=function(e,t){this.$gutterLayer.addGutterDecoration(e,t)},e.prototype.removeGutterDecoration=function(e,t){this.$gutterLayer.removeGutterDecoration(e,t)},e.prototype.updateBreakpoints=function(e){this.$loop.schedule(this.CHANGE_GUTTER)},e.prototype.setAnnotations=function(e){this.$gutterLayer.setAnnotations(e),this.$loop.schedule(this.CHANGE_GUTTER)},e.prototype.updateCursor=function(){this.$loop.schedule(this.CHANGE_CURSOR)},e.prototype.hideCursor=function(){this.$cursorLayer.hideCursor()},e.prototype.showCursor=function(){this.$cursorLayer.showCursor()},e.prototype.scrollSelectionIntoView=function(e,t,n){this.scrollCursorIntoView(e,n),this.scrollCursorIntoView(t,n)},e.prototype.scrollCursorIntoView=function(e,t,n){if(this.$size.scrollerHeight===0)return;var r=this.$cursorLayer.getPixelPosition(e),i=r.left,s=r.top,o=n&&n.top||0,u=n&&n.bottom||0;this.$scrollAnimation&&(this.$stopAnimation=!0);var a=this.$scrollAnimation?this.session.getScrollTop():this.scrollTop;a+o>s?(t&&a+o>s+this.lineHeight&&(s-=t*this.$size.scrollerHeight),s===0&&(s=-this.scrollMargin.top),this.session.setScrollTop(s)):a+this.$size.scrollerHeight-u<s+this.lineHeight&&(t&&a+this.$size.scrollerHeight-u<s-this.lineHeight&&(s+=t*this.$size.scrollerHeight),this.session.setScrollTop(s+this.lineHeight+u-this.$size.scrollerHeight));var f=this.scrollLeft,l=2*this.layerConfig.characterWidth;i-l<f?(i-=l,i<this.$padding+l&&(i=-this.scrollMargin.left),this.session.setScrollLeft(i)):(i+=l,f+this.$size.scrollerWidth<i+this.characterWidth?this.session.setScrollLeft(Math.round(i+this.characterWidth-this.$size.scrollerWidth)):f<=this.$padding&&i-f<this.characterWidth&&this.session.setScrollLeft(0))},e.prototype.getScrollTop=function(){return this.session.getScrollTop()},e.prototype.getScrollLeft=function(){return this.session.getScrollLeft()},e.prototype.getScrollTopRow=function(){return this.scrollTop/this.lineHeight},e.prototype.getScrollBottomRow=function(){return Math.max(0,Math.floor((this.scrollTop+this.$size.scrollerHeight)/this.lineHeight)-1)},e.prototype.scrollToRow=function(e){this.session.setScrollTop(e*this.lineHeight)},e.prototype.alignCursor=function(e,t){typeof e=="number"&&(e={row:e,column:0});var n=this.$cursorLayer.getPixelPosition(e),r=this.$size.scrollerHeight-this.lineHeight,i=n.top-r*(t||0);return this.session.setScrollTop(i),i},e.prototype.$calcSteps=function(e,t){var n=0,r=this.STEPS,i=[],s=function(e,t,n){return n*(Math.pow(e-1,3)+1)+t};for(n=0;n<r;++n)i.push(s(n/this.STEPS,e,t-e));return i},e.prototype.scrollToLine=function(e,t,n,r){var i=this.$cursorLayer.getPixelPosition({row:e,column:0}),s=i.top;t&&(s-=this.$size.scrollerHeight/2);var o=this.scrollTop;this.session.setScrollTop(s),n!==!1&&this.animateScrolling(o,r)},e.prototype.animateScrolling=function(e,t){function o(){r.$timer=clearInterval(r.$timer),r.$scrollAnimation=null,r.$stopAnimation=!1,t&&t()}var n=this.scrollTop;if(!this.$animatedScroll)return;var r=this;if(e==n)return;if(this.$scrollAnimation){var i=this.$scrollAnimation.steps;if(i.length){e=i[0];if(e==n)return}}var s=r.$calcSteps(e,n);this.$scrollAnimation={from:e,to:n,steps:s},clearInterval(this.$timer),r.session.setScrollTop(s.shift()),r.session.$scrollTop=n,this.$timer=setInterval(function(){if(r.$stopAnimation){o();return}if(!r.session)return clearInterval(r.$timer);s.length?(r.session.setScrollTop(s.shift()),r.session.$scrollTop=n):n!=null?(r.session.$scrollTop=-1,r.session.setScrollTop(n),n=null):o()},10)},e.prototype.scrollToY=function(e){this.scrollTop!==e&&(this.$loop.schedule(this.CHANGE_SCROLL),this.scrollTop=e)},e.prototype.scrollToX=function(e){this.scrollLeft!==e&&(this.scrollLeft=e),this.$loop.schedule(this.CHANGE_H_SCROLL)},e.prototype.scrollTo=function(e,t){this.session.setScrollTop(t),this.session.setScrollLeft(e)},e.prototype.scrollBy=function(e,t){t&&this.session.setScrollTop(this.session.getScrollTop()+t),e&&this.session.setScrollLeft(this.session.getScrollLeft()+e)},e.prototype.isScrollableBy=function(e,t){if(t<0&&this.session.getScrollTop()>=1-this.scrollMargin.top)return!0;if(t>0&&this.session.getScrollTop()+this.$size.scrollerHeight-this.layerConfig.maxHeight<-1+this.scrollMargin.bottom)return!0;if(e<0&&this.session.getScrollLeft()>=1-this.scrollMargin.left)return!0;if(e>0&&this.session.getScrollLeft()+this.$size.scrollerWidth-this.layerConfig.width<-1+this.scrollMargin.right)return!0},e.prototype.pixelToScreenCoordinates=function(e,t){var n;if(this.$hasCssTransforms){n={top:0,left:0};var r=this.$fontMetrics.transformCoordinates([e,t]);e=r[1]-this.gutterWidth-this.margin.left,t=r[0]}else n=this.scroller.getBoundingClientRect();var i=e+this.scrollLeft-n.left-this.$padding,s=i/this.characterWidth,o=Math.floor((t+this.scrollTop-n.top)/this.lineHeight),u=this.$blockCursor?Math.floor(s):Math.round(s);return{row:o,column:u,side:s-u>0?1:-1,offsetX:i}},e.prototype.screenToTextCoordinates=function(e,t){var n;if(this.$hasCssTransforms){n={top:0,left:0};var r=this.$fontMetrics.transformCoordinates([e,t]);e=r[1]-this.gutterWidth-this.margin.left,t=r[0]}else n=this.scroller.getBoundingClientRect();var i=e+this.scrollLeft-n.left-this.$padding,s=i/this.characterWidth,o=this.$blockCursor?Math.floor(s):Math.round(s),u=Math.floor((t+this.scrollTop-n.top)/this.lineHeight);return this.session.screenToDocumentPosition(u,Math.max(o,0),i)},e.prototype.textToScreenCoordinates=function(e,t){var n=this.scroller.getBoundingClientRect(),r=this.session.documentToScreenPosition(e,t),i=this.$padding+(this.session.$bidiHandler.isBidiRow(r.row,e)?this.session.$bidiHandler.getPosLeft(r.column):Math.round(r.column*this.characterWidth)),s=r.row*this.lineHeight;return{pageX:n.left+i-this.scrollLeft,pageY:n.top+s-this.scrollTop}},e.prototype.visualizeFocus=function(){i.addCssClass(this.container,"ace_focus")},e.prototype.visualizeBlur=function(){i.removeCssClass(this.container,"ace_focus")},e.prototype.showComposition=function(e){this.$composition=e,e.cssText||(e.cssText=this.textarea.style.cssText),e.useTextareaForIME==undefined&&(e.useTextareaForIME=this.$useTextareaForIME),this.$useTextareaForIME?(i.addCssClass(this.textarea,"ace_composition"),this.textarea.style.cssText="",this.$moveTextAreaToCursor(),this.$cursorLayer.element.style.display="none"):e.markerId=this.session.addMarker(e.markerRange,"ace_composition_marker","text")},e.prototype.setCompositionText=function(e){var t=this.session.selection.cursor;this.addToken(e,"composition_placeholder",t.row,t.column),this.$moveTextAreaToCursor()},e.prototype.hideComposition=function(){if(!this.$composition)return;this.$composition.markerId&&this.session.removeMarker(this.$composition.markerId),i.removeCssClass(this.textarea,"ace_composition"),this.textarea.style.cssText=this.$composition.cssText;var e=this.session.selection.cursor;this.removeExtraToken(e.row,e.column),this.$composition=null,this.$cursorLayer.element.style.display=""},e.prototype.setGhostText=function(e,t){var n=this.session.selection.cursor,r=t||{row:n.row,column:n.column};this.removeGhostText();var i=e.split("\n");this.addToken(i[0],"ghost_text",r.row,r.column),this.$ghostText={text:e,position:{row:r.row,column:r.column}},i.length>1&&(this.$ghostTextWidget={text:i.slice(1).join("\n"),row:r.row,column:r.column,className:"ace_ghost_text"},this.session.widgetManager.addLineWidget(this.$ghostTextWidget))},e.prototype.removeGhostText=function(){if(!this.$ghostText)return;var e=this.$ghostText.position;this.removeExtraToken(e.row,e.column),this.$ghostTextWidget&&(this.session.widgetManager.removeLineWidget(this.$ghostTextWidget),this.$ghostTextWidget=null),this.$ghostText=null},e.prototype.addToken=function(e,t,n,r){var i=this.session;i.bgTokenizer.lines[n]=null;var s={type:t,value:e},o=i.getTokens(n);if(r==null||!o.length)o.push(s);else{var u=0;for(var a=0;a<o.length;a++){var f=o[a];u+=f.value.length;if(r<=u){var l=f.value.length-(u-r),c=f.value.slice(0,l),h=f.value.slice(l);o.splice(a,1,{type:f.type,value:c},s,{type:f.type,value:h});break}}}this.updateLines(n,n)},e.prototype.removeExtraToken=function(e,t){this.session.bgTokenizer.lines[e]=null,this.updateLines(e,e)},e.prototype.setTheme=function(e,t){function s(r){if(n.$themeId!=e)return t&&t();if(!r||!r.cssClass)throw new Error("couldn't load module "+e+" or it didn't call define");r.$id&&(n.$themeId=r.$id),i.importCssString(r.cssText,r.cssClass,n.container),n.theme&&i.removeCssClass(n.container,n.theme.cssClass);var s="padding"in r?r.padding:"padding"in(n.theme||{})?4:n.$padding;n.$padding&&s!=n.$padding&&n.setPadding(s),n.$theme=r.cssClass,n.theme=r,i.addCssClass(n.container,r.cssClass),i.setCssClass(n.container,"ace_dark",r.isDark),n.$size&&(n.$size.width=0,n.$updateSizeAsync()),n._dispatchEvent("themeLoaded",{theme:r}),t&&t()}var n=this;this.$themeId=e,n._dispatchEvent("themeChange",{theme:e});if(!e||typeof e=="string"){var r=e||this.$options.theme.initialValue;o.loadModule(["theme",r],s)}else s(e)},e.prototype.getTheme=function(){return this.$themeId},e.prototype.setStyle=function(e,t){i.setCssClass(this.container,e,t!==!1)},e.prototype.unsetStyle=function(e){i.removeCssClass(this.container,e)},e.prototype.setCursorStyle=function(e){i.setStyle(this.scroller.style,"cursor",e)},e.prototype.setMouseCursor=function(e){i.setStyle(this.scroller.style,"cursor",e)},e.prototype.attachToShadowRoot=function(){i.importCssString(y,"ace_editor.css",this.container)},e.prototype.destroy=function(){this.freeze(),this.$fontMetrics.destroy(),this.$cursorLayer.destroy(),this.removeAllListeners(),this.container.textContent="",this.setOption("useResizeObserver",!1)},e.prototype.$updateCustomScrollbar=function(e){var t=this;this.$horizScroll=this.$vScroll=null,this.scrollBarV.element.remove(),this.scrollBarH.element.remove(),this.$scrollDecorator&&delete this.$scrollDecorator,e===!0?(this.scrollBarV=new d(this.container,this),this.scrollBarH=new p(this.container,this),this.scrollBarV.setHeight(this.$size.scrollerHeight),this.scrollBarH.setWidth(this.$size.scrollerWidth),this.scrollBarV.addEventListener("scroll",function(e){t.$scrollAnimation||t.session.setScrollTop(e.data-t.scrollMargin.top)}),this.scrollBarH.addEventListener("scroll",function(e){t.$scrollAnimation||t.session.setScrollLeft(e.data-t.scrollMargin.left)}),this.$scrollDecorator=new b(this.scrollBarV,this),this.$scrollDecorator.$updateDecorators()):(this.scrollBarV=new h(this.container,this),this.scrollBarH=new c(this.container,this),this.scrollBarV.addEventListener("scroll",function(e){t.$scrollAnimation||t.session.setScrollTop(e.data-t.scrollMargin.top)}),this.scrollBarH.addEventListener("scroll",function(e){t.$scrollAnimation||t.session.setScrollLeft(e.data-t.scrollMargin.left)}))},e.prototype.$addResizeObserver=function(){if(!window.ResizeObserver||this.$resizeObserver)return;var e=this;this.$resizeTimer=s.delayedCall(function(){e.destroyed||e.onResize()},50),this.$resizeObserver=new window.ResizeObserver(function(t){var n=t[0].contentRect.width,r=t[0].contentRect.height;Math.abs(e.$size.width-n)>1||Math.abs(e.$size.height-r)>1?e.$resizeTimer.delay():e.$resizeTimer.cancel()}),this.$resizeObserver.observe(this.container)},e}();E.prototype.CHANGE_CURSOR=1,E.prototype.CHANGE_MARKER=2,E.prototype.CHANGE_GUTTER=4,E.prototype.CHANGE_SCROLL=8,E.prototype.CHANGE_LINES=16,E.prototype.CHANGE_TEXT=32,E.prototype.CHANGE_SIZE=64,E.prototype.CHANGE_MARKER_BACK=128,E.prototype.CHANGE_MARKER_FRONT=256,E.prototype.CHANGE_FULL=512,E.prototype.CHANGE_H_SCROLL=1024,E.prototype.$changes=0,E.prototype.$padding=null,E.prototype.$frozen=!1,E.prototype.STEPS=8,r.implement(E.prototype,g),o.defineOptions(E.prototype,"renderer",{useResizeObserver:{set:function(e){!e&&this.$resizeObserver?(this.$resizeObserver.disconnect(),this.$resizeTimer.cancel(),this.$resizeTimer=this.$resizeObserver=null):e&&!this.$resizeObserver&&this.$addResizeObserver()}},animatedScroll:{initialValue:!1},showInvisibles:{set:function(e){this.$textLayer.setShowInvisibles(e)&&this.$loop.schedule(this.CHANGE_TEXT)},initialValue:!1},showPrintMargin:{set:function(){this.$updatePrintMargin()},initialValue:!0},printMarginColumn:{set:function(){this.$updatePrintMargin()},initialValue:80},printMargin:{set:function(e){typeof e=="number"&&(this.$printMarginColumn=e),this.$showPrintMargin=!!e,this.$updatePrintMargin()},get:function(){return this.$showPrintMargin&&this.$printMarginColumn}},showGutter:{set:function(e){this.$gutter.style.display=e?"block":"none",this.$loop.schedule(this.CHANGE_FULL),this.onGutterResize()},initialValue:!0},useSvgGutterIcons:{set:function(e){this.$gutterLayer.$useSvgGutterIcons=e},initialValue:!1},showFoldedAnnotations:{set:function(e){this.$gutterLayer.$showFoldedAnnotations=e},initialValue:!1},fadeFoldWidgets:{set:function(e){i.setCssClass(this.$gutter,"ace_fade-fold-widgets",e)},initialValue:!1},showFoldWidgets:{set:function(e){this.$gutterLayer.setShowFoldWidgets(e),this.$loop.schedule(this.CHANGE_GUTTER)},initialValue:!0},displayIndentGuides:{set:function(e){this.$textLayer.setDisplayIndentGuides(e)&&this.$loop.schedule(this.CHANGE_TEXT)},initialValue:!0},highlightIndentGuides:{set:function(e){this.$textLayer.setHighlightIndentGuides(e)==1?this.$textLayer.$highlightIndentGuide():this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells)},initialValue:!0},highlightGutterLine:{set:function(e){this.$gutterLayer.setHighlightGutterLine(e),this.$loop.schedule(this.CHANGE_GUTTER)},initialValue:!0},hScrollBarAlwaysVisible:{set:function(e){(!this.$hScrollBarAlwaysVisible||!this.$horizScroll)&&this.$loop.schedule(this.CHANGE_SCROLL)},initialValue:!1},vScrollBarAlwaysVisible:{set:function(e){(!this.$vScrollBarAlwaysVisible||!this.$vScroll)&&this.$loop.schedule(this.CHANGE_SCROLL)},initialValue:!1},fontSize:{set:function(e){typeof e=="number"&&(e+="px"),this.container.style.fontSize=e,this.updateFontSize()},initialValue:12},fontFamily:{set:function(e){this.container.style.fontFamily=e,this.updateFontSize()}},maxLines:{set:function(e){this.updateFull()}},minLines:{set:function(e){this.$minLines<562949953421311||(this.$minLines=0),this.updateFull()}},maxPixelHeight:{set:function(e){this.updateFull()},initialValue:0},scrollPastEnd:{set:function(e){e=+e||0;if(this.$scrollPastEnd==e)return;this.$scrollPastEnd=e,this.$loop.schedule(this.CHANGE_SCROLL)},initialValue:0,handlesSet:!0},fixedWidthGutter:{set:function(e){this.$gutterLayer.$fixedWidth=!!e,this.$loop.schedule(this.CHANGE_GUTTER)}},customScrollbar:{set:function(e){this.$updateCustomScrollbar(e)},initialValue:!1},theme:{set:function(e){this.setTheme(e)},get:function(){return this.$themeId||this.theme},initialValue:"./theme/textmate",handlesSet:!0},hasCssTransforms:{},useTextareaForIME:{initialValue:!w.isMobile&&!w.isIE}}),t.VirtualRenderer=E}),ace.define("ace/worker/worker_client",["require","exports","module","ace/lib/oop","ace/lib/net","ace/lib/event_emitter","ace/config"],function(e,t,n){"use strict";function u(e){var t="importScripts('"+i.qualifyURL(e)+"');";try{return new Blob([t],{type:"application/javascript"})}catch(n){var r=window.BlobBuilder||window.WebKitBlobBuilder||window.MozBlobBuilder,s=new r;return s.append(t),s.getBlob("application/javascript")}}function a(e){if(typeof Worker=="undefined")return{postMessage:function(){},terminate:function(){}};if(o.get("loadWorkerFromBlob")){var t=u(e),n=window.URL||window.webkitURL,r=n.createObjectURL(t);return new Worker(r)}return new Worker(e)}var r=e("../lib/oop"),i=e("../lib/net"),s=e("../lib/event_emitter").EventEmitter,o=e("../config"),f=function(e){e.postMessage||(e=this.$createWorkerFromOldConfig.apply(this,arguments)),this.$worker=e,this.$sendDeltaQueue=this.$sendDeltaQueue.bind(this),this.changeListener=this.changeListener.bind(this),this.onMessage=this.onMessage.bind(this),this.callbackId=1,this.callbacks={},this.$worker.onmessage=this.onMessage};(function(){r.implement(this,s),this.$createWorkerFromOldConfig=function(t,n,r,i,s){e.nameToUrl&&!e.toUrl&&(e.toUrl=e.nameToUrl);if(o.get("packaged")||!e.toUrl)i=i||o.moduleUrl(n,"worker");else{var u=this.$normalizePath;i=i||u(e.toUrl("ace/worker/worker.js",null,"_"));var f={};t.forEach(function(t){f[t]=u(e.toUrl(t,null,"_").replace(/(\.js)?(\?.*)?$/,""))})}return this.$worker=a(i),s&&this.send("importScripts",s),this.$worker.postMessage({init:!0,tlns:f,module:n,classname:r}),this.$worker},this.onMessage=function(e){var t=e.data;switch(t.type){case"event":this._signal(t.name,{data:t.data});break;case"call":var n=this.callbacks[t.id];n&&(n(t.data),delete this.callbacks[t.id]);break;case"error":this.reportError(t.data);break;case"log":window.console&&console.log&&console.log.apply(console,t.data)}},this.reportError=function(e){window.console&&console.error&&console.error(e)},this.$normalizePath=function(e){return i.qualifyURL(e)},this.terminate=function(){this._signal("terminate",{}),this.deltaQueue=null,this.$worker.terminate(),this.$worker=null,this.$doc&&this.$doc.off("change",this.changeListener),this.$doc=null},this.send=function(e,t){this.$worker.postMessage({command:e,args:t})},this.call=function(e,t,n){if(n){var r=this.callbackId++;this.callbacks[r]=n,t.push(r)}this.send(e,t)},this.emit=function(e,t){try{t.data&&t.data.err&&(t.data.err={message:t.data.err.message,stack:t.data.err.stack,code:t.data.err.code}),this.$worker&&this.$worker.postMessage({event:e,data:{data:t.data}})}catch(n){console.error(n.stack)}},this.attachToDocument=function(e){this.$doc&&this.terminate(),this.$doc=e,this.call("setValue",[e.getValue()]),e.on("change",this.changeListener,!0)},this.changeListener=function(e){this.deltaQueue||(this.deltaQueue=[],setTimeout(this.$sendDeltaQueue,0)),e.action=="insert"?this.deltaQueue.push(e.start,e.lines):this.deltaQueue.push(e.start,e.end)},this.$sendDeltaQueue=function(){var e=this.deltaQueue;if(!e)return;this.deltaQueue=null,e.length>50&&e.length>this.$doc.getLength()>>1?this.call("setValue",[this.$doc.getValue()]):this.emit("change",{data:e})}}).call(f.prototype);var l=function(e,t,n){var r=null,i=!1,u=Object.create(s),a=[],l=new f({messageBuffer:a,terminate:function(){},postMessage:function(e){a.push(e);if(!r)return;i?setTimeout(c):c()}});l.setEmitSync=function(e){i=e};var c=function(){var e=a.shift();e.command?r[e.command].apply(r,e.args):e.event&&u._signal(e.event,e.data)};return u.postMessage=function(e){l.onMessage({data:e})},u.callback=function(e,t){this.postMessage({type:"call",id:t,data:e})},u.emit=function(e,t){this.postMessage({type:"event",name:e,data:t})},o.loadModule(["worker",t],function(e){r=new e[n](u);while(a.length)c()}),l};t.UIWorkerClient=l,t.WorkerClient=f,t.createWorker=a}),ace.define("ace/placeholder",["require","exports","module","ace/range","ace/lib/event_emitter","ace/lib/oop"],function(e,t,n){"use strict";var r=e("./range").Range,i=e("./lib/event_emitter").EventEmitter,s=e("./lib/oop"),o=function(){function e(e,t,n,r,i,s){var o=this;this.length=t,this.session=e,this.doc=e.getDocument(),this.mainClass=i,this.othersClass=s,this.$onUpdate=this.onUpdate.bind(this),this.doc.on("change",this.$onUpdate,!0),this.$others=r,this.$onCursorChange=function(){setTimeout(function(){o.onCursorChange()})},this.$pos=n;var u=e.getUndoManager().$undoStack||e.getUndoManager().$undostack||{length:-1};this.$undoStackDepth=u.length,this.setup(),e.selection.on("changeCursor",this.$onCursorChange)}return e.prototype.setup=function(){var e=this,t=this.doc,n=this.session;this.selectionBefore=n.selection.toJSON(),n.selection.inMultiSelectMode&&n.selection.toSingleRange(),this.pos=t.createAnchor(this.$pos.row,this.$pos.column);var i=this.pos;i.$insertRight=!0,i.detach(),i.markerId=n.addMarker(new r(i.row,i.column,i.row,i.column+this.length),this.mainClass,null,!1),this.others=[],this.$others.forEach(function(n){var r=t.createAnchor(n.row,n.column);r.$insertRight=!0,r.detach(),e.others.push(r)}),n.setUndoSelect(!1)},e.prototype.showOtherMarkers=function(){if(this.othersActive)return;var e=this.session,t=this;this.othersActive=!0,this.others.forEach(function(n){n.markerId=e.addMarker(new r(n.row,n.column,n.row,n.column+t.length),t.othersClass,null,!1)})},e.prototype.hideOtherMarkers=function(){if(!this.othersActive)return;this.othersActive=!1;for(var e=0;e<this.others.length;e++)this.session.removeMarker(this.others[e].markerId)},e.prototype.onUpdate=function(e){if(this.$updating)return this.updateAnchors(e);var t=e;if(t.start.row!==t.end.row)return;if(t.start.row!==this.pos.row)return;this.$updating=!0;var n=e.action==="insert"?t.end.column-t.start.column:t.start.column-t.end.column,i=t.start.column>=this.pos.column&&t.start.column<=this.pos.column+this.length+1,s=t.start.column-this.pos.column;this.updateAnchors(e),i&&(this.length+=n);if(i&&!this.session.$fromUndo)if(e.action==="insert")for(var o=this.others.length-1;o>=0;o--){var u=this.others[o],a={row:u.row,column:u.column+s};this.doc.insertMergedLines(a,e.lines)}else if(e.action==="remove")for(var o=this.others.length-1;o>=0;o--){var u=this.others[o],a={row:u.row,column:u.column+s};this.doc.remove(new r(a.row,a.column,a.row,a.column-n))}this.$updating=!1,this.updateMarkers()},e.prototype.updateAnchors=function(e){this.pos.onChange(e);for(var t=this.others.length;t--;)this.others[t].onChange(e);this.updateMarkers()},e.prototype.updateMarkers=function(){if(this.$updating)return;var e=this,t=this.session,n=function(n,i){t.removeMarker(n.markerId),n.markerId=t.addMarker(new r(n.row,n.column,n.row,n.column+e.length),i,null,!1)};n(this.pos,this.mainClass);for(var i=this.others.length;i--;)n(this.others[i],this.othersClass)},e.prototype.onCursorChange=function(e){if(this.$updating||!this.session)return;var t=this.session.selection.getCursor();t.row===this.pos.row&&t.column>=this.pos.column&&t.column<=this.pos.column+this.length?(this.showOtherMarkers(),this._emit("cursorEnter",e)):(this.hideOtherMarkers(),this._emit("cursorLeave",e))},e.prototype.detach=function(){this.session.removeMarker(this.pos&&this.pos.markerId),this.hideOtherMarkers(),this.doc.off("change",this.$onUpdate),this.session.selection.off("changeCursor",this.$onCursorChange),this.session.setUndoSelect(!0),this.session=null},e.prototype.cancel=function(){if(this.$undoStackDepth===-1)return;var e=this.session.getUndoManager(),t=(e.$undoStack||e.$undostack).length-this.$undoStackDepth;for(var n=0;n<t;n++)e.undo(this.session,!0);this.selectionBefore&&this.session.selection.fromJSON(this.selectionBefore)},e}();s.implement(o.prototype,i),t.PlaceHolder=o}),ace.define("ace/mouse/multi_select_handler",["require","exports","module","ace/lib/event","ace/lib/useragent"],function(e,t,n){function s(e,t){return e.row==t.row&&e.column==t.column}function o(e){var t=e.domEvent,n=t.altKey,o=t.shiftKey,u=t.ctrlKey,a=e.getAccelKey(),f=e.getButton();u&&i.isMac&&(f=t.button);if(e.editor.inMultiSelectMode&&f==2){e.editor.textInput.onContextMenu(e.domEvent);return}if(!u&&!n&&!a){f===0&&e.editor.inMultiSelectMode&&e.editor.exitMultiSelectMode();return}if(f!==0)return;var l=e.editor,c=l.selection,h=l.inMultiSelectMode,p=e.getDocumentPosition(),d=c.getCursor(),v=e.inSelection()||c.isEmpty()&&s(p,d),m=e.x,g=e.y,y=function(e){m=e.clientX,g=e.clientY},b=l.session,w=l.renderer.pixelToScreenCoordinates(m,g),E=w,S;if(l.$mouseHandler.$enableJumpToDef)u&&n||a&&n?S=o?"block":"add":n&&l.$blockSelectEnabled&&(S="block");else if(a&&!n){S="add";if(!h&&o)return}else n&&l.$blockSelectEnabled&&(S="block");S&&i.isMac&&t.ctrlKey&&l.$mouseHandler.cancelContextMenu();if(S=="add"){if(!h&&v)return;if(!h){var x=c.toOrientedRange();l.addSelectionMarker(x)}var T=c.rangeList.rangeAtPoint(p);l.inVirtualSelectionMode=!0,o&&(T=null,x=c.ranges[0]||x,l.removeSelectionMarker(x)),l.once("mouseup",function(){var e=c.toOrientedRange();T&&e.isEmpty()&&s(T.cursor,e.cursor)?c.substractPoint(e.cursor):(o?c.substractPoint(x.cursor):x&&(l.removeSelectionMarker(x),c.addRange(x)),c.addRange(e)),l.inVirtualSelectionMode=!1})}else if(S=="block"){e.stop(),l.inVirtualSelectionMode=!0;var N,C=[],k=function(){var e=l.renderer.pixelToScreenCoordinates(m,g),t=b.screenToDocumentPosition(e.row,e.column,e.offsetX);if(s(E,e)&&s(t,c.lead))return;E=e,l.selection.moveToPosition(t),l.renderer.scrollCursorIntoView(),l.removeSelectionMarkers(C),C=c.rectangularRangeBlock(E,w),l.$mouseHandler.$clickSelection&&C.length==1&&C[0].isEmpty()&&(C[0]=l.$mouseHandler.$clickSelection.clone()),C.forEach(l.addSelectionMarker,l),l.updateSelectionMarkers()};h&&!a?c.toSingleRange():!h&&a&&(N=c.toOrientedRange(),l.addSelectionMarker(N)),o?w=b.documentToScreenPosition(c.lead):c.moveToPosition(p),E={row:-1,column:-1};var L=function(e){k(),clearInterval(O),l.removeSelectionMarkers(C),C.length||(C=[c.toOrientedRange()]),N&&(l.removeSelectionMarker(N),c.toSingleRange(N));for(var t=0;t<C.length;t++)c.addRange(C[t]);l.inVirtualSelectionMode=!1,l.$mouseHandler.$clickSelection=null},A=k;r.capture(l.container,y,L);var O=setInterval(function(){A()},20);return e.preventDefault()}}var r=e("../lib/event"),i=e("../lib/useragent");t.onMouseDown=o}),ace.define("ace/commands/multi_select_commands",["require","exports","module","ace/keyboard/hash_handler"],function(e,t,n){t.defaultCommands=[{name:"addCursorAbove",description:"Add cursor above",exec:function(e){e.selectMoreLines(-1)},bindKey:{win:"Ctrl-Alt-Up",mac:"Ctrl-Alt-Up"},scrollIntoView:"cursor",readOnly:!0},{name:"addCursorBelow",description:"Add cursor below",exec:function(e){e.selectMoreLines(1)},bindKey:{win:"Ctrl-Alt-Down",mac:"Ctrl-Alt-Down"},scrollIntoView:"cursor",readOnly:!0},{name:"addCursorAboveSkipCurrent",description:"Add cursor above (skip current)",exec:function(e){e.selectMoreLines(-1,!0)},bindKey:{win:"Ctrl-Alt-Shift-Up",mac:"Ctrl-Alt-Shift-Up"},scrollIntoView:"cursor",readOnly:!0},{name:"addCursorBelowSkipCurrent",description:"Add cursor below (skip current)",exec:function(e){e.selectMoreLines(1,!0)},bindKey:{win:"Ctrl-Alt-Shift-Down",mac:"Ctrl-Alt-Shift-Down"},scrollIntoView:"cursor",readOnly:!0},{name:"selectMoreBefore",description:"Select more before",exec:function(e){e.selectMore(-1)},bindKey:{win:"Ctrl-Alt-Left",mac:"Ctrl-Alt-Left"},scrollIntoView:"cursor",readOnly:!0},{name:"selectMoreAfter",description:"Select more after",exec:function(e){e.selectMore(1)},bindKey:{win:"Ctrl-Alt-Right",mac:"Ctrl-Alt-Right"},scrollIntoView:"cursor",readOnly:!0},{name:"selectNextBefore",description:"Select next before",exec:function(e){e.selectMore(-1,!0)},bindKey:{win:"Ctrl-Alt-Shift-Left",mac:"Ctrl-Alt-Shift-Left"},scrollIntoView:"cursor",readOnly:!0},{name:"selectNextAfter",description:"Select next after",exec:function(e){e.selectMore(1,!0)},bindKey:{win:"Ctrl-Alt-Shift-Right",mac:"Ctrl-Alt-Shift-Right"},scrollIntoView:"cursor",readOnly:!0},{name:"toggleSplitSelectionIntoLines",description:"Split selection into lines",exec:function(e){e.multiSelect.rangeCount>1?e.multiSelect.joinSelections():e.multiSelect.splitIntoLines()},bindKey:{win:"Ctrl-Alt-L",mac:"Ctrl-Alt-L"},readOnly:!0},{name:"splitSelectionIntoLines",description:"Split into lines",exec:function(e){e.multiSelect.splitIntoLines()},readOnly:!0},{name:"alignCursors",description:"Align cursors",exec:function(e){e.alignCursors()},bindKey:{win:"Ctrl-Alt-A",mac:"Ctrl-Alt-A"},scrollIntoView:"cursor"},{name:"findAll",description:"Find all",exec:function(e){e.findAll()},bindKey:{win:"Ctrl-Alt-K",mac:"Ctrl-Alt-G"},scrollIntoView:"cursor",readOnly:!0}],t.multiSelectCommands=[{name:"singleSelection",description:"Single selection",bindKey:"esc",exec:function(e){e.exitMultiSelectMode()},scrollIntoView:"cursor",readOnly:!0,isAvailable:function(e){return e&&e.inMultiSelectMode}}];var r=e("../keyboard/hash_handler").HashHandler;t.keyboardHandler=new r(t.multiSelectCommands)}),ace.define("ace/multi_select",["require","exports","module","ace/range_list","ace/range","ace/selection","ace/mouse/multi_select_handler","ace/lib/event","ace/lib/lang","ace/commands/multi_select_commands","ace/search","ace/edit_session","ace/editor","ace/config"],function(e,t,n){function h(e,t,n){return c.$options.wrap=!0,c.$options.needle=t,c.$options.backwards=n==-1,c.find(e)}function v(e,t){return e.row==t.row&&e.column==t.column}function m(e){if(e.$multiselectOnSessionChange)return;e.$onAddRange=e.$onAddRange.bind(e),e.$onRemoveRange=e.$onRemoveRange.bind(e),e.$onMultiSelect=e.$onMultiSelect.bind(e),e.$onSingleSelect=e.$onSingleSelect.bind(e),e.$multiselectOnSessionChange=t.onSessionChange.bind(e),e.$checkMultiselectChange=e.$checkMultiselectChange.bind(e),e.$multiselectOnSessionChange(e),e.on("changeSession",e.$multiselectOnSessionChange),e.on("mousedown",o),e.commands.addCommands(f.defaultCommands),g(e)}function g(e){function r(t){n&&(e.renderer.setMouseCursor(""),n=!1)}if(!e.textInput)return;var t=e.textInput.getElement(),n=!1;u.addListener(t,"keydown",function(t){var i=t.keyCode==18&&!(t.ctrlKey||t.shiftKey||t.metaKey);e.$blockSelectEnabled&&i?n||(e.renderer.setMouseCursor("crosshair"),n=!0):n&&r()},e),u.addListener(t,"keyup",r,e),u.addListener(t,"blur",r,e)}var r=e("./range_list").RangeList,i=e("./range").Range,s=e("./selection").Selection,o=e("./mouse/multi_select_handler").onMouseDown,u=e("./lib/event"),a=e("./lib/lang"),f=e("./commands/multi_select_commands");t.commands=f.defaultCommands.concat(f.multiSelectCommands);var l=e("./search").Search,c=new l,p=e("./edit_session").EditSession;(function(){this.getSelectionMarkers=function(){return this.$selectionMarkers}}).call(p.prototype),function(){this.ranges=null,this.rangeList=null,this.addRange=function(e,t){if(!e)return;if(!this.inMultiSelectMode&&this.rangeCount===0){var n=this.toOrientedRange();this.rangeList.add(n),this.rangeList.add(e);if(this.rangeList.ranges.length!=2)return this.rangeList.removeAll(),t||this.fromOrientedRange(e);this.rangeList.removeAll(),this.rangeList.add(n),this.$onAddRange(n)}e.cursor||(e.cursor=e.end);var r=this.rangeList.add(e);return this.$onAddRange(e),r.length&&this.$onRemoveRange(r),this.rangeCount>1&&!this.inMultiSelectMode&&(this._signal("multiSelect"),this.inMultiSelectMode=!0,this.session.$undoSelect=!1,this.rangeList.attach(this.session)),t||this.fromOrientedRange(e)},this.toSingleRange=function(e){e=e||this.ranges[0];var t=this.rangeList.removeAll();t.length&&this.$onRemoveRange(t),e&&this.fromOrientedRange(e)},this.substractPoint=function(e){var t=this.rangeList.substractPoint(e);if(t)return this.$onRemoveRange(t),t[0]},this.mergeOverlappingRanges=function(){var e=this.rangeList.merge();e.length&&this.$onRemoveRange(e)},this.$onAddRange=function(e){this.rangeCount=this.rangeList.ranges.length,this.ranges.unshift(e),this._signal("addRange",{range:e})},this.$onRemoveRange=function(e){this.rangeCount=this.rangeList.ranges.length;if(this.rangeCount==1&&this.inMultiSelectMode){var t=this.rangeList.ranges.pop();e.push(t),this.rangeCount=0}for(var n=e.length;n--;){var r=this.ranges.indexOf(e[n]);this.ranges.splice(r,1)}this._signal("removeRange",{ranges:e}),this.rangeCount===0&&this.inMultiSelectMode&&(this.inMultiSelectMode=!1,this._signal("singleSelect"),this.session.$undoSelect=!0,this.rangeList.detach(this.session)),t=t||this.ranges[0],t&&!t.isEqual(this.getRange())&&this.fromOrientedRange(t)},this.$initRangeList=function(){if(this.rangeList)return;this.rangeList=new r,this.ranges=[],this.rangeCount=0},this.getAllRanges=function(){return this.rangeCount?this.rangeList.ranges.concat():[this.getRange()]},this.splitIntoLines=function(){var e=this.ranges.length?this.ranges:[this.getRange()],t=[];for(var n=0;n<e.length;n++){var r=e[n],s=r.start.row,o=r.end.row;if(s===o)t.push(r.clone());else{t.push(new i(s,r.start.column,s,this.session.getLine(s).length));while(++s<o)t.push(this.getLineRange(s,!0));t.push(new i(o,0,o,r.end.column))}n==0&&!this.isBackwards()&&(t=t.reverse())}this.toSingleRange();for(var n=t.length;n--;)this.addRange(t[n])},this.joinSelections=function(){var e=this.rangeList.ranges,t=e[e.length-1],n=i.fromPoints(e[0].start,t.end);this.toSingleRange(),this.setSelectionRange(n,t.cursor==t.start)},this.toggleBlockSelection=function(){if(this.rangeCount>1){var e=this.rangeList.ranges,t=e[e.length-1],n=i.fromPoints(e[0].start,t.end);this.toSingleRange(),this.setSelectionRange(n,t.cursor==t.start)}else{var r=this.session.documentToScreenPosition(this.cursor),s=this.session.documentToScreenPosition(this.anchor),o=this.rectangularRangeBlock(r,s);o.forEach(this.addRange,this)}},this.rectangularRangeBlock=function(e,t,n){var r=[],s=e.column<t.column;if(s)var o=e.column,u=t.column,a=e.offsetX,f=t.offsetX;else var o=t.column,u=e.column,a=t.offsetX,f=e.offsetX;var l=e.row<t.row;if(l)var c=e.row,h=t.row;else var c=t.row,h=e.row;o<0&&(o=0),c<0&&(c=0),c==h&&(n=!0);var p;for(var d=c;d<=h;d++){var m=i.fromPoints(this.session.screenToDocumentPosition(d,o,a),this.session.screenToDocumentPosition(d,u,f));if(m.isEmpty()){if(p&&v(m.end,p))break;p=m.end}m.cursor=s?m.start:m.end,r.push(m)}l&&r.reverse();if(!n){var g=r.length-1;while(r[g].isEmpty()&&g>0)g--;if(g>0){var y=0;while(r[y].isEmpty())y++}for(var b=g;b>=y;b--)r[b].isEmpty()&&r.splice(b,1)}return r}}.call(s.prototype);var d=e("./editor").Editor;(function(){this.updateSelectionMarkers=function(){this.renderer.updateCursor(),this.renderer.updateBackMarkers()},this.addSelectionMarker=function(e){e.cursor||(e.cursor=e.end);var t=this.getSelectionStyle();return e.marker=this.session.addMarker(e,"ace_selection",t),this.session.$selectionMarkers.push(e),this.session.selectionMarkerCount=this.session.$selectionMarkers.length,e},this.removeSelectionMarker=function(e){if(!e.marker)return;this.session.removeMarker(e.marker);var t=this.session.$selectionMarkers.indexOf(e);t!=-1&&this.session.$selectionMarkers.splice(t,1),this.session.selectionMarkerCount=this.session.$selectionMarkers.length},this.removeSelectionMarkers=function(e){var t=this.session.$selectionMarkers;for(var n=e.length;n--;){var r=e[n];if(!r.marker)continue;this.session.removeMarker(r.marker);var i=t.indexOf(r);i!=-1&&t.splice(i,1)}this.session.selectionMarkerCount=t.length},this.$onAddRange=function(e){this.addSelectionMarker(e.range),this.renderer.updateCursor(),this.renderer.updateBackMarkers()},this.$onRemoveRange=function(e){this.removeSelectionMarkers(e.ranges),this.renderer.updateCursor(),this.renderer.updateBackMarkers()},this.$onMultiSelect=function(e){if(this.inMultiSelectMode)return;this.inMultiSelectMode=!0,this.setStyle("ace_multiselect"),this.keyBinding.addKeyboardHandler(f.keyboardHandler),this.commands.setDefaultHandler("exec",this.$onMultiSelectExec),this.renderer.updateCursor(),this.renderer.updateBackMarkers()},this.$onSingleSelect=function(e){if(this.session.multiSelect.inVirtualMode)return;this.inMultiSelectMode=!1,this.unsetStyle("ace_multiselect"),this.keyBinding.removeKeyboardHandler(f.keyboardHandler),this.commands.removeDefaultHandler("exec",this.$onMultiSelectExec),this.renderer.updateCursor(),this.renderer.updateBackMarkers(),this._emit("changeSelection")},this.$onMultiSelectExec=function(e){var t=e.command,n=e.editor;if(!n.multiSelect)return;if(!t.multiSelectAction){var r=t.exec(n,e.args||{});n.multiSelect.addRange(n.multiSelect.toOrientedRange()),n.multiSelect.mergeOverlappingRanges()}else t.multiSelectAction=="forEach"?r=n.forEachSelection(t,e.args):t.multiSelectAction=="forEachLine"?r=n.forEachSelection(t,e.args,!0):t.multiSelectAction=="single"?(n.exitMultiSelectMode(),r=t.exec(n,e.args||{})):r=t.multiSelectAction(n,e.args||{});return r},this.forEachSelection=function(e,t,n){if(this.inVirtualSelectionMode)return;var r=n&&n.keepOrder,i=n==1||n&&n.$byLines,o=this.session,u=this.selection,a=u.rangeList,f=(r?u:a).ranges,l;if(!f.length)return e.exec?e.exec(this,t||{}):e(this,t||{});var c=u._eventRegistry;u._eventRegistry={};var h=new s(o);this.inVirtualSelectionMode=!0;for(var p=f.length;p--;){if(i)while(p>0&&f[p].start.row==f[p-1].end.row)p--;h.fromOrientedRange(f[p]),h.index=p,this.selection=o.selection=h;var d=e.exec?e.exec(this,t||{}):e(this,t||{});!l&&d!==undefined&&(l=d),h.toOrientedRange(f[p])}h.detach(),this.selection=o.selection=u,this.inVirtualSelectionMode=!1,u._eventRegistry=c,u.mergeOverlappingRanges(),u.ranges[0]&&u.fromOrientedRange(u.ranges[0]);var v=this.renderer.$scrollAnimation;return this.onCursorChange(),this.onSelectionChange(),v&&v.from==v.to&&this.renderer.animateScrolling(v.from),l},this.exitMultiSelectMode=function(){if(!this.inMultiSelectMode||this.inVirtualSelectionMode)return;this.multiSelect.toSingleRange()},this.getSelectedText=function(){var e="";if(this.inMultiSelectMode&&!this.inVirtualSelectionMode){var t=this.multiSelect.rangeList.ranges,n=[];for(var r=0;r<t.length;r++)n.push(this.session.getTextRange(t[r]));var i=this.session.getDocument().getNewLineCharacter();e=n.join(i),e.length==(n.length-1)*i.length&&(e="")}else this.selection.isEmpty()||(e=this.session.getTextRange(this.getSelectionRange()));return e},this.$checkMultiselectChange=function(e,t){if(this.inMultiSelectMode&&!this.inVirtualSelectionMode){var n=this.multiSelect.ranges[0];if(this.multiSelect.isEmpty()&&t==this.multiSelect.anchor)return;var r=t==this.multiSelect.anchor?n.cursor==n.start?n.end:n.start:n.cursor;r.row!=t.row||this.session.$clipPositionToDocument(r.row,r.column).column!=t.column?this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange()):this.multiSelect.mergeOverlappingRanges()}},this.findAll=function(e,t,n){t=t||{},t.needle=e||t.needle;if(t.needle==undefined){var r=this.selection.isEmpty()?this.selection.getWordRange():this.selection.getRange();t.needle=this.session.getTextRange(r)}this.$search.set(t);var i=this.$search.findAll(this.session);if(!i.length)return 0;var s=this.multiSelect;n||s.toSingleRange(i[0]);for(var o=i.length;o--;)s.addRange(i[o],!0);return r&&s.rangeList.rangeAtPoint(r.start)&&s.addRange(r,!0),i.length},this.selectMoreLines=function(e,t){var n=this.selection.toOrientedRange(),r=n.cursor==n.end,s=this.session.documentToScreenPosition(n.cursor);this.selection.$desiredColumn&&(s.column=this.selection.$desiredColumn);var o=this.session.screenToDocumentPosition(s.row+e,s.column);if(!n.isEmpty())var u=this.session.documentToScreenPosition(r?n.end:n.start),a=this.session.screenToDocumentPosition(u.row+e,u.column);else var a=o;if(r){var f=i.fromPoints(o,a);f.cursor=f.start}else{var f=i.fromPoints(a,o);f.cursor=f.end}f.desiredColumn=s.column;if(!this.selection.inMultiSelectMode)this.selection.addRange(n);else if(t)var l=n.cursor;this.selection.addRange(f),l&&this.selection.substractPoint(l)},this.transposeSelections=function(e){var t=this.session,n=t.multiSelect,r=n.ranges;for(var i=r.length;i--;){var s=r[i];if(s.isEmpty()){var o=t.getWordRange(s.start.row,s.start.column);s.start.row=o.start.row,s.start.column=o.start.column,s.end.row=o.end.row,s.end.column=o.end.column}}n.mergeOverlappingRanges();var u=[];for(var i=r.length;i--;){var s=r[i];u.unshift(t.getTextRange(s))}e<0?u.unshift(u.pop()):u.push(u.shift());for(var i=r.length;i--;){var s=r[i],o=s.clone();t.replace(s,u[i]),s.start.row=o.start.row,s.start.column=o.start.column}n.fromOrientedRange(n.ranges[0])},this.selectMore=function(e,t,n){var r=this.session,i=r.multiSelect,s=i.toOrientedRange();if(s.isEmpty()){s=r.getWordRange(s.start.row,s.start.column),s.cursor=e==-1?s.start:s.end,this.multiSelect.addRange(s);if(n)return}var o=r.getTextRange(s),u=h(r,o,e);u&&(u.cursor=e==-1?u.start:u.end,this.session.unfold(u),this.multiSelect.addRange(u),this.renderer.scrollCursorIntoView(null,.5)),t&&this.multiSelect.substractPoint(s.cursor)},this.alignCursors=function(){var e=this.session,t=e.multiSelect,n=t.ranges,r=-1,s=n.filter(function(e){if(e.cursor.row==r)return!0;r=e.cursor.row});if(!n.length||s.length==n.length-1){var o=this.selection.getRange(),u=o.start.row,f=o.end.row,l=u==f;if(l){var c=this.session.getLength(),h;do h=this.session.getLine(f);while(/[=:]/.test(h)&&++f<c);do h=this.session.getLine(u);while(/[=:]/.test(h)&&--u>0);u<0&&(u=0),f>=c&&(f=c-1)}var p=this.session.removeFullLines(u,f);p=this.$reAlignText(p,l),this.session.insert({row:u,column:0},p.join("\n")+"\n"),l||(o.start.column=0,o.end.column=p[p.length-1].length),this.selection.setRange(o)}else{s.forEach(function(e){t.substractPoint(e.cursor)});var d=0,v=Infinity,m=n.map(function(t){var n=t.cursor,r=e.getLine(n.row),i=r.substr(n.column).search(/\S/g);return i==-1&&(i=0),n.column>d&&(d=n.column),i<v&&(v=i),i});n.forEach(function(t,n){var r=t.cursor,s=d-r.column,o=m[n]-v;s>o?e.insert(r,a.stringRepeat(" ",s-o)):e.remove(new i(r.row,r.column,r.row,r.column-s+o)),t.start.column=t.end.column=d,t.start.row=t.end.row=r.row,t.cursor=t.end}),t.fromOrientedRange(n[0]),this.renderer.updateCursor(),this.renderer.updateBackMarkers()}},this.$reAlignText=function(e,t){function u(e){return a.stringRepeat(" ",e)}function f(e){return e[2]?u(i)+e[2]+u(s-e[2].length+o)+e[4].replace(/^([=:])\s+/,"$1 "):e[0]}function l(e){return e[2]?u(i+s-e[2].length)+e[2]+u(o)+e[4].replace(/^([=:])\s+/,"$1 "):e[0]}function c(e){return e[2]?u(i)+e[2]+u(o)+e[4].replace(/^([=:])\s+/,"$1 "):e[0]}var n=!0,r=!0,i,s,o;return e.map(function(e){var t=e.match(/(\s*)(.*?)(\s*)([=:].*)/);return t?i==null?(i=t[1].length,s=t[2].length,o=t[3].length,t):(i+s+o!=t[1].length+t[2].length+t[3].length&&(r=!1),i!=t[1].length&&(n=!1),i>t[1].length&&(i=t[1].length),s<t[2].length&&(s=t[2].length),o>t[3].length&&(o=t[3].length),t):[e]}).map(t?f:n?r?l:f:c)}}).call(d.prototype),t.onSessionChange=function(e){var t=e.session;t&&!t.multiSelect&&(t.$selectionMarkers=[],t.selection.$initRangeList(),t.multiSelect=t.selection),this.multiSelect=t&&t.multiSelect;var n=e.oldSession;n&&(n.multiSelect.off("addRange",this.$onAddRange),n.multiSelect.off("removeRange",this.$onRemoveRange),n.multiSelect.off("multiSelect",this.$onMultiSelect),n.multiSelect.off("singleSelect",this.$onSingleSelect),n.multiSelect.lead.off("change",this.$checkMultiselectChange),n.multiSelect.anchor.off("change",this.$checkMultiselectChange)),t&&(t.multiSelect.on("addRange",this.$onAddRange),t.multiSelect.on("removeRange",this.$onRemoveRange),t.multiSelect.on("multiSelect",this.$onMultiSelect),t.multiSelect.on("singleSelect",this.$onSingleSelect),t.multiSelect.lead.on("change",this.$checkMultiselectChange),t.multiSelect.anchor.on("change",this.$checkMultiselectChange)),t&&this.inMultiSelectMode!=t.selection.inMultiSelectMode&&(t.selection.inMultiSelectMode?this.$onMultiSelect():this.$onSingleSelect())},t.MultiSelect=m,e("./config").defineOptions(d.prototype,"editor",{enableMultiselect:{set:function(e){m(this),e?(this.on("changeSession",this.$multiselectOnSessionChange),this.on("mousedown",o)):(this.off("changeSession",this.$multiselectOnSessionChange),this.off("mousedown",o))},value:!0},enableBlockSelect:{set:function(e){this.$blockSelectEnabled=e},value:!0}})}),ace.define("ace/mode/folding/fold_mode",["require","exports","module","ace/range"],function(e,t,n){"use strict";var r=e("../../range").Range,i=t.FoldMode=function(){};(function(){this.foldingStartMarker=null,this.foldingStopMarker=null,this.getFoldWidget=function(e,t,n){var r=e.getLine(n);return this.foldingStartMarker.test(r)?"start":t=="markbeginend"&&this.foldingStopMarker&&this.foldingStopMarker.test(r)?"end":""},this.getFoldWidgetRange=function(e,t,n){return null},this.indentationBlock=function(e,t,n){var i=/\S/,s=e.getLine(t),o=s.search(i);if(o==-1)return;var u=n||s.length,a=e.getLength(),f=t,l=t;while(++t<a){var c=e.getLine(t).search(i);if(c==-1)continue;if(c<=o){var h=e.getTokenAt(t,0);if(!h||h.type!=="string")break}l=t}if(l>f){var p=e.getLine(l).length;return new r(f,u,l,p)}},this.openingBracketBlock=function(e,t,n,i,s){var o={row:n,column:i+1},u=e.$findClosingBracket(t,o,s);if(!u)return;var a=e.foldWidgets[u.row];return a==null&&(a=e.getFoldWidget(u.row)),a=="start"&&u.row>o.row&&(u.row--,u.column=e.getLine(u.row).length),r.fromPoints(o,u)},this.closingBracketBlock=function(e,t,n,i,s){var o={row:n,column:i},u=e.$findOpeningBracket(t,o);if(!u)return;return u.column++,o.column--,r.fromPoints(u,o)}}).call(i.prototype)}),ace.define("ace/ext/error_marker",["require","exports","module","ace/line_widgets","ace/lib/dom","ace/range"],function(e,t,n){"use strict";function o(e,t,n){var r=0,i=e.length-1;while(r<=i){var s=r+i>>1,o=n(t,e[s]);if(o>0)r=s+1;else{if(!(o<0))return s;i=s-1}}return-(r+1)}function u(e,t,n){var r=e.getAnnotations().sort(s.comparePoints);if(!r.length)return;var i=o(r,{row:t,column:-1},s.comparePoints);i<0&&(i=-i-1),i>=r.length?i=n>0?0:r.length-1:i===0&&n<0&&(i=r.length-1);var u=r[i];if(!u||!n)return;if(u.row===t){do u=r[i+=n];while(u&&u.row===t);if(!u)return r.slice()}var a=[];t=u.row;do a[n<0?"unshift":"push"](u),u=r[i+=n];while(u&&u.row==t);return a.length&&a}var r=e("../line_widgets").LineWidgets,i=e("../lib/dom"),s=e("../range").Range;t.showErrorMarker=function(e,t){var n=e.session;n.widgetManager||(n.widgetManager=new r(n),n.widgetManager.attach(e));var s=e.getCursorPosition(),o=s.row,a=n.widgetManager.getWidgetsAtRow(o).filter(function(e){return e.type=="errorMarker"})[0];a?a.destroy():o-=t;var f=u(n,o,t),l;if(f){var c=f[0];s.column=(c.pos&&typeof c.column!="number"?c.pos.sc:c.column)||0,s.row=c.row,l=e.renderer.$gutterLayer.$annotations[s.row]}else{if(a)return;l={text:["Looks good!"],className:"ace_ok"}}e.session.unfold(s.row),e.selection.moveToPosition(s);var h={row:s.row,fixedWidth:!0,coverGutter:!0,el:i.createElement("div"),type:"errorMarker"},p=h.el.appendChild(i.createElement("div")),d=h.el.appendChild(i.createElement("div"));d.className="error_widget_arrow "+l.className;var v=e.renderer.$cursorLayer.getPixelPosition(s).left;d.style.left=v+e.renderer.gutterWidth-5+"px",h.el.className="error_widget_wrapper",p.className="error_widget "+l.className,p.innerHTML=l.text.join("<br>"),p.appendChild(i.createElement("div"));var m=function(e,t,n){if(t===0&&(n==="esc"||n==="return"))return h.destroy(),{command:"null"}};h.destroy=function(){if(e.$mouseHandler.isMousePressed)return;e.keyBinding.removeKeyboardHandler(m),n.widgetManager.removeLineWidget(h),e.off("changeSelection",h.destroy),e.off("changeSession",h.destroy),e.off("mouseup",h.destroy),e.off("change",h.destroy)},e.keyBinding.addKeyboardHandler(m),e.on("changeSelection",h.destroy),e.on("changeSession",h.destroy),e.on("mouseup",h.destroy),e.on("change",h.destroy),e.session.widgetManager.addLineWidget(h),h.el.onmousedown=e.focus.bind(e),e.renderer.scrollCursorIntoView(null,.5,{bottom:h.el.offsetHeight})},i.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n","error_marker.css",!1)}),ace.define("ace/ace",["require","exports","module","ace/lib/dom","ace/range","ace/editor","ace/edit_session","ace/undomanager","ace/virtual_renderer","ace/worker/worker_client","ace/keyboard/hash_handler","ace/placeholder","ace/multi_select","ace/mode/folding/fold_mode","ace/theme/textmate","ace/ext/error_marker","ace/config","ace/loader_build"],function(e,t,n){"use strict";e("./loader_build")(t);var r=e("./lib/dom"),i=e("./range").Range,s=e("./editor").Editor,o=e("./edit_session").EditSession,u=e("./undomanager").UndoManager,a=e("./virtual_renderer").VirtualRenderer;e("./worker/worker_client"),e("./keyboard/hash_handler"),e("./placeholder"),e("./multi_select"),e("./mode/folding/fold_mode"),e("./theme/textmate"),e("./ext/error_marker"),t.config=e("./config"),t.edit=function(e,n){if(typeof e=="string"){var i=e;e=document.getElementById(i);if(!e)throw new Error("ace.edit can't find div #"+i)}if(e&&e.env&&e.env.editor instanceof s)return e.env.editor;var o="";if(e&&/input|textarea/i.test(e.tagName)){var u=e;o=u.value,e=r.createElement("pre"),u.parentNode.replaceChild(e,u)}else e&&(o=e.textContent,e.innerHTML="");var f=t.createEditSession(o),l=new s(new a(e),f,n),c={document:f,editor:l,onResize:l.resize.bind(l,null)};return u&&(c.textarea=u),l.on("destroy",function(){c.editor.container.env=null}),l.container.env=l.env=c,l},t.createEditSession=function(e,t){var n=new o(e,t);return n.setUndoManager(new u),n},t.Range=i,t.Editor=s,t.EditSession=o,t.UndoManager=u,t.VirtualRenderer=a,t.version=t.config.version});            (function() {
                ace.require(["ace/ace"], function(a) {
                    if (a) {
                        a.config.init(true);
                        a.define = ace.define;
                    }
                    if (!window.ace)
                        window.ace = a;
                    for (var key in a) if (a.hasOwnProperty(key))
                        window.ace[key] = a[key];
                    window.ace["default"] = window.ace;
                    if (typeof module == "object" && typeof exports == "object" && module) {
                        module.exports = window.ace;
                    }
                });
            })();
        /* global kijs, this, ace */

// --------------------------------------------------------------
// kijs.gui.field.AceEditor
// --------------------------------------------------------------
// Text/Sourcecode Editor
kijs.gui.field.AceEditor = class kijs_gui_field_AceEditor extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    constructor(config={}) {
        super(false);

        this._aceEditor = null;
        this._aceEditorNode = null;
        this._mode = 'javascript';
        this._theme = null;
        this._value = '';
        this._valueTrimEnable = true;
        this._previousChangeValue = '';

        this._dom.clsAdd('kijs-field-aceeditor');

       // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            mode: true,          // 'javascript' (Default), 'json', 'css', 'html', 'php', 'mysql', 'plain_text' (weitere siehe Ordner kijs\lib\ace)
            theme: true,         // (siehe Ordner kijs\lib\ace)
            valueTrimEnable: true, // Sollen Leerzeichen am Anfang und Ende des Values automatisch entfernt werden?
            virtualKeyboardPolicy: { target: 'virtualKeyboardPolicy' }
        });

        // Listeners
        this.on('afterResize', this.#onAfterResize, this);
        this.on('input', this.#onInput, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }
    }



    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------
    get hasFocus() { return this._aceEditorNode.firstChild === document.activeElement; }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    get mode() { return this._mode; }
    set mode(val) { this._mode = val; }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        if (this._aceEditor) {
            this._aceEditor.setReadOnly(!!val);
        }
    }

    get theme() { return this._theme; }
    set theme(val) {
        this._theme = val;
        if (this._aceEditor) {
            this._aceEditor.setTheme('ace/theme/' + val);
        }
    }

    // overwrite
    get value() {
        let val = '';
        if (this._aceEditor) {
            val = this._aceEditor.getValue();
        } else {
            val = kijs.toString(this._value);
        }
        if (this._valueTrimEnable) {
            val = val.trim();
        }
        return val;
    }
    set value(val) {
        val = kijs.toString(val);
        this._value = val;
        this._previousChangeValue = val;
        if (this._aceEditor) {
            this._aceEditor.setValue(val, 1);
        }
    }

    get valueTrimEnable() { return this._valueTrimEnable; }
    set valueTrimEnable(val) { this._valueTrimEnable = !!val; }

    /**
     * Die virtual keyboard policy bestimmt, ob beim focus die virtuelle
     * Tastatur geöffnet wird ('auto', default) oder nicht ('manual'). (Nur Mobile, Chrome)
     */
    get virtualKeyboardPolicy() {
        return this._aceEditorNode.firstChild.virtualKeyboardPolicy;
    }
    set virtualKeyboardPolicy(val) {
        this._aceEditorNode.firstChild.virtualKeyboardPolicy = val;
    }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);
        if (this._aceEditor) {
            this._aceEditor.setReadOnly(!!val);
        }
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {undefined}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        if (this._aceEditor) {
            this._aceEditor.focus();
            if (selectText) {
                this._aceEditor.selectAll();
            }
        }
        return false;
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // aceEditor erstellen
        if (!this._aceEditor) {
            this._aceEditorNode = document.createElement('div');
            this._inputWrapperDom.node.appendChild(this._aceEditorNode);

            this._aceEditor = ace.edit(this._aceEditorNode);
            let inputNode = this._aceEditorNode.firstChild;
            inputNode.id = this._inputId;

            // Zeitverzögert den Listener erstellen
            kijs.defer(function() {
                this._aceEditor.on('change', () => { this.raiseEvent('input'); });
                this._aceEditor.getSession().on('changeAnnotation', () => { this.#onAnnotationChange(); });

                kijs.Dom.addEventListener('blur', inputNode, this.#onInputNodeBlur, this);
            }, 200, this);

            this._aceEditor.setHighlightActiveLine(false);
            //this._aceEditor.$blockScrolling = Infinity;

            if (this._theme) {
                this._aceEditor.setTheme('ace/theme/' + this._theme);
            } else {
                if (kijs.Dom.themeGet() === 'dark') {
                    this._aceEditor.setTheme('ace/theme/ambiance');
                } else {
                    this._aceEditor.setTheme('');
                }
            }
            if (this._mode) {
                this._aceEditor.session.setMode('ace/mode/' + this._mode);
            }

            this._aceEditor.setReadOnly(this.readOnly || this.disabled);

            this.value = this._value ? this._value : '';
        } else {
            this._inputWrapperDom.node.appendChild(this._aceEditorNode);
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }


    // PROTECTED
    // overwrite
    _validationRules(value, ignoreEmpty) {
        if (ignoreEmpty && kijs.isEmpty(value)) {
            return;
        }

        super._validationRules(value, ignoreEmpty);

        // Fehler des Editors auch übernehmen
        if (this._aceEditor) {
            const annot = this._aceEditor.session.getAnnotations();
            for (let key in annot) {
                if (annot.hasOwnProperty(key)) {
                    this._errors.push("'" + annot[key].text + "'" + ' in Zeile ' + (annot[key].row+1));
                }
            }
        }
    }


    // PRIVATE
    // LISTENERS
    #onAfterResize(e) {
        if (this._aceEditor) {
            this._aceEditor.resize();
        }
    }

    #onAnnotationChange() {
        if (this._value) {
            this.validate();
        }
    }

    #onInput() {
        this.validate();
    }


    #onInputNodeBlur() {
        if (this.value !== this._previousChangeValue) {
            this.raiseEvent('change', { value: this.value, oldValue: this._previousChangeValue });
            this._previousChangeValue = this.value;
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    // overwrite
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        kijs.Dom.removeEventListener('change', this._aceEditorNode.firstChild, this);

        // Elemente/DOM-Objekte entladen
        this._aceEditor.destroy();
        this._aceEditor.container.remove();

        // Variablen (Objekte/Arrays) leeren
        this._aceEditor = null;
        this._aceEditorNode = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.Quill=e():t.Quill=e()}("undefined"!=typeof self?self:this,function(){return function(t){function e(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,e),o.l=!0,o.exports}var n={};return e.m=t,e.c=n,e.d=function(t,n,r){e.o(t,n)||Object.defineProperty(t,n,{configurable:!1,enumerable:!0,get:r})},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},e.p="",e(e.s=45)}([function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(17),o=n(18),i=n(19),l=n(48),a=n(49),s=n(50),u=n(51),c=n(52),f=n(11),h=n(29),p=n(30),d=n(28),y=n(1),v={Scope:y.Scope,create:y.create,find:y.find,query:y.query,register:y.register,Container:r.default,Format:o.default,Leaf:i.default,Embed:u.default,Scroll:l.default,Block:s.default,Inline:a.default,Text:c.default,Attributor:{Attribute:f.default,Class:h.default,Style:p.default,Store:d.default}};e.default=v},function(t,e,n){"use strict";function r(t,e){var n=i(t);if(null==n)throw new s("Unable to create "+t+" blot");var r=n;return new r(t instanceof Node||t.nodeType===Node.TEXT_NODE?t:r.create(e),e)}function o(t,n){return void 0===n&&(n=!1),null==t?null:null!=t[e.DATA_KEY]?t[e.DATA_KEY].blot:n?o(t.parentNode,n):null}function i(t,e){void 0===e&&(e=p.ANY);var n;if("string"==typeof t)n=h[t]||u[t];else if(t instanceof Text||t.nodeType===Node.TEXT_NODE)n=h.text;else if("number"==typeof t)t&p.LEVEL&p.BLOCK?n=h.block:t&p.LEVEL&p.INLINE&&(n=h.inline);else if(t instanceof HTMLElement){var r=(t.getAttribute("class")||"").split(/\s+/);for(var o in r)if(n=c[r[o]])break;n=n||f[t.tagName]}return null==n?null:e&p.LEVEL&n.scope&&e&p.TYPE&n.scope?n:null}function l(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];if(t.length>1)return t.map(function(t){return l(t)});var n=t[0];if("string"!=typeof n.blotName&&"string"!=typeof n.attrName)throw new s("Invalid definition");if("abstract"===n.blotName)throw new s("Cannot register abstract class");if(h[n.blotName||n.attrName]=n,"string"==typeof n.keyName)u[n.keyName]=n;else if(null!=n.className&&(c[n.className]=n),null!=n.tagName){Array.isArray(n.tagName)?n.tagName=n.tagName.map(function(t){return t.toUpperCase()}):n.tagName=n.tagName.toUpperCase();var r=Array.isArray(n.tagName)?n.tagName:[n.tagName];r.forEach(function(t){null!=f[t]&&null!=n.className||(f[t]=n)})}return n}var a=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var s=function(t){function e(e){var n=this;return e="[Parchment] "+e,n=t.call(this,e)||this,n.message=e,n.name=n.constructor.name,n}return a(e,t),e}(Error);e.ParchmentError=s;var u={},c={},f={},h={};e.DATA_KEY="__blot";var p;!function(t){t[t.TYPE=3]="TYPE",t[t.LEVEL=12]="LEVEL",t[t.ATTRIBUTE=13]="ATTRIBUTE",t[t.BLOT=14]="BLOT",t[t.INLINE=7]="INLINE",t[t.BLOCK=11]="BLOCK",t[t.BLOCK_BLOT=10]="BLOCK_BLOT",t[t.INLINE_BLOT=6]="INLINE_BLOT",t[t.BLOCK_ATTRIBUTE=9]="BLOCK_ATTRIBUTE",t[t.INLINE_ATTRIBUTE=5]="INLINE_ATTRIBUTE",t[t.ANY=15]="ANY"}(p=e.Scope||(e.Scope={})),e.create=r,e.find=o,e.query=i,e.register=l},function(t,e){"use strict";var n=Object.prototype.hasOwnProperty,r=Object.prototype.toString,o=Object.defineProperty,i=Object.getOwnPropertyDescriptor,l=function(t){return"function"==typeof Array.isArray?Array.isArray(t):"[object Array]"===r.call(t)},a=function(t){if(!t||"[object Object]"!==r.call(t))return!1;var e=n.call(t,"constructor"),o=t.constructor&&t.constructor.prototype&&n.call(t.constructor.prototype,"isPrototypeOf");if(t.constructor&&!e&&!o)return!1;var i;for(i in t);return void 0===i||n.call(t,i)},s=function(t,e){o&&"__proto__"===e.name?o(t,e.name,{enumerable:!0,configurable:!0,value:e.newValue,writable:!0}):t[e.name]=e.newValue},u=function(t,e){if("__proto__"===e){if(!n.call(t,e))return;if(i)return i(t,e).value}return t[e]};t.exports=function t(){var e,n,r,o,i,c,f=arguments[0],h=1,p=arguments.length,d=!1;for("boolean"==typeof f&&(d=f,f=arguments[1]||{},h=2),(null==f||"object"!=typeof f&&"function"!=typeof f)&&(f={});h<p;++h)if(null!=(e=arguments[h]))for(n in e)r=u(f,n),o=u(e,n),f!==o&&(d&&o&&(a(o)||(i=l(o)))?(i?(i=!1,c=r&&l(r)?r:[]):c=r&&a(r)?r:{},s(f,{name:n,newValue:t(d,c,o)})):void 0!==o&&s(f,{name:n,newValue:o}));return f}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==t?e:("function"==typeof t.formats&&(e=(0,f.default)(e,t.formats())),null==t.parent||"scroll"==t.parent.blotName||t.parent.statics.scope!==t.statics.scope?e:a(t.parent,e))}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.BlockEmbed=e.bubbleFormats=void 0;var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},c=n(2),f=r(c),h=n(4),p=r(h),d=n(0),y=r(d),v=n(14),b=r(v),g=n(5),m=r(g),_=n(8),O=r(_),w=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),s(e,[{key:"attach",value:function(){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"attach",this).call(this),this.attributes=new y.default.Attributor.Store(this.domNode)}},{key:"delta",value:function(){return(new p.default).insert(this.value(),(0,f.default)(this.formats(),this.attributes.values()))}},{key:"format",value:function(t,e){var n=y.default.query(t,y.default.Scope.BLOCK_ATTRIBUTE);null!=n&&this.attributes.attribute(n,e)}},{key:"formatAt",value:function(t,e,n,r){this.format(n,r)}},{key:"insertAt",value:function(t,n,r){if("string"==typeof n&&n.endsWith("\n")){var o=y.default.create(x.blotName);this.parent.insertBefore(o,0===t?this:this.next),o.insertAt(0,n.slice(0,-1))}else u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertAt",this).call(this,t,n,r)}}]),e}(y.default.Embed);w.scope=y.default.Scope.BLOCK_BLOT;var x=function(t){function e(t){o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.cache={},n}return l(e,t),s(e,[{key:"delta",value:function(){return null==this.cache.delta&&(this.cache.delta=this.descendants(y.default.Leaf).reduce(function(t,e){return 0===e.length()?t:t.insert(e.value(),a(e))},new p.default).insert("\n",a(this))),this.cache.delta}},{key:"deleteAt",value:function(t,n){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"deleteAt",this).call(this,t,n),this.cache={}}},{key:"formatAt",value:function(t,n,r,o){n<=0||(y.default.query(r,y.default.Scope.BLOCK)?t+n===this.length()&&this.format(r,o):u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"formatAt",this).call(this,t,Math.min(n,this.length()-t-1),r,o),this.cache={})}},{key:"insertAt",value:function(t,n,r){if(null!=r)return u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertAt",this).call(this,t,n,r);if(0!==n.length){var o=n.split("\n"),i=o.shift();i.length>0&&(t<this.length()-1||null==this.children.tail?u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertAt",this).call(this,Math.min(t,this.length()-1),i):this.children.tail.insertAt(this.children.tail.length(),i),this.cache={});var l=this;o.reduce(function(t,e){return l=l.split(t,!0),l.insertAt(0,e),e.length},t+i.length)}}},{key:"insertBefore",value:function(t,n){var r=this.children.head;u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertBefore",this).call(this,t,n),r instanceof b.default&&r.remove(),this.cache={}}},{key:"length",value:function(){return null==this.cache.length&&(this.cache.length=u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"length",this).call(this)+1),this.cache.length}},{key:"moveChildren",value:function(t,n){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"moveChildren",this).call(this,t,n),this.cache={}}},{key:"optimize",value:function(t){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"optimize",this).call(this,t),this.cache={}}},{key:"path",value:function(t){return u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"path",this).call(this,t,!0)}},{key:"removeChild",value:function(t){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"removeChild",this).call(this,t),this.cache={}}},{key:"split",value:function(t){var n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&(0===t||t>=this.length()-1)){var r=this.clone();return 0===t?(this.parent.insertBefore(r,this),this):(this.parent.insertBefore(r,this.next),r)}var o=u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"split",this).call(this,t,n);return this.cache={},o}}]),e}(y.default.Block);x.blotName="block",x.tagName="P",x.defaultChild="break",x.allowedChildren=[m.default,y.default.Embed,O.default],e.bubbleFormats=a,e.BlockEmbed=w,e.default=x},function(t,e,n){var r=n(54),o=n(12),i=n(2),l=n(20),a=String.fromCharCode(0),s=function(t){Array.isArray(t)?this.ops=t:null!=t&&Array.isArray(t.ops)?this.ops=t.ops:this.ops=[]};s.prototype.insert=function(t,e){var n={};return 0===t.length?this:(n.insert=t,null!=e&&"object"==typeof e&&Object.keys(e).length>0&&(n.attributes=e),this.push(n))},s.prototype.delete=function(t){return t<=0?this:this.push({delete:t})},s.prototype.retain=function(t,e){if(t<=0)return this;var n={retain:t};return null!=e&&"object"==typeof e&&Object.keys(e).length>0&&(n.attributes=e),this.push(n)},s.prototype.push=function(t){var e=this.ops.length,n=this.ops[e-1];if(t=i(!0,{},t),"object"==typeof n){if("number"==typeof t.delete&&"number"==typeof n.delete)return this.ops[e-1]={delete:n.delete+t.delete},this;if("number"==typeof n.delete&&null!=t.insert&&(e-=1,"object"!=typeof(n=this.ops[e-1])))return this.ops.unshift(t),this;if(o(t.attributes,n.attributes)){if("string"==typeof t.insert&&"string"==typeof n.insert)return this.ops[e-1]={insert:n.insert+t.insert},"object"==typeof t.attributes&&(this.ops[e-1].attributes=t.attributes),this;if("number"==typeof t.retain&&"number"==typeof n.retain)return this.ops[e-1]={retain:n.retain+t.retain},"object"==typeof t.attributes&&(this.ops[e-1].attributes=t.attributes),this}}return e===this.ops.length?this.ops.push(t):this.ops.splice(e,0,t),this},s.prototype.chop=function(){var t=this.ops[this.ops.length-1];return t&&t.retain&&!t.attributes&&this.ops.pop(),this},s.prototype.filter=function(t){return this.ops.filter(t)},s.prototype.forEach=function(t){this.ops.forEach(t)},s.prototype.map=function(t){return this.ops.map(t)},s.prototype.partition=function(t){var e=[],n=[];return this.forEach(function(r){(t(r)?e:n).push(r)}),[e,n]},s.prototype.reduce=function(t,e){return this.ops.reduce(t,e)},s.prototype.changeLength=function(){return this.reduce(function(t,e){return e.insert?t+l.length(e):e.delete?t-e.delete:t},0)},s.prototype.length=function(){return this.reduce(function(t,e){return t+l.length(e)},0)},s.prototype.slice=function(t,e){t=t||0,"number"!=typeof e&&(e=1/0);for(var n=[],r=l.iterator(this.ops),o=0;o<e&&r.hasNext();){var i;o<t?i=r.next(t-o):(i=r.next(e-o),n.push(i)),o+=l.length(i)}return new s(n)},s.prototype.compose=function(t){var e=l.iterator(this.ops),n=l.iterator(t.ops),r=[],i=n.peek();if(null!=i&&"number"==typeof i.retain&&null==i.attributes){for(var a=i.retain;"insert"===e.peekType()&&e.peekLength()<=a;)a-=e.peekLength(),r.push(e.next());i.retain-a>0&&n.next(i.retain-a)}for(var u=new s(r);e.hasNext()||n.hasNext();)if("insert"===n.peekType())u.push(n.next());else if("delete"===e.peekType())u.push(e.next());else{var c=Math.min(e.peekLength(),n.peekLength()),f=e.next(c),h=n.next(c);if("number"==typeof h.retain){var p={};"number"==typeof f.retain?p.retain=c:p.insert=f.insert;var d=l.attributes.compose(f.attributes,h.attributes,"number"==typeof f.retain);if(d&&(p.attributes=d),u.push(p),!n.hasNext()&&o(u.ops[u.ops.length-1],p)){var y=new s(e.rest());return u.concat(y).chop()}}else"number"==typeof h.delete&&"number"==typeof f.retain&&u.push(h)}return u.chop()},s.prototype.concat=function(t){var e=new s(this.ops.slice());return t.ops.length>0&&(e.push(t.ops[0]),e.ops=e.ops.concat(t.ops.slice(1))),e},s.prototype.diff=function(t,e){if(this.ops===t.ops)return new s;var n=[this,t].map(function(e){return e.map(function(n){if(null!=n.insert)return"string"==typeof n.insert?n.insert:a;var r=e===t?"on":"with";throw new Error("diff() called "+r+" non-document")}).join("")}),i=new s,u=r(n[0],n[1],e),c=l.iterator(this.ops),f=l.iterator(t.ops);return u.forEach(function(t){for(var e=t[1].length;e>0;){var n=0;switch(t[0]){case r.INSERT:n=Math.min(f.peekLength(),e),i.push(f.next(n));break;case r.DELETE:n=Math.min(e,c.peekLength()),c.next(n),i.delete(n);break;case r.EQUAL:n=Math.min(c.peekLength(),f.peekLength(),e);var a=c.next(n),s=f.next(n);o(a.insert,s.insert)?i.retain(n,l.attributes.diff(a.attributes,s.attributes)):i.push(s).delete(n)}e-=n}}),i.chop()},s.prototype.eachLine=function(t,e){e=e||"\n";for(var n=l.iterator(this.ops),r=new s,o=0;n.hasNext();){if("insert"!==n.peekType())return;var i=n.peek(),a=l.length(i)-n.peekLength(),u="string"==typeof i.insert?i.insert.indexOf(e,a)-a:-1;if(u<0)r.push(n.next());else if(u>0)r.push(n.next(u));else{if(!1===t(r,n.next(1).attributes||{},o))return;o+=1,r=new s}}r.length()>0&&t(r,{},o)},s.prototype.transform=function(t,e){if(e=!!e,"number"==typeof t)return this.transformPosition(t,e);for(var n=l.iterator(this.ops),r=l.iterator(t.ops),o=new s;n.hasNext()||r.hasNext();)if("insert"!==n.peekType()||!e&&"insert"===r.peekType())if("insert"===r.peekType())o.push(r.next());else{var i=Math.min(n.peekLength(),r.peekLength()),a=n.next(i),u=r.next(i);if(a.delete)continue;u.delete?o.push(u):o.retain(i,l.attributes.transform(a.attributes,u.attributes,e))}else o.retain(l.length(n.next()));return o.chop()},s.prototype.transformPosition=function(t,e){e=!!e;for(var n=l.iterator(this.ops),r=0;n.hasNext()&&r<=t;){var o=n.peekLength(),i=n.peekType();n.next(),"delete"!==i?("insert"===i&&(r<t||!e)&&(t+=o),r+=o):t-=Math.min(o,t-r)}return t},t.exports=s},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=n(8),c=r(u),f=n(0),h=r(f),p=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),a(e,[{key:"formatAt",value:function(t,n,r,o){if(e.compare(this.statics.blotName,r)<0&&h.default.query(r,h.default.Scope.BLOT)){var i=this.isolate(t,n);o&&i.wrap(r,o)}else s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"formatAt",this).call(this,t,n,r,o)}},{key:"optimize",value:function(t){if(s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"optimize",this).call(this,t),this.parent instanceof e&&e.compare(this.statics.blotName,this.parent.statics.blotName)>0){var n=this.parent.isolate(this.offset(),this.length());this.moveChildren(n),n.wrap(this)}}}],[{key:"compare",value:function(t,n){var r=e.order.indexOf(t),o=e.order.indexOf(n);return r>=0||o>=0?r-o:t===n?0:t<n?-1:1}}]),e}(h.default.Inline);p.allowedChildren=[p,h.default.Embed,c.default],p.order=["cursor","inline","underline","strike","italic","bold","script","link","code"],e.default=p},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){if(e=(0,N.default)(!0,{container:t,modules:{clipboard:!0,keyboard:!0,history:!0}},e),e.theme&&e.theme!==S.DEFAULTS.theme){if(e.theme=S.import("themes/"+e.theme),null==e.theme)throw new Error("Invalid theme "+e.theme+". Did you register it?")}else e.theme=T.default;var n=(0,N.default)(!0,{},e.theme.DEFAULTS);[n,e].forEach(function(t){t.modules=t.modules||{},Object.keys(t.modules).forEach(function(e){!0===t.modules[e]&&(t.modules[e]={})})});var r=Object.keys(n.modules).concat(Object.keys(e.modules)),o=r.reduce(function(t,e){var n=S.import("modules/"+e);return null==n?P.error("Cannot load "+e+" module. Are you sure you registered it?"):t[e]=n.DEFAULTS||{},t},{});return null!=e.modules&&e.modules.toolbar&&e.modules.toolbar.constructor!==Object&&(e.modules.toolbar={container:e.modules.toolbar}),e=(0,N.default)(!0,{},S.DEFAULTS,{modules:o},n,e),["bounds","container","scrollingContainer"].forEach(function(t){"string"==typeof e[t]&&(e[t]=document.querySelector(e[t]))}),e.modules=Object.keys(e.modules).reduce(function(t,n){return e.modules[n]&&(t[n]=e.modules[n]),t},{}),e}function a(t,e,n,r){if(this.options.strict&&!this.isEnabled()&&e===g.default.sources.USER)return new d.default;var o=null==n?null:this.getSelection(),i=this.editor.delta,l=t();if(null!=o&&(!0===n&&(n=o.index),null==r?o=u(o,l,e):0!==r&&(o=u(o,n,r,e)),this.setSelection(o,g.default.sources.SILENT)),l.length()>0){var a,s=[g.default.events.TEXT_CHANGE,l,i,e];if((a=this.emitter).emit.apply(a,[g.default.events.EDITOR_CHANGE].concat(s)),e!==g.default.sources.SILENT){var c;(c=this.emitter).emit.apply(c,s)}}return l}function s(t,e,n,r,o){var i={};return"number"==typeof t.index&&"number"==typeof t.length?"number"!=typeof e?(o=r,r=n,n=e,e=t.length,t=t.index):(e=t.length,t=t.index):"number"!=typeof e&&(o=r,r=n,n=e,e=0),"object"===(void 0===n?"undefined":c(n))?(i=n,o=r):"string"==typeof n&&(null!=r?i[n]=r:o=n),o=o||g.default.sources.API,[t,e,i,o]}function u(t,e,n,r){if(null==t)return null;var o=void 0,i=void 0;if(e instanceof d.default){var l=[t.index,t.index+t.length].map(function(t){return e.transformPosition(t,r!==g.default.sources.USER)}),a=f(l,2);o=a[0],i=a[1]}else{var s=[t.index,t.index+t.length].map(function(t){return t<e||t===e&&r===g.default.sources.USER?t:n>=0?t+n:Math.max(e,t+n)}),u=f(s,2);o=u[0],i=u[1]}return new x.Range(o,i-o)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.overload=e.expandConfig=void 0;var c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},f=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),h=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}();n(53);var p=n(4),d=r(p),y=n(57),v=r(y),b=n(9),g=r(b),m=n(7),_=r(m),O=n(0),w=r(O),x=n(22),k=r(x),E=n(2),N=r(E),j=n(10),A=r(j),q=n(32),T=r(q),P=(0,A.default)("quill"),S=function(){function t(e){var n=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(i(this,t),this.options=l(e,r),this.container=this.options.container,null==this.container)return P.error("Invalid Quill container",e);this.options.debug&&t.debug(this.options.debug);var o=this.container.innerHTML.trim();this.container.classList.add("ql-container"),this.container.innerHTML="",this.container.__quill=this,this.root=this.addContainer("ql-editor"),this.root.classList.add("ql-blank"),this.root.setAttribute("data-gramm",!1),this.scrollingContainer=this.options.scrollingContainer||this.root,this.emitter=new g.default,this.scroll=w.default.create(this.root,{emitter:this.emitter,whitelist:this.options.formats}),this.editor=new v.default(this.scroll),this.selection=new k.default(this.scroll,this.emitter),this.theme=new this.options.theme(this,this.options),this.keyboard=this.theme.addModule("keyboard"),this.clipboard=this.theme.addModule("clipboard"),this.history=this.theme.addModule("history"),this.theme.init(),this.emitter.on(g.default.events.EDITOR_CHANGE,function(t){t===g.default.events.TEXT_CHANGE&&n.root.classList.toggle("ql-blank",n.editor.isBlank())}),this.emitter.on(g.default.events.SCROLL_UPDATE,function(t,e){var r=n.selection.lastRange,o=r&&0===r.length?r.index:void 0;a.call(n,function(){return n.editor.update(null,e,o)},t)});var s=this.clipboard.convert("<div class='ql-editor' style=\"white-space: normal;\">"+o+"<p><br></p></div>");this.setContents(s),this.history.clear(),this.options.placeholder&&this.root.setAttribute("data-placeholder",this.options.placeholder),this.options.readOnly&&this.disable()}return h(t,null,[{key:"debug",value:function(t){!0===t&&(t="log"),A.default.level(t)}},{key:"find",value:function(t){return t.__quill||w.default.find(t)}},{key:"import",value:function(t){return null==this.imports[t]&&P.error("Cannot import "+t+". Are you sure it was registered?"),this.imports[t]}},{key:"register",value:function(t,e){var n=this,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if("string"!=typeof t){var o=t.attrName||t.blotName;"string"==typeof o?this.register("formats/"+o,t,e):Object.keys(t).forEach(function(r){n.register(r,t[r],e)})}else null==this.imports[t]||r||P.warn("Overwriting "+t+" with",e),this.imports[t]=e,(t.startsWith("blots/")||t.startsWith("formats/"))&&"abstract"!==e.blotName?w.default.register(e):t.startsWith("modules")&&"function"==typeof e.register&&e.register()}}]),h(t,[{key:"addContainer",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if("string"==typeof t){var n=t;t=document.createElement("div"),t.classList.add(n)}return this.container.insertBefore(t,e),t}},{key:"blur",value:function(){this.selection.setRange(null)}},{key:"deleteText",value:function(t,e,n){var r=this,o=s(t,e,n),i=f(o,4);return t=i[0],e=i[1],n=i[3],a.call(this,function(){return r.editor.deleteText(t,e)},n,t,-1*e)}},{key:"disable",value:function(){this.enable(!1)}},{key:"enable",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.scroll.enable(t),this.container.classList.toggle("ql-disabled",!t)}},{key:"focus",value:function(){var t=this.scrollingContainer.scrollTop;this.selection.focus(),this.scrollingContainer.scrollTop=t,this.scrollIntoView()}},{key:"format",value:function(t,e){var n=this,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:g.default.sources.API;return a.call(this,function(){var r=n.getSelection(!0),i=new d.default;if(null==r)return i;if(w.default.query(t,w.default.Scope.BLOCK))i=n.editor.formatLine(r.index,r.length,o({},t,e));else{if(0===r.length)return n.selection.format(t,e),i;i=n.editor.formatText(r.index,r.length,o({},t,e))}return n.setSelection(r,g.default.sources.SILENT),i},r)}},{key:"formatLine",value:function(t,e,n,r,o){var i=this,l=void 0,u=s(t,e,n,r,o),c=f(u,4);return t=c[0],e=c[1],l=c[2],o=c[3],a.call(this,function(){return i.editor.formatLine(t,e,l)},o,t,0)}},{key:"formatText",value:function(t,e,n,r,o){var i=this,l=void 0,u=s(t,e,n,r,o),c=f(u,4);return t=c[0],e=c[1],l=c[2],o=c[3],a.call(this,function(){return i.editor.formatText(t,e,l)},o,t,0)}},{key:"getBounds",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=void 0;n="number"==typeof t?this.selection.getBounds(t,e):this.selection.getBounds(t.index,t.length);var r=this.container.getBoundingClientRect();return{bottom:n.bottom-r.top,height:n.height,left:n.left-r.left,right:n.right-r.left,top:n.top-r.top,width:n.width}}},{key:"getContents",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getLength()-t,n=s(t,e),r=f(n,2);return t=r[0],e=r[1],this.editor.getContents(t,e)}},{key:"getFormat",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.getSelection(!0),e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return"number"==typeof t?this.editor.getFormat(t,e):this.editor.getFormat(t.index,t.length)}},{key:"getIndex",value:function(t){return t.offset(this.scroll)}},{key:"getLength",value:function(){return this.scroll.length()}},{key:"getLeaf",value:function(t){return this.scroll.leaf(t)}},{key:"getLine",value:function(t){return this.scroll.line(t)}},{key:"getLines",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE;return"number"!=typeof t?this.scroll.lines(t.index,t.length):this.scroll.lines(t,e)}},{key:"getModule",value:function(t){return this.theme.modules[t]}},{key:"getSelection",value:function(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]&&this.focus(),this.update(),this.selection.getRange()[0]}},{key:"getText",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.getLength()-t,n=s(t,e),r=f(n,2);return t=r[0],e=r[1],this.editor.getText(t,e)}},{key:"hasFocus",value:function(){return this.selection.hasFocus()}},{key:"insertEmbed",value:function(e,n,r){var o=this,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t.sources.API;return a.call(this,function(){return o.editor.insertEmbed(e,n,r)},i,e)}},{key:"insertText",value:function(t,e,n,r,o){var i=this,l=void 0,u=s(t,0,n,r,o),c=f(u,4);return t=c[0],l=c[2],o=c[3],a.call(this,function(){return i.editor.insertText(t,e,l)},o,t,e.length)}},{key:"isEnabled",value:function(){return!this.container.classList.contains("ql-disabled")}},{key:"off",value:function(){return this.emitter.off.apply(this.emitter,arguments)}},{key:"on",value:function(){return this.emitter.on.apply(this.emitter,arguments)}},{key:"once",value:function(){return this.emitter.once.apply(this.emitter,arguments)}},{key:"pasteHTML",value:function(t,e,n){this.clipboard.dangerouslyPasteHTML(t,e,n)}},{key:"removeFormat",value:function(t,e,n){var r=this,o=s(t,e,n),i=f(o,4);return t=i[0],e=i[1],n=i[3],a.call(this,function(){return r.editor.removeFormat(t,e)},n,t)}},{key:"scrollIntoView",value:function(){this.selection.scrollIntoView(this.scrollingContainer)}},{key:"setContents",value:function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.default.sources.API;return a.call(this,function(){t=new d.default(t);var n=e.getLength(),r=e.editor.deleteText(0,n),o=e.editor.applyDelta(t),i=o.ops[o.ops.length-1];return null!=i&&"string"==typeof i.insert&&"\n"===i.insert[i.insert.length-1]&&(e.editor.deleteText(e.getLength()-1,1),o.delete(1)),r.compose(o)},n)}},{key:"setSelection",value:function(e,n,r){if(null==e)this.selection.setRange(null,n||t.sources.API);else{var o=s(e,n,r),i=f(o,4);e=i[0],n=i[1],r=i[3],this.selection.setRange(new x.Range(e,n),r),r!==g.default.sources.SILENT&&this.selection.scrollIntoView(this.scrollingContainer)}}},{key:"setText",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.default.sources.API,n=(new d.default).insert(t);return this.setContents(n,e)}},{key:"update",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:g.default.sources.USER,e=this.scroll.update(t);return this.selection.update(t),e}},{key:"updateContents",value:function(t){var e=this,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:g.default.sources.API;return a.call(this,function(){return t=new d.default(t),e.editor.applyDelta(t,n)},n,!0)}}]),t}();S.DEFAULTS={bounds:null,formats:null,modules:{},placeholder:"",readOnly:!1,scrollingContainer:null,strict:!0,theme:"default"},S.events=g.default.events,S.sources=g.default.sources,S.version="1.3.7",S.imports={delta:d.default,parchment:w.default,"core/module":_.default,"core/theme":T.default},e.expandConfig=l,e.overload=s,e.default=S},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r(this,t),this.quill=e,this.options=n};o.DEFAULTS={},e.default=o},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=n(0),a=function(t){return t&&t.__esModule?t:{default:t}}(l),s=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),e}(a.default.Text);e.default=s},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=n(58),c=r(u),f=n(10),h=r(f),p=(0,h.default)("quill:events");["selectionchange","mousedown","mouseup","click"].forEach(function(t){document.addEventListener(t,function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];[].slice.call(document.querySelectorAll(".ql-container")).forEach(function(t){if(t.__quill&&t.__quill.emitter){var n;(n=t.__quill.emitter).handleDOM.apply(n,e)}})})});var d=function(t){function e(){o(this,e);var t=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));return t.listeners={},t.on("error",p.error),t}return l(e,t),a(e,[{key:"emit",value:function(){p.log.apply(p,arguments),s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"emit",this).apply(this,arguments)}},{key:"handleDOM",value:function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];(this.listeners[t.type]||[]).forEach(function(e){var r=e.node,o=e.handler;(t.target===r||r.contains(t.target))&&o.apply(void 0,[t].concat(n))})}},{key:"listenDOM",value:function(t,e,n){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push({node:e,handler:n})}}]),e}(c.default);d.events={EDITOR_CHANGE:"editor-change",SCROLL_BEFORE_UPDATE:"scroll-before-update",SCROLL_OPTIMIZE:"scroll-optimize",SCROLL_UPDATE:"scroll-update",SELECTION_CHANGE:"selection-change",TEXT_CHANGE:"text-change"},d.sources={API:"api",SILENT:"silent",USER:"user"},e.default=d},function(t,e,n){"use strict";function r(t){if(i.indexOf(t)<=i.indexOf(l)){for(var e,n=arguments.length,r=Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];(e=console)[t].apply(e,r)}}function o(t){return i.reduce(function(e,n){return e[n]=r.bind(console,n,t),e},{})}Object.defineProperty(e,"__esModule",{value:!0});var i=["error","warn","log","info"],l="warn";r.level=o.level=function(t){l=t},e.default=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(1),o=function(){function t(t,e,n){void 0===n&&(n={}),this.attrName=t,this.keyName=e;var o=r.Scope.TYPE&r.Scope.ATTRIBUTE;null!=n.scope?this.scope=n.scope&r.Scope.LEVEL|o:this.scope=r.Scope.ATTRIBUTE,null!=n.whitelist&&(this.whitelist=n.whitelist)}return t.keys=function(t){return[].map.call(t.attributes,function(t){return t.name})},t.prototype.add=function(t,e){return!!this.canAdd(t,e)&&(t.setAttribute(this.keyName,e),!0)},t.prototype.canAdd=function(t,e){return null!=r.query(t,r.Scope.BLOT&(this.scope|r.Scope.TYPE))&&(null==this.whitelist||("string"==typeof e?this.whitelist.indexOf(e.replace(/["']/g,""))>-1:this.whitelist.indexOf(e)>-1))},t.prototype.remove=function(t){t.removeAttribute(this.keyName)},t.prototype.value=function(t){var e=t.getAttribute(this.keyName);return this.canAdd(t,e)&&e?e:""},t}();e.default=o},function(t,e,n){function r(t){return null===t||void 0===t}function o(t){return!(!t||"object"!=typeof t||"number"!=typeof t.length)&&("function"==typeof t.copy&&"function"==typeof t.slice&&!(t.length>0&&"number"!=typeof t[0]))}function i(t,e,n){var i,c;if(r(t)||r(e))return!1;if(t.prototype!==e.prototype)return!1;if(s(t))return!!s(e)&&(t=l.call(t),e=l.call(e),u(t,e,n));if(o(t)){if(!o(e))return!1;if(t.length!==e.length)return!1;for(i=0;i<t.length;i++)if(t[i]!==e[i])return!1;return!0}try{var f=a(t),h=a(e)}catch(t){return!1}if(f.length!=h.length)return!1;for(f.sort(),h.sort(),i=f.length-1;i>=0;i--)if(f[i]!=h[i])return!1;for(i=f.length-1;i>=0;i--)if(c=f[i],!u(t[c],e[c],n))return!1;return typeof t==typeof e}var l=Array.prototype.slice,a=n(55),s=n(56),u=t.exports=function(t,e,n){return n||(n={}),t===e||(t instanceof Date&&e instanceof Date?t.getTime()===e.getTime():!t||!e||"object"!=typeof t&&"object"!=typeof e?n.strict?t===e:t==e:i(t,e,n))}},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Code=void 0;var a=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},c=n(4),f=r(c),h=n(0),p=r(h),d=n(3),y=r(d),v=n(5),b=r(v),g=n(8),m=r(g),_=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),e}(b.default);_.blotName="code",_.tagName="CODE";var O=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),s(e,[{key:"delta",value:function(){var t=this,e=this.domNode.textContent;return e.endsWith("\n")&&(e=e.slice(0,-1)),e.split("\n").reduce(function(e,n){return e.insert(n).insert("\n",t.formats())},new f.default)}},{key:"format",value:function(t,n){if(t!==this.statics.blotName||!n){var r=this.descendant(m.default,this.length()-1),o=a(r,1),i=o[0];null!=i&&i.deleteAt(i.length()-1,1),u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"format",this).call(this,t,n)}}},{key:"formatAt",value:function(t,n,r,o){if(0!==n&&null!=p.default.query(r,p.default.Scope.BLOCK)&&(r!==this.statics.blotName||o!==this.statics.formats(this.domNode))){var i=this.newlineIndex(t);if(!(i<0||i>=t+n)){var l=this.newlineIndex(t,!0)+1,a=i-l+1,s=this.isolate(l,a),u=s.next;s.format(r,o),u instanceof e&&u.formatAt(0,t-l+n-a,r,o)}}}},{key:"insertAt",value:function(t,e,n){if(null==n){var r=this.descendant(m.default,t),o=a(r,2),i=o[0],l=o[1];i.insertAt(l,e)}}},{key:"length",value:function(){var t=this.domNode.textContent.length;return this.domNode.textContent.endsWith("\n")?t:t+1}},{key:"newlineIndex",value:function(t){if(arguments.length>1&&void 0!==arguments[1]&&arguments[1])return this.domNode.textContent.slice(0,t).lastIndexOf("\n");var e=this.domNode.textContent.slice(t).indexOf("\n");return e>-1?t+e:-1}},{key:"optimize",value:function(t){this.domNode.textContent.endsWith("\n")||this.appendChild(p.default.create("text","\n")),u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"optimize",this).call(this,t);var n=this.next;null!=n&&n.prev===this&&n.statics.blotName===this.statics.blotName&&this.statics.formats(this.domNode)===n.statics.formats(n.domNode)&&(n.optimize(t),n.moveChildren(this),n.remove())}},{key:"replace",value:function(t){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"replace",this).call(this,t),[].slice.call(this.domNode.querySelectorAll("*")).forEach(function(t){var e=p.default.find(t);null==e?t.parentNode.removeChild(t):e instanceof p.default.Embed?e.remove():e.unwrap()})}}],[{key:"create",value:function(t){var n=u(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,t);return n.setAttribute("spellcheck",!1),n}},{key:"formats",value:function(){return!0}}]),e}(y.default);O.blotName="code-block",O.tagName="PRE",O.TAB="  ",e.Code=_,e.default=O},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(0),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"insertInto",value:function(t,n){0===t.children.length?a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertInto",this).call(this,t,n):this.remove()}},{key:"length",value:function(){return 0}},{key:"value",value:function(){return""}}],[{key:"value",value:function(){}}]),e}(u.default.Embed);c.blotName="break",c.tagName="BR",e.default=c},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function l(t,e){var n=document.createElement("a");n.href=t;var r=n.href.slice(0,n.href.indexOf(":"));return e.indexOf(r)>-1}Object.defineProperty(e,"__esModule",{value:!0}),e.sanitize=e.default=void 0;var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=n(5),c=function(t){return t&&t.__esModule?t:{default:t}}(u),f=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),a(e,[{key:"format",value:function(t,n){if(t!==this.statics.blotName||!n)return s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"format",this).call(this,t,n);n=this.constructor.sanitize(n),this.domNode.setAttribute("href",n)}}],[{key:"create",value:function(t){var n=s(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,t);return t=this.sanitize(t),n.setAttribute("href",t),n.setAttribute("rel","noopener noreferrer"),n.setAttribute("target","_blank"),n}},{key:"formats",value:function(t){return t.getAttribute("href")}},{key:"sanitize",value:function(t){return l(t,this.PROTOCOL_WHITELIST)?t:this.SANITIZED_URL}}]),e}(c.default);f.blotName="link",f.tagName="A",f.SANITIZED_URL="about:blank",f.PROTOCOL_WHITELIST=["http","https","mailto","tel"],e.default=f,e.sanitize=l},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){t.setAttribute(e,!("true"===t.getAttribute(e)))}Object.defineProperty(e,"__esModule",{value:!0});var l="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=n(25),u=r(s),c=n(106),f=r(c),h=0,p=function(){function t(e){var n=this;o(this,t),this.select=e,this.container=document.createElement("span"),this.buildPicker(),this.select.style.display="none",this.select.parentNode.insertBefore(this.container,this.select),this.label.addEventListener("mousedown",function(){n.togglePicker()}),this.label.addEventListener("keydown",function(t){switch(t.keyCode){case u.default.keys.ENTER:n.togglePicker();break;case u.default.keys.ESCAPE:n.escape(),t.preventDefault()}}),this.select.addEventListener("change",this.update.bind(this))}return a(t,[{key:"togglePicker",value:function(){this.container.classList.toggle("ql-expanded"),i(this.label,"aria-expanded"),i(this.options,"aria-hidden")}},{key:"buildItem",value:function(t){var e=this,n=document.createElement("span");return n.tabIndex="0",n.setAttribute("role","button"),n.classList.add("ql-picker-item"),t.hasAttribute("value")&&n.setAttribute("data-value",t.getAttribute("value")),t.textContent&&n.setAttribute("data-label",t.textContent),n.addEventListener("click",function(){e.selectItem(n,!0)}),n.addEventListener("keydown",function(t){switch(t.keyCode){case u.default.keys.ENTER:e.selectItem(n,!0),t.preventDefault();break;case u.default.keys.ESCAPE:e.escape(),t.preventDefault()}}),n}},{key:"buildLabel",value:function(){var t=document.createElement("span");return t.classList.add("ql-picker-label"),t.innerHTML=f.default,t.tabIndex="0",t.setAttribute("role","button"),t.setAttribute("aria-expanded","false"),this.container.appendChild(t),t}},{key:"buildOptions",value:function(){var t=this,e=document.createElement("span");e.classList.add("ql-picker-options"),e.setAttribute("aria-hidden","true"),e.tabIndex="-1",e.id="ql-picker-options-"+h,h+=1,this.label.setAttribute("aria-controls",e.id),this.options=e,[].slice.call(this.select.options).forEach(function(n){var r=t.buildItem(n);e.appendChild(r),!0===n.selected&&t.selectItem(r)}),this.container.appendChild(e)}},{key:"buildPicker",value:function(){var t=this;[].slice.call(this.select.attributes).forEach(function(e){t.container.setAttribute(e.name,e.value)}),this.container.classList.add("ql-picker"),this.label=this.buildLabel(),this.buildOptions()}},{key:"escape",value:function(){var t=this;this.close(),setTimeout(function(){return t.label.focus()},1)}},{key:"close",value:function(){this.container.classList.remove("ql-expanded"),this.label.setAttribute("aria-expanded","false"),this.options.setAttribute("aria-hidden","true")}},{key:"selectItem",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=this.container.querySelector(".ql-selected");if(t!==n&&(null!=n&&n.classList.remove("ql-selected"),null!=t&&(t.classList.add("ql-selected"),this.select.selectedIndex=[].indexOf.call(t.parentNode.children,t),t.hasAttribute("data-value")?this.label.setAttribute("data-value",t.getAttribute("data-value")):this.label.removeAttribute("data-value"),t.hasAttribute("data-label")?this.label.setAttribute("data-label",t.getAttribute("data-label")):this.label.removeAttribute("data-label"),e))){if("function"==typeof Event)this.select.dispatchEvent(new Event("change"));else if("object"===("undefined"==typeof Event?"undefined":l(Event))){var r=document.createEvent("Event");r.initEvent("change",!0,!0),this.select.dispatchEvent(r)}this.close()}}},{key:"update",value:function(){var t=void 0;if(this.select.selectedIndex>-1){var e=this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];t=this.select.options[this.select.selectedIndex],this.selectItem(e)}else this.selectItem(null);var n=null!=t&&t!==this.select.querySelector("option[selected]");this.label.classList.toggle("ql-active",n)}}]),t}();e.default=p},function(t,e,n){"use strict";function r(t){var e=a.find(t);if(null==e)try{e=a.create(t)}catch(n){e=a.create(a.Scope.INLINE),[].slice.call(t.childNodes).forEach(function(t){e.domNode.appendChild(t)}),t.parentNode&&t.parentNode.replaceChild(e.domNode,t),e.attach()}return e}var o=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var i=n(47),l=n(27),a=n(1),s=function(t){function e(e){var n=t.call(this,e)||this;return n.build(),n}return o(e,t),e.prototype.appendChild=function(t){this.insertBefore(t)},e.prototype.attach=function(){t.prototype.attach.call(this),this.children.forEach(function(t){t.attach()})},e.prototype.build=function(){var t=this;this.children=new i.default,[].slice.call(this.domNode.childNodes).reverse().forEach(function(e){try{var n=r(e);t.insertBefore(n,t.children.head||void 0)}catch(t){if(t instanceof a.ParchmentError)return;throw t}})},e.prototype.deleteAt=function(t,e){if(0===t&&e===this.length())return this.remove();this.children.forEachAt(t,e,function(t,e,n){t.deleteAt(e,n)})},e.prototype.descendant=function(t,n){var r=this.children.find(n),o=r[0],i=r[1];return null==t.blotName&&t(o)||null!=t.blotName&&o instanceof t?[o,i]:o instanceof e?o.descendant(t,i):[null,-1]},e.prototype.descendants=function(t,n,r){void 0===n&&(n=0),void 0===r&&(r=Number.MAX_VALUE);var o=[],i=r;return this.children.forEachAt(n,r,function(n,r,l){(null==t.blotName&&t(n)||null!=t.blotName&&n instanceof t)&&o.push(n),n instanceof e&&(o=o.concat(n.descendants(t,r,i))),i-=l}),o},e.prototype.detach=function(){this.children.forEach(function(t){t.detach()}),t.prototype.detach.call(this)},e.prototype.formatAt=function(t,e,n,r){this.children.forEachAt(t,e,function(t,e,o){t.formatAt(e,o,n,r)})},e.prototype.insertAt=function(t,e,n){var r=this.children.find(t),o=r[0],i=r[1];if(o)o.insertAt(i,e,n);else{var l=null==n?a.create("text",e):a.create(e,n);this.appendChild(l)}},e.prototype.insertBefore=function(t,e){if(null!=this.statics.allowedChildren&&!this.statics.allowedChildren.some(function(e){return t instanceof e}))throw new a.ParchmentError("Cannot insert "+t.statics.blotName+" into "+this.statics.blotName);t.insertInto(this,e)},e.prototype.length=function(){return this.children.reduce(function(t,e){return t+e.length()},0)},e.prototype.moveChildren=function(t,e){this.children.forEach(function(n){t.insertBefore(n,e)})},e.prototype.optimize=function(e){if(t.prototype.optimize.call(this,e),0===this.children.length)if(null!=this.statics.defaultChild){var n=a.create(this.statics.defaultChild);this.appendChild(n),n.optimize(e)}else this.remove()},e.prototype.path=function(t,n){void 0===n&&(n=!1);var r=this.children.find(t,n),o=r[0],i=r[1],l=[[this,t]];return o instanceof e?l.concat(o.path(i,n)):(null!=o&&l.push([o,i]),l)},e.prototype.removeChild=function(t){this.children.remove(t)},e.prototype.replace=function(n){n instanceof e&&n.moveChildren(this),t.prototype.replace.call(this,n)},e.prototype.split=function(t,e){if(void 0===e&&(e=!1),!e){if(0===t)return this;if(t===this.length())return this.next}var n=this.clone();return this.parent.insertBefore(n,this.next),this.children.forEachAt(t,this.length(),function(t,r,o){t=t.split(r,e),n.appendChild(t)}),n},e.prototype.unwrap=function(){this.moveChildren(this.parent,this.next),this.remove()},e.prototype.update=function(t,e){var n=this,o=[],i=[];t.forEach(function(t){t.target===n.domNode&&"childList"===t.type&&(o.push.apply(o,t.addedNodes),i.push.apply(i,t.removedNodes))}),i.forEach(function(t){if(!(null!=t.parentNode&&"IFRAME"!==t.tagName&&document.body.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_CONTAINED_BY)){var e=a.find(t);null!=e&&(null!=e.domNode.parentNode&&e.domNode.parentNode!==n.domNode||e.detach())}}),o.filter(function(t){return t.parentNode==n.domNode}).sort(function(t,e){return t===e?0:t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING?1:-1}).forEach(function(t){var e=null;null!=t.nextSibling&&(e=a.find(t.nextSibling));var o=r(t);o.next==e&&null!=o.next||(null!=o.parent&&o.parent.removeChild(n),n.insertBefore(o,e||void 0))})},e}(l.default);e.default=s},function(t,e,n){"use strict";var r=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var o=n(11),i=n(28),l=n(17),a=n(1),s=function(t){function e(e){var n=t.call(this,e)||this;return n.attributes=new i.default(n.domNode),n}return r(e,t),e.formats=function(t){return"string"==typeof this.tagName||(Array.isArray(this.tagName)?t.tagName.toLowerCase():void 0)},e.prototype.format=function(t,e){var n=a.query(t);n instanceof o.default?this.attributes.attribute(n,e):e&&(null==n||t===this.statics.blotName&&this.formats()[t]===e||this.replaceWith(t,e))},e.prototype.formats=function(){var t=this.attributes.values(),e=this.statics.formats(this.domNode);return null!=e&&(t[this.statics.blotName]=e),t},e.prototype.replaceWith=function(e,n){var r=t.prototype.replaceWith.call(this,e,n);return this.attributes.copy(r),r},e.prototype.update=function(e,n){var r=this;t.prototype.update.call(this,e,n),e.some(function(t){return t.target===r.domNode&&"attributes"===t.type})&&this.attributes.build()},e.prototype.wrap=function(n,r){var o=t.prototype.wrap.call(this,n,r);return o instanceof e&&o.statics.scope===this.statics.scope&&this.attributes.move(o),o},e}(l.default);e.default=s},function(t,e,n){"use strict";var r=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var o=n(27),i=n(1),l=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return r(e,t),e.value=function(t){return!0},e.prototype.index=function(t,e){return this.domNode===t||this.domNode.compareDocumentPosition(t)&Node.DOCUMENT_POSITION_CONTAINED_BY?Math.min(e,1):-1},e.prototype.position=function(t,e){var n=[].indexOf.call(this.parent.domNode.childNodes,this.domNode);return t>0&&(n+=1),[this.parent.domNode,n]},e.prototype.value=function(){var t;return t={},t[this.statics.blotName]=this.statics.value(this.domNode)||!0,t},e.scope=i.Scope.INLINE_BLOT,e}(o.default);e.default=l},function(t,e,n){function r(t){this.ops=t,this.index=0,this.offset=0}var o=n(12),i=n(2),l={attributes:{compose:function(t,e,n){"object"!=typeof t&&(t={}),"object"!=typeof e&&(e={});var r=i(!0,{},e);n||(r=Object.keys(r).reduce(function(t,e){return null!=r[e]&&(t[e]=r[e]),t},{}));for(var o in t)void 0!==t[o]&&void 0===e[o]&&(r[o]=t[o]);return Object.keys(r).length>0?r:void 0},diff:function(t,e){"object"!=typeof t&&(t={}),"object"!=typeof e&&(e={});var n=Object.keys(t).concat(Object.keys(e)).reduce(function(n,r){return o(t[r],e[r])||(n[r]=void 0===e[r]?null:e[r]),n},{});return Object.keys(n).length>0?n:void 0},transform:function(t,e,n){if("object"!=typeof t)return e;if("object"==typeof e){if(!n)return e;var r=Object.keys(e).reduce(function(n,r){return void 0===t[r]&&(n[r]=e[r]),n},{});return Object.keys(r).length>0?r:void 0}}},iterator:function(t){return new r(t)},length:function(t){return"number"==typeof t.delete?t.delete:"number"==typeof t.retain?t.retain:"string"==typeof t.insert?t.insert.length:1}};r.prototype.hasNext=function(){return this.peekLength()<1/0},r.prototype.next=function(t){t||(t=1/0);var e=this.ops[this.index];if(e){var n=this.offset,r=l.length(e);if(t>=r-n?(t=r-n,this.index+=1,this.offset=0):this.offset+=t,"number"==typeof e.delete)return{delete:t};var o={};return e.attributes&&(o.attributes=e.attributes),"number"==typeof e.retain?o.retain=t:"string"==typeof e.insert?o.insert=e.insert.substr(n,t):o.insert=e.insert,o}return{retain:1/0}},r.prototype.peek=function(){return this.ops[this.index]},r.prototype.peekLength=function(){return this.ops[this.index]?l.length(this.ops[this.index])-this.offset:1/0},r.prototype.peekType=function(){return this.ops[this.index]?"number"==typeof this.ops[this.index].delete?"delete":"number"==typeof this.ops[this.index].retain?"retain":"insert":"retain"},r.prototype.rest=function(){if(this.hasNext()){if(0===this.offset)return this.ops.slice(this.index);var t=this.offset,e=this.index,n=this.next(),r=this.ops.slice(this.index);return this.offset=t,this.index=e,[n].concat(r)}return[]},t.exports=l},function(t,e){var n=function(){"use strict";function t(t,e){return null!=e&&t instanceof e}function e(n,r,o,i,c){function f(n,o){if(null===n)return null;if(0===o)return n;var y,v;if("object"!=typeof n)return n;if(t(n,a))y=new a;else if(t(n,s))y=new s;else if(t(n,u))y=new u(function(t,e){n.then(function(e){t(f(e,o-1))},function(t){e(f(t,o-1))})});else if(e.__isArray(n))y=[];else if(e.__isRegExp(n))y=new RegExp(n.source,l(n)),n.lastIndex&&(y.lastIndex=n.lastIndex);else if(e.__isDate(n))y=new Date(n.getTime());else{if(d&&Buffer.isBuffer(n))return y=Buffer.allocUnsafe?Buffer.allocUnsafe(n.length):new Buffer(n.length),n.copy(y),y;t(n,Error)?y=Object.create(n):void 0===i?(v=Object.getPrototypeOf(n),y=Object.create(v)):(y=Object.create(i),v=i)}if(r){var b=h.indexOf(n);if(-1!=b)return p[b];h.push(n),p.push(y)}t(n,a)&&n.forEach(function(t,e){var n=f(e,o-1),r=f(t,o-1);y.set(n,r)}),t(n,s)&&n.forEach(function(t){var e=f(t,o-1);y.add(e)});for(var g in n){var m;v&&(m=Object.getOwnPropertyDescriptor(v,g)),m&&null==m.set||(y[g]=f(n[g],o-1))}if(Object.getOwnPropertySymbols)for(var _=Object.getOwnPropertySymbols(n),g=0;g<_.length;g++){var O=_[g],w=Object.getOwnPropertyDescriptor(n,O);(!w||w.enumerable||c)&&(y[O]=f(n[O],o-1),w.enumerable||Object.defineProperty(y,O,{enumerable:!1}))}if(c)for(var x=Object.getOwnPropertyNames(n),g=0;g<x.length;g++){var k=x[g],w=Object.getOwnPropertyDescriptor(n,k);w&&w.enumerable||(y[k]=f(n[k],o-1),Object.defineProperty(y,k,{enumerable:!1}))}return y}"object"==typeof r&&(o=r.depth,i=r.prototype,c=r.includeNonEnumerable,r=r.circular);var h=[],p=[],d="undefined"!=typeof Buffer;return void 0===r&&(r=!0),void 0===o&&(o=1/0),f(n,o)}function n(t){return Object.prototype.toString.call(t)}function r(t){return"object"==typeof t&&"[object Date]"===n(t)}function o(t){return"object"==typeof t&&"[object Array]"===n(t)}function i(t){return"object"==typeof t&&"[object RegExp]"===n(t)}function l(t){var e="";return t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),e}var a;try{a=Map}catch(t){a=function(){}}var s;try{s=Set}catch(t){s=function(){}}var u;try{u=Promise}catch(t){u=function(){}}return e.clonePrototype=function(t){if(null===t)return null;var e=function(){};return e.prototype=t,new e},e.__objToStr=n,e.__isDate=r,e.__isArray=o,e.__isRegExp=i,e.__getRegExpFlags=l,e}();"object"==typeof t&&t.exports&&(t.exports=n)},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t){if(Array.isArray(t)){for(var e=0,n=Array(t.length);e<t.length;e++)n[e]=t[e];return n}return Array.from(t)}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){try{e.parentNode}catch(t){return!1}return e instanceof Text&&(e=e.parentNode),t.contains(e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.Range=void 0;var a=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(0),c=r(u),f=n(21),h=r(f),p=n(12),d=r(p),y=n(9),v=r(y),b=n(10),g=r(b),m=(0,g.default)("quill:selection"),_=function t(e){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;i(this,t),this.index=e,this.length=n},O=function(){function t(e,n){var r=this;i(this,t),this.emitter=n,this.scroll=e,this.composing=!1,this.mouseDown=!1,this.root=this.scroll.domNode,this.cursor=c.default.create("cursor",this),this.lastRange=this.savedRange=new _(0,0),this.handleComposition(),this.handleDragging(),this.emitter.listenDOM("selectionchange",document,function(){r.mouseDown||setTimeout(r.update.bind(r,v.default.sources.USER),1)}),this.emitter.on(v.default.events.EDITOR_CHANGE,function(t,e){t===v.default.events.TEXT_CHANGE&&e.length()>0&&r.update(v.default.sources.SILENT)}),this.emitter.on(v.default.events.SCROLL_BEFORE_UPDATE,function(){if(r.hasFocus()){var t=r.getNativeRange();null!=t&&t.start.node!==r.cursor.textNode&&r.emitter.once(v.default.events.SCROLL_UPDATE,function(){try{r.setNativeRange(t.start.node,t.start.offset,t.end.node,t.end.offset)}catch(t){}})}}),this.emitter.on(v.default.events.SCROLL_OPTIMIZE,function(t,e){if(e.range){var n=e.range,o=n.startNode,i=n.startOffset,l=n.endNode,a=n.endOffset;r.setNativeRange(o,i,l,a)}}),this.update(v.default.sources.SILENT)}return s(t,[{key:"handleComposition",value:function(){var t=this;this.root.addEventListener("compositionstart",function(){t.composing=!0}),this.root.addEventListener("compositionend",function(){if(t.composing=!1,t.cursor.parent){var e=t.cursor.restore();if(!e)return;setTimeout(function(){t.setNativeRange(e.startNode,e.startOffset,e.endNode,e.endOffset)},1)}})}},{key:"handleDragging",value:function(){var t=this;this.emitter.listenDOM("mousedown",document.body,function(){t.mouseDown=!0}),this.emitter.listenDOM("mouseup",document.body,function(){t.mouseDown=!1,t.update(v.default.sources.USER)})}},{key:"focus",value:function(){this.hasFocus()||(this.root.focus(),this.setRange(this.savedRange))}},{key:"format",value:function(t,e){if(null==this.scroll.whitelist||this.scroll.whitelist[t]){this.scroll.update();var n=this.getNativeRange();if(null!=n&&n.native.collapsed&&!c.default.query(t,c.default.Scope.BLOCK)){if(n.start.node!==this.cursor.textNode){var r=c.default.find(n.start.node,!1);if(null==r)return;if(r instanceof c.default.Leaf){var o=r.split(n.start.offset);r.parent.insertBefore(this.cursor,o)}else r.insertBefore(this.cursor,n.start.node);this.cursor.attach()}this.cursor.format(t,e),this.scroll.optimize(),this.setNativeRange(this.cursor.textNode,this.cursor.textNode.data.length),this.update()}}}},{key:"getBounds",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=this.scroll.length();t=Math.min(t,n-1),e=Math.min(t+e,n-1)-t;var r=void 0,o=this.scroll.leaf(t),i=a(o,2),l=i[0],s=i[1];if(null==l)return null;var u=l.position(s,!0),c=a(u,2);r=c[0],s=c[1];var f=document.createRange();if(e>0){f.setStart(r,s);var h=this.scroll.leaf(t+e),p=a(h,2);if(l=p[0],s=p[1],null==l)return null;var d=l.position(s,!0),y=a(d,2);return r=y[0],s=y[1],f.setEnd(r,s),f.getBoundingClientRect()}var v="left",b=void 0;return r instanceof Text?(s<r.data.length?(f.setStart(r,s),f.setEnd(r,s+1)):(f.setStart(r,s-1),f.setEnd(r,s),v="right"),b=f.getBoundingClientRect()):(b=l.domNode.getBoundingClientRect(),s>0&&(v="right")),{bottom:b.top+b.height,height:b.height,left:b[v],right:b[v],top:b.top,width:0}}},{key:"getNativeRange",value:function(){var t=document.getSelection();if(null==t||t.rangeCount<=0)return null;var e=t.getRangeAt(0);if(null==e)return null;var n=this.normalizeNative(e);return m.info("getNativeRange",n),n}},{key:"getRange",value:function(){var t=this.getNativeRange();return null==t?[null,null]:[this.normalizedToRange(t),t]}},{key:"hasFocus",value:function(){return document.activeElement===this.root}},{key:"normalizedToRange",value:function(t){var e=this,n=[[t.start.node,t.start.offset]];t.native.collapsed||n.push([t.end.node,t.end.offset]);var r=n.map(function(t){var n=a(t,2),r=n[0],o=n[1],i=c.default.find(r,!0),l=i.offset(e.scroll);return 0===o?l:i instanceof c.default.Container?l+i.length():l+i.index(r,o)}),i=Math.min(Math.max.apply(Math,o(r)),this.scroll.length()-1),l=Math.min.apply(Math,[i].concat(o(r)));return new _(l,i-l)}},{key:"normalizeNative",value:function(t){if(!l(this.root,t.startContainer)||!t.collapsed&&!l(this.root,t.endContainer))return null;var e={start:{node:t.startContainer,offset:t.startOffset},end:{node:t.endContainer,offset:t.endOffset},native:t};return[e.start,e.end].forEach(function(t){for(var e=t.node,n=t.offset;!(e instanceof Text)&&e.childNodes.length>0;)if(e.childNodes.length>n)e=e.childNodes[n],n=0;else{if(e.childNodes.length!==n)break;e=e.lastChild,n=e instanceof Text?e.data.length:e.childNodes.length+1}t.node=e,t.offset=n}),e}},{key:"rangeToNative",value:function(t){var e=this,n=t.collapsed?[t.index]:[t.index,t.index+t.length],r=[],o=this.scroll.length();return n.forEach(function(t,n){t=Math.min(o-1,t);var i=void 0,l=e.scroll.leaf(t),s=a(l,2),u=s[0],c=s[1],f=u.position(c,0!==n),h=a(f,2);i=h[0],c=h[1],r.push(i,c)}),r.length<2&&(r=r.concat(r)),r}},{key:"scrollIntoView",value:function(t){var e=this.lastRange;if(null!=e){var n=this.getBounds(e.index,e.length);if(null!=n){var r=this.scroll.length()-1,o=this.scroll.line(Math.min(e.index,r)),i=a(o,1),l=i[0],s=l;if(e.length>0){var u=this.scroll.line(Math.min(e.index+e.length,r));s=a(u,1)[0]}if(null!=l&&null!=s){var c=t.getBoundingClientRect();n.top<c.top?t.scrollTop-=c.top-n.top:n.bottom>c.bottom&&(t.scrollTop+=n.bottom-c.bottom)}}}}},{key:"setNativeRange",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e,o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(m.info("setNativeRange",t,e,n,r),null==t||null!=this.root.parentNode&&null!=t.parentNode&&null!=n.parentNode){var i=document.getSelection();if(null!=i)if(null!=t){this.hasFocus()||this.root.focus();var l=(this.getNativeRange()||{}).native;if(null==l||o||t!==l.startContainer||e!==l.startOffset||n!==l.endContainer||r!==l.endOffset){"BR"==t.tagName&&(e=[].indexOf.call(t.parentNode.childNodes,t),t=t.parentNode),"BR"==n.tagName&&(r=[].indexOf.call(n.parentNode.childNodes,n),n=n.parentNode);var a=document.createRange();a.setStart(t,e),a.setEnd(n,r),i.removeAllRanges(),i.addRange(a)}}else i.removeAllRanges(),this.root.blur(),document.body.focus()}}},{key:"setRange",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:v.default.sources.API;if("string"==typeof e&&(n=e,e=!1),m.info("setRange",t),null!=t){var r=this.rangeToNative(t);this.setNativeRange.apply(this,o(r).concat([e]))}else this.setNativeRange(null);this.update(n)}},{key:"update",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:v.default.sources.USER,e=this.lastRange,n=this.getRange(),r=a(n,2),o=r[0],i=r[1];if(this.lastRange=o,null!=this.lastRange&&(this.savedRange=this.lastRange),!(0,d.default)(e,this.lastRange)){var l;!this.composing&&null!=i&&i.native.collapsed&&i.start.node!==this.cursor.textNode&&this.cursor.restore();var s=[v.default.events.SELECTION_CHANGE,(0,h.default)(this.lastRange),(0,h.default)(e),t];if((l=this.emitter).emit.apply(l,[v.default.events.EDITOR_CHANGE].concat(s)),t!==v.default.sources.SILENT){var u;(u=this.emitter).emit.apply(u,s)}}}}]),t}();e.Range=_,e.default=O},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=n(0),s=r(a),u=n(3),c=r(u),f=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),e}(s.default.Container);f.allowedChildren=[c.default,u.BlockEmbed,f],e.default=f},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.ColorStyle=e.ColorClass=e.ColorAttributor=void 0;var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(0),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"value",value:function(t){var n=a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"value",this).call(this,t);return n.startsWith("rgb(")?(n=n.replace(/^[^\d]+/,"").replace(/[^\d]+$/,""),"#"+n.split(",").map(function(t){return("00"+parseInt(t).toString(16)).slice(-2)}).join("")):n}}]),e}(u.default.Attributor.Style),f=new u.default.Attributor.Class("color","ql-color",{scope:u.default.Scope.INLINE}),h=new c("color","color",{scope:u.default.Scope.INLINE});e.ColorAttributor=c,e.ColorClass=f,e.ColorStyle=h},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e){var n,r=t===D.keys.LEFT?"prefix":"suffix";return n={key:t,shiftKey:e,altKey:null},o(n,r,/^$/),o(n,"handler",function(n){var r=n.index;t===D.keys.RIGHT&&(r+=n.length+1);var o=this.quill.getLeaf(r);return!(b(o,1)[0]instanceof T.default.Embed)||(t===D.keys.LEFT?e?this.quill.setSelection(n.index-1,n.length+1,S.default.sources.USER):this.quill.setSelection(n.index-1,S.default.sources.USER):e?this.quill.setSelection(n.index,n.length+1,S.default.sources.USER):this.quill.setSelection(n.index+n.length+1,S.default.sources.USER),!1)}),n}function u(t,e){if(!(0===t.index||this.quill.getLength()<=1)){var n=this.quill.getLine(t.index),r=b(n,1),o=r[0],i={};if(0===e.offset){var l=this.quill.getLine(t.index-1),a=b(l,1),s=a[0];if(null!=s&&s.length()>1){var u=o.formats(),c=this.quill.getFormat(t.index-1,1);i=A.default.attributes.diff(u,c)||{}}}var f=/[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e.prefix)?2:1;this.quill.deleteText(t.index-f,f,S.default.sources.USER),Object.keys(i).length>0&&this.quill.formatLine(t.index-f,f,i,S.default.sources.USER),this.quill.focus()}}function c(t,e){var n=/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e.suffix)?2:1;if(!(t.index>=this.quill.getLength()-n)){var r={},o=0,i=this.quill.getLine(t.index),l=b(i,1),a=l[0];if(e.offset>=a.length()-1){var s=this.quill.getLine(t.index+1),u=b(s,1),c=u[0];if(c){var f=a.formats(),h=this.quill.getFormat(t.index,1);r=A.default.attributes.diff(f,h)||{},o=c.length()}}this.quill.deleteText(t.index,n,S.default.sources.USER),Object.keys(r).length>0&&this.quill.formatLine(t.index+o-1,n,r,S.default.sources.USER)}}function f(t){var e=this.quill.getLines(t),n={};if(e.length>1){var r=e[0].formats(),o=e[e.length-1].formats();n=A.default.attributes.diff(o,r)||{}}this.quill.deleteText(t,S.default.sources.USER),Object.keys(n).length>0&&this.quill.formatLine(t.index,1,n,S.default.sources.USER),this.quill.setSelection(t.index,S.default.sources.SILENT),this.quill.focus()}function h(t,e){var n=this;t.length>0&&this.quill.scroll.deleteAt(t.index,t.length);var r=Object.keys(e.format).reduce(function(t,n){return T.default.query(n,T.default.Scope.BLOCK)&&!Array.isArray(e.format[n])&&(t[n]=e.format[n]),t},{});this.quill.insertText(t.index,"\n",r,S.default.sources.USER),this.quill.setSelection(t.index+1,S.default.sources.SILENT),this.quill.focus(),Object.keys(e.format).forEach(function(t){null==r[t]&&(Array.isArray(e.format[t])||"link"!==t&&n.quill.format(t,e.format[t],S.default.sources.USER))})}function p(t){return{key:D.keys.TAB,shiftKey:!t,format:{"code-block":!0},handler:function(e){var n=T.default.query("code-block"),r=e.index,o=e.length,i=this.quill.scroll.descendant(n,r),l=b(i,2),a=l[0],s=l[1];if(null!=a){var u=this.quill.getIndex(a),c=a.newlineIndex(s,!0)+1,f=a.newlineIndex(u+s+o),h=a.domNode.textContent.slice(c,f).split("\n");s=0,h.forEach(function(e,i){t?(a.insertAt(c+s,n.TAB),s+=n.TAB.length,0===i?r+=n.TAB.length:o+=n.TAB.length):e.startsWith(n.TAB)&&(a.deleteAt(c+s,n.TAB.length),s-=n.TAB.length,0===i?r-=n.TAB.length:o-=n.TAB.length),s+=e.length+1}),this.quill.update(S.default.sources.USER),this.quill.setSelection(r,o,S.default.sources.SILENT)}}}}function d(t){return{key:t[0].toUpperCase(),shortKey:!0,handler:function(e,n){this.quill.format(t,!n.format[t],S.default.sources.USER)}}}function y(t){if("string"==typeof t||"number"==typeof t)return y({key:t});if("object"===(void 0===t?"undefined":v(t))&&(t=(0,_.default)(t,!1)),"string"==typeof t.key)if(null!=D.keys[t.key.toUpperCase()])t.key=D.keys[t.key.toUpperCase()];else{if(1!==t.key.length)return null;t.key=t.key.toUpperCase().charCodeAt(0)}return t.shortKey&&(t[B]=t.shortKey,delete t.shortKey),t}Object.defineProperty(e,"__esModule",{value:!0}),e.SHORTKEY=e.default=void 0;var v="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},b=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),g=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),m=n(21),_=r(m),O=n(12),w=r(O),x=n(2),k=r(x),E=n(4),N=r(E),j=n(20),A=r(j),q=n(0),T=r(q),P=n(6),S=r(P),C=n(10),L=r(C),M=n(7),R=r(M),I=(0,L.default)("quill:keyboard"),B=/Mac/i.test(navigator.platform)?"metaKey":"ctrlKey",D=function(t){function e(t,n){i(this,e);var r=l(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.bindings={},Object.keys(r.options.bindings).forEach(function(e){("list autofill"!==e||null==t.scroll.whitelist||t.scroll.whitelist.list)&&r.options.bindings[e]&&r.addBinding(r.options.bindings[e])}),r.addBinding({key:e.keys.ENTER,shiftKey:null},h),r.addBinding({key:e.keys.ENTER,metaKey:null,ctrlKey:null,altKey:null},function(){}),/Firefox/i.test(navigator.userAgent)?(r.addBinding({key:e.keys.BACKSPACE},{collapsed:!0},u),r.addBinding({key:e.keys.DELETE},{collapsed:!0},c)):(r.addBinding({key:e.keys.BACKSPACE},{collapsed:!0,prefix:/^.?$/},u),r.addBinding({key:e.keys.DELETE},{collapsed:!0,suffix:/^.?$/},c)),r.addBinding({key:e.keys.BACKSPACE},{collapsed:!1},f),r.addBinding({key:e.keys.DELETE},{collapsed:!1},f),r.addBinding({key:e.keys.BACKSPACE,altKey:null,ctrlKey:null,metaKey:null,shiftKey:null},{collapsed:!0,offset:0},u),r.listen(),r}return a(e,t),g(e,null,[{key:"match",value:function(t,e){return e=y(e),!["altKey","ctrlKey","metaKey","shiftKey"].some(function(n){return!!e[n]!==t[n]&&null!==e[n]})&&e.key===(t.which||t.keyCode)}}]),g(e,[{key:"addBinding",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=y(t);if(null==r||null==r.key)return I.warn("Attempted to add invalid keyboard binding",r);"function"==typeof e&&(e={handler:e}),"function"==typeof n&&(n={handler:n}),r=(0,k.default)(r,e,n),this.bindings[r.key]=this.bindings[r.key]||[],this.bindings[r.key].push(r)}},{key:"listen",value:function(){var t=this;this.quill.root.addEventListener("keydown",function(n){if(!n.defaultPrevented){var r=n.which||n.keyCode,o=(t.bindings[r]||[]).filter(function(t){return e.match(n,t)});if(0!==o.length){var i=t.quill.getSelection();if(null!=i&&t.quill.hasFocus()){var l=t.quill.getLine(i.index),a=b(l,2),s=a[0],u=a[1],c=t.quill.getLeaf(i.index),f=b(c,2),h=f[0],p=f[1],d=0===i.length?[h,p]:t.quill.getLeaf(i.index+i.length),y=b(d,2),g=y[0],m=y[1],_=h instanceof T.default.Text?h.value().slice(0,p):"",O=g instanceof T.default.Text?g.value().slice(m):"",x={collapsed:0===i.length,empty:0===i.length&&s.length()<=1,format:t.quill.getFormat(i),offset:u,prefix:_,suffix:O};o.some(function(e){if(null!=e.collapsed&&e.collapsed!==x.collapsed)return!1;if(null!=e.empty&&e.empty!==x.empty)return!1;if(null!=e.offset&&e.offset!==x.offset)return!1;if(Array.isArray(e.format)){if(e.format.every(function(t){return null==x.format[t]}))return!1}else if("object"===v(e.format)&&!Object.keys(e.format).every(function(t){return!0===e.format[t]?null!=x.format[t]:!1===e.format[t]?null==x.format[t]:(0,w.default)(e.format[t],x.format[t])}))return!1;return!(null!=e.prefix&&!e.prefix.test(x.prefix))&&(!(null!=e.suffix&&!e.suffix.test(x.suffix))&&!0!==e.handler.call(t,i,x))})&&n.preventDefault()}}}})}}]),e}(R.default);D.keys={BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46},D.DEFAULTS={bindings:{bold:d("bold"),italic:d("italic"),underline:d("underline"),indent:{key:D.keys.TAB,format:["blockquote","indent","list"],handler:function(t,e){if(e.collapsed&&0!==e.offset)return!0;this.quill.format("indent","+1",S.default.sources.USER)}},outdent:{key:D.keys.TAB,shiftKey:!0,format:["blockquote","indent","list"],handler:function(t,e){if(e.collapsed&&0!==e.offset)return!0;this.quill.format("indent","-1",S.default.sources.USER)}},"outdent backspace":{key:D.keys.BACKSPACE,collapsed:!0,shiftKey:null,metaKey:null,ctrlKey:null,altKey:null,format:["indent","list"],offset:0,handler:function(t,e){null!=e.format.indent?this.quill.format("indent","-1",S.default.sources.USER):null!=e.format.list&&this.quill.format("list",!1,S.default.sources.USER)}},"indent code-block":p(!0),"outdent code-block":p(!1),"remove tab":{key:D.keys.TAB,shiftKey:!0,collapsed:!0,prefix:/\t$/,handler:function(t){this.quill.deleteText(t.index-1,1,S.default.sources.USER)}},tab:{key:D.keys.TAB,handler:function(t){this.quill.history.cutoff();var e=(new N.default).retain(t.index).delete(t.length).insert("\t");this.quill.updateContents(e,S.default.sources.USER),this.quill.history.cutoff(),this.quill.setSelection(t.index+1,S.default.sources.SILENT)}},"list empty enter":{key:D.keys.ENTER,collapsed:!0,format:["list"],empty:!0,handler:function(t,e){this.quill.format("list",!1,S.default.sources.USER),e.format.indent&&this.quill.format("indent",!1,S.default.sources.USER)}},"checklist enter":{key:D.keys.ENTER,collapsed:!0,format:{list:"checked"},handler:function(t){var e=this.quill.getLine(t.index),n=b(e,2),r=n[0],o=n[1],i=(0,k.default)({},r.formats(),{list:"checked"}),l=(new N.default).retain(t.index).insert("\n",i).retain(r.length()-o-1).retain(1,{list:"unchecked"});this.quill.updateContents(l,S.default.sources.USER),this.quill.setSelection(t.index+1,S.default.sources.SILENT),this.quill.scrollIntoView()}},"header enter":{key:D.keys.ENTER,collapsed:!0,format:["header"],suffix:/^$/,handler:function(t,e){var n=this.quill.getLine(t.index),r=b(n,2),o=r[0],i=r[1],l=(new N.default).retain(t.index).insert("\n",e.format).retain(o.length()-i-1).retain(1,{header:null});this.quill.updateContents(l,S.default.sources.USER),this.quill.setSelection(t.index+1,S.default.sources.SILENT),this.quill.scrollIntoView()}},"list autofill":{key:" ",collapsed:!0,format:{list:!1},prefix:/^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,handler:function(t,e){var n=e.prefix.length,r=this.quill.getLine(t.index),o=b(r,2),i=o[0],l=o[1];if(l>n)return!0;var a=void 0;switch(e.prefix.trim()){case"[]":case"[ ]":a="unchecked";break;case"[x]":a="checked";break;case"-":case"*":a="bullet";break;default:a="ordered"}this.quill.insertText(t.index," ",S.default.sources.USER),this.quill.history.cutoff();var s=(new N.default).retain(t.index-l).delete(n+1).retain(i.length()-2-l).retain(1,{list:a});this.quill.updateContents(s,S.default.sources.USER),this.quill.history.cutoff(),this.quill.setSelection(t.index-n,S.default.sources.SILENT)}},"code exit":{key:D.keys.ENTER,collapsed:!0,format:["code-block"],prefix:/\n\n$/,suffix:/^\s+$/,handler:function(t){var e=this.quill.getLine(t.index),n=b(e,2),r=n[0],o=n[1],i=(new N.default).retain(t.index+r.length()-o-2).retain(1,{"code-block":null}).delete(1);this.quill.updateContents(i,S.default.sources.USER)}},"embed left":s(D.keys.LEFT,!1),"embed left shift":s(D.keys.LEFT,!0),"embed right":s(D.keys.RIGHT,!1),"embed right shift":s(D.keys.RIGHT,!0)}},e.default=D,e.SHORTKEY=B},function(t,e,n){"use strict";t.exports={align:{"":n(75),center:n(76),right:n(77),justify:n(78)},background:n(79),blockquote:n(80),bold:n(81),clean:n(82),code:n(40),"code-block":n(40),color:n(83),direction:{"":n(84),rtl:n(85)},float:{center:n(86),full:n(87),left:n(88),right:n(89)},formula:n(90),header:{1:n(91),2:n(92)},italic:n(93),image:n(94),indent:{"+1":n(95),"-1":n(96)},link:n(97),list:{ordered:n(98),bullet:n(99),check:n(100)},script:{sub:n(101),super:n(102)},strike:n(103),underline:n(104),video:n(105)}},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(1),o=function(){function t(t){this.domNode=t,this.domNode[r.DATA_KEY]={blot:this}}return Object.defineProperty(t.prototype,"statics",{get:function(){return this.constructor},enumerable:!0,configurable:!0}),t.create=function(t){if(null==this.tagName)throw new r.ParchmentError("Blot definition missing tagName");var e;return Array.isArray(this.tagName)?("string"==typeof t&&(t=t.toUpperCase(),parseInt(t).toString()===t&&(t=parseInt(t))),e="number"==typeof t?document.createElement(this.tagName[t-1]):this.tagName.indexOf(t)>-1?document.createElement(t):document.createElement(this.tagName[0])):e=document.createElement(this.tagName),this.className&&e.classList.add(this.className),e},t.prototype.attach=function(){null!=this.parent&&(this.scroll=this.parent.scroll)},t.prototype.clone=function(){var t=this.domNode.cloneNode(!1);return r.create(t)},t.prototype.detach=function(){null!=this.parent&&this.parent.removeChild(this),delete this.domNode[r.DATA_KEY]},t.prototype.deleteAt=function(t,e){this.isolate(t,e).remove()},t.prototype.formatAt=function(t,e,n,o){var i=this.isolate(t,e);if(null!=r.query(n,r.Scope.BLOT)&&o)i.wrap(n,o);else if(null!=r.query(n,r.Scope.ATTRIBUTE)){var l=r.create(this.statics.scope);i.wrap(l),l.format(n,o)}},t.prototype.insertAt=function(t,e,n){var o=null==n?r.create("text",e):r.create(e,n),i=this.split(t);this.parent.insertBefore(o,i)},t.prototype.insertInto=function(t,e){void 0===e&&(e=null),null!=this.parent&&this.parent.children.remove(this);var n=null;t.children.insertBefore(this,e),null!=e&&(n=e.domNode),this.domNode.parentNode==t.domNode&&this.domNode.nextSibling==n||t.domNode.insertBefore(this.domNode,n),this.parent=t,this.attach()},t.prototype.isolate=function(t,e){var n=this.split(t);return n.split(e),n},t.prototype.length=function(){return 1},t.prototype.offset=function(t){return void 0===t&&(t=this.parent),null==this.parent||this==t?0:this.parent.children.offset(this)+this.parent.offset(t)},t.prototype.optimize=function(t){null!=this.domNode[r.DATA_KEY]&&delete this.domNode[r.DATA_KEY].mutations},t.prototype.remove=function(){null!=this.domNode.parentNode&&this.domNode.parentNode.removeChild(this.domNode),this.detach()},t.prototype.replace=function(t){null!=t.parent&&(t.parent.insertBefore(this,t.next),t.remove())},t.prototype.replaceWith=function(t,e){var n="string"==typeof t?r.create(t,e):t;return n.replace(this),n},t.prototype.split=function(t,e){return 0===t?this:this.next},t.prototype.update=function(t,e){},t.prototype.wrap=function(t,e){var n="string"==typeof t?r.create(t,e):t;return null!=this.parent&&this.parent.insertBefore(n,this.next),n.appendChild(this),n},t.blotName="abstract",t}();e.default=o},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=n(11),o=n(29),i=n(30),l=n(1),a=function(){function t(t){this.attributes={},this.domNode=t,this.build()}return t.prototype.attribute=function(t,e){e?t.add(this.domNode,e)&&(null!=t.value(this.domNode)?this.attributes[t.attrName]=t:delete this.attributes[t.attrName]):(t.remove(this.domNode),delete this.attributes[t.attrName])},t.prototype.build=function(){var t=this;this.attributes={};var e=r.default.keys(this.domNode),n=o.default.keys(this.domNode),a=i.default.keys(this.domNode);e.concat(n).concat(a).forEach(function(e){var n=l.query(e,l.Scope.ATTRIBUTE);n instanceof r.default&&(t.attributes[n.attrName]=n)})},t.prototype.copy=function(t){var e=this;Object.keys(this.attributes).forEach(function(n){var r=e.attributes[n].value(e.domNode);t.format(n,r)})},t.prototype.move=function(t){var e=this;this.copy(t),Object.keys(this.attributes).forEach(function(t){e.attributes[t].remove(e.domNode)}),this.attributes={}},t.prototype.values=function(){var t=this;return Object.keys(this.attributes).reduce(function(e,n){return e[n]=t.attributes[n].value(t.domNode),e},{})},t}();e.default=a},function(t,e,n){"use strict";function r(t,e){return(t.getAttribute("class")||"").split(/\s+/).filter(function(t){return 0===t.indexOf(e+"-")})}var o=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var i=n(11),l=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return o(e,t),e.keys=function(t){return(t.getAttribute("class")||"").split(/\s+/).map(function(t){return t.split("-").slice(0,-1).join("-")})},e.prototype.add=function(t,e){return!!this.canAdd(t,e)&&(this.remove(t),t.classList.add(this.keyName+"-"+e),!0)},e.prototype.remove=function(t){r(t,this.keyName).forEach(function(e){t.classList.remove(e)}),0===t.classList.length&&t.removeAttribute("class")},e.prototype.value=function(t){var e=r(t,this.keyName)[0]||"",n=e.slice(this.keyName.length+1);return this.canAdd(t,n)?n:""},e}(i.default);e.default=l},function(t,e,n){"use strict";function r(t){var e=t.split("-"),n=e.slice(1).map(function(t){return t[0].toUpperCase()+t.slice(1)}).join("");return e[0]+n}var o=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var i=n(11),l=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return o(e,t),e.keys=function(t){return(t.getAttribute("style")||"").split(";").map(function(t){return t.split(":")[0].trim()})},e.prototype.add=function(t,e){return!!this.canAdd(t,e)&&(t.style[r(this.keyName)]=e,!0)},e.prototype.remove=function(t){t.style[r(this.keyName)]="",t.getAttribute("style")||t.removeAttribute("style")},e.prototype.value=function(t){var e=t.style[r(this.keyName)];return this.canAdd(t,e)?e:""},e}(i.default);e.default=l},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),f=r(c),h=n(8),p=r(h),d=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return r.selection=n,r.textNode=document.createTextNode(e.CONTENTS),r.domNode.appendChild(r.textNode),r._length=0,r}return l(e,t),u(e,null,[{key:"value",value:function(){}}]),u(e,[{key:"detach",value:function(){null!=this.parent&&this.parent.removeChild(this)}},{key:"format",value:function(t,n){if(0!==this._length)return s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"format",this).call(this,t,n);for(var r=this,o=0;null!=r&&r.statics.scope!==f.default.Scope.BLOCK_BLOT;)o+=r.offset(r.parent),r=r.parent;null!=r&&(this._length=e.CONTENTS.length,r.optimize(),r.formatAt(o,e.CONTENTS.length,t,n),this._length=0)}},{key:"index",value:function(t,n){return t===this.textNode?0:s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"index",this).call(this,t,n)}},{key:"length",value:function(){return this._length}},{key:"position",value:function(){return[this.textNode,this.textNode.data.length]}},{key:"remove",value:function(){s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"remove",this).call(this),this.parent=null}},{key:"restore",value:function(){if(!this.selection.composing&&null!=this.parent){var t=this.textNode,n=this.selection.getNativeRange(),r=void 0,o=void 0,i=void 0;if(null!=n&&n.start.node===t&&n.end.node===t){var l=[t,n.start.offset,n.end.offset];r=l[0],o=l[1],i=l[2]}for(;null!=this.domNode.lastChild&&this.domNode.lastChild!==this.textNode;)this.domNode.parentNode.insertBefore(this.domNode.lastChild,this.domNode);if(this.textNode.data!==e.CONTENTS){var s=this.textNode.data.split(e.CONTENTS).join("");this.next instanceof p.default?(r=this.next.domNode,this.next.insertAt(0,s),this.textNode.data=e.CONTENTS):(this.textNode.data=s,this.parent.insertBefore(f.default.create(this.textNode),this),this.textNode=document.createTextNode(e.CONTENTS),this.domNode.appendChild(this.textNode))}if(this.remove(),null!=o){var u=[o,i].map(function(t){return Math.max(0,Math.min(r.data.length,t-1))}),c=a(u,2);return o=c[0],i=c[1],{startNode:r,startOffset:o,endNode:r,endOffset:i}}}}},{key:"update",value:function(t,e){var n=this;if(t.some(function(t){return"characterData"===t.type&&t.target===n.textNode})){var r=this.restore();r&&(e.range=r)}}},{key:"value",value:function(){return""}}]),e}(f.default.Embed);d.blotName="cursor",d.className="ql-cursor",d.tagName="span",d.CONTENTS="\ufeff",e.default=d},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),i=function(){function t(e,n){r(this,t),this.quill=e,this.options=n,this.modules={}}return o(t,[{key:"init",value:function(){var t=this;Object.keys(this.options.modules).forEach(function(e){null==t.modules[e]&&t.addModule(e)})}},{key:"addModule",value:function(t){var e=this.quill.constructor.import("modules/"+t);return this.modules[t]=new e(this.quill,this.options.modules[t]||{}),this.modules[t]}}]),t}();i.DEFAULTS={modules:{}},i.themes={default:i},e.default=i},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=n(0),c=r(u),f=n(8),h=r(f),p="\ufeff",d=function(t){function e(t){o(this,e);var n=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return n.contentNode=document.createElement("span"),n.contentNode.setAttribute("contenteditable",!1),[].slice.call(n.domNode.childNodes).forEach(function(t){n.contentNode.appendChild(t)}),n.leftGuard=document.createTextNode(p),n.rightGuard=document.createTextNode(p),n.domNode.appendChild(n.leftGuard),n.domNode.appendChild(n.contentNode),n.domNode.appendChild(n.rightGuard),n}return l(e,t),a(e,[{key:"index",value:function(t,n){return t===this.leftGuard?0:t===this.rightGuard?1:s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"index",this).call(this,t,n)}},{key:"restore",value:function(t){var e=void 0,n=void 0,r=t.data.split(p).join("");if(t===this.leftGuard)if(this.prev instanceof h.default){var o=this.prev.length();this.prev.insertAt(o,r),e={startNode:this.prev.domNode,startOffset:o+r.length}}else n=document.createTextNode(r),this.parent.insertBefore(c.default.create(n),this),e={startNode:n,startOffset:r.length};else t===this.rightGuard&&(this.next instanceof h.default?(this.next.insertAt(0,r),e={startNode:this.next.domNode,startOffset:r.length}):(n=document.createTextNode(r),this.parent.insertBefore(c.default.create(n),this.next),e={startNode:n,startOffset:r.length}));return t.data=p,e}},{key:"update",value:function(t,e){var n=this;t.forEach(function(t){if("characterData"===t.type&&(t.target===n.leftGuard||t.target===n.rightGuard)){var r=n.restore(t.target);r&&(e.range=r)}})}}]),e}(c.default.Embed);e.default=d},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.AlignStyle=e.AlignClass=e.AlignAttribute=void 0;var r=n(0),o=function(t){return t&&t.__esModule?t:{default:t}}(r),i={scope:o.default.Scope.BLOCK,whitelist:["right","center","justify"]},l=new o.default.Attributor.Attribute("align","align",i),a=new o.default.Attributor.Class("align","ql-align",i),s=new o.default.Attributor.Style("align","text-align",i);e.AlignAttribute=l,e.AlignClass=a,e.AlignStyle=s},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.BackgroundStyle=e.BackgroundClass=void 0;var r=n(0),o=function(t){return t&&t.__esModule?t:{default:t}}(r),i=n(24),l=new o.default.Attributor.Class("background","ql-bg",{scope:o.default.Scope.INLINE}),a=new i.ColorAttributor("background","background-color",{scope:o.default.Scope.INLINE});e.BackgroundClass=l,e.BackgroundStyle=a},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.DirectionStyle=e.DirectionClass=e.DirectionAttribute=void 0;var r=n(0),o=function(t){return t&&t.__esModule?t:{default:t}}(r),i={scope:o.default.Scope.BLOCK,whitelist:["rtl"]},l=new o.default.Attributor.Attribute("direction","dir",i),a=new o.default.Attributor.Class("direction","ql-direction",i),s=new o.default.Attributor.Style("direction","direction",i);e.DirectionAttribute=l,e.DirectionClass=a,e.DirectionStyle=s},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.FontClass=e.FontStyle=void 0;var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(0),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c={scope:u.default.Scope.INLINE,whitelist:["serif","monospace"]},f=new u.default.Attributor.Class("font","ql-font",c),h=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"value",value:function(t){return a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"value",this).call(this,t).replace(/["']/g,"")}}]),e}(u.default.Attributor.Style),p=new h("font","font-family",c);e.FontStyle=p,e.FontClass=f},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.SizeStyle=e.SizeClass=void 0;var r=n(0),o=function(t){return t&&t.__esModule?t:{default:t}}(r),i=new o.default.Attributor.Class("size","ql-size",{scope:o.default.Scope.INLINE,whitelist:["small","large","huge"]}),l=new o.default.Attributor.Style("size","font-size",{scope:o.default.Scope.INLINE,whitelist:["10px","18px","32px"]});e.SizeClass=i,e.SizeStyle=l},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(5),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"optimize",value:function(t){a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"optimize",this).call(this,t),this.domNode.tagName!==this.statics.tagName[0]&&this.replaceWith(this.statics.blotName)}}],[{key:"create",value:function(){return a(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this)}},{key:"formats",value:function(){return!0}}]),e}(u.default);c.blotName="bold",c.tagName=["STRONG","B"],e.default=c},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>'},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(16),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(t,n){r(this,e);var i=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return i.label.innerHTML=n,i.container.classList.add("ql-color-picker"),[].slice.call(i.container.querySelectorAll(".ql-picker-item"),0,7).forEach(function(t){t.classList.add("ql-primary")}),i}return i(e,t),l(e,[{key:"buildItem",value:function(t){var n=a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"buildItem",this).call(this,t);return n.style.backgroundColor=t.getAttribute("value")||"",n}},{key:"selectItem",value:function(t,n){a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"selectItem",this).call(this,t,n);var r=this.label.querySelector(".ql-color-label"),o=t?t.getAttribute("data-value")||"":"";r&&("line"===r.tagName?r.style.stroke=o:r.style.fill=o)}}]),e}(u.default);e.default=c},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(16),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(t,n){r(this,e);var i=o(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return i.container.classList.add("ql-icon-picker"),[].forEach.call(i.container.querySelectorAll(".ql-picker-item"),function(t){t.innerHTML=n[t.getAttribute("data-value")||""]}),i.defaultItem=i.container.querySelector(".ql-selected"),i.selectItem(i.defaultItem),i}return i(e,t),l(e,[{key:"selectItem",value:function(t,n){a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"selectItem",this).call(this,t,n),t=t||this.defaultItem,this.label.innerHTML=t.innerHTML}}]),e}(u.default);e.default=c},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(e,"__esModule",{value:!0});var o=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),i=function(){function t(e,n){var o=this;r(this,t),this.quill=e,this.boundsContainer=n||document.body,this.root=e.addContainer("ql-tooltip"),this.root.innerHTML=this.constructor.TEMPLATE,this.quill.root===this.quill.scrollingContainer&&this.quill.root.addEventListener("scroll",function(){o.root.style.marginTop=-1*o.quill.root.scrollTop+"px"}),this.hide()}return o(t,[{key:"hide",value:function(){this.root.classList.add("ql-hidden")}},{key:"position",value:function(t){var e=t.left+t.width/2-this.root.offsetWidth/2,n=t.bottom+this.quill.root.scrollTop;this.root.style.left=e+"px",this.root.style.top=n+"px",this.root.classList.remove("ql-flip");var r=this.boundsContainer.getBoundingClientRect(),o=this.root.getBoundingClientRect(),i=0;if(o.right>r.right&&(i=r.right-o.right,this.root.style.left=e+i+"px"),o.left<r.left&&(i=r.left-o.left,this.root.style.left=e+i+"px"),o.bottom>r.bottom){var l=o.bottom-o.top,a=t.bottom-t.top+l;this.root.style.top=n-a+"px",this.root.classList.add("ql-flip")}return i}},{key:"show",value:function(){this.root.classList.remove("ql-editing"),this.root.classList.remove("ql-hidden")}}]),t}();e.default=i},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t){var e=t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/)||t.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);return e?(e[1]||"https")+"://www.youtube.com/embed/"+e[2]+"?showinfo=0":(e=t.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/))?(e[1]||"https")+"://player.vimeo.com/video/"+e[2]+"/":t}function s(t,e){var n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];e.forEach(function(e){var r=document.createElement("option");e===n?r.setAttribute("selected","selected"):r.setAttribute("value",e),t.appendChild(r)})}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.BaseTooltip=void 0;var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},f=n(2),h=r(f),p=n(4),d=r(p),y=n(9),v=r(y),b=n(25),g=r(b),m=n(32),_=r(m),O=n(41),w=r(O),x=n(42),k=r(x),E=n(16),N=r(E),j=n(43),A=r(j),q=[!1,"center","right","justify"],T=["#000000","#e60000","#ff9900","#ffff00","#008a00","#0066cc","#9933ff","#ffffff","#facccc","#ffebcc","#ffffcc","#cce8cc","#cce0f5","#ebd6ff","#bbbbbb","#f06666","#ffc266","#ffff66","#66b966","#66a3e0","#c285ff","#888888","#a10000","#b26b00","#b2b200","#006100","#0047b2","#6b24b2","#444444","#5c0000","#663d00","#666600","#003700","#002966","#3d1466"],P=[!1,"serif","monospace"],S=["1","2","3",!1],C=["small",!1,"large","huge"],L=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n)),l=function e(n){if(!document.body.contains(t.root))return document.body.removeEventListener("click",e);null==r.tooltip||r.tooltip.root.contains(n.target)||document.activeElement===r.tooltip.textbox||r.quill.hasFocus()||r.tooltip.hide(),null!=r.pickers&&r.pickers.forEach(function(t){t.container.contains(n.target)||t.close()})};return t.emitter.listenDOM("click",document.body,l),r}return l(e,t),u(e,[{key:"addModule",value:function(t){var n=c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"addModule",this).call(this,t);return"toolbar"===t&&this.extendToolbar(n),n}},{key:"buildButtons",value:function(t,e){t.forEach(function(t){(t.getAttribute("class")||"").split(/\s+/).forEach(function(n){if(n.startsWith("ql-")&&(n=n.slice("ql-".length),null!=e[n]))if("direction"===n)t.innerHTML=e[n][""]+e[n].rtl;else if("string"==typeof e[n])t.innerHTML=e[n];else{var r=t.value||"";null!=r&&e[n][r]&&(t.innerHTML=e[n][r])}})})}},{key:"buildPickers",value:function(t,e){var n=this;this.pickers=t.map(function(t){if(t.classList.contains("ql-align"))return null==t.querySelector("option")&&s(t,q),new k.default(t,e.align);if(t.classList.contains("ql-background")||t.classList.contains("ql-color")){var n=t.classList.contains("ql-background")?"background":"color";return null==t.querySelector("option")&&s(t,T,"background"===n?"#ffffff":"#000000"),new w.default(t,e[n])}return null==t.querySelector("option")&&(t.classList.contains("ql-font")?s(t,P):t.classList.contains("ql-header")?s(t,S):t.classList.contains("ql-size")&&s(t,C)),new N.default(t)});var r=function(){n.pickers.forEach(function(t){t.update()})};this.quill.on(v.default.events.EDITOR_CHANGE,r)}}]),e}(_.default);L.DEFAULTS=(0,h.default)(!0,{},_.default.DEFAULTS,{modules:{toolbar:{handlers:{formula:function(){this.quill.theme.tooltip.edit("formula")},image:function(){var t=this,e=this.container.querySelector("input.ql-image[type=file]");null==e&&(e=document.createElement("input"),e.setAttribute("type","file"),e.setAttribute("accept","image/png, image/gif, image/jpeg, image/bmp, image/x-icon"),e.classList.add("ql-image"),e.addEventListener("change",function(){if(null!=e.files&&null!=e.files[0]){var n=new FileReader;n.onload=function(n){var r=t.quill.getSelection(!0);t.quill.updateContents((new d.default).retain(r.index).delete(r.length).insert({image:n.target.result}),v.default.sources.USER),t.quill.setSelection(r.index+1,v.default.sources.SILENT),e.value=""},n.readAsDataURL(e.files[0])}}),this.container.appendChild(e)),e.click()},video:function(){this.quill.theme.tooltip.edit("video")}}}}});var M=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.textbox=r.root.querySelector('input[type="text"]'),r.listen(),r}return l(e,t),u(e,[{key:"listen",value:function(){var t=this;this.textbox.addEventListener("keydown",function(e){g.default.match(e,"enter")?(t.save(),e.preventDefault()):g.default.match(e,"escape")&&(t.cancel(),e.preventDefault())})}},{key:"cancel",value:function(){this.hide()}},{key:"edit",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"link",e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;this.root.classList.remove("ql-hidden"),this.root.classList.add("ql-editing"),null!=e?this.textbox.value=e:t!==this.root.getAttribute("data-mode")&&(this.textbox.value=""),this.position(this.quill.getBounds(this.quill.selection.savedRange)),this.textbox.select(),this.textbox.setAttribute("placeholder",this.textbox.getAttribute("data-"+t)||""),this.root.setAttribute("data-mode",t)}},{key:"restoreFocus",value:function(){var t=this.quill.scrollingContainer.scrollTop;this.quill.focus(),this.quill.scrollingContainer.scrollTop=t}},{key:"save",value:function(){var t=this.textbox.value;switch(this.root.getAttribute("data-mode")){case"link":var e=this.quill.root.scrollTop;this.linkRange?(this.quill.formatText(this.linkRange,"link",t,v.default.sources.USER),delete this.linkRange):(this.restoreFocus(),this.quill.format("link",t,v.default.sources.USER)),this.quill.root.scrollTop=e;break;case"video":t=a(t);case"formula":if(!t)break;var n=this.quill.getSelection(!0);if(null!=n){var r=n.index+n.length;this.quill.insertEmbed(r,this.root.getAttribute("data-mode"),t,v.default.sources.USER),"formula"===this.root.getAttribute("data-mode")&&this.quill.insertText(r+1," ",v.default.sources.USER),this.quill.setSelection(r+2,v.default.sources.USER)}}this.textbox.value="",this.hide()}}]),e}(A.default);e.BaseTooltip=M,e.default=L},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var o=n(46),i=r(o),l=n(34),a=n(36),s=n(62),u=n(63),c=r(u),f=n(64),h=r(f),p=n(65),d=r(p),y=n(35),v=n(24),b=n(37),g=n(38),m=n(39),_=r(m),O=n(66),w=r(O),x=n(15),k=r(x),E=n(67),N=r(E),j=n(68),A=r(j),q=n(69),T=r(q),P=n(70),S=r(P),C=n(71),L=r(C),M=n(13),R=r(M),I=n(72),B=r(I),D=n(73),U=r(D),F=n(74),H=r(F),K=n(26),z=r(K),V=n(16),Z=r(V),W=n(41),G=r(W),Y=n(42),X=r(Y),$=n(43),Q=r($),J=n(107),tt=r(J),et=n(108),nt=r(et);i.default.register({"attributors/attribute/direction":a.DirectionAttribute,"attributors/class/align":l.AlignClass,"attributors/class/background":y.BackgroundClass,"attributors/class/color":v.ColorClass,"attributors/class/direction":a.DirectionClass,"attributors/class/font":b.FontClass,"attributors/class/size":g.SizeClass,"attributors/style/align":l.AlignStyle,"attributors/style/background":y.BackgroundStyle,"attributors/style/color":v.ColorStyle,"attributors/style/direction":a.DirectionStyle,"attributors/style/font":b.FontStyle,"attributors/style/size":g.SizeStyle},!0),i.default.register({"formats/align":l.AlignClass,"formats/direction":a.DirectionClass,"formats/indent":s.IndentClass,"formats/background":y.BackgroundStyle,"formats/color":v.ColorStyle,"formats/font":b.FontClass,"formats/size":g.SizeClass,"formats/blockquote":c.default,"formats/code-block":R.default,"formats/header":h.default,"formats/list":d.default,"formats/bold":_.default,"formats/code":M.Code,"formats/italic":w.default,"formats/link":k.default,"formats/script":N.default,"formats/strike":A.default,"formats/underline":T.default,"formats/image":S.default,"formats/video":L.default,"formats/list/item":p.ListItem,"modules/formula":B.default,"modules/syntax":U.default,"modules/toolbar":H.default,"themes/bubble":tt.default,"themes/snow":nt.default,"ui/icons":z.default,"ui/picker":Z.default,"ui/icon-picker":X.default,"ui/color-picker":G.default,"ui/tooltip":Q.default},!0),e.default=i.default},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}Object.defineProperty(e,"__esModule",{value:!0});var o=n(0),i=r(o),l=n(6),a=r(l),s=n(3),u=r(s),c=n(14),f=r(c),h=n(23),p=r(h),d=n(31),y=r(d),v=n(33),b=r(v),g=n(5),m=r(g),_=n(59),O=r(_),w=n(8),x=r(w),k=n(60),E=r(k),N=n(61),j=r(N),A=n(25),q=r(A);a.default.register({"blots/block":u.default,"blots/block/embed":s.BlockEmbed,"blots/break":f.default,"blots/container":p.default,"blots/cursor":y.default,"blots/embed":b.default,"blots/inline":m.default,"blots/scroll":O.default,"blots/text":x.default,"modules/clipboard":E.default,"modules/history":j.default,"modules/keyboard":q.default}),i.default.register(u.default,f.default,y.default,m.default,O.default,x.default),e.default=a.default},function(t,e,n){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=function(){function t(){this.head=this.tail=null,this.length=0}return t.prototype.append=function(){for(var t=[],e=0;e<arguments.length;e++)t[e]=arguments[e];this.insertBefore(t[0],null),t.length>1&&this.append.apply(this,t.slice(1))},t.prototype.contains=function(t){for(var e,n=this.iterator();e=n();)if(e===t)return!0;return!1},t.prototype.insertBefore=function(t,e){t&&(t.next=e,null!=e?(t.prev=e.prev,null!=e.prev&&(e.prev.next=t),e.prev=t,e===this.head&&(this.head=t)):null!=this.tail?(this.tail.next=t,t.prev=this.tail,this.tail=t):(t.prev=null,this.head=this.tail=t),this.length+=1)},t.prototype.offset=function(t){for(var e=0,n=this.head;null!=n;){if(n===t)return e;e+=n.length(),n=n.next}return-1},t.prototype.remove=function(t){this.contains(t)&&(null!=t.prev&&(t.prev.next=t.next),null!=t.next&&(t.next.prev=t.prev),t===this.head&&(this.head=t.next),t===this.tail&&(this.tail=t.prev),this.length-=1)},t.prototype.iterator=function(t){return void 0===t&&(t=this.head),function(){var e=t;return null!=t&&(t=t.next),e}},t.prototype.find=function(t,e){void 0===e&&(e=!1);for(var n,r=this.iterator();n=r();){var o=n.length();if(t<o||e&&t===o&&(null==n.next||0!==n.next.length()))return[n,t];t-=o}return[null,0]},t.prototype.forEach=function(t){for(var e,n=this.iterator();e=n();)t(e)},t.prototype.forEachAt=function(t,e,n){if(!(e<=0))for(var r,o=this.find(t),i=o[0],l=o[1],a=t-l,s=this.iterator(i);(r=s())&&a<t+e;){var u=r.length();t>a?n(r,t-a,Math.min(e,a+u-t)):n(r,0,Math.min(u,t+e-a)),a+=u}},t.prototype.map=function(t){return this.reduce(function(e,n){return e.push(t(n)),e},[])},t.prototype.reduce=function(t,e){for(var n,r=this.iterator();n=r();)e=t(e,n);return e},t}();e.default=r},function(t,e,n){"use strict";var r=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var o=n(17),i=n(1),l={attributes:!0,characterData:!0,characterDataOldValue:!0,childList:!0,subtree:!0},a=function(t){function e(e){var n=t.call(this,e)||this;return n.scroll=n,n.observer=new MutationObserver(function(t){n.update(t)}),n.observer.observe(n.domNode,l),n.attach(),n}return r(e,t),e.prototype.detach=function(){t.prototype.detach.call(this),this.observer.disconnect()},e.prototype.deleteAt=function(e,n){this.update(),0===e&&n===this.length()?this.children.forEach(function(t){t.remove()}):t.prototype.deleteAt.call(this,e,n)},e.prototype.formatAt=function(e,n,r,o){this.update(),t.prototype.formatAt.call(this,e,n,r,o)},e.prototype.insertAt=function(e,n,r){this.update(),t.prototype.insertAt.call(this,e,n,r)},e.prototype.optimize=function(e,n){var r=this;void 0===e&&(e=[]),void 0===n&&(n={}),t.prototype.optimize.call(this,n);for(var l=[].slice.call(this.observer.takeRecords());l.length>0;)e.push(l.pop());for(var a=function(t,e){void 0===e&&(e=!0),null!=t&&t!==r&&null!=t.domNode.parentNode&&(null==t.domNode[i.DATA_KEY].mutations&&(t.domNode[i.DATA_KEY].mutations=[]),e&&a(t.parent))},s=function(t){null!=t.domNode[i.DATA_KEY]&&null!=t.domNode[i.DATA_KEY].mutations&&(t instanceof o.default&&t.children.forEach(s),t.optimize(n))},u=e,c=0;u.length>0;c+=1){if(c>=100)throw new Error("[Parchment] Maximum optimize iterations reached");for(u.forEach(function(t){var e=i.find(t.target,!0);null!=e&&(e.domNode===t.target&&("childList"===t.type?(a(i.find(t.previousSibling,!1)),[].forEach.call(t.addedNodes,function(t){var e=i.find(t,!1);a(e,!1),e instanceof o.default&&e.children.forEach(function(t){a(t,!1)})})):"attributes"===t.type&&a(e.prev)),a(e))}),this.children.forEach(s),u=[].slice.call(this.observer.takeRecords()),l=u.slice();l.length>0;)e.push(l.pop())}},e.prototype.update=function(e,n){var r=this;void 0===n&&(n={}),e=e||this.observer.takeRecords(),e.map(function(t){var e=i.find(t.target,!0);return null==e?null:null==e.domNode[i.DATA_KEY].mutations?(e.domNode[i.DATA_KEY].mutations=[t],e):(e.domNode[i.DATA_KEY].mutations.push(t),null)}).forEach(function(t){null!=t&&t!==r&&null!=t.domNode[i.DATA_KEY]&&t.update(t.domNode[i.DATA_KEY].mutations||[],n)}),null!=this.domNode[i.DATA_KEY].mutations&&t.prototype.update.call(this,this.domNode[i.DATA_KEY].mutations,n),this.optimize(e,n)},e.blotName="scroll",e.defaultChild="block",e.scope=i.Scope.BLOCK_BLOT,e.tagName="DIV",e}(o.default);e.default=a},function(t,e,n){"use strict";function r(t,e){if(Object.keys(t).length!==Object.keys(e).length)return!1;for(var n in t)if(t[n]!==e[n])return!1;return!0}var o=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var i=n(18),l=n(1),a=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return o(e,t),e.formats=function(n){if(n.tagName!==e.tagName)return t.formats.call(this,n)},e.prototype.format=function(n,r){var o=this;n!==this.statics.blotName||r?t.prototype.format.call(this,n,r):(this.children.forEach(function(t){t instanceof i.default||(t=t.wrap(e.blotName,!0)),o.attributes.copy(t)}),this.unwrap())},e.prototype.formatAt=function(e,n,r,o){if(null!=this.formats()[r]||l.query(r,l.Scope.ATTRIBUTE)){this.isolate(e,n).format(r,o)}else t.prototype.formatAt.call(this,e,n,r,o)},e.prototype.optimize=function(n){t.prototype.optimize.call(this,n);var o=this.formats();if(0===Object.keys(o).length)return this.unwrap();var i=this.next;i instanceof e&&i.prev===this&&r(o,i.formats())&&(i.moveChildren(this),i.remove())},e.blotName="inline",e.scope=l.Scope.INLINE_BLOT,e.tagName="SPAN",e}(i.default);e.default=a},function(t,e,n){"use strict";var r=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var o=n(18),i=n(1),l=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return r(e,t),e.formats=function(n){var r=i.query(e.blotName).tagName;if(n.tagName!==r)return t.formats.call(this,n)},e.prototype.format=function(n,r){null!=i.query(n,i.Scope.BLOCK)&&(n!==this.statics.blotName||r?t.prototype.format.call(this,n,r):this.replaceWith(e.blotName))},e.prototype.formatAt=function(e,n,r,o){null!=i.query(r,i.Scope.BLOCK)?this.format(r,o):t.prototype.formatAt.call(this,e,n,r,o)},e.prototype.insertAt=function(e,n,r){if(null==r||null!=i.query(n,i.Scope.INLINE))t.prototype.insertAt.call(this,e,n,r);else{var o=this.split(e),l=i.create(n,r);o.parent.insertBefore(l,o)}},e.prototype.update=function(e,n){navigator.userAgent.match(/Trident/)?this.build():t.prototype.update.call(this,e,n)},e.blotName="block",e.scope=i.Scope.BLOCK_BLOT,e.tagName="P",e}(o.default);e.default=l},function(t,e,n){"use strict";var r=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var o=n(19),i=function(t){function e(){return null!==t&&t.apply(this,arguments)||this}return r(e,t),e.formats=function(t){},e.prototype.format=function(e,n){t.prototype.formatAt.call(this,0,this.length(),e,n)},e.prototype.formatAt=function(e,n,r,o){0===e&&n===this.length()?this.format(r,o):t.prototype.formatAt.call(this,e,n,r,o)},e.prototype.formats=function(){return this.statics.formats(this.domNode)},e}(o.default);e.default=i},function(t,e,n){"use strict";var r=this&&this.__extends||function(){var t=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,e){t.__proto__=e}||function(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])};return function(e,n){function r(){this.constructor=e}t(e,n),e.prototype=null===n?Object.create(n):(r.prototype=n.prototype,new r)}}();Object.defineProperty(e,"__esModule",{value:!0});var o=n(19),i=n(1),l=function(t){function e(e){var n=t.call(this,e)||this;return n.text=n.statics.value(n.domNode),n}return r(e,t),e.create=function(t){return document.createTextNode(t)},e.value=function(t){var e=t.data;return e.normalize&&(e=e.normalize()),e},e.prototype.deleteAt=function(t,e){this.domNode.data=this.text=this.text.slice(0,t)+this.text.slice(t+e)},e.prototype.index=function(t,e){return this.domNode===t?e:-1},e.prototype.insertAt=function(e,n,r){null==r?(this.text=this.text.slice(0,e)+n+this.text.slice(e),this.domNode.data=this.text):t.prototype.insertAt.call(this,e,n,r)},e.prototype.length=function(){return this.text.length},e.prototype.optimize=function(n){t.prototype.optimize.call(this,n),this.text=this.statics.value(this.domNode),0===this.text.length?this.remove():this.next instanceof e&&this.next.prev===this&&(this.insertAt(this.length(),this.next.value()),this.next.remove())},e.prototype.position=function(t,e){return void 0===e&&(e=!1),[this.domNode,t]},e.prototype.split=function(t,e){if(void 0===e&&(e=!1),!e){if(0===t)return this;if(t===this.length())return this.next}var n=i.create(this.domNode.splitText(t));return this.parent.insertBefore(n,this.next),this.text=this.statics.value(this.domNode),n},e.prototype.update=function(t,e){var n=this;t.some(function(t){return"characterData"===t.type&&t.target===n.domNode})&&(this.text=this.statics.value(this.domNode))},e.prototype.value=function(){return this.text},e.blotName="text",e.scope=i.Scope.INLINE_BLOT,e}(o.default);e.default=l},function(t,e,n){"use strict";var r=document.createElement("div");if(r.classList.toggle("test-class",!1),r.classList.contains("test-class")){var o=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(t,e){return arguments.length>1&&!this.contains(t)==!e?e:o.call(this,t)}}String.prototype.startsWith||(String.prototype.startsWith=function(t,e){return e=e||0,this.substr(e,t.length)===t}),String.prototype.endsWith||(String.prototype.endsWith=function(t,e){var n=this.toString();("number"!=typeof e||!isFinite(e)||Math.floor(e)!==e||e>n.length)&&(e=n.length),e-=t.length;var r=n.indexOf(t,e);return-1!==r&&r===e}),Array.prototype.find||Object.defineProperty(Array.prototype,"find",{value:function(t){if(null===this)throw new TypeError("Array.prototype.find called on null or undefined");if("function"!=typeof t)throw new TypeError("predicate must be a function");for(var e,n=Object(this),r=n.length>>>0,o=arguments[1],i=0;i<r;i++)if(e=n[i],t.call(o,e,i,n))return e}}),document.addEventListener("DOMContentLoaded",function(){document.execCommand("enableObjectResizing",!1,!1),document.execCommand("autoUrlDetect",!1,!1)})},function(t,e){function n(t,e,n){if(t==e)return t?[[v,t]]:[];(n<0||t.length<n)&&(n=null);var o=l(t,e),i=t.substring(0,o);t=t.substring(o),e=e.substring(o),o=a(t,e);var s=t.substring(t.length-o);t=t.substring(0,t.length-o),e=e.substring(0,e.length-o);var c=r(t,e);return i&&c.unshift([v,i]),s&&c.push([v,s]),u(c),null!=n&&(c=f(c,n)),c=h(c)}function r(t,e){var r;if(!t)return[[y,e]];if(!e)return[[d,t]];var i=t.length>e.length?t:e,l=t.length>e.length?e:t,a=i.indexOf(l);if(-1!=a)return r=[[y,i.substring(0,a)],[v,l],[y,i.substring(a+l.length)]],t.length>e.length&&(r[0][0]=r[2][0]=d),r;if(1==l.length)return[[d,t],[y,e]];var u=s(t,e);if(u){var c=u[0],f=u[1],h=u[2],p=u[3],b=u[4],g=n(c,h),m=n(f,p);return g.concat([[v,b]],m)}return o(t,e)}function o(t,e){for(var n=t.length,r=e.length,o=Math.ceil((n+r)/2),l=o,a=2*o,s=new Array(a),u=new Array(a),c=0;c<a;c++)s[c]=-1,u[c]=-1;s[l+1]=0,u[l+1]=0;for(var f=n-r,h=f%2!=0,p=0,v=0,b=0,g=0,m=0;m<o;m++){for(var _=-m+p;_<=m-v;_+=2){var O,w=l+_;O=_==-m||_!=m&&s[w-1]<s[w+1]?s[w+1]:s[w-1]+1;for(var x=O-_;O<n&&x<r&&t.charAt(O)==e.charAt(x);)O++,x++;if(s[w]=O,O>n)v+=2;else if(x>r)p+=2;else if(h){var k=l+f-_;if(k>=0&&k<a&&-1!=u[k]){var E=n-u[k];if(O>=E)return i(t,e,O,x)}}}for(var N=-m+b;N<=m-g;N+=2){var E,k=l+N;E=N==-m||N!=m&&u[k-1]<u[k+1]?u[k+1]:u[k-1]+1;for(var j=E-N;E<n&&j<r&&t.charAt(n-E-1)==e.charAt(r-j-1);)E++,j++;if(u[k]=E,E>n)g+=2;else if(j>r)b+=2;else if(!h){var w=l+f-N;if(w>=0&&w<a&&-1!=s[w]){var O=s[w],x=l+O-w;if(E=n-E,O>=E)return i(t,e,O,x)}}}}return[[d,t],[y,e]]}function i(t,e,r,o){var i=t.substring(0,r),l=e.substring(0,o),a=t.substring(r),s=e.substring(o),u=n(i,l),c=n(a,s);return u.concat(c)}function l(t,e){if(!t||!e||t.charAt(0)!=e.charAt(0))return 0;for(var n=0,r=Math.min(t.length,e.length),o=r,i=0;n<o;)t.substring(i,o)==e.substring(i,o)?(n=o,i=n):r=o,o=Math.floor((r-n)/2+n);return o}function a(t,e){if(!t||!e||t.charAt(t.length-1)!=e.charAt(e.length-1))return 0;for(var n=0,r=Math.min(t.length,e.length),o=r,i=0;n<o;)t.substring(t.length-o,t.length-i)==e.substring(e.length-o,e.length-i)?(n=o,i=n):r=o,o=Math.floor((r-n)/2+n);return o}function s(t,e){function n(t,e,n){for(var r,o,i,s,u=t.substring(n,n+Math.floor(t.length/4)),c=-1,f="";-1!=(c=e.indexOf(u,c+1));){var h=l(t.substring(n),e.substring(c)),p=a(t.substring(0,n),e.substring(0,c));f.length<p+h&&(f=e.substring(c-p,c)+e.substring(c,c+h),r=t.substring(0,n-p),o=t.substring(n+h),i=e.substring(0,c-p),s=e.substring(c+h))}return 2*f.length>=t.length?[r,o,i,s,f]:null}var r=t.length>e.length?t:e,o=t.length>e.length?e:t;if(r.length<4||2*o.length<r.length)return null;var i,s=n(r,o,Math.ceil(r.length/4)),u=n(r,o,Math.ceil(r.length/2));if(!s&&!u)return null;i=u?s&&s[4].length>u[4].length?s:u:s;var c,f,h,p;return t.length>e.length?(c=i[0],f=i[1],h=i[2],p=i[3]):(h=i[0],p=i[1],c=i[2],f=i[3]),[c,f,h,p,i[4]]}function u(t){t.push([v,""]);for(var e,n=0,r=0,o=0,i="",s="";n<t.length;)switch(t[n][0]){case y:o++,s+=t[n][1],n++;break;case d:r++,i+=t[n][1],n++;break;case v:r+o>1?(0!==r&&0!==o&&(e=l(s,i),0!==e&&(n-r-o>0&&t[n-r-o-1][0]==v?t[n-r-o-1][1]+=s.substring(0,e):(t.splice(0,0,[v,s.substring(0,e)]),n++),s=s.substring(e),i=i.substring(e)),0!==(e=a(s,i))&&(t[n][1]=s.substring(s.length-e)+t[n][1],s=s.substring(0,s.length-e),i=i.substring(0,i.length-e))),0===r?t.splice(n-o,r+o,[y,s]):0===o?t.splice(n-r,r+o,[d,i]):t.splice(n-r-o,r+o,[d,i],[y,s]),n=n-r-o+(r?1:0)+(o?1:0)+1):0!==n&&t[n-1][0]==v?(t[n-1][1]+=t[n][1],t.splice(n,1)):n++,o=0,r=0,i="",s=""}""===t[t.length-1][1]&&t.pop();var c=!1;for(n=1;n<t.length-1;)t[n-1][0]==v&&t[n+1][0]==v&&(t[n][1].substring(t[n][1].length-t[n-1][1].length)==t[n-1][1]?(t[n][1]=t[n-1][1]+t[n][1].substring(0,t[n][1].length-t[n-1][1].length),t[n+1][1]=t[n-1][1]+t[n+1][1],t.splice(n-1,1),c=!0):t[n][1].substring(0,t[n+1][1].length)==t[n+1][1]&&(t[n-1][1]+=t[n+1][1],t[n][1]=t[n][1].substring(t[n+1][1].length)+t[n+1][1],t.splice(n+1,1),c=!0)),n++;c&&u(t)}function c(t,e){if(0===e)return[v,t];for(var n=0,r=0;r<t.length;r++){var o=t[r];if(o[0]===d||o[0]===v){var i=n+o[1].length;if(e===i)return[r+1,t];if(e<i){t=t.slice();var l=e-n,a=[o[0],o[1].slice(0,l)],s=[o[0],o[1].slice(l)];return t.splice(r,1,a,s),[r+1,t]}n=i}}throw new Error("cursor_pos is out of bounds!")}function f(t,e){var n=c(t,e),r=n[1],o=n[0],i=r[o],l=r[o+1];if(null==i)return t;if(i[0]!==v)return t;if(null!=l&&i[1]+l[1]===l[1]+i[1])return r.splice(o,2,l,i),p(r,o,2);if(null!=l&&0===l[1].indexOf(i[1])){r.splice(o,2,[l[0],i[1]],[0,i[1]]);var a=l[1].slice(i[1].length);return a.length>0&&r.splice(o+2,0,[l[0],a]),p(r,o,3)}return t}function h(t){for(var e=!1,n=function(t){return t.charCodeAt(0)>=56320&&t.charCodeAt(0)<=57343},r=2;r<t.length;r+=1)t[r-2][0]===v&&function(t){return t.charCodeAt(t.length-1)>=55296&&t.charCodeAt(t.length-1)<=56319}(t[r-2][1])&&t[r-1][0]===d&&n(t[r-1][1])&&t[r][0]===y&&n(t[r][1])&&(e=!0,t[r-1][1]=t[r-2][1].slice(-1)+t[r-1][1],t[r][1]=t[r-2][1].slice(-1)+t[r][1],t[r-2][1]=t[r-2][1].slice(0,-1));if(!e)return t;for(var o=[],r=0;r<t.length;r+=1)t[r][1].length>0&&o.push(t[r]);return o}function p(t,e,n){for(var r=e+n-1;r>=0&&r>=e-1;r--)if(r+1<t.length){var o=t[r],i=t[r+1];o[0]===i[1]&&t.splice(r,2,[o[0],o[1]+i[1]])}return t}var d=-1,y=1,v=0,b=n;b.INSERT=y,b.DELETE=d,b.EQUAL=v,t.exports=b},function(t,e){function n(t){var e=[];for(var n in t)e.push(n);return e}e=t.exports="function"==typeof Object.keys?Object.keys:n,e.shim=n},function(t,e){function n(t){return"[object Arguments]"==Object.prototype.toString.call(t)}function r(t){return t&&"object"==typeof t&&"number"==typeof t.length&&Object.prototype.hasOwnProperty.call(t,"callee")&&!Object.prototype.propertyIsEnumerable.call(t,"callee")||!1}var o="[object Arguments]"==function(){return Object.prototype.toString.call(arguments)}();e=t.exports=o?n:r,e.supported=n,e.unsupported=r},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){return Object.keys(e).reduce(function(n,r){return null==t[r]?n:(e[r]===t[r]?n[r]=e[r]:Array.isArray(e[r])?e[r].indexOf(t[r])<0&&(n[r]=e[r].concat([t[r]])):n[r]=[e[r],t[r]],n)},{})}function a(t){return t.reduce(function(t,e){if(1===e.insert){var n=(0,N.default)(e.attributes);return delete n.image,t.insert({image:e.attributes.image},n)}if(null==e.attributes||!0!==e.attributes.list&&!0!==e.attributes.bullet||(e=(0,N.default)(e),e.attributes.list?e.attributes.list="ordered":(e.attributes.list="bullet",delete e.attributes.bullet)),"string"==typeof e.insert){var r=e.insert.replace(/\r\n/g,"\n").replace(/\r/g,"\n");return t.insert(r,e.attributes)}return t.push(e)},new h.default)}Object.defineProperty(e,"__esModule",{value:!0});var s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},u=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),c=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),f=n(4),h=r(f),p=n(20),d=r(p),y=n(0),v=r(y),b=n(13),g=r(b),m=n(31),_=r(m),O=n(3),w=r(O),x=n(14),k=r(x),E=n(21),N=r(E),j=n(12),A=r(j),q=n(2),T=r(q),P=/^[ -~]*$/,S=function(){function t(e){i(this,t),this.scroll=e,this.delta=this.getDelta()}return c(t,[{key:"applyDelta",value:function(t){var e=this,n=!1;this.scroll.update();var r=this.scroll.length();return this.scroll.batchStart(),t=a(t),t.reduce(function(t,o){var i=o.retain||o.delete||o.insert.length||1,l=o.attributes||{};if(null!=o.insert){if("string"==typeof o.insert){var a=o.insert;a.endsWith("\n")&&n&&(n=!1,a=a.slice(0,-1)),t>=r&&!a.endsWith("\n")&&(n=!0),e.scroll.insertAt(t,a);var c=e.scroll.line(t),f=u(c,2),h=f[0],p=f[1],y=(0,T.default)({},(0,O.bubbleFormats)(h));if(h instanceof w.default){var b=h.descendant(v.default.Leaf,p),g=u(b,1),m=g[0];y=(0,T.default)(y,(0,O.bubbleFormats)(m))}l=d.default.attributes.diff(y,l)||{}}else if("object"===s(o.insert)){var _=Object.keys(o.insert)[0];if(null==_)return t;e.scroll.insertAt(t,_,o.insert[_])}r+=i}return Object.keys(l).forEach(function(n){e.scroll.formatAt(t,i,n,l[n])}),t+i},0),t.reduce(function(t,n){return"number"==typeof n.delete?(e.scroll.deleteAt(t,n.delete),t):t+(n.retain||n.insert.length||1)},0),this.scroll.batchEnd(),this.update(t)}},{key:"deleteText",value:function(t,e){return this.scroll.deleteAt(t,e),this.update((new h.default).retain(t).delete(e))}},{key:"formatLine",value:function(t,e){var n=this,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.scroll.update(),Object.keys(r).forEach(function(o){if(null==n.scroll.whitelist||n.scroll.whitelist[o]){var i=n.scroll.lines(t,Math.max(e,1)),l=e;i.forEach(function(e){var i=e.length();if(e instanceof g.default){var a=t-e.offset(n.scroll),s=e.newlineIndex(a+l)-a+1;e.formatAt(a,s,o,r[o])}else e.format(o,r[o]);l-=i})}}),this.scroll.optimize(),this.update((new h.default).retain(t).retain(e,(0,N.default)(r)))}},{key:"formatText",value:function(t,e){var n=this,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return Object.keys(r).forEach(function(o){n.scroll.formatAt(t,e,o,r[o])}),this.update((new h.default).retain(t).retain(e,(0,N.default)(r)))}},{key:"getContents",value:function(t,e){return this.delta.slice(t,t+e)}},{key:"getDelta",value:function(){return this.scroll.lines().reduce(function(t,e){return t.concat(e.delta())},new h.default)}},{key:"getFormat",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=[],r=[];0===e?this.scroll.path(t).forEach(function(t){var e=u(t,1),o=e[0];o instanceof w.default?n.push(o):o instanceof v.default.Leaf&&r.push(o)}):(n=this.scroll.lines(t,e),r=this.scroll.descendants(v.default.Leaf,t,e));var o=[n,r].map(function(t){if(0===t.length)return{};for(var e=(0,O.bubbleFormats)(t.shift());Object.keys(e).length>0;){var n=t.shift();if(null==n)return e;e=l((0,O.bubbleFormats)(n),e)}return e});return T.default.apply(T.default,o)}},{key:"getText",value:function(t,e){return this.getContents(t,e).filter(function(t){return"string"==typeof t.insert}).map(function(t){return t.insert}).join("")}},{key:"insertEmbed",value:function(t,e,n){return this.scroll.insertAt(t,e,n),this.update((new h.default).retain(t).insert(o({},e,n)))}},{key:"insertText",value:function(t,e){var n=this,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return e=e.replace(/\r\n/g,"\n").replace(/\r/g,"\n"),this.scroll.insertAt(t,e),Object.keys(r).forEach(function(o){n.scroll.formatAt(t,e.length,o,r[o])}),this.update((new h.default).retain(t).insert(e,(0,N.default)(r)))}},{key:"isBlank",value:function(){if(0==this.scroll.children.length)return!0;if(this.scroll.children.length>1)return!1;var t=this.scroll.children.head;return t.statics.blotName===w.default.blotName&&(!(t.children.length>1)&&t.children.head instanceof k.default)}},{key:"removeFormat",value:function(t,e){var n=this.getText(t,e),r=this.scroll.line(t+e),o=u(r,2),i=o[0],l=o[1],a=0,s=new h.default;null!=i&&(a=i instanceof g.default?i.newlineIndex(l)-l+1:i.length()-l,s=i.delta().slice(l,l+a-1).insert("\n"));var c=this.getContents(t,e+a),f=c.diff((new h.default).insert(n).concat(s)),p=(new h.default).retain(t).concat(f);return this.applyDelta(p)}},{key:"update",value:function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0,r=this.delta;if(1===e.length&&"characterData"===e[0].type&&e[0].target.data.match(P)&&v.default.find(e[0].target)){var o=v.default.find(e[0].target),i=(0,O.bubbleFormats)(o),l=o.offset(this.scroll),a=e[0].oldValue.replace(_.default.CONTENTS,""),s=(new h.default).insert(a),u=(new h.default).insert(o.value());t=(new h.default).retain(l).concat(s.diff(u,n)).reduce(function(t,e){return e.insert?t.insert(e.insert,i):t.push(e)},new h.default),this.delta=r.compose(t)}else this.delta=this.getDelta(),t&&(0,A.default)(r.compose(t),this.delta)||(t=r.diff(this.delta,n));return t}}]),t}();e.default=S},function(t,e){"use strict";function n(){}function r(t,e,n){this.fn=t,this.context=e,this.once=n||!1}function o(){this._events=new n,this._eventsCount=0}var i=Object.prototype.hasOwnProperty,l="~";Object.create&&(n.prototype=Object.create(null),(new n).__proto__||(l=!1)),o.prototype.eventNames=function(){var t,e,n=[];if(0===this._eventsCount)return n;for(e in t=this._events)i.call(t,e)&&n.push(l?e.slice(1):e);return Object.getOwnPropertySymbols?n.concat(Object.getOwnPropertySymbols(t)):n},o.prototype.listeners=function(t,e){var n=l?l+t:t,r=this._events[n];if(e)return!!r;if(!r)return[];if(r.fn)return[r.fn];for(var o=0,i=r.length,a=new Array(i);o<i;o++)a[o]=r[o].fn;return a},o.prototype.emit=function(t,e,n,r,o,i){var a=l?l+t:t;if(!this._events[a])return!1;var s,u,c=this._events[a],f=arguments.length;if(c.fn){switch(c.once&&this.removeListener(t,c.fn,void 0,!0),f){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,n),!0;case 4:return c.fn.call(c.context,e,n,r),!0;case 5:return c.fn.call(c.context,e,n,r,o),!0;case 6:return c.fn.call(c.context,e,n,r,o,i),!0}for(u=1,s=new Array(f-1);u<f;u++)s[u-1]=arguments[u];c.fn.apply(c.context,s)}else{var h,p=c.length;for(u=0;u<p;u++)switch(c[u].once&&this.removeListener(t,c[u].fn,void 0,!0),f){case 1:c[u].fn.call(c[u].context);break;case 2:c[u].fn.call(c[u].context,e);break;case 3:c[u].fn.call(c[u].context,e,n);break;case 4:c[u].fn.call(c[u].context,e,n,r);break;default:if(!s)for(h=1,s=new Array(f-1);h<f;h++)s[h-1]=arguments[h];c[u].fn.apply(c[u].context,s)}}return!0},o.prototype.on=function(t,e,n){var o=new r(e,n||this),i=l?l+t:t;return this._events[i]?this._events[i].fn?this._events[i]=[this._events[i],o]:this._events[i].push(o):(this._events[i]=o,this._eventsCount++),this},o.prototype.once=function(t,e,n){var o=new r(e,n||this,!0),i=l?l+t:t;return this._events[i]?this._events[i].fn?this._events[i]=[this._events[i],o]:this._events[i].push(o):(this._events[i]=o,this._eventsCount++),this},o.prototype.removeListener=function(t,e,r,o){var i=l?l+t:t;if(!this._events[i])return this;if(!e)return 0==--this._eventsCount?this._events=new n:delete this._events[i],this;var a=this._events[i];if(a.fn)a.fn!==e||o&&!a.once||r&&a.context!==r||(0==--this._eventsCount?this._events=new n:delete this._events[i]);else{for(var s=0,u=[],c=a.length;s<c;s++)(a[s].fn!==e||o&&!a[s].once||r&&a[s].context!==r)&&u.push(a[s]);u.length?this._events[i]=1===u.length?u[0]:u:0==--this._eventsCount?this._events=new n:delete this._events[i]}return this},o.prototype.removeAllListeners=function(t){var e;return t?(e=l?l+t:t,this._events[e]&&(0==--this._eventsCount?this._events=new n:delete this._events[e])):(this._events=new n,this._eventsCount=0),this},o.prototype.off=o.prototype.removeListener,o.prototype.addListener=o.prototype.on,o.prototype.setMaxListeners=function(){return this},o.prefixed=l,o.EventEmitter=o,void 0!==t&&(t.exports=o)},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t){return t instanceof v.default||t instanceof y.BlockEmbed}Object.defineProperty(e,"__esModule",{value:!0});var s=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},f=n(0),h=r(f),p=n(9),d=r(p),y=n(3),v=r(y),b=n(14),g=r(b),m=n(13),_=r(m),O=n(23),w=r(O),x=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t));return r.emitter=n.emitter,Array.isArray(n.whitelist)&&(r.whitelist=n.whitelist.reduce(function(t,e){return t[e]=!0,t},{})),r.domNode.addEventListener("DOMNodeInserted",function(){}),r.optimize(),r.enable(),r}return l(e,t),u(e,[{key:"batchStart",value:function(){this.batch=!0}},{key:"batchEnd",value:function(){this.batch=!1,this.optimize()}},{key:"deleteAt",value:function(t,n){var r=this.line(t),o=s(r,2),i=o[0],l=o[1],a=this.line(t+n),u=s(a,1),f=u[0];if(c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"deleteAt",this).call(this,t,n),null!=f&&i!==f&&l>0){if(i instanceof y.BlockEmbed||f instanceof y.BlockEmbed)return void this.optimize();if(i instanceof _.default){var h=i.newlineIndex(i.length(),!0);if(h>-1&&(i=i.split(h+1))===f)return void this.optimize()}else if(f instanceof _.default){var p=f.newlineIndex(0);p>-1&&f.split(p+1)}var d=f.children.head instanceof g.default?null:f.children.head;i.moveChildren(f,d),i.remove()}this.optimize()}},{key:"enable",value:function(){var t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];this.domNode.setAttribute("contenteditable",t)}},{key:"formatAt",value:function(t,n,r,o){(null==this.whitelist||this.whitelist[r])&&(c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"formatAt",this).call(this,t,n,r,o),this.optimize())}},{key:"insertAt",value:function(t,n,r){if(null==r||null==this.whitelist||this.whitelist[n]){if(t>=this.length())if(null==r||null==h.default.query(n,h.default.Scope.BLOCK)){var o=h.default.create(this.statics.defaultChild);this.appendChild(o),null==r&&n.endsWith("\n")&&(n=n.slice(0,-1)),o.insertAt(0,n,r)}else{var i=h.default.create(n,r);this.appendChild(i)}else c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertAt",this).call(this,t,n,r);this.optimize()}}},{key:"insertBefore",value:function(t,n){if(t.statics.scope===h.default.Scope.INLINE_BLOT){var r=h.default.create(this.statics.defaultChild);r.appendChild(t),t=r}c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertBefore",this).call(this,t,n)}},{key:"leaf",value:function(t){return this.path(t).pop()||[null,-1]}},{key:"line",value:function(t){return t===this.length()?this.line(t-1):this.descendant(a,t)}},{key:"lines",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Number.MAX_VALUE;return function t(e,n,r){var o=[],i=r;return e.children.forEachAt(n,r,function(e,n,r){a(e)?o.push(e):e instanceof h.default.Container&&(o=o.concat(t(e,n,i))),i-=r}),o}(this,t,e)}},{key:"optimize",value:function(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};!0!==this.batch&&(c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"optimize",this).call(this,t,n),t.length>0&&this.emitter.emit(d.default.events.SCROLL_OPTIMIZE,t,n))}},{key:"path",value:function(t){return c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"path",this).call(this,t).slice(1)}},{key:"update",value:function(t){if(!0!==this.batch){var n=d.default.sources.USER;"string"==typeof t&&(n=t),Array.isArray(t)||(t=this.observer.takeRecords()),t.length>0&&this.emitter.emit(d.default.events.SCROLL_BEFORE_UPDATE,n,t),c(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"update",this).call(this,t.concat([])),t.length>0&&this.emitter.emit(d.default.events.SCROLL_UPDATE,n,t)}}}]),e}(h.default.Scroll);x.blotName="scroll",x.className="ql-editor",x.tagName="DIV",x.defaultChild="block",x.allowedChildren=[v.default,y.BlockEmbed,w.default],e.default=x},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e,n){return"object"===(void 0===e?"undefined":x(e))?Object.keys(e).reduce(function(t,n){return s(t,n,e[n])},t):t.reduce(function(t,r){return r.attributes&&r.attributes[e]?t.push(r):t.insert(r.insert,(0,j.default)({},o({},e,n),r.attributes))},new q.default)}function u(t){if(t.nodeType!==Node.ELEMENT_NODE)return{};return t["__ql-computed-style"]||(t["__ql-computed-style"]=window.getComputedStyle(t))}function c(t,e){for(var n="",r=t.ops.length-1;r>=0&&n.length<e.length;--r){var o=t.ops[r];if("string"!=typeof o.insert)break;n=o.insert+n}return n.slice(-1*e.length)===e}function f(t){return 0!==t.childNodes.length&&["block","list-item"].indexOf(u(t).display)>-1}function h(t,e,n){return t.nodeType===t.TEXT_NODE?n.reduce(function(e,n){return n(t,e)},new q.default):t.nodeType===t.ELEMENT_NODE?[].reduce.call(t.childNodes||[],function(r,o){var i=h(o,e,n);return o.nodeType===t.ELEMENT_NODE&&(i=e.reduce(function(t,e){return e(o,t)},i),i=(o[W]||[]).reduce(function(t,e){return e(o,t)},i)),r.concat(i)},new q.default):new q.default}function p(t,e,n){return s(n,t,!0)}function d(t,e){var n=P.default.Attributor.Attribute.keys(t),r=P.default.Attributor.Class.keys(t),o=P.default.Attributor.Style.keys(t),i={};return n.concat(r).concat(o).forEach(function(e){var n=P.default.query(e,P.default.Scope.ATTRIBUTE);null!=n&&(i[n.attrName]=n.value(t),i[n.attrName])||(n=Y[e],null==n||n.attrName!==e&&n.keyName!==e||(i[n.attrName]=n.value(t)||void 0),null==(n=X[e])||n.attrName!==e&&n.keyName!==e||(n=X[e],i[n.attrName]=n.value(t)||void 0))}),Object.keys(i).length>0&&(e=s(e,i)),e}function y(t,e){var n=P.default.query(t);if(null==n)return e;if(n.prototype instanceof P.default.Embed){var r={},o=n.value(t);null!=o&&(r[n.blotName]=o,e=(new q.default).insert(r,n.formats(t)))}else"function"==typeof n.formats&&(e=s(e,n.blotName,n.formats(t)));return e}function v(t,e){return c(e,"\n")||e.insert("\n"),e}function b(){return new q.default}function g(t,e){var n=P.default.query(t);if(null==n||"list-item"!==n.blotName||!c(e,"\n"))return e;for(var r=-1,o=t.parentNode;!o.classList.contains("ql-clipboard");)"list"===(P.default.query(o)||{}).blotName&&(r+=1),o=o.parentNode;return r<=0?e:e.compose((new q.default).retain(e.length()-1).retain(1,{indent:r}))}function m(t,e){return c(e,"\n")||(f(t)||e.length()>0&&t.nextSibling&&f(t.nextSibling))&&e.insert("\n"),e}function _(t,e){if(f(t)&&null!=t.nextElementSibling&&!c(e,"\n\n")){var n=t.offsetHeight+parseFloat(u(t).marginTop)+parseFloat(u(t).marginBottom);t.nextElementSibling.offsetTop>t.offsetTop+1.5*n&&e.insert("\n")}return e}function O(t,e){var n={},r=t.style||{};return r.fontStyle&&"italic"===u(t).fontStyle&&(n.italic=!0),r.fontWeight&&(u(t).fontWeight.startsWith("bold")||parseInt(u(t).fontWeight)>=700)&&(n.bold=!0),Object.keys(n).length>0&&(e=s(e,n)),parseFloat(r.textIndent||0)>0&&(e=(new q.default).insert("\t").concat(e)),e}function w(t,e){var n=t.data;if("O:P"===t.parentNode.tagName)return e.insert(n.trim());if(0===n.trim().length&&t.parentNode.classList.contains("ql-clipboard"))return e;if(!u(t.parentNode).whiteSpace.startsWith("pre")){var r=function(t,e){return e=e.replace(/[^\u00a0]/g,""),e.length<1&&t?" ":e};n=n.replace(/\r\n/g," ").replace(/\n/g," "),n=n.replace(/\s\s+/g,r.bind(r,!0)),(null==t.previousSibling&&f(t.parentNode)||null!=t.previousSibling&&f(t.previousSibling))&&(n=n.replace(/^\s+/,r.bind(r,!1))),(null==t.nextSibling&&f(t.parentNode)||null!=t.nextSibling&&f(t.nextSibling))&&(n=n.replace(/\s+$/,r.bind(r,!1)))}return e.insert(n)}Object.defineProperty(e,"__esModule",{value:!0}),e.matchText=e.matchSpacing=e.matchNewline=e.matchBlot=e.matchAttributor=e.default=void 0;var x="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},k=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),E=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),N=n(2),j=r(N),A=n(4),q=r(A),T=n(0),P=r(T),S=n(6),C=r(S),L=n(10),M=r(L),R=n(7),I=r(R),B=n(34),D=n(35),U=n(13),F=r(U),H=n(24),K=n(36),z=n(37),V=n(38),Z=(0,M.default)("quill:clipboard"),W="__ql-matcher",G=[[Node.TEXT_NODE,w],[Node.TEXT_NODE,m],["br",v],[Node.ELEMENT_NODE,m],[Node.ELEMENT_NODE,y],[Node.ELEMENT_NODE,_],[Node.ELEMENT_NODE,d],[Node.ELEMENT_NODE,O],["li",g],["b",p.bind(p,"bold")],["i",p.bind(p,"italic")],["style",b]],Y=[B.AlignAttribute,K.DirectionAttribute].reduce(function(t,e){return t[e.keyName]=e,t},{}),X=[B.AlignStyle,D.BackgroundStyle,H.ColorStyle,K.DirectionStyle,z.FontStyle,V.SizeStyle].reduce(function(t,e){return t[e.keyName]=e,t},{}),$=function(t){function e(t,n){i(this,e);var r=l(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.quill.root.addEventListener("paste",r.onPaste.bind(r)),r.container=r.quill.addContainer("ql-clipboard"),r.container.setAttribute("contenteditable",!0),r.container.setAttribute("tabindex",-1),r.matchers=[],G.concat(r.options.matchers).forEach(function(t){var e=k(t,2),o=e[0],i=e[1];(n.matchVisual||i!==_)&&r.addMatcher(o,i)}),r}return a(e,t),E(e,[{key:"addMatcher",value:function(t,e){this.matchers.push([t,e])}},{key:"convert",value:function(t){if("string"==typeof t)return this.container.innerHTML=t.replace(/\>\r?\n +\</g,"><"),this.convert();var e=this.quill.getFormat(this.quill.selection.savedRange.index);if(e[F.default.blotName]){var n=this.container.innerText;return this.container.innerHTML="",(new q.default).insert(n,o({},F.default.blotName,e[F.default.blotName]))}var r=this.prepareMatching(),i=k(r,2),l=i[0],a=i[1],s=h(this.container,l,a);return c(s,"\n")&&null==s.ops[s.ops.length-1].attributes&&(s=s.compose((new q.default).retain(s.length()-1).delete(1))),Z.log("convert",this.container.innerHTML,s),this.container.innerHTML="",s}},{key:"dangerouslyPasteHTML",value:function(t,e){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:C.default.sources.API;if("string"==typeof t)this.quill.setContents(this.convert(t),e),this.quill.setSelection(0,C.default.sources.SILENT);else{var r=this.convert(e);this.quill.updateContents((new q.default).retain(t).concat(r),n),this.quill.setSelection(t+r.length(),C.default.sources.SILENT)}}},{key:"onPaste",value:function(t){var e=this;if(!t.defaultPrevented&&this.quill.isEnabled()){var n=this.quill.getSelection(),r=(new q.default).retain(n.index),o=this.quill.scrollingContainer.scrollTop;this.container.focus(),this.quill.selection.update(C.default.sources.SILENT),setTimeout(function(){r=r.concat(e.convert()).delete(n.length),e.quill.updateContents(r,C.default.sources.USER),e.quill.setSelection(r.length()-n.length,C.default.sources.SILENT),e.quill.scrollingContainer.scrollTop=o,e.quill.focus()},1)}}},{key:"prepareMatching",value:function(){var t=this,e=[],n=[];return this.matchers.forEach(function(r){var o=k(r,2),i=o[0],l=o[1];switch(i){case Node.TEXT_NODE:n.push(l);break;case Node.ELEMENT_NODE:e.push(l);break;default:[].forEach.call(t.container.querySelectorAll(i),function(t){t[W]=t[W]||[],t[W].push(l)})}}),[e,n]}}]),e}(I.default);$.DEFAULTS={matchers:[],matchVisual:!0},e.default=$,e.matchAttributor=d,e.matchBlot=y,e.matchNewline=m,e.matchSpacing=_,e.matchText=w},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function a(t){var e=t.ops[t.ops.length-1];return null!=e&&(null!=e.insert?"string"==typeof e.insert&&e.insert.endsWith("\n"):null!=e.attributes&&Object.keys(e.attributes).some(function(t){return null!=f.default.query(t,f.default.Scope.BLOCK)}))}function s(t){var e=t.reduce(function(t,e){return t+=e.delete||0},0),n=t.length()-e;return a(t)&&(n-=1),n}Object.defineProperty(e,"__esModule",{value:!0}),e.getLastChangeIndex=e.default=void 0;var u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(0),f=r(c),h=n(6),p=r(h),d=n(7),y=r(d),v=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.lastRecorded=0,r.ignoreChange=!1,r.clear(),r.quill.on(p.default.events.EDITOR_CHANGE,function(t,e,n,o){t!==p.default.events.TEXT_CHANGE||r.ignoreChange||(r.options.userOnly&&o!==p.default.sources.USER?r.transform(e):r.record(e,n))}),r.quill.keyboard.addBinding({key:"Z",shortKey:!0},r.undo.bind(r)),r.quill.keyboard.addBinding({key:"Z",shortKey:!0,shiftKey:!0},r.redo.bind(r)),/Win/i.test(navigator.platform)&&r.quill.keyboard.addBinding({key:"Y",shortKey:!0},r.redo.bind(r)),r}return l(e,t),u(e,[{key:"change",value:function(t,e){if(0!==this.stack[t].length){var n=this.stack[t].pop();this.stack[e].push(n),this.lastRecorded=0,this.ignoreChange=!0,this.quill.updateContents(n[t],p.default.sources.USER),this.ignoreChange=!1;var r=s(n[t]);this.quill.setSelection(r)}}},{key:"clear",value:function(){this.stack={undo:[],redo:[]}}},{key:"cutoff",value:function(){this.lastRecorded=0}},{key:"record",value:function(t,e){if(0!==t.ops.length){this.stack.redo=[];var n=this.quill.getContents().diff(e),r=Date.now();if(this.lastRecorded+this.options.delay>r&&this.stack.undo.length>0){var o=this.stack.undo.pop();n=n.compose(o.undo),t=o.redo.compose(t)}else this.lastRecorded=r;this.stack.undo.push({redo:t,undo:n}),this.stack.undo.length>this.options.maxStack&&this.stack.undo.shift()}}},{key:"redo",value:function(){this.change("redo","undo")}},{key:"transform",value:function(t){this.stack.undo.forEach(function(e){e.undo=t.transform(e.undo,!0),e.redo=t.transform(e.redo,!0)}),this.stack.redo.forEach(function(e){e.undo=t.transform(e.undo,!0),e.redo=t.transform(e.redo,!0)})}},{key:"undo",value:function(){this.change("undo","redo")}}]),e}(y.default);v.DEFAULTS={delay:1e3,maxStack:100,userOnly:!1},e.default=v,e.getLastChangeIndex=s},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.IndentClass=void 0;var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(0),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"add",value:function(t,n){if("+1"===n||"-1"===n){var r=this.value(t)||0;n="+1"===n?r+1:r-1}return 0===n?(this.remove(t),!0):a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"add",this).call(this,t,n)}},{key:"canAdd",value:function(t,n){return a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"canAdd",this).call(this,t,n)||a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"canAdd",this).call(this,t,parseInt(n))}},{key:"value",value:function(t){return parseInt(a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"value",this).call(this,t))||void 0}}]),e}(u.default.Attributor.Class),f=new c("indent","ql-indent",{scope:u.default.Scope.BLOCK,whitelist:[1,2,3,4,5,6,7,8]});e.IndentClass=f},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=n(3),a=function(t){return t&&t.__esModule?t:{default:t}}(l),s=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),e}(a.default);s.blotName="blockquote",s.tagName="blockquote",e.default=s},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=n(3),s=function(t){return t&&t.__esModule?t:{default:t}}(a),u=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,null,[{key:"formats",value:function(t){return this.tagName.indexOf(t.tagName)+1}}]),e}(s.default);u.blotName="header",u.tagName=["H1","H2","H3","H4","H5","H6"],e.default=u},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.ListItem=void 0;var s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},c=n(0),f=r(c),h=n(3),p=r(h),d=n(23),y=r(d),v=function(t){function e(){return i(this,e),l(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return a(e,t),s(e,[{key:"format",value:function(t,n){t!==b.blotName||n?u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"format",this).call(this,t,n):this.replaceWith(f.default.create(this.statics.scope))}},{key:"remove",value:function(){null==this.prev&&null==this.next?this.parent.remove():u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"remove",this).call(this)}},{key:"replaceWith",value:function(t,n){return this.parent.isolate(this.offset(this.parent),this.length()),t===this.parent.statics.blotName?(this.parent.replaceWith(t,n),this):(this.parent.unwrap(),u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"replaceWith",this).call(this,t,n))}}],[{key:"formats",value:function(t){return t.tagName===this.tagName?void 0:u(e.__proto__||Object.getPrototypeOf(e),"formats",this).call(this,t)}}]),e}(p.default);v.blotName="list-item",v.tagName="LI";var b=function(t){function e(t){i(this,e);var n=l(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t)),r=function(e){if(e.target.parentNode===t){var r=n.statics.formats(t),o=f.default.find(e.target);"checked"===r?o.format("list","unchecked"):"unchecked"===r&&o.format("list","checked")}};return t.addEventListener("touchstart",r),t.addEventListener("mousedown",r),n}return a(e,t),s(e,null,[{key:"create",value:function(t){var n="ordered"===t?"OL":"UL",r=u(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,n);return"checked"!==t&&"unchecked"!==t||r.setAttribute("data-checked","checked"===t),r}},{key:"formats",value:function(t){return"OL"===t.tagName?"ordered":"UL"===t.tagName?t.hasAttribute("data-checked")?"true"===t.getAttribute("data-checked")?"checked":"unchecked":"bullet":void 0}}]),s(e,[{key:"format",value:function(t,e){this.children.length>0&&this.children.tail.format(t,e)}},{key:"formats",value:function(){return o({},this.statics.blotName,this.statics.formats(this.domNode))}},{key:"insertBefore",value:function(t,n){if(t instanceof v)u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"insertBefore",this).call(this,t,n);else{var r=null==n?this.length():n.offset(this),o=this.split(r);o.parent.insertBefore(t,o)}}},{key:"optimize",value:function(t){u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"optimize",this).call(this,t);var n=this.next;null!=n&&n.prev===this&&n.statics.blotName===this.statics.blotName&&n.domNode.tagName===this.domNode.tagName&&n.domNode.getAttribute("data-checked")===this.domNode.getAttribute("data-checked")&&(n.moveChildren(this),n.remove())}},{key:"replace",value:function(t){if(t.statics.blotName!==this.statics.blotName){var n=f.default.create(this.statics.defaultChild);t.moveChildren(n),this.appendChild(n)}u(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"replace",this).call(this,t)}}]),e}(y.default);b.blotName="list",b.scope=f.default.Scope.BLOCK_BLOT,b.tagName=["OL","UL"],b.defaultChild="list-item",b.allowedChildren=[v],e.ListItem=v,e.default=b},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=n(39),a=function(t){return t&&t.__esModule?t:{default:t}}(l),s=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),e}(a.default);s.blotName="italic",s.tagName=["EM","I"],e.default=s},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(5),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,null,[{key:"create",value:function(t){return"super"===t?document.createElement("sup"):"sub"===t?document.createElement("sub"):a(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,t)}},{key:"formats",value:function(t){return"SUB"===t.tagName?"sub":"SUP"===t.tagName?"super":void 0}}]),e}(u.default);c.blotName="script",c.tagName=["SUB","SUP"],e.default=c},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=n(5),a=function(t){return t&&t.__esModule?t:{default:t}}(l),s=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),e}(a.default);s.blotName="strike",s.tagName="S",e.default=s},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=n(5),a=function(t){return t&&t.__esModule?t:{default:t}}(l),s=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),e}(a.default);s.blotName="underline",s.tagName="U",e.default=s},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(0),u=function(t){return t&&t.__esModule?t:{default:t}}(s),c=n(15),f=["alt","height","width"],h=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"format",value:function(t,n){f.indexOf(t)>-1?n?this.domNode.setAttribute(t,n):this.domNode.removeAttribute(t):a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"format",this).call(this,t,n)}}],[{key:"create",value:function(t){var n=a(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,t);return"string"==typeof t&&n.setAttribute("src",this.sanitize(t)),n}},{key:"formats",value:function(t){return f.reduce(function(e,n){return t.hasAttribute(n)&&(e[n]=t.getAttribute(n)),e},{})}},{key:"match",value:function(t){return/\.(jpe?g|gif|png)$/.test(t)||/^data:image\/.+;base64/.test(t)}},{key:"sanitize",value:function(t){return(0,c.sanitize)(t,["http","https","data"])?t:"//:0"}},{key:"value",value:function(t){return t.getAttribute("src")}}]),e}(u.default.Embed);h.blotName="image",h.tagName="IMG",e.default=h},function(t,e,n){"use strict";function r(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function o(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function i(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var l=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=n(3),u=n(15),c=function(t){return t&&t.__esModule?t:{default:t}}(u),f=["height","width"],h=function(t){function e(){return r(this,e),o(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return i(e,t),l(e,[{key:"format",value:function(t,n){f.indexOf(t)>-1?n?this.domNode.setAttribute(t,n):this.domNode.removeAttribute(t):a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"format",this).call(this,t,n)}}],[{key:"create",value:function(t){var n=a(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,t);return n.setAttribute("frameborder","0"),n.setAttribute("allowfullscreen",!0),n.setAttribute("src",this.sanitize(t)),n}},{key:"formats",value:function(t){return f.reduce(function(e,n){return t.hasAttribute(n)&&(e[n]=t.getAttribute(n)),e},{})}},{key:"sanitize",value:function(t){return c.default.sanitize(t)}},{key:"value",value:function(t){return t.getAttribute("src")}}]),e}(s.BlockEmbed);h.blotName="video",h.className="ql-video",h.tagName="IFRAME",e.default=h},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.FormulaBlot=void 0;var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=n(33),c=r(u),f=n(6),h=r(f),p=n(7),d=r(p),y=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),a(e,null,[{key:"create",value:function(t){var n=s(e.__proto__||Object.getPrototypeOf(e),"create",this).call(this,t);return"string"==typeof t&&(window.katex.render(t,n,{throwOnError:!1,errorColor:"#f00"}),n.setAttribute("data-value",t)),n}},{key:"value",value:function(t){return t.getAttribute("data-value")}}]),e}(c.default);y.blotName="formula",y.className="ql-formula",y.tagName="SPAN";var v=function(t){function e(){o(this,e);var t=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this));if(null==window.katex)throw new Error("Formula module requires KaTeX.");return t}return l(e,t),a(e,null,[{key:"register",value:function(){h.default.register(y,!0)}}]),e}(d.default);e.FormulaBlot=y,e.default=v},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.CodeToken=e.CodeBlock=void 0;var a=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=n(0),c=r(u),f=n(6),h=r(f),p=n(7),d=r(p),y=n(13),v=r(y),b=function(t){function e(){return o(this,e),i(this,(e.__proto__||Object.getPrototypeOf(e)).apply(this,arguments))}return l(e,t),a(e,[{key:"replaceWith",value:function(t){this.domNode.textContent=this.domNode.textContent,this.attach(),s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"replaceWith",this).call(this,t)}},{key:"highlight",value:function(t){var e=this.domNode.textContent;this.cachedText!==e&&((e.trim().length>0||null==this.cachedText)&&(this.domNode.innerHTML=t(e),this.domNode.normalize(),this.attach()),this.cachedText=e)}}]),e}(v.default);b.className="ql-syntax";var g=new c.default.Attributor.Class("token","hljs",{scope:c.default.Scope.INLINE}),m=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));if("function"!=typeof r.options.highlight)throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");var l=null;return r.quill.on(h.default.events.SCROLL_OPTIMIZE,function(){clearTimeout(l),l=setTimeout(function(){r.highlight(),l=null},r.options.interval)}),r.highlight(),r}return l(e,t),a(e,null,[{key:"register",value:function(){h.default.register(g,!0),h.default.register(b,!0)}}]),a(e,[{key:"highlight",value:function(){var t=this;if(!this.quill.selection.composing){this.quill.update(h.default.sources.USER);var e=this.quill.getSelection();this.quill.scroll.descendants(b).forEach(function(e){e.highlight(t.options.highlight)}),this.quill.update(h.default.sources.SILENT),null!=e&&this.quill.setSelection(e,h.default.sources.SILENT)}}}]),e}(d.default);m.DEFAULTS={highlight:function(){return null==window.hljs?null:function(t){return window.hljs.highlightAuto(t).value}}(),interval:1e3},e.CodeBlock=b,e.CodeToken=g,e.default=m},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function l(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function a(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}function s(t,e,n){var r=document.createElement("button");r.setAttribute("type","button"),r.classList.add("ql-"+e),null!=n&&(r.value=n),t.appendChild(r)}function u(t,e){Array.isArray(e[0])||(e=[e]),e.forEach(function(e){var n=document.createElement("span");n.classList.add("ql-formats"),e.forEach(function(t){if("string"==typeof t)s(n,t);else{var e=Object.keys(t)[0],r=t[e];Array.isArray(r)?c(n,e,r):s(n,e,r)}}),t.appendChild(n)})}function c(t,e,n){var r=document.createElement("select");r.classList.add("ql-"+e),n.forEach(function(t){var e=document.createElement("option");!1!==t?e.setAttribute("value",t):e.setAttribute("selected","selected"),r.appendChild(e)}),t.appendChild(r)}Object.defineProperty(e,"__esModule",{value:!0}),e.addControls=e.default=void 0;var f=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),h=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),p=n(4),d=r(p),y=n(0),v=r(y),b=n(6),g=r(b),m=n(10),_=r(m),O=n(7),w=r(O),x=(0,_.default)("quill:toolbar"),k=function(t){function e(t,n){i(this,e);var r=l(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));if(Array.isArray(r.options.container)){var o=document.createElement("div");u(o,r.options.container),t.container.parentNode.insertBefore(o,t.container),r.container=o}else"string"==typeof r.options.container?r.container=document.querySelector(r.options.container):r.container=r.options.container;if(!(r.container instanceof HTMLElement)){var a;return a=x.error("Container required for toolbar",r.options),l(r,a)}return r.container.classList.add("ql-toolbar"),r.controls=[],r.handlers={},Object.keys(r.options.handlers).forEach(function(t){r.addHandler(t,r.options.handlers[t])}),[].forEach.call(r.container.querySelectorAll("button, select"),function(t){r.attach(t)}),r.quill.on(g.default.events.EDITOR_CHANGE,function(t,e){t===g.default.events.SELECTION_CHANGE&&r.update(e)}),r.quill.on(g.default.events.SCROLL_OPTIMIZE,function(){var t=r.quill.selection.getRange(),e=f(t,1),n=e[0];r.update(n)}),r}return a(e,t),h(e,[{key:"addHandler",value:function(t,e){this.handlers[t]=e}},{key:"attach",value:function(t){var e=this,n=[].find.call(t.classList,function(t){return 0===t.indexOf("ql-")});if(n){if(n=n.slice("ql-".length),"BUTTON"===t.tagName&&t.setAttribute("type","button"),null==this.handlers[n]){if(null!=this.quill.scroll.whitelist&&null==this.quill.scroll.whitelist[n])return void x.warn("ignoring attaching to disabled format",n,t);if(null==v.default.query(n))return void x.warn("ignoring attaching to nonexistent format",n,t)}var r="SELECT"===t.tagName?"change":"click";t.addEventListener(r,function(r){var i=void 0;if("SELECT"===t.tagName){if(t.selectedIndex<0)return;var l=t.options[t.selectedIndex];i=!l.hasAttribute("selected")&&(l.value||!1)}else i=!t.classList.contains("ql-active")&&(t.value||!t.hasAttribute("value")),r.preventDefault();e.quill.focus();var a=e.quill.selection.getRange(),s=f(a,1),u=s[0];if(null!=e.handlers[n])e.handlers[n].call(e,i);else if(v.default.query(n).prototype instanceof v.default.Embed){if(!(i=prompt("Enter "+n)))return;e.quill.updateContents((new d.default).retain(u.index).delete(u.length).insert(o({},n,i)),g.default.sources.USER)}else e.quill.format(n,i,g.default.sources.USER);e.update(u)}),this.controls.push([n,t])}}},{key:"update",value:function(t){var e=null==t?{}:this.quill.getFormat(t);this.controls.forEach(function(n){var r=f(n,2),o=r[0],i=r[1];if("SELECT"===i.tagName){var l=void 0;if(null==t)l=null;else if(null==e[o])l=i.querySelector("option[selected]");else if(!Array.isArray(e[o])){var a=e[o];"string"==typeof a&&(a=a.replace(/\"/g,'\\"')),l=i.querySelector('option[value="'+a+'"]')}null==l?(i.value="",i.selectedIndex=-1):l.selected=!0}else if(null==t)i.classList.remove("ql-active");else if(i.hasAttribute("value")){var s=e[o]===i.getAttribute("value")||null!=e[o]&&e[o].toString()===i.getAttribute("value")||null==e[o]&&!i.getAttribute("value");i.classList.toggle("ql-active",s)}else i.classList.toggle("ql-active",null!=e[o])})}}]),e}(w.default);k.DEFAULTS={},k.DEFAULTS={container:null,handlers:{clean:function(){var t=this,e=this.quill.getSelection();if(null!=e)if(0==e.length){var n=this.quill.getFormat();Object.keys(n).forEach(function(e){null!=v.default.query(e,v.default.Scope.INLINE)&&t.quill.format(e,!1)})}else this.quill.removeFormat(e,g.default.sources.USER)},direction:function(t){var e=this.quill.getFormat().align;"rtl"===t&&null==e?this.quill.format("align","right",g.default.sources.USER):t||"right"!==e||this.quill.format("align",!1,g.default.sources.USER),this.quill.format("direction",t,g.default.sources.USER)},indent:function(t){var e=this.quill.getSelection(),n=this.quill.getFormat(e),r=parseInt(n.indent||0);if("+1"===t||"-1"===t){var o="+1"===t?1:-1;"rtl"===n.direction&&(o*=-1),this.quill.format("indent",r+o,g.default.sources.USER)}},link:function(t){!0===t&&(t=prompt("Enter link URL:")),this.quill.format("link",t,g.default.sources.USER)},list:function(t){var e=this.quill.getSelection(),n=this.quill.getFormat(e);"check"===t?"checked"===n.list||"unchecked"===n.list?this.quill.format("list",!1,g.default.sources.USER):this.quill.format("list","unchecked",g.default.sources.USER):this.quill.format("list",t,g.default.sources.USER)}}},e.default=k,e.addControls=u},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>'},function(t,e){t.exports='<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>'},function(t,e){t.exports='<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>'},function(t,e){t.exports='<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>'},function(t,e){t.exports='<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>'},function(t,e){t.exports='<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>'},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0}),e.default=e.BubbleTooltip=void 0;var a=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},s=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),u=n(2),c=r(u),f=n(9),h=r(f),p=n(44),d=r(p),y=n(22),v=n(26),b=r(v),g=[["bold","italic","link"],[{header:1},{header:2},"blockquote"]],m=function(t){function e(t,n){o(this,e),null!=n.modules.toolbar&&null==n.modules.toolbar.container&&(n.modules.toolbar.container=g);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.quill.container.classList.add("ql-bubble"),r}return l(e,t),s(e,[{key:"extendToolbar",value:function(t){this.tooltip=new _(this.quill,this.options.bounds),this.tooltip.root.appendChild(t.container),this.buildButtons([].slice.call(t.container.querySelectorAll("button")),b.default),this.buildPickers([].slice.call(t.container.querySelectorAll("select")),b.default)}}]),e}(d.default);m.DEFAULTS=(0,c.default)(!0,{},d.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function(t){t?this.quill.theme.tooltip.edit():this.quill.format("link",!1)}}}}});var _=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.quill.on(h.default.events.EDITOR_CHANGE,function(t,e,n,o){if(t===h.default.events.SELECTION_CHANGE)if(null!=e&&e.length>0&&o===h.default.sources.USER){r.show(),r.root.style.left="0px",r.root.style.width="",r.root.style.width=r.root.offsetWidth+"px";var i=r.quill.getLines(e.index,e.length);if(1===i.length)r.position(r.quill.getBounds(e));else{var l=i[i.length-1],a=r.quill.getIndex(l),s=Math.min(l.length()-1,e.index+e.length-a),u=r.quill.getBounds(new y.Range(a,s));r.position(u)}}else document.activeElement!==r.textbox&&r.quill.hasFocus()&&r.hide()}),r}return l(e,t),s(e,[{key:"listen",value:function(){var t=this;a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"listen",this).call(this),this.root.querySelector(".ql-close").addEventListener("click",function(){t.root.classList.remove("ql-editing")}),this.quill.on(h.default.events.SCROLL_OPTIMIZE,function(){setTimeout(function(){if(!t.root.classList.contains("ql-hidden")){var e=t.quill.getSelection();null!=e&&t.position(t.quill.getBounds(e))}},1)})}},{key:"cancel",value:function(){this.show()}},{key:"position",value:function(t){var n=a(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"position",this).call(this,t),r=this.root.querySelector(".ql-tooltip-arrow");if(r.style.marginLeft="",0===n)return n;r.style.marginLeft=-1*n-r.offsetWidth/2+"px"}}]),e}(p.BaseTooltip);_.TEMPLATE=['<span class="ql-tooltip-arrow"></span>','<div class="ql-tooltip-editor">','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-close"></a>',"</div>"].join(""),e.BubbleTooltip=_,e.default=m},function(t,e,n){"use strict";function r(t){return t&&t.__esModule?t:{default:t}}function o(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function i(t,e){if(!t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!e||"object"!=typeof e&&"function"!=typeof e?t:e}function l(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(Object.setPrototypeOf?Object.setPrototypeOf(t,e):t.__proto__=e)}Object.defineProperty(e,"__esModule",{value:!0});var a=function(){function t(t,e){var n=[],r=!0,o=!1,i=void 0;try{for(var l,a=t[Symbol.iterator]();!(r=(l=a.next()).done)&&(n.push(l.value),!e||n.length!==e);r=!0);}catch(t){o=!0,i=t}finally{try{!r&&a.return&&a.return()}finally{if(o)throw i}}return n}return function(e,n){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return t(e,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),s=function t(e,n,r){null===e&&(e=Function.prototype);var o=Object.getOwnPropertyDescriptor(e,n);if(void 0===o){var i=Object.getPrototypeOf(e);return null===i?void 0:t(i,n,r)}if("value"in o)return o.value;var l=o.get;if(void 0!==l)return l.call(r)},u=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r)}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}(),c=n(2),f=r(c),h=n(9),p=r(h),d=n(44),y=r(d),v=n(15),b=r(v),g=n(22),m=n(26),_=r(m),O=[[{header:["1","2","3",!1]}],["bold","italic","underline","link"],[{list:"ordered"},{list:"bullet"}],["clean"]],w=function(t){function e(t,n){o(this,e),null!=n.modules.toolbar&&null==n.modules.toolbar.container&&(n.modules.toolbar.container=O);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.quill.container.classList.add("ql-snow"),r}return l(e,t),u(e,[{key:"extendToolbar",value:function(t){t.container.classList.add("ql-snow"),this.buildButtons([].slice.call(t.container.querySelectorAll("button")),_.default),this.buildPickers([].slice.call(t.container.querySelectorAll("select")),_.default),this.tooltip=new x(this.quill,this.options.bounds),t.container.querySelector(".ql-link")&&this.quill.keyboard.addBinding({key:"K",shortKey:!0},function(e,n){t.handlers.link.call(t,!n.format.link)})}}]),e}(y.default);w.DEFAULTS=(0,f.default)(!0,{},y.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function(t){if(t){var e=this.quill.getSelection();if(null==e||0==e.length)return;var n=this.quill.getText(e);/^\S+@\S+\.\S+$/.test(n)&&0!==n.indexOf("mailto:")&&(n="mailto:"+n);this.quill.theme.tooltip.edit("link",n)}else this.quill.format("link",!1)}}}}});var x=function(t){function e(t,n){o(this,e);var r=i(this,(e.__proto__||Object.getPrototypeOf(e)).call(this,t,n));return r.preview=r.root.querySelector("a.ql-preview"),r}return l(e,t),u(e,[{key:"listen",value:function(){var t=this;s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"listen",this).call(this),this.root.querySelector("a.ql-action").addEventListener("click",function(e){t.root.classList.contains("ql-editing")?t.save():t.edit("link",t.preview.textContent),e.preventDefault()}),this.root.querySelector("a.ql-remove").addEventListener("click",function(e){if(null!=t.linkRange){var n=t.linkRange;t.restoreFocus(),t.quill.formatText(n,"link",!1,p.default.sources.USER),delete t.linkRange}e.preventDefault(),t.hide()}),this.quill.on(p.default.events.SELECTION_CHANGE,function(e,n,r){if(null!=e){if(0===e.length&&r===p.default.sources.USER){var o=t.quill.scroll.descendant(b.default,e.index),i=a(o,2),l=i[0],s=i[1];if(null!=l){t.linkRange=new g.Range(e.index-s,l.length());var u=b.default.formats(l.domNode);return t.preview.textContent=u,t.preview.setAttribute("href",u),t.show(),void t.position(t.quill.getBounds(t.linkRange))}}else delete t.linkRange;t.hide()}})}},{key:"show",value:function(){s(e.prototype.__proto__||Object.getPrototypeOf(e.prototype),"show",this).call(this),this.root.removeAttribute("data-mode")}}]),e}(d.BaseTooltip);x.TEMPLATE=['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-action"></a>','<a class="ql-remove"></a>'].join(""),e.default=w}]).default});
//# sourceMappingURL=quill.min.js.map/* global kijs, this, quill */

// --------------------------------------------------------------
// kijs.gui.field.QuillEditor
// --------------------------------------------------------------
// WYSIWYG Editor
kijs.gui.field.QuillEditor = class kijs_gui_field_QuillEditor extends kijs.gui.field.Field {


    // --------------------------------------------------------------
    // CONSTRUCTOR
    // --------------------------------------------------------------
    constructor(config={}) {
        super(false);

        this._disabled = false;

        this._quillEditor = null;
        this._quillEditorContainerNode = null;
        this._quillEditorNode = null;

        this._placeholder = '';
        this._theme = 'snow';
        this._value = '';
        this._valueTrimEnable = true;
        this._previousChangeValue = '';

        this._toolbarOptions = [
            ['bold',  'underline', 'strike'],              // toggled buttons
            ['blockquote', 'code-block'],

            [{ header: 1 }, { header: 2 }],                // custom button values
            [{ list: 'ordered'}, { list: 'bullet' }],
            [{ script: 'sub'}, { script: 'super' }],       // superscript/subscript
            [{ indent: '-1'}, { indent: '+1' }],           // outdent/indent
            [{ direction: 'rtl' }],                        // text direction

            [{ size: ['small', false, 'large', 'huge'] }], // custom dropdown
            [{ header: [1, 2, 3, 4, 5, 6, false] }],

            [{ color: [] }, { background: [] }],           // dropdown with defaults from theme
            [{ font: [] }],
            [{ align: [] }],

            ['clean']                                      // remove formatting button
        ];

        // Standard-config-Eigenschaften mergen
        Object.assign(this._defaultConfig, {
            cls: 'kijs-field-quilleditor'
        });

        // Mapping für die Zuweisung der Config-Eigenschaften
        Object.assign(this._configMap, {
            placeholder: true,
            theme: true,          // snow (default), bubble
            toolbarOptions : true,
            valueTrimEnable: true // Sollen Leerzeichen am Anfang und Ende des Values automatisch entfernt werden?
        });

        // Listeners
        this.on('input', this.#onInput, this);

        // Config anwenden
        if (kijs.isObject(config)) {
            config = Object.assign({}, this._defaultConfig, config);
            this.applyConfig(config, true);
        }

        // Listener
        this.on('afterRender', this.#onAfterRender, this);
    }


    // --------------------------------------------------------------
    // GETTERS / SETTERS
    // --------------------------------------------------------------

    get content() {
        return this._quillEditor.getContents();
    }

    set content(val) {
        this._quillEditor.setContents(val);
    }
    get hasFocus() {
        if (this._quillEditor) {
            return this._quillEditor.hasFocus();
        }
        return false;
    }

    // overwrite
    get isEmpty() { return kijs.isEmpty(this.value); }

    // overwrite
    get readOnly() { return super.readOnly; }
    set readOnly(val) {
        super.readOnly = !!val;
        if (this._quillEditor) {
            this._quillEditor.setReadOnly(!!val);
        }
    }

    get theme() { return this._theme; }
    set theme(val) { this._theme = val; }

    // overwrite
    get value() {
        let val = '';
        if (this._quillEditor) {
            val = this._quillEditor.root.innerHTML;
        } else {
            val = kijs.toString(this._value);
        }
        if (this._valueTrimEnable) {
            val = val.trim();
        }
        return val;
    }
    set value(val) {
        val = kijs.toString(val);
        this._value = val;
        this._previousChangeValue = val;
        if (this._quillEditor) {
            this._quillEditor.setContents([]);
            this._quillEditor.clipboard.dangerouslyPasteHTML(0, val);
        }
        this.isDirty = false;
    }

    get valueTrimEnable() { return this._valueTrimEnable; }
    set valueTrimEnable(val) { this._valueTrimEnable = !!val; }



    // --------------------------------------------------------------
    // MEMBERS
    // --------------------------------------------------------------
    // overwrite
    changeDisabled(val, callFromParent) {
        super.changeDisabled(!!val, callFromParent);

        this._disabled = !!val;
        if (this._quillEditor) {
            if (this._disabled) {
                this._quillEditor.disable(true);
            } else {
                this._quillEditor.enable(true);
            }
        }
    }

    /**
     * Setzt den Focus auf das Feld. Optional wird der Text selektiert.
     * @param {Boolean} [alsoSetIfNoTabIndex=false]
     * @param {Boolean} [selectText=false]
     * @returns {HTMLElement|false}
     * @overwrite
     */
    focus(alsoSetIfNoTabIndex, selectText) {
        if (this._quillEditor) {
            this._quillEditor.focus();

            if (selectText) {
                this._quillEditor.setSelection(0, this._quillEditor.getLength());
            }

            return this._quillEditorNode.firstChild;

        } else {
            return false;

        }
    }

    // overwrite
    render(superCall) {
        super.render(true);

        // quillEditor erstellen
        if (!this._quillEditor) {

            // dirty?
            const isDirtyBeforeRender = this.isDirty;

            // Container erstellen
            //this._quillEditorContainerNode = document.createElement('div');
            //this._quillEditorContainerNode.className = 'quill-editor-container';

            // Div für Editor erstellen
            this._quillEditorNode = document.createElement('div');
            //this._quillEditorContainerNode.appendChild(this._quillEditorNode);

            //this._inputWrapperDom.node.appendChild(this._quillEditorContainerNode);
            this._inputWrapperDom.node.appendChild(this._quillEditorNode);

            // Editor erstellen
            this._quillEditor = new Quill(this._quillEditorNode, {
                theme: this._theme,
                bounds: this._quillEditorNode,
                placeholder: this._placeholder,
                //readOnly: this.readOnly || this.disabled,
                //scrollingContainer: this._quillEditorContainerNode,
                modules: {
                    toolbar: this._toolbarOptions
                }
            });
            let inputNode = this._quillEditorNode.firstChild;
            //inputNode.tabIndex = 0;
            inputNode.id = this._inputId;

            kijs.Dom.addEventListener('blur', inputNode, this.#onInputNodeBlur, this);

            // Listener setzen und Event weiterleiten
            this._quillEditor.on('text-change', function() { this.raiseEvent('input'); }, this);

            // Inhalt einfügen
            this.value = !kijs.isEmpty(this._value) ? this._value : '';

            // reset isDirty flag
            if (!isDirtyBeforeRender) {
                this.isDirty = false;
            }
        } else {
            this._inputWrapperDom.node.appendChild(this._quillEditorNode);
        }

        // Event afterRender auslösen
        if (!superCall) {
            this.raiseEvent('afterRender');
        }
    }


    // PRIVATE
    // LISTENERS
    #onAfterRender() {
        if (this._disabled) {
            this._quillEditor.disable(true);
        }
    }

    #onInput() {
        this.validate();
    }

    #onInputNodeBlur() {
        if (this.value !== this._previousChangeValue) {
            this.raiseEvent('change', { value: this.value, oldValue: this._previousChangeValue });
            this._previousChangeValue = this.value;
        }
    }



    // --------------------------------------------------------------
    // DESTRUCTOR
    // --------------------------------------------------------------
    destruct(superCall) {
        if (!superCall) {
            // unrendern
            this.unrender(superCall);

            // Event auslösen.
            this.raiseEvent('destruct');
        }

        // Elemente/DOM-Objekte entladen

        // Variablen (Objekte/Arrays) leeren
        this._disabled = null;
        this._quillEditor = null;
        this._quillEditorNode = null;
        this._quillEditorContainerNode = null;
        this._toolbarOptions = null;
        this._value = null;
        this._previousChangeValue = null;

        // Basisklasse entladen
        super.destruct(true);
    }

};
